[
  {
    "name": "StringUtils.StringUtils#166",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.StringUtils()",
    "snippet": "public StringUtils() {\n        super();\n    }",
    "begin_line": 166,
    "end_line": 168,
    "comment": "/** \n * \u003cp\u003e\u003ccode\u003eStringUtils\u003c/code\u003e instances should NOT be constructed in standard programming. Instead, the class should be used as \u003ccode\u003eStringUtils.trim(\" foo \");\u003c/code\u003e.\u003c/p\u003e \u003cp\u003eThis constructor is public to permit tools that require a JavaBean instance to operate.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isEmpty#190",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isEmpty(java.lang.CharSequence)",
    "snippet": "public static boolean isEmpty(CharSequence str) {\n        return str \u003d\u003d null || str.length() \u003d\u003d 0;\n    }",
    "begin_line": 190,
    "end_line": 192,
    "comment": "/** \n * \u003cp\u003eChecks if a String is empty (\"\") or null.\u003c/p\u003e \u003cpre\u003e StringUtils.isEmpty(null)      \u003d true StringUtils.isEmpty(\"\")        \u003d true StringUtils.isEmpty(\" \")       \u003d false StringUtils.isEmpty(\"bob\")     \u003d false StringUtils.isEmpty(\"  bob  \") \u003d false \u003c/pre\u003e \u003cp\u003eNOTE: This method changed in Lang version 2.0. It no longer trims the String. That functionality is available in isBlank().\u003c/p\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String is empty or null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNotEmpty#208",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNotEmpty(java.lang.CharSequence)",
    "snippet": "public static boolean isNotEmpty(CharSequence str) {\n        return !StringUtils.isEmpty(str);\n    }",
    "begin_line": 208,
    "end_line": 210,
    "comment": "/** \n * \u003cp\u003eChecks if a String is not empty (\"\") and not null.\u003c/p\u003e \u003cpre\u003e StringUtils.isNotEmpty(null)      \u003d false StringUtils.isNotEmpty(\"\")        \u003d false StringUtils.isNotEmpty(\" \")       \u003d true StringUtils.isNotEmpty(\"bob\")     \u003d true StringUtils.isNotEmpty(\"  bob  \") \u003d true \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String is not empty and not null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isBlank#227",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isBlank(java.lang.CharSequence)",
    "snippet": "public static boolean isBlank(CharSequence str) {\n        int strLen;\n        if (str \u003d\u003d null || (strLen \u003d str.length()) \u003d\u003d 0) {\n            return true;\n        }\n        for (int i \u003d 0; i \u003c strLen; i++) {\n            if ((Character.isWhitespace(str.charAt(i)) \u003d\u003d false)) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 227,
    "end_line": 238,
    "comment": "/** \n * \u003cp\u003eChecks if a String is whitespace, empty (\"\") or null.\u003c/p\u003e \u003cpre\u003e StringUtils.isBlank(null)      \u003d true StringUtils.isBlank(\"\")        \u003d true StringUtils.isBlank(\" \")       \u003d true StringUtils.isBlank(\"bob\")     \u003d false StringUtils.isBlank(\"  bob  \") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String is null, empty or whitespace\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNotBlank#256",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNotBlank(java.lang.CharSequence)",
    "snippet": "public static boolean isNotBlank(CharSequence str) {\n        return !StringUtils.isBlank(str);\n    }",
    "begin_line": 256,
    "end_line": 258,
    "comment": "/** \n * \u003cp\u003eChecks if a String is not empty (\"\"), not null and not whitespace only.\u003c/p\u003e \u003cpre\u003e StringUtils.isNotBlank(null)      \u003d false StringUtils.isNotBlank(\"\")        \u003d false StringUtils.isNotBlank(\" \")       \u003d false StringUtils.isNotBlank(\"bob\")     \u003d true StringUtils.isNotBlank(\"  bob  \") \u003d true \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String isnot empty and not null and not whitespace\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.trim#285",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.trim(java.lang.String)",
    "snippet": "public static String trim(String str) {\n        return str \u003d\u003d null ? null : str.trim();\n    }",
    "begin_line": 285,
    "end_line": 287,
    "comment": "/** \n * \u003cp\u003eRemoves control characters (char \u0026lt;\u003d 32) from both ends of this String, handling \u003ccode\u003enull\u003c/code\u003e by returning \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cp\u003eThe String is trimmed using  {@link String#trim()}. Trim removes start and end characters \u0026lt;\u003d 32. To strip whitespace use  {@link #strip(String)}.\u003c/p\u003e \u003cp\u003eTo trim your choice of characters, use the {@link #strip(String,String)} methods.\u003c/p\u003e\u003cpre\u003e StringUtils.trim(null)          \u003d null StringUtils.trim(\"\")            \u003d \"\" StringUtils.trim(\"     \")       \u003d \"\" StringUtils.trim(\"abc\")         \u003d \"abc\" StringUtils.trim(\"    abc    \") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to be trimmed, may be null\n * @return the trimmed string, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.trimToNull#311",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.trimToNull(java.lang.String)",
    "snippet": "public static String trimToNull(String str) {\n        String ts \u003d trim(str);\n        return isEmpty(ts) ? null : ts;\n    }",
    "begin_line": 311,
    "end_line": 314,
    "comment": "/** \n * \u003cp\u003eRemoves control characters (char \u0026lt;\u003d 32) from both ends of this String returning \u003ccode\u003enull\u003c/code\u003e if the String is empty (\"\") after the trim or if it is \u003ccode\u003enull\u003c/code\u003e. \u003cp\u003eThe String is trimmed using  {@link String#trim()}. Trim removes start and end characters \u0026lt;\u003d 32. To strip whitespace use  {@link #stripToNull(String)}.\u003c/p\u003e \u003cpre\u003e StringUtils.trimToNull(null)          \u003d null StringUtils.trimToNull(\"\")            \u003d null StringUtils.trimToNull(\"     \")       \u003d null StringUtils.trimToNull(\"abc\")         \u003d \"abc\" StringUtils.trimToNull(\"    abc    \") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to be trimmed, may be null\n * @return the trimmed String,\u003ccode\u003enull\u003c/code\u003e if only chars \u0026lt;\u003d 32, empty or null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.trimToEmpty#337",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.trimToEmpty(java.lang.String)",
    "snippet": "public static String trimToEmpty(String str) {\n        return str \u003d\u003d null ? EMPTY : str.trim();\n    }",
    "begin_line": 337,
    "end_line": 339,
    "comment": "/** \n * \u003cp\u003eRemoves control characters (char \u0026lt;\u003d 32) from both ends of this String returning an empty String (\"\") if the String is empty (\"\") after the trim or if it is \u003ccode\u003enull\u003c/code\u003e. \u003cp\u003eThe String is trimmed using  {@link String#trim()}. Trim removes start and end characters \u0026lt;\u003d 32. To strip whitespace use  {@link #stripToEmpty(String)}.\u003c/p\u003e \u003cpre\u003e StringUtils.trimToEmpty(null)          \u003d \"\" StringUtils.trimToEmpty(\"\")            \u003d \"\" StringUtils.trimToEmpty(\"     \")       \u003d \"\" StringUtils.trimToEmpty(\"abc\")         \u003d \"abc\" StringUtils.trimToEmpty(\"    abc    \") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to be trimmed, may be null\n * @return the trimmed String, or an empty String if \u003ccode\u003enull\u003c/code\u003e input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.strip#365",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.strip(java.lang.String)",
    "snippet": "public static String strip(String str) {\n        return strip(str, null);\n    }",
    "begin_line": 365,
    "end_line": 367,
    "comment": "/** \n * \u003cp\u003eStrips whitespace from the start and end of a String.\u003c/p\u003e \u003cp\u003eThis is similar to  {@link #trim(String)} but removes whitespace.Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.strip(null)     \u003d null StringUtils.strip(\"\")       \u003d \"\" StringUtils.strip(\"   \")    \u003d \"\" StringUtils.strip(\"abc\")    \u003d \"abc\" StringUtils.strip(\"  abc\")  \u003d \"abc\" StringUtils.strip(\"abc  \")  \u003d \"abc\" StringUtils.strip(\" abc \")  \u003d \"abc\" StringUtils.strip(\" ab c \") \u003d \"ab c\" \u003c/pre\u003e\n * @param str  the String to remove whitespace from, may be null\n * @return the stripped String, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripToNull#392",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripToNull(java.lang.String)",
    "snippet": "public static String stripToNull(String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        str \u003d strip(str, null);\n        return str.length() \u003d\u003d 0 ? null : str;\n    }",
    "begin_line": 392,
    "end_line": 398,
    "comment": "/** \n * \u003cp\u003eStrips whitespace from the start and end of a String  returning \u003ccode\u003enull\u003c/code\u003e if the String is empty (\"\") after the strip.\u003c/p\u003e \u003cp\u003eThis is similar to  {@link #trimToNull(String)} but removes whitespace.Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripToNull(null)     \u003d null StringUtils.stripToNull(\"\")       \u003d null StringUtils.stripToNull(\"   \")    \u003d null StringUtils.stripToNull(\"abc\")    \u003d \"abc\" StringUtils.stripToNull(\"  abc\")  \u003d \"abc\" StringUtils.stripToNull(\"abc  \")  \u003d \"abc\" StringUtils.stripToNull(\" abc \")  \u003d \"abc\" StringUtils.stripToNull(\" ab c \") \u003d \"ab c\" \u003c/pre\u003e\n * @param str  the String to be stripped, may be null\n * @return the stripped String,\u003ccode\u003enull\u003c/code\u003e if whitespace, empty or null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripToEmpty#422",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripToEmpty(java.lang.String)",
    "snippet": "public static String stripToEmpty(String str) {\n        return str \u003d\u003d null ? EMPTY : strip(str, null);\n    }",
    "begin_line": 422,
    "end_line": 424,
    "comment": "/** \n * \u003cp\u003eStrips whitespace from the start and end of a String  returning an empty String if \u003ccode\u003enull\u003c/code\u003e input.\u003c/p\u003e \u003cp\u003eThis is similar to  {@link #trimToEmpty(String)} but removes whitespace.Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripToEmpty(null)     \u003d \"\" StringUtils.stripToEmpty(\"\")       \u003d \"\" StringUtils.stripToEmpty(\"   \")    \u003d \"\" StringUtils.stripToEmpty(\"abc\")    \u003d \"abc\" StringUtils.stripToEmpty(\"  abc\")  \u003d \"abc\" StringUtils.stripToEmpty(\"abc  \")  \u003d \"abc\" StringUtils.stripToEmpty(\" abc \")  \u003d \"abc\" StringUtils.stripToEmpty(\" ab c \") \u003d \"ab c\" \u003c/pre\u003e\n * @param str  the String to be stripped, may be null\n * @return the trimmed String, or an empty String if \u003ccode\u003enull\u003c/code\u003e input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.strip#452",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.strip(java.lang.String, java.lang.String)",
    "snippet": "public static String strip(String str, String stripChars) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        str \u003d stripStart(str, stripChars);\n        return stripEnd(str, stripChars);\n    }",
    "begin_line": 452,
    "end_line": 458,
    "comment": "/** \n * \u003cp\u003eStrips any of a set of characters from the start and end of a String. This is similar to  {@link String#trim()} but allows the charactersto be stripped to be controlled.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. An empty string (\"\") input returns the empty string.\u003c/p\u003e \u003cp\u003eIf the stripChars String is \u003ccode\u003enull\u003c/code\u003e, whitespace is stripped as defined by  {@link Character#isWhitespace(char)}. Alternatively use  {@link #strip(String)}.\u003c/p\u003e \u003cpre\u003e StringUtils.strip(null, *)          \u003d null StringUtils.strip(\"\", *)            \u003d \"\" StringUtils.strip(\"abc\", null)      \u003d \"abc\" StringUtils.strip(\"  abc\", null)    \u003d \"abc\" StringUtils.strip(\"abc  \", null)    \u003d \"abc\" StringUtils.strip(\" abc \", null)    \u003d \"abc\" StringUtils.strip(\"  abcyx\", \"xyz\") \u003d \"  abc\" \u003c/pre\u003e\n * @param str  the String to remove characters from, may be null\n * @param stripChars  the characters to remove, null treated as whitespace\n * @return the stripped String, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripStart#484",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripStart(java.lang.String, java.lang.String)",
    "snippet": "public static String stripStart(String str, String stripChars) {\n        int strLen;\n        if (str \u003d\u003d null || (strLen \u003d str.length()) \u003d\u003d 0) {\n            return str;\n        }\n        int start \u003d 0;\n        if (stripChars \u003d\u003d null) {\n            while ((start !\u003d strLen) \u0026\u0026 Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() \u003d\u003d 0) {\n            return str;\n        } else {\n            while ((start !\u003d strLen) \u0026\u0026 (stripChars.indexOf(str.charAt(start)) !\u003d -1)) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }",
    "begin_line": 484,
    "end_line": 502,
    "comment": "/** \n * \u003cp\u003eStrips any of a set of characters from the start of a String.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. An empty string (\"\") input returns the empty string.\u003c/p\u003e \u003cp\u003eIf the stripChars String is \u003ccode\u003enull\u003c/code\u003e, whitespace is stripped as defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripStart(null, *)          \u003d null StringUtils.stripStart(\"\", *)            \u003d \"\" StringUtils.stripStart(\"abc\", \"\")        \u003d \"abc\" StringUtils.stripStart(\"abc\", null)      \u003d \"abc\" StringUtils.stripStart(\"  abc\", null)    \u003d \"abc\" StringUtils.stripStart(\"abc  \", null)    \u003d \"abc  \" StringUtils.stripStart(\" abc \", null)    \u003d \"abc \" StringUtils.stripStart(\"yxabc  \", \"xyz\") \u003d \"abc  \" \u003c/pre\u003e\n * @param str  the String to remove characters from, may be null\n * @param stripChars  the characters to remove, null treated as whitespace\n * @return the stripped String, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripEnd#528",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripEnd(java.lang.String, java.lang.String)",
    "snippet": "public static String stripEnd(String str, String stripChars) {\n        int end;\n        if (str \u003d\u003d null || (end \u003d str.length()) \u003d\u003d 0) {\n            return str;\n        }\n\n        if (stripChars \u003d\u003d null) {\n            while ((end !\u003d 0) \u0026\u0026 Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() \u003d\u003d 0) {\n            return str;\n        } else {\n            while ((end !\u003d 0) \u0026\u0026 (stripChars.indexOf(str.charAt(end - 1)) !\u003d -1)) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }",
    "begin_line": 528,
    "end_line": 546,
    "comment": "/** \n * \u003cp\u003eStrips any of a set of characters from the end of a String.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. An empty string (\"\") input returns the empty string.\u003c/p\u003e \u003cp\u003eIf the stripChars String is \u003ccode\u003enull\u003c/code\u003e, whitespace is stripped as defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripEnd(null, *)          \u003d null StringUtils.stripEnd(\"\", *)            \u003d \"\" StringUtils.stripEnd(\"abc\", \"\")        \u003d \"abc\" StringUtils.stripEnd(\"abc\", null)      \u003d \"abc\" StringUtils.stripEnd(\"  abc\", null)    \u003d \"  abc\" StringUtils.stripEnd(\"abc  \", null)    \u003d \"abc\" StringUtils.stripEnd(\" abc \", null)    \u003d \" abc\" StringUtils.stripEnd(\"  abcyx\", \"xyz\") \u003d \"  abc\" \u003c/pre\u003e\n * @param str  the String to remove characters from, may be null\n * @param stripChars  the characters to remove, null treated as whitespace\n * @return the stripped String, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripAll#569",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripAll(java.lang.String[])",
    "snippet": "public static String[] stripAll(String[] strs) {\n        return stripAll(strs, null);\n    }",
    "begin_line": 569,
    "end_line": 571,
    "comment": "/** \n * \u003cp\u003eStrips whitespace from the start and end of every String in an array. Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eA new array is returned each time, except for length zero. A \u003ccode\u003enull\u003c/code\u003e array will return \u003ccode\u003enull\u003c/code\u003e. An empty array will return itself. A \u003ccode\u003enull\u003c/code\u003e array entry will be ignored.\u003c/p\u003e \u003cpre\u003e StringUtils.stripAll(null)             \u003d null StringUtils.stripAll([])               \u003d [] StringUtils.stripAll([\"abc\", \"  abc\"]) \u003d [\"abc\", \"abc\"] StringUtils.stripAll([\"abc  \", null])  \u003d [\"abc\", null] \u003c/pre\u003e\n * @param strs  the array to remove whitespace from, may be null\n * @return the stripped Strings, \u003ccode\u003enull\u003c/code\u003e if null array input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripAll#598",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripAll(java.lang.String[], java.lang.String)",
    "snippet": "public static String[] stripAll(String[] strs, String stripChars) {\n        int strsLen;\n        if (strs \u003d\u003d null || (strsLen \u003d strs.length) \u003d\u003d 0) {\n            return strs;\n        }\n        String[] newArr \u003d new String[strsLen];\n        for (int i \u003d 0; i \u003c strsLen; i++) {\n            newArr[i] \u003d strip(strs[i], stripChars);\n        }\n        return newArr;\n    }",
    "begin_line": 598,
    "end_line": 608,
    "comment": "/** \n * \u003cp\u003eStrips any of a set of characters from the start and end of every String in an array.\u003c/p\u003e Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eA new array is returned each time, except for length zero. A \u003ccode\u003enull\u003c/code\u003e array will return \u003ccode\u003enull\u003c/code\u003e. An empty array will return itself. A \u003ccode\u003enull\u003c/code\u003e array entry will be ignored. A \u003ccode\u003enull\u003c/code\u003e stripChars will strip whitespace as defined by {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripAll(null, *)                \u003d null StringUtils.stripAll([], *)                  \u003d [] StringUtils.stripAll([\"abc\", \"  abc\"], null) \u003d [\"abc\", \"abc\"] StringUtils.stripAll([\"abc  \", null], null)  \u003d [\"abc\", null] StringUtils.stripAll([\"abc  \", null], \"yz\")  \u003d [\"abc  \", null] StringUtils.stripAll([\"yabcz\", null], \"yz\")  \u003d [\"abc\", null] \u003c/pre\u003e\n * @param strs  the array to remove characters from, may be null\n * @param stripChars  the characters to remove, null treated as whitespace\n * @return the stripped Strings, \u003ccode\u003enull\u003c/code\u003e if null array input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripAccents#626",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripAccents(java.lang.String)",
    "snippet": "public static String stripAccents(String input) {\n        if(input \u003d\u003d null) {\n            return null;\n        }\n        if(SystemUtils.isJavaVersionAtLeast(1.6f)) {\n\n            // String decomposed \u003d Normalizer.normalize(input, Normalizer.Form.NFD);\n\n            // START of 1.5 reflection - in 1.6 use the line commented out above\n            try {\n                // get java.text.Normalizer.Form class\n                Class normalizerFormClass \u003d ClassUtils.getClass(\"java.text.Normalizer$Form\", false);\n\n                // get Normlizer class\n                Class normalizerClass \u003d ClassUtils.getClass(\"java.text.Normalizer\", false);\n\n                // get static method on Normalizer\n                java.lang.reflect.Method method \u003d normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );\n\n                // get Normalizer.NFD field\n                java.lang.reflect.Field nfd \u003d normalizerFormClass.getField(\"NFD\");\n\n                // invoke method\n                String decomposed \u003d (String) method.invoke( null, input, nfd.get(null) );\n                // END of 1.5 reflection\n\n                java.util.regex.Pattern accentPattern \u003d java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n                return accentPattern.matcher(decomposed).replaceAll(\"\");\n            } catch(ClassNotFoundException cnfe) {\n                throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe);\n            } catch(NoSuchMethodException nsme) {\n                throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);\n            } catch(NoSuchFieldException nsfe) {\n                throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);\n            } catch(IllegalAccessException iae) {\n                throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);\n            } catch(IllegalArgumentException iae) {\n                throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);\n            } catch(java.lang.reflect.InvocationTargetException ite) {\n                throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);\n            } catch(SecurityException se) {\n                throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\");\n        }\n    }",
    "begin_line": 626,
    "end_line": 672,
    "comment": "/** \n * \u003cp\u003eRemoves the accents from a string. \u003c/p\u003e \u003cp\u003eNOTE: This is a JDK 1.6 method, it will fail on JDK 1.5. \u003c/p\u003e \u003cpre\u003e StringUtils.stripAccents(null)                \u003d null StringUtils.stripAccents(\"\")                  \u003d \"\" StringUtils.stripAccents(\"control\")           \u003d \"control\" StringUtils.stripAccents(\"\u0026ecute;clair\")      \u003d \"eclair\" \u003c/pre\u003e\n * @param input String to be stripped\n * @return String without accents on the text\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.equals#696",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.equals(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equals(String str1, String str2) {\n        return str1 \u003d\u003d null ? str2 \u003d\u003d null : str1.equals(str2);\n    }",
    "begin_line": 696,
    "end_line": 698,
    "comment": "/** \n * \u003cp\u003eCompares two Strings, returning \u003ccode\u003etrue\u003c/code\u003e if they are equal.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003es are handled without exceptions. Two \u003ccode\u003enull\u003c/code\u003e references are considered to be equal. The comparison is case sensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.equals(null, null)   \u003d true StringUtils.equals(null, \"abc\")  \u003d false StringUtils.equals(\"abc\", null)  \u003d false StringUtils.equals(\"abc\", \"abc\") \u003d true StringUtils.equals(\"abc\", \"ABC\") \u003d false \u003c/pre\u003e\n * @see java.lang.String#equals(Object)\n * @param str1  the first String, may be null\n * @param str2  the second String, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the Strings are equal, case sensitive, orboth \u003ccode\u003enull\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.equalsIgnoreCase#721",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.equalsIgnoreCase(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 \u003d\u003d null ? str2 \u003d\u003d null : str1.equalsIgnoreCase(str2);\n    }",
    "begin_line": 721,
    "end_line": 723,
    "comment": "/** \n * \u003cp\u003eCompares two Strings, returning \u003ccode\u003etrue\u003c/code\u003e if they are equal ignoring the case.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003es are handled without exceptions. Two \u003ccode\u003enull\u003c/code\u003e references are considered equal. Comparison is case insensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.equalsIgnoreCase(null, null)   \u003d true StringUtils.equalsIgnoreCase(null, \"abc\")  \u003d false StringUtils.equalsIgnoreCase(\"abc\", null)  \u003d false StringUtils.equalsIgnoreCase(\"abc\", \"abc\") \u003d true StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") \u003d true \u003c/pre\u003e\n * @see java.lang.String#equalsIgnoreCase(String)\n * @param str1  the first String, may be null\n * @param str2  the second String, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the Strings are equal, case insensitive, orboth \u003ccode\u003enull\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOf#746",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOf(java.lang.String, char)",
    "snippet": "public static int indexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.indexOf(searchChar);\n    }",
    "begin_line": 746,
    "end_line": 751,
    "comment": "/** \n * \u003cp\u003eFinds the first index within a String, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#indexOf(int)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e or empty (\"\") String will return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOf(null, *)         \u003d -1 StringUtils.indexOf(\"\", *)           \u003d -1 StringUtils.indexOf(\"aabaabaa\", \u0027a\u0027) \u003d 0 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027) \u003d 2 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChar  the character to find\n * @return the first index of the search character,-1 if no match or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOf#778",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOf(java.lang.String, char, int)",
    "snippet": "public static int indexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.indexOf(searchChar, startPos);\n    }",
    "begin_line": 778,
    "end_line": 783,
    "comment": "/** \n * \u003cp\u003eFinds the first index within a String from a start position, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#indexOf(int,int)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e or empty (\"\") String will return \u003ccode\u003e-1\u003c/code\u003e. A negative start position is treated as zero. A start position greater than the string length returns \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOf(null, *, *)          \u003d -1 StringUtils.indexOf(\"\", *, *)            \u003d -1 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027, 0)  \u003d 2 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027, 3)  \u003d 5 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027, 9)  \u003d -1 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027, -1) \u003d 2 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChar  the character to find\n * @param startPos  the start position, negative treated as zero\n * @return the first index of the search character,-1 if no match or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOf#807",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOf(java.lang.String, java.lang.String)",
    "snippet": "public static int indexOf(String str, String searchStr) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return -1;\n        }\n        return str.indexOf(searchStr);\n    }",
    "begin_line": 807,
    "end_line": 812,
    "comment": "/** \n * \u003cp\u003eFinds the first index within a String, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#indexOf(String)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOf(null, *)          \u003d -1 StringUtils.indexOf(*, null)          \u003d -1 StringUtils.indexOf(\"\", \"\")           \u003d 0 StringUtils.indexOf(\"aabaabaa\", \"a\")  \u003d 0 StringUtils.indexOf(\"aabaabaa\", \"b\")  \u003d 2 StringUtils.indexOf(\"aabaabaa\", \"ab\") \u003d 1 StringUtils.indexOf(\"aabaabaa\", \"\")   \u003d 0 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchStr  the String to find, may be null\n * @return the first index of the search String,-1 if no match or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.ordinalIndexOf#841",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.ordinalIndexOf(java.lang.String, java.lang.String, int)",
    "snippet": "public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null || ordinal \u003c\u003d 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() \u003d\u003d 0) {\n            return 0;\n        }\n        int found \u003d 0;\n        int index \u003d INDEX_NOT_FOUND;\n        do {\n            index \u003d str.indexOf(searchStr, index + 1);\n            if (index \u003c 0) {\n                return index;\n            }\n            found++;\n        } while (found \u003c ordinal);\n        return index;\n    }",
    "begin_line": 841,
    "end_line": 858,
    "comment": "/** \n * \u003cp\u003eFinds the n-th index within a String, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#indexOf(String)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.ordinalIndexOf(null, *, *)          \u003d -1 StringUtils.ordinalIndexOf(*, null, *)          \u003d -1 StringUtils.ordinalIndexOf(\"\", \"\", *)           \u003d 0 StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1)  \u003d 0 StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2)  \u003d 1 StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1)  \u003d 2 StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2)  \u003d 5 StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1) \u003d 1 StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2) \u003d 4 StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1)   \u003d 0 StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2)   \u003d 0 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchStr  the String to find, may be null\n * @param ordinal  the n-th \u003ccode\u003esearchStr\u003c/code\u003e to find\n * @return the n-th index of the search String,\u003ccode\u003e-1\u003c/code\u003e (\u003ccode\u003eINDEX_NOT_FOUND\u003c/code\u003e) if no match or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOf#891",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOf(java.lang.String, java.lang.String, int)",
    "snippet": "public static int indexOf(String str, String searchStr, int startPos) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return -1;\n        }\n        // JDK1.2/JDK1.3 have a bug, when startPos \u003e str.length for \"\", hence\n        if (searchStr.length() \u003d\u003d 0 \u0026\u0026 startPos \u003e\u003d str.length()) {\n            return str.length();\n        }\n        return str.indexOf(searchStr, startPos);\n    }",
    "begin_line": 891,
    "end_line": 900,
    "comment": "/** \n * \u003cp\u003eFinds the first index within a String, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#indexOf(String,int)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e. A negative start position is treated as zero. An empty (\"\") search String always matches. A start position greater than the string length only matches an empty search String.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOf(null, *, *)          \u003d -1 StringUtils.indexOf(*, null, *)          \u003d -1 StringUtils.indexOf(\"\", \"\", 0)           \u003d 0 StringUtils.indexOf(\"aabaabaa\", \"a\", 0)  \u003d 0 StringUtils.indexOf(\"aabaabaa\", \"b\", 0)  \u003d 2 StringUtils.indexOf(\"aabaabaa\", \"ab\", 0) \u003d 1 StringUtils.indexOf(\"aabaabaa\", \"b\", 3)  \u003d 5 StringUtils.indexOf(\"aabaabaa\", \"b\", 9)  \u003d -1 StringUtils.indexOf(\"aabaabaa\", \"b\", -1) \u003d 2 StringUtils.indexOf(\"aabaabaa\", \"\", 2)   \u003d 2 StringUtils.indexOf(\"abc\", \"\", 9)        \u003d 3 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchStr  the String to find, may be null\n * @param startPos  the start position, negative treated as zero\n * @return the first index of the search String,-1 if no match or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOf#923",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOf(java.lang.String, char)",
    "snippet": "public static int lastIndexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.lastIndexOf(searchChar);\n    }",
    "begin_line": 923,
    "end_line": 928,
    "comment": "/** \n * \u003cp\u003eFinds the last index within a String, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#lastIndexOf(int)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e or empty (\"\") String will return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOf(null, *)         \u003d -1 StringUtils.lastIndexOf(\"\", *)           \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \u0027a\u0027) \u003d 7 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027) \u003d 5 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChar  the character to find\n * @return the last index of the search character,-1 if no match or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOf#957",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOf(java.lang.String, char, int)",
    "snippet": "public static int lastIndexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }",
    "begin_line": 957,
    "end_line": 962,
    "comment": "/** \n * \u003cp\u003eFinds the last index within a String from a start position, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#lastIndexOf(int,int)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e or empty (\"\") String will return \u003ccode\u003e-1\u003c/code\u003e. A negative start position returns \u003ccode\u003e-1\u003c/code\u003e. A start position greater than the string length searches the whole string.\u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOf(null, *, *)          \u003d -1 StringUtils.lastIndexOf(\"\", *,  *)           \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, 8)  \u003d 5 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, 4)  \u003d 2 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, 0)  \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, 9)  \u003d 5 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, -1) \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \u0027a\u0027, 0)  \u003d 0 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChar  the character to find\n * @param startPos  the start position\n * @return the last index of the search character,-1 if no match or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOf#986",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOf(java.lang.String, java.lang.String)",
    "snippet": "public static int lastIndexOf(String str, String searchStr) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return -1;\n        }\n        return str.lastIndexOf(searchStr);\n    }",
    "begin_line": 986,
    "end_line": 991,
    "comment": "/** \n * \u003cp\u003eFinds the last index within a String, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#lastIndexOf(String)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOf(null, *)          \u003d -1 StringUtils.lastIndexOf(*, null)          \u003d -1 StringUtils.lastIndexOf(\"\", \"\")           \u003d 0 StringUtils.lastIndexOf(\"aabaabaa\", \"a\")  \u003d 0 StringUtils.lastIndexOf(\"aabaabaa\", \"b\")  \u003d 2 StringUtils.lastIndexOf(\"aabaabaa\", \"ab\") \u003d 1 StringUtils.lastIndexOf(\"aabaabaa\", \"\")   \u003d 8 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchStr  the String to find, may be null\n * @return the last index of the search String,-1 if no match or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOf#1021",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOf(java.lang.String, java.lang.String, int)",
    "snippet": "public static int lastIndexOf(String str, String searchStr, int startPos) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return -1;\n        }\n        return str.lastIndexOf(searchStr, startPos);\n    }",
    "begin_line": 1021,
    "end_line": 1026,
    "comment": "/** \n * \u003cp\u003eFinds the first index within a String, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#lastIndexOf(String,int)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e. A negative start position returns \u003ccode\u003e-1\u003c/code\u003e. An empty (\"\") search String always matches unless the start position is negative. A start position greater than the string length searches the whole string.\u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOf(null, *, *)          \u003d -1 StringUtils.lastIndexOf(*, null, *)          \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 8)  \u003d 7 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 8)  \u003d 5 StringUtils.lastIndexOf(\"aabaabaa\", \"ab\", 8) \u003d 4 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 9)  \u003d 5 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1) \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0)  \u003d 0 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  \u003d -1 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchStr  the String to find, may be null\n * @param startPos  the start position, negative treated as zero\n * @return the first index of the search String,-1 if no match or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.contains#1049",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.contains(java.lang.String, char)",
    "snippet": "public static boolean contains(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return false;\n        }\n        return str.indexOf(searchChar) \u003e\u003d 0;\n    }",
    "begin_line": 1049,
    "end_line": 1054,
    "comment": "/** \n * \u003cp\u003eChecks if String contains a search character, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#indexOf(int)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e or empty (\"\") String will return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.contains(null, *)    \u003d false StringUtils.contains(\"\", *)      \u003d false StringUtils.contains(\"abc\", \u0027a\u0027) \u003d true StringUtils.contains(\"abc\", \u0027z\u0027) \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChar  the character to find\n * @return true if the String contains the search character,false if not or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.contains#1077",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.contains(java.lang.String, java.lang.String)",
    "snippet": "public static boolean contains(String str, String searchStr) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return false;\n        }\n        return str.indexOf(searchStr) \u003e\u003d 0;\n    }",
    "begin_line": 1077,
    "end_line": 1082,
    "comment": "/** \n * \u003cp\u003eChecks if String contains a search String, handling \u003ccode\u003enull\u003c/code\u003e. This method uses  {@link String#indexOf(String)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.contains(null, *)     \u003d false StringUtils.contains(*, null)     \u003d false StringUtils.contains(\"\", \"\")      \u003d true StringUtils.contains(\"abc\", \"\")   \u003d true StringUtils.contains(\"abc\", \"a\")  \u003d true StringUtils.contains(\"abc\", \"z\")  \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchStr  the String to find, may be null\n * @return true if the String contains the search String,false if not or \u003ccode\u003enull\u003c/code\u003e string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsIgnoreCase#1107",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsIgnoreCase(java.lang.String, java.lang.String)",
    "snippet": "public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return false;\n        }\n        int len \u003d searchStr.length();\n        int max \u003d str.length() - len;\n        for (int i \u003d 0; i \u003c\u003d max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "begin_line": 1107,
    "end_line": 1119,
    "comment": "/** \n * \u003cp\u003eChecks if String contains a search String irrespective of case, handling \u003ccode\u003enull\u003c/code\u003e. Case-insensitivity is defined as by {@link String#equalsIgnoreCase(String)}. \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.contains(null, *) \u003d false StringUtils.contains(*, null) \u003d false StringUtils.contains(\"\", \"\") \u003d true StringUtils.contains(\"abc\", \"\") \u003d true StringUtils.contains(\"abc\", \"a\") \u003d true StringUtils.contains(\"abc\", \"z\") \u003d false StringUtils.contains(\"abc\", \"A\") \u003d true StringUtils.contains(\"abc\", \"Z\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchStr  the String to find, may be null\n * @return true if the String contains the search String irrespective ofcase or false if not or \u003ccode\u003enull\u003c/code\u003e string input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAny#1145",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAny(java.lang.String, char[])",
    "snippet": "public static int indexOfAny(String str, char[] searchChars) {\n        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return -1;\n        }\n        for (int i \u003d 0; i \u003c str.length(); i++) {\n            char ch \u003d str.charAt(i);\n            for (int j \u003d 0; j \u003c searchChars.length; j++) {\n                if (searchChars[j] \u003d\u003d ch) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }",
    "begin_line": 1145,
    "end_line": 1158,
    "comment": "/** \n * \u003cp\u003eSearch a String to find the first index of any character in the given set of characters.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e or zero length search array will return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfAny(null, *)                \u003d -1 StringUtils.indexOfAny(\"\", *)                  \u003d -1 StringUtils.indexOfAny(*, null)                \u003d -1 StringUtils.indexOfAny(*, [])                  \u003d -1 StringUtils.indexOfAny(\"zzabyycdxx\",[\u0027z\u0027,\u0027a\u0027]) \u003d 0 StringUtils.indexOfAny(\"zzabyycdxx\",[\u0027b\u0027,\u0027y\u0027]) \u003d 3 StringUtils.indexOfAny(\"aba\", [\u0027z\u0027])           \u003d -1 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAny#1182",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAny(java.lang.String, java.lang.String)",
    "snippet": "public static int indexOfAny(String str, String searchChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return -1;\n        }\n        return indexOfAny(str, searchChars.toCharArray());\n    }",
    "begin_line": 1182,
    "end_line": 1187,
    "comment": "/** \n * \u003cp\u003eSearch a String to find the first index of any character in the given set of characters.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e search string will return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfAny(null, *)            \u003d -1 StringUtils.indexOfAny(\"\", *)              \u003d -1 StringUtils.indexOfAny(*, null)            \u003d -1 StringUtils.indexOfAny(*, \"\")              \u003d -1 StringUtils.indexOfAny(\"zzabyycdxx\", \"za\") \u003d 0 StringUtils.indexOfAny(\"zzabyycdxx\", \"by\") \u003d 3 StringUtils.indexOfAny(\"aba\",\"z\")          \u003d -1 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsAny#1214",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsAny(java.lang.String, char[])",
    "snippet": "public static boolean containsAny(String str, char[] searchChars) {\n        if (str \u003d\u003d null || str.length() \u003d\u003d 0 || searchChars \u003d\u003d null || searchChars.length \u003d\u003d 0) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c str.length(); i++) {\n            char ch \u003d str.charAt(i);\n            for (int j \u003d 0; j \u003c searchChars.length; j++) {\n                if (searchChars[j] \u003d\u003d ch) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
    "begin_line": 1214,
    "end_line": 1227,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains any character in the given set of characters.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003efalse\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e or zero length search array will return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.containsAny(null, *)                \u003d false StringUtils.containsAny(\"\", *)                  \u003d false StringUtils.containsAny(*, null)                \u003d false StringUtils.containsAny(*, [])                  \u003d false StringUtils.containsAny(\"zzabyycdxx\",[\u0027z\u0027,\u0027a\u0027]) \u003d true StringUtils.containsAny(\"zzabyycdxx\",[\u0027b\u0027,\u0027y\u0027]) \u003d true StringUtils.containsAny(\"aba\", [\u0027z\u0027])           \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the \u003ccode\u003etrue\u003c/code\u003e if any of the chars are found,\u003ccode\u003efalse\u003c/code\u003e if no match or null input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsAny#1256",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsAny(java.lang.String, java.lang.String)",
    "snippet": "public static boolean containsAny(String str, String searchChars) {\n        if (searchChars \u003d\u003d null) {\n            return false;\n        }\n        return containsAny(str, searchChars.toCharArray());\n    }",
    "begin_line": 1256,
    "end_line": 1261,
    "comment": "/** \n * \u003cp\u003e Checks if the String contains any character in the given set of characters. \u003c/p\u003e \u003cp\u003e A \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003efalse\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e search string will return \u003ccode\u003efalse\u003c/code\u003e. \u003c/p\u003e \u003cpre\u003e StringUtils.containsAny(null, *)            \u003d false StringUtils.containsAny(\"\", *)              \u003d false StringUtils.containsAny(*, null)            \u003d false StringUtils.containsAny(*, \"\")              \u003d false StringUtils.containsAny(\"zzabyycdxx\", \"za\") \u003d true StringUtils.containsAny(\"zzabyycdxx\", \"by\") \u003d true StringUtils.containsAny(\"aba\",\"z\")          \u003d false \u003c/pre\u003e\n * @param str the String to check, may be null\n * @param searchChars the chars to search for, may be null\n * @return the \u003ccode\u003etrue\u003c/code\u003e if any of the chars are found, \u003ccode\u003efalse\u003c/code\u003e if no match or null input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAnyBut#1287",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAnyBut(java.lang.String, char[])",
    "snippet": "public static int indexOfAnyBut(String str, char[] searchChars) {\n        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return -1;\n        }\n        outer : for (int i \u003d 0; i \u003c str.length(); i++) {\n            char ch \u003d str.charAt(i);\n            for (int j \u003d 0; j \u003c searchChars.length; j++) {\n                if (searchChars[j] \u003d\u003d ch) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }",
    "begin_line": 1287,
    "end_line": 1301,
    "comment": "/** \n * \u003cp\u003eSearch a String to find the first index of any character not in the given set of characters.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e or zero length search array will return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfAnyBut(null, *)           \u003d -1 StringUtils.indexOfAnyBut(\"\", *)             \u003d -1 StringUtils.indexOfAnyBut(*, null)           \u003d -1 StringUtils.indexOfAnyBut(*, [])             \u003d -1 StringUtils.indexOfAnyBut(\"zzabyycdxx\",\u0027za\u0027) \u003d 3 StringUtils.indexOfAnyBut(\"zzabyycdxx\", \u0027\u0027)  \u003d 0 StringUtils.indexOfAnyBut(\"aba\", \u0027ab\u0027)       \u003d -1 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAnyBut#1325",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAnyBut(java.lang.String, java.lang.String)",
    "snippet": "public static int indexOfAnyBut(String str, String searchChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return -1;\n        }\n        for (int i \u003d 0; i \u003c str.length(); i++) {\n            if (searchChars.indexOf(str.charAt(i)) \u003c 0) {\n                return i;\n            }\n        }\n        return -1;\n    }",
    "begin_line": 1325,
    "end_line": 1335,
    "comment": "/** \n * \u003cp\u003eSearch a String to find the first index of any character not in the given set of characters.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e search string will return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfAnyBut(null, *)            \u003d -1 StringUtils.indexOfAnyBut(\"\", *)              \u003d -1 StringUtils.indexOfAnyBut(*, null)            \u003d -1 StringUtils.indexOfAnyBut(*, \"\")              \u003d -1 StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") \u003d 3 StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   \u003d 0 StringUtils.indexOfAnyBut(\"aba\",\"ab\")         \u003d -1 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsOnly#1360",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsOnly(java.lang.String, char[])",
    "snippet": "public static boolean containsOnly(String str, char[] valid) {\n        // All these pre-checks are to maintain API with an older version\n        if ((valid \u003d\u003d null) || (str \u003d\u003d null)) {\n            return false;\n        }\n        if (str.length() \u003d\u003d 0) {\n            return true;\n        }\n        if (valid.length \u003d\u003d 0) {\n            return false;\n        }\n        return indexOfAnyBut(str, valid) \u003d\u003d -1;\n    }",
    "begin_line": 1360,
    "end_line": 1372,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only certain characters.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003efalse\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e valid character array will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") always returns \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.containsOnly(null, *)       \u003d false StringUtils.containsOnly(*, null)       \u003d false StringUtils.containsOnly(\"\", *)         \u003d true StringUtils.containsOnly(\"ab\", \u0027\u0027)      \u003d false StringUtils.containsOnly(\"abab\", \u0027abc\u0027) \u003d true StringUtils.containsOnly(\"ab1\", \u0027abc\u0027)  \u003d false StringUtils.containsOnly(\"abz\", \u0027abc\u0027)  \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param valid  an array of valid chars, may be null\n * @return true if it only contains valid chars and is non-null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsOnly#1396",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsOnly(java.lang.String, java.lang.String)",
    "snippet": "public static boolean containsOnly(String str, String validChars) {\n        if (str \u003d\u003d null || validChars \u003d\u003d null) {\n            return false;\n        }\n        return containsOnly(str, validChars.toCharArray());\n    }",
    "begin_line": 1396,
    "end_line": 1401,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only certain characters.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003efalse\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e valid character String will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") always returns \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.containsOnly(null, *)       \u003d false StringUtils.containsOnly(*, null)       \u003d false StringUtils.containsOnly(\"\", *)         \u003d true StringUtils.containsOnly(\"ab\", \"\")      \u003d false StringUtils.containsOnly(\"abab\", \"abc\") \u003d true StringUtils.containsOnly(\"ab1\", \"abc\")  \u003d false StringUtils.containsOnly(\"abz\", \"abc\")  \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param validChars  a String of valid chars, may be null\n * @return true if it only contains valid chars and is non-null\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsNone#1427",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsNone(java.lang.String, char[])",
    "snippet": "public static boolean containsNone(String str, char[] invalidChars) {\n        if (str \u003d\u003d null || invalidChars \u003d\u003d null) {\n            return true;\n        }\n        int strSize \u003d str.length();\n        int validSize \u003d invalidChars.length;\n        for (int i \u003d 0; i \u003c strSize; i++) {\n            char ch \u003d str.charAt(i);\n            for (int j \u003d 0; j \u003c validSize; j++) {\n                if (invalidChars[j] \u003d\u003d ch) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
    "begin_line": 1427,
    "end_line": 1442,
    "comment": "/** \n * \u003cp\u003eChecks that the String does not contain certain characters.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003etrue\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e invalid character array will return \u003ccode\u003etrue\u003c/code\u003e. An empty String (\"\") always returns true.\u003c/p\u003e \u003cpre\u003e StringUtils.containsNone(null, *)       \u003d true StringUtils.containsNone(*, null)       \u003d true StringUtils.containsNone(\"\", *)         \u003d true StringUtils.containsNone(\"ab\", \u0027\u0027)      \u003d true StringUtils.containsNone(\"abab\", \u0027xyz\u0027) \u003d true StringUtils.containsNone(\"ab1\", \u0027xyz\u0027)  \u003d true StringUtils.containsNone(\"abz\", \u0027xyz\u0027)  \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param invalidChars  an array of invalid chars, may be null\n * @return true if it contains none of the invalid chars, or is null\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsNone#1466",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsNone(java.lang.String, java.lang.String)",
    "snippet": "public static boolean containsNone(String str, String invalidChars) {\n        if (str \u003d\u003d null || invalidChars \u003d\u003d null) {\n            return true;\n        }\n        return containsNone(str, invalidChars.toCharArray());\n    }",
    "begin_line": 1466,
    "end_line": 1471,
    "comment": "/** \n * \u003cp\u003eChecks that the String does not contain certain characters.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003etrue\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e invalid character array will return \u003ccode\u003etrue\u003c/code\u003e. An empty String (\"\") always returns true.\u003c/p\u003e \u003cpre\u003e StringUtils.containsNone(null, *)       \u003d true StringUtils.containsNone(*, null)       \u003d true StringUtils.containsNone(\"\", *)         \u003d true StringUtils.containsNone(\"ab\", \"\")      \u003d true StringUtils.containsNone(\"abab\", \"xyz\") \u003d true StringUtils.containsNone(\"ab1\", \"xyz\")  \u003d true StringUtils.containsNone(\"abz\", \"xyz\")  \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param invalidChars  a String of invalid chars, may be null\n * @return true if it contains none of the invalid chars, or is null\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAny#1501",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAny(java.lang.String, java.lang.String[])",
    "snippet": "public static int indexOfAny(String str, String[] searchStrs) {\n        if ((str \u003d\u003d null) || (searchStrs \u003d\u003d null)) {\n            return -1;\n        }\n        int sz \u003d searchStrs.length;\n\n        // String\u0027s can\u0027t have a MAX_VALUEth index.\n        int ret \u003d Integer.MAX_VALUE;\n\n        int tmp \u003d 0;\n        for (int i \u003d 0; i \u003c sz; i++) {\n            String search \u003d searchStrs[i];\n            if (search \u003d\u003d null) {\n                continue;\n            }\n            tmp \u003d str.indexOf(search);\n            if (tmp \u003d\u003d -1) {\n                continue;\n            }\n\n            if (tmp \u003c ret) {\n                ret \u003d tmp;\n            }\n        }\n\n        return (ret \u003d\u003d Integer.MAX_VALUE) ? -1 : ret;\n    }",
    "begin_line": 1501,
    "end_line": 1527,
    "comment": "/** \n * \u003cp\u003eFind the first index of any of a set of potential substrings.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e or zero length search array will return \u003ccode\u003e-1\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e search array entry will be ignored, but a search array containing \"\" will return \u003ccode\u003e0\u003c/code\u003e if \u003ccode\u003estr\u003c/code\u003e is not null. This method uses  {@link String#indexOf(String)}.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfAny(null, *)                     \u003d -1 StringUtils.indexOfAny(*, null)                     \u003d -1 StringUtils.indexOfAny(*, [])                       \u003d -1 StringUtils.indexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"])   \u003d 2 StringUtils.indexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"])   \u003d 2 StringUtils.indexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"])   \u003d -1 StringUtils.indexOfAny(\"zzabyycdxx\", [\"zab\",\"aby\"]) \u003d 1 StringUtils.indexOfAny(\"zzabyycdxx\", [\"\"])          \u003d 0 StringUtils.indexOfAny(\"\", [\"\"])                    \u003d 0 StringUtils.indexOfAny(\"\", [\"a\"])                   \u003d -1 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchStrs  the Strings to search for, may be null\n * @return the first index of any of the searchStrs in str, -1 if no match\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOfAny#1554",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOfAny(java.lang.String, java.lang.String[])",
    "snippet": "public static int lastIndexOfAny(String str, String[] searchStrs) {\n        if ((str \u003d\u003d null) || (searchStrs \u003d\u003d null)) {\n            return -1;\n        }\n        int sz \u003d searchStrs.length;\n        int ret \u003d -1;\n        int tmp \u003d 0;\n        for (int i \u003d 0; i \u003c sz; i++) {\n            String search \u003d searchStrs[i];\n            if (search \u003d\u003d null) {\n                continue;\n            }\n            tmp \u003d str.lastIndexOf(search);\n            if (tmp \u003e ret) {\n                ret \u003d tmp;\n            }\n        }\n        return ret;\n    }",
    "begin_line": 1554,
    "end_line": 1572,
    "comment": "/** \n * \u003cp\u003eFind the latest index of any of a set of potential substrings.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003e-1\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e search array will return \u003ccode\u003e-1\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e or zero length search array entry will be ignored, but a search array containing \"\" will return the length of \u003ccode\u003estr\u003c/code\u003e if \u003ccode\u003estr\u003c/code\u003e is not null. This method uses  {@link String#indexOf(String)}\u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOfAny(null, *)                   \u003d -1 StringUtils.lastIndexOfAny(*, null)                   \u003d -1 StringUtils.lastIndexOfAny(*, [])                     \u003d -1 StringUtils.lastIndexOfAny(*, [null])                 \u003d -1 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"]) \u003d 6 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"]) \u003d 6 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) \u003d -1 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) \u003d -1 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   \u003d 10 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param searchStrs  the Strings to search for, may be null\n * @return the last index of any of the Strings, -1 if no match\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substring#1600",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substring(java.lang.String, int)",
    "snippet": "public static String substring(String str, int start) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n\n        // handle negatives, which means last n characters\n        if (start \u003c 0) {\n            start \u003d str.length() + start; // remember start is negative\n        }\n\n        if (start \u003c 0) {\n            start \u003d 0;\n        }\n        if (start \u003e str.length()) {\n            return EMPTY;\n        }\n\n        return str.substring(start);\n    }",
    "begin_line": 1600,
    "end_line": 1618,
    "comment": "/** \n * \u003cp\u003eGets a substring from the specified String avoiding exceptions.\u003c/p\u003e \u003cp\u003eA negative start position can be used to start \u003ccode\u003en\u003c/code\u003e characters from the end of the String.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") String will return \"\".\u003c/p\u003e \u003cpre\u003e StringUtils.substring(null, *)   \u003d null StringUtils.substring(\"\", *)     \u003d \"\" StringUtils.substring(\"abc\", 0)  \u003d \"abc\" StringUtils.substring(\"abc\", 2)  \u003d \"c\" StringUtils.substring(\"abc\", 4)  \u003d \"\" StringUtils.substring(\"abc\", -2) \u003d \"bc\" StringUtils.substring(\"abc\", -4) \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get the substring from, may be null\n * @param start  the position to start from, negative meanscount back from the end of the String by this many characters\n * @return substring from start position, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substring#1655",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substring(java.lang.String, int, int)",
    "snippet": "public static String substring(String str, int start, int end) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n\n        // handle negatives\n        if (end \u003c 0) {\n            end \u003d str.length() + end; // remember end is negative\n        }\n        if (start \u003c 0) {\n            start \u003d str.length() + start; // remember start is negative\n        }\n\n        // check length next\n        if (end \u003e str.length()) {\n            end \u003d str.length();\n        }\n\n        // if start is greater than end, return \"\"\n        if (start \u003e end) {\n            return EMPTY;\n        }\n\n        if (start \u003c 0) {\n            start \u003d 0;\n        }\n        if (end \u003c 0) {\n            end \u003d 0;\n        }\n\n        return str.substring(start, end);\n    }",
    "begin_line": 1655,
    "end_line": 1686,
    "comment": "/** \n * \u003cp\u003eGets a substring from the specified String avoiding exceptions.\u003c/p\u003e \u003cp\u003eA negative start position can be used to start/end \u003ccode\u003en\u003c/code\u003e characters from the end of the String.\u003c/p\u003e \u003cp\u003eThe returned substring starts with the character in the \u003ccode\u003estart\u003c/code\u003e position and ends before the \u003ccode\u003eend\u003c/code\u003e position. All position counting is zero-based -- i.e., to start at the beginning of the string use \u003ccode\u003estart \u003d 0\u003c/code\u003e. Negative start and end positions can be used to specify offsets relative to the end of the String.\u003c/p\u003e \u003cp\u003eIf \u003ccode\u003estart\u003c/code\u003e is not strictly to the left of \u003ccode\u003eend\u003c/code\u003e, \"\" is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substring(null, *, *)    \u003d null StringUtils.substring(\"\", * ,  *)    \u003d \"\"; StringUtils.substring(\"abc\", 0, 2)   \u003d \"ab\" StringUtils.substring(\"abc\", 2, 0)   \u003d \"\" StringUtils.substring(\"abc\", 2, 4)   \u003d \"c\" StringUtils.substring(\"abc\", 4, 6)   \u003d \"\" StringUtils.substring(\"abc\", 2, 2)   \u003d \"\" StringUtils.substring(\"abc\", -2, -1) \u003d \"b\" StringUtils.substring(\"abc\", -4, 2)  \u003d \"ab\" \u003c/pre\u003e\n * @param str  the String to get the substring from, may be null\n * @param start  the position to start from, negative meanscount back from the end of the String by this many characters\n * @param end  the position to end at (exclusive), negative meanscount back from the end of the String by this many characters\n * @return substring from start position to end positon,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.left#1710",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.left(java.lang.String, int)",
    "snippet": "public static String left(String str, int len) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (len \u003c 0) {\n            return EMPTY;\n        }\n        if (str.length() \u003c\u003d len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }",
    "begin_line": 1710,
    "end_line": 1721,
    "comment": "/** \n * \u003cp\u003eGets the leftmost \u003ccode\u003elen\u003c/code\u003e characters of a String.\u003c/p\u003e \u003cp\u003eIf \u003ccode\u003elen\u003c/code\u003e characters are not available, or the String is \u003ccode\u003enull\u003c/code\u003e, the String will be returned without an exception. An exception is thrown if len is negative.\u003c/p\u003e \u003cpre\u003e StringUtils.left(null, *)    \u003d null StringUtils.left(*, -ve)     \u003d \"\" StringUtils.left(\"\", *)      \u003d \"\" StringUtils.left(\"abc\", 0)   \u003d \"\" StringUtils.left(\"abc\", 2)   \u003d \"ab\" StringUtils.left(\"abc\", 4)   \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get the leftmost characters from, may be null\n * @param len  the length of the required String, must be zero or positive\n * @return the leftmost characters, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.right#1743",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.right(java.lang.String, int)",
    "snippet": "public static String right(String str, int len) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (len \u003c 0) {\n            return EMPTY;\n        }\n        if (str.length() \u003c\u003d len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }",
    "begin_line": 1743,
    "end_line": 1754,
    "comment": "/** \n * \u003cp\u003eGets the rightmost \u003ccode\u003elen\u003c/code\u003e characters of a String.\u003c/p\u003e \u003cp\u003eIf \u003ccode\u003elen\u003c/code\u003e characters are not available, or the String is \u003ccode\u003enull\u003c/code\u003e, the String will be returned without an an exception. An exception is thrown if len is negative.\u003c/p\u003e \u003cpre\u003e StringUtils.right(null, *)    \u003d null StringUtils.right(*, -ve)     \u003d \"\" StringUtils.right(\"\", *)      \u003d \"\" StringUtils.right(\"abc\", 0)   \u003d \"\" StringUtils.right(\"abc\", 2)   \u003d \"bc\" StringUtils.right(\"abc\", 4)   \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get the rightmost characters from, may be null\n * @param len  the length of the required String, must be zero or positive\n * @return the rightmost characters, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.mid#1780",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.mid(java.lang.String, int, int)",
    "snippet": "public static String mid(String str, int pos, int len) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (len \u003c 0 || pos \u003e str.length()) {\n            return EMPTY;\n        }\n        if (pos \u003c 0) {\n            pos \u003d 0;\n        }\n        if (str.length() \u003c\u003d (pos + len)) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }",
    "begin_line": 1780,
    "end_line": 1794,
    "comment": "/** \n * \u003cp\u003eGets \u003ccode\u003elen\u003c/code\u003e characters from the middle of a String.\u003c/p\u003e \u003cp\u003eIf \u003ccode\u003elen\u003c/code\u003e characters are not available, the remainder of the String will be returned without an exception. If the String is \u003ccode\u003enull\u003c/code\u003e, \u003ccode\u003enull\u003c/code\u003e will be returned. An exception is thrown if len is negative.\u003c/p\u003e \u003cpre\u003e StringUtils.mid(null, *, *)    \u003d null StringUtils.mid(*, *, -ve)     \u003d \"\" StringUtils.mid(\"\", 0, *)      \u003d \"\" StringUtils.mid(\"abc\", 0, 2)   \u003d \"ab\" StringUtils.mid(\"abc\", 0, 4)   \u003d \"abc\" StringUtils.mid(\"abc\", 2, 4)   \u003d \"c\" StringUtils.mid(\"abc\", 4, 2)   \u003d \"\" StringUtils.mid(\"abc\", -2, 2)  \u003d \"ab\" \u003c/pre\u003e\n * @param str  the String to get the characters from, may be null\n * @param pos  the position to start from, negative treated as zero\n * @param len  the length of the required String, must be zero or positive\n * @return the middle characters, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringBefore#1825",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringBefore(java.lang.String, java.lang.String)",
    "snippet": "public static String substringBefore(String str, String separator) {\n        if (isEmpty(str) || separator \u003d\u003d null) {\n            return str;\n        }\n        if (separator.length() \u003d\u003d 0) {\n            return EMPTY;\n        }\n        int pos \u003d str.indexOf(separator);\n        if (pos \u003d\u003d -1) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }",
    "begin_line": 1825,
    "end_line": 1837,
    "comment": "/** \n * \u003cp\u003eGets the substring before the first occurrence of a separator. The separator is not returned.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e string input will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") string input will return the empty string. A \u003ccode\u003enull\u003c/code\u003e separator will return the input string.\u003c/p\u003e \u003cp\u003eIf nothing is found, the string input is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substringBefore(null, *)      \u003d null StringUtils.substringBefore(\"\", *)        \u003d \"\" StringUtils.substringBefore(\"abc\", \"a\")   \u003d \"\" StringUtils.substringBefore(\"abcba\", \"b\") \u003d \"a\" StringUtils.substringBefore(\"abc\", \"c\")   \u003d \"ab\" StringUtils.substringBefore(\"abc\", \"d\")   \u003d \"abc\" StringUtils.substringBefore(\"abc\", \"\")    \u003d \"\" StringUtils.substringBefore(\"abc\", null)  \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring before the first occurrence of the separator,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringAfter#1867",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringAfter(java.lang.String, java.lang.String)",
    "snippet": "public static String substringAfter(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (separator \u003d\u003d null) {\n            return EMPTY;\n        }\n        int pos \u003d str.indexOf(separator);\n        if (pos \u003d\u003d -1) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }",
    "begin_line": 1867,
    "end_line": 1879,
    "comment": "/** \n * \u003cp\u003eGets the substring after the first occurrence of a separator. The separator is not returned.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e string input will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") string input will return the empty string. A \u003ccode\u003enull\u003c/code\u003e separator will return the empty string if the input string is not \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cp\u003eIf nothing is found, the empty string is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substringAfter(null, *)      \u003d null StringUtils.substringAfter(\"\", *)        \u003d \"\" StringUtils.substringAfter(*, null)      \u003d \"\" StringUtils.substringAfter(\"abc\", \"a\")   \u003d \"bc\" StringUtils.substringAfter(\"abcba\", \"b\") \u003d \"cba\" StringUtils.substringAfter(\"abc\", \"c\")   \u003d \"\" StringUtils.substringAfter(\"abc\", \"d\")   \u003d \"\" StringUtils.substringAfter(\"abc\", \"\")    \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring after the first occurrence of the separator,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringBeforeLast#1908",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringBeforeLast(java.lang.String, java.lang.String)",
    "snippet": "public static String substringBeforeLast(String str, String separator) {\n        if (isEmpty(str) || isEmpty(separator)) {\n            return str;\n        }\n        int pos \u003d str.lastIndexOf(separator);\n        if (pos \u003d\u003d -1) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }",
    "begin_line": 1908,
    "end_line": 1917,
    "comment": "/** \n * \u003cp\u003eGets the substring before the last occurrence of a separator. The separator is not returned.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e string input will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") string input will return the empty string. An empty or \u003ccode\u003enull\u003c/code\u003e separator will return the input string.\u003c/p\u003e \u003cp\u003eIf nothing is found, the string input is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substringBeforeLast(null, *)      \u003d null StringUtils.substringBeforeLast(\"\", *)        \u003d \"\" StringUtils.substringBeforeLast(\"abcba\", \"b\") \u003d \"abc\" StringUtils.substringBeforeLast(\"abc\", \"c\")   \u003d \"ab\" StringUtils.substringBeforeLast(\"a\", \"a\")     \u003d \"\" StringUtils.substringBeforeLast(\"a\", \"z\")     \u003d \"a\" StringUtils.substringBeforeLast(\"a\", null)    \u003d \"a\" StringUtils.substringBeforeLast(\"a\", \"\")      \u003d \"a\" \u003c/pre\u003e\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring before the last occurrence of the separator,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringAfterLast#1948",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringAfterLast(java.lang.String, java.lang.String)",
    "snippet": "public static String substringAfterLast(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (isEmpty(separator)) {\n            return EMPTY;\n        }\n        int pos \u003d str.lastIndexOf(separator);\n        if (pos \u003d\u003d -1 || pos \u003d\u003d (str.length() - separator.length())) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }",
    "begin_line": 1948,
    "end_line": 1960,
    "comment": "/** \n * \u003cp\u003eGets the substring after the last occurrence of a separator. The separator is not returned.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e string input will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") string input will return the empty string. An empty or \u003ccode\u003enull\u003c/code\u003e separator will return the empty string if the input string is not \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cp\u003eIf nothing is found, the empty string is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substringAfterLast(null, *)      \u003d null StringUtils.substringAfterLast(\"\", *)        \u003d \"\" StringUtils.substringAfterLast(*, \"\")        \u003d \"\" StringUtils.substringAfterLast(*, null)      \u003d \"\" StringUtils.substringAfterLast(\"abc\", \"a\")   \u003d \"bc\" StringUtils.substringAfterLast(\"abcba\", \"b\") \u003d \"a\" StringUtils.substringAfterLast(\"abc\", \"c\")   \u003d \"\" StringUtils.substringAfterLast(\"a\", \"a\")     \u003d \"\" StringUtils.substringAfterLast(\"a\", \"z\")     \u003d \"\" \u003c/pre\u003e\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring after the last occurrence of the separator,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringBetween#1985",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringBetween(java.lang.String, java.lang.String)",
    "snippet": "public static String substringBetween(String str, String tag) {\n        return substringBetween(str, tag, tag);\n    }",
    "begin_line": 1985,
    "end_line": 1987,
    "comment": "/** \n * \u003cp\u003eGets the String that is nested in between two instances of the same String.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e tag returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.substringBetween(null, *)            \u003d null StringUtils.substringBetween(\"\", \"\")             \u003d \"\" StringUtils.substringBetween(\"\", \"tag\")          \u003d null StringUtils.substringBetween(\"tagabctag\", null)  \u003d null StringUtils.substringBetween(\"tagabctag\", \"\")    \u003d \"\" StringUtils.substringBetween(\"tagabctag\", \"tag\") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String containing the substring, may be null\n * @param tag  the String before and after the substring, may be null\n * @return the substring, \u003ccode\u003enull\u003c/code\u003e if no match\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringBetween#2016",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringBetween(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String substringBetween(String str, String open, String close) {\n        if (str \u003d\u003d null || open \u003d\u003d null || close \u003d\u003d null) {\n            return null;\n        }\n        int start \u003d str.indexOf(open);\n        if (start !\u003d -1) {\n            int end \u003d str.indexOf(close, start + open.length());\n            if (end !\u003d -1) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }",
    "begin_line": 2016,
    "end_line": 2028,
    "comment": "/** \n * \u003cp\u003eGets the String that is nested in between two Strings. Only the first match is returned.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e open/close returns \u003ccode\u003enull\u003c/code\u003e (no match). An empty (\"\") open and close returns an empty string.\u003c/p\u003e \u003cpre\u003e StringUtils.substringBetween(\"wx[b]yz\", \"[\", \"]\") \u003d \"b\" StringUtils.substringBetween(null, *, *)          \u003d null StringUtils.substringBetween(*, null, *)          \u003d null StringUtils.substringBetween(*, *, null)          \u003d null StringUtils.substringBetween(\"\", \"\", \"\")          \u003d \"\" StringUtils.substringBetween(\"\", \"\", \"]\")         \u003d null StringUtils.substringBetween(\"\", \"[\", \"]\")        \u003d null StringUtils.substringBetween(\"yabcz\", \"\", \"\")     \u003d \"\" StringUtils.substringBetween(\"yabcz\", \"y\", \"z\")   \u003d \"abc\" StringUtils.substringBetween(\"yabczyabcz\", \"y\", \"z\")   \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String containing the substring, may be null\n * @param open  the String before the substring, may be null\n * @param close  the String after the substring, may be null\n * @return the substring, \u003ccode\u003enull\u003c/code\u003e if no match\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringsBetween#2052",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringsBetween(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String[] substringsBetween(String str, String open, String close) {\n        if (str \u003d\u003d null || isEmpty(open) || isEmpty(close)) {\n            return null;\n        }\n        int strLen \u003d str.length();\n        if (strLen \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen \u003d close.length();\n        int openLen \u003d open.length();\n        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n        int pos \u003d 0;\n        while (pos \u003c (strLen - closeLen)) {\n            int start \u003d str.indexOf(open, pos);\n            if (start \u003c 0) {\n                break;\n            }\n            start +\u003d openLen;\n            int end \u003d str.indexOf(close, start);\n            if (end \u003c 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos \u003d end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        } \n        return list.toArray(new String [list.size()]);\n    }",
    "begin_line": 2052,
    "end_line": 2081,
    "comment": "/** \n * \u003cp\u003eSearches a String for substrings delimited by a start and end tag, returning all matching substrings in an array.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e open/close returns \u003ccode\u003enull\u003c/code\u003e (no match). An empty (\"\") open/close returns \u003ccode\u003enull\u003c/code\u003e (no match).\u003c/p\u003e \u003cpre\u003e StringUtils.substringsBetween(\"[a][b][c]\", \"[\", \"]\") \u003d [\"a\",\"b\",\"c\"] StringUtils.substringsBetween(null, *, *)            \u003d null StringUtils.substringsBetween(*, null, *)            \u003d null StringUtils.substringsBetween(*, *, null)            \u003d null StringUtils.substringsBetween(\"\", \"[\", \"]\")          \u003d [] \u003c/pre\u003e\n * @param str  the String containing the substrings, null returns null, empty returns empty\n * @param open  the String identifying the start of the substring, empty returns null\n * @param close  the String identifying the end of the substring, empty returns null\n * @return a String Array of substrings, or \u003ccode\u003enull\u003c/code\u003e if no match\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.split#2110",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.split(java.lang.String)",
    "snippet": "public static String[] split(String str) {\n        return split(str, null, -1);\n    }",
    "begin_line": 2110,
    "end_line": 2112,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, using whitespace as the separator. Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as one separator. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.split(null)       \u003d null StringUtils.split(\"\")         \u003d [] StringUtils.split(\"abc def\")  \u003d [\"abc\", \"def\"] StringUtils.split(\"abc  def\") \u003d [\"abc\", \"def\"] StringUtils.split(\" abc \")    \u003d [\"abc\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.split#2138",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.split(java.lang.String, char)",
    "snippet": "public static String[] split(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, false);\n    }",
    "begin_line": 2138,
    "end_line": 2140,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator specified. This is an alternative to using StringTokenizer.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as one separator. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.split(null, *)         \u003d null StringUtils.split(\"\", *)           \u003d [] StringUtils.split(\"a.b.c\", \u0027.\u0027)    \u003d [\"a\", \"b\", \"c\"] StringUtils.split(\"a..b.c\", \u0027.\u0027)   \u003d [\"a\", \"b\", \"c\"] StringUtils.split(\"a:b:c\", \u0027.\u0027)    \u003d [\"a:b:c\"] StringUtils.split(\"a b c\", \u0027 \u0027)    \u003d [\"a\", \"b\", \"c\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separatorChar  the character used as the delimiter\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.split#2167",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.split(java.lang.String, java.lang.String)",
    "snippet": "public static String[] split(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, false);\n    }",
    "begin_line": 2167,
    "end_line": 2169,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separators specified. This is an alternative to using StringTokenizer.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as one separator. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e separatorChars splits on whitespace.\u003c/p\u003e \u003cpre\u003e StringUtils.split(null, *)         \u003d null StringUtils.split(\"\", *)           \u003d [] StringUtils.split(\"abc def\", null) \u003d [\"abc\", \"def\"] StringUtils.split(\"abc def\", \" \")  \u003d [\"abc\", \"def\"] StringUtils.split(\"abc  def\", \" \") \u003d [\"abc\", \"def\"] StringUtils.split(\"ab:cd:ef\", \":\") \u003d [\"ab\", \"cd\", \"ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separatorChars  the characters used as the delimiters,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.split#2201",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.split(java.lang.String, java.lang.String, int)",
    "snippet": "public static String[] split(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, false);\n    }",
    "begin_line": 2201,
    "end_line": 2203,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array with a maximum length, separators specified.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as one separator.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e separatorChars splits on whitespace.\u003c/p\u003e \u003cp\u003eIf more than \u003ccode\u003emax\u003c/code\u003e delimited substrings are found, the last returned string includes all characters after the first \u003ccode\u003emax - 1\u003c/code\u003e returned strings (including separator characters).\u003c/p\u003e \u003cpre\u003e StringUtils.split(null, *, *)            \u003d null StringUtils.split(\"\", *, *)              \u003d [] StringUtils.split(\"ab de fg\", null, 0)   \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.split(\"ab   de fg\", null, 0) \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.split(\"ab:cd:ef\", \":\", 0)    \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.split(\"ab:cd:ef\", \":\", 2)    \u003d [\"ab\", \"cd:ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separatorChars  the characters used as the delimiters,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @param max  the maximum number of elements to include in thearray. A zero or negative value implies no limit\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparator#2228",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparator(java.lang.String, java.lang.String)",
    "snippet": "public static String[] splitByWholeSeparator(String str, String separator) {\n        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n    }",
    "begin_line": 2228,
    "end_line": 2230,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator string specified.\u003c/p\u003e \u003cp\u003eThe separator(s) will not be included in the returned String array. Adjacent separators are treated as one separator.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e separator splits on whitespace.\u003c/p\u003e \u003cpre\u003e StringUtils.splitByWholeSeparator(null, *)               \u003d null StringUtils.splitByWholeSeparator(\"\", *)                 \u003d [] StringUtils.splitByWholeSeparator(\"ab de fg\", null)      \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparator(\"ab   de fg\", null)    \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\")       \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\") \u003d [\"ab\", \"cd\", \"ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separator  String containing the String to be used as a delimiter,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String was input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparator#2259",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparator(java.lang.String, java.lang.String, int)",
    "snippet": "public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n        return splitByWholeSeparatorWorker(str, separator, max, false);\n    }",
    "begin_line": 2259,
    "end_line": 2261,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator string specified. Returns a maximum of \u003ccode\u003emax\u003c/code\u003e substrings.\u003c/p\u003e \u003cp\u003eThe separator(s) will not be included in the returned String array. Adjacent separators are treated as one separator.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e separator splits on whitespace.\u003c/p\u003e \u003cpre\u003e StringUtils.splitByWholeSeparator(null, *, *)               \u003d null StringUtils.splitByWholeSeparator(\"\", *, *)                 \u003d [] StringUtils.splitByWholeSeparator(\"ab de fg\", null, 0)      \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparator(\"ab   de fg\", null, 0)    \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\", 2)       \u003d [\"ab\", \"cd:ef\"] StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 5) \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 2) \u003d [\"ab\", \"cd-!-ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separator  String containing the String to be used as a delimiter,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @param max  the maximum number of elements to include in the returnedarray. A zero or negative value implies no limit.\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String was input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparatorPreserveAllTokens#2288",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparatorPreserveAllTokens(java.lang.String, java.lang.String)",
    "snippet": "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n        return splitByWholeSeparatorWorker(str, separator, -1, true);\n    }",
    "begin_line": 2288,
    "end_line": 2290,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator string specified. \u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e separator splits on whitespace.\u003c/p\u003e \u003cpre\u003e StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               \u003d null StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *)                 \u003d [] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null)      \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null)    \u003d [\"ab\", \"\", \"\", \"de\", \"fg\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\")       \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\") \u003d [\"ab\", \"cd\", \"ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separator  String containing the String to be used as a delimiter,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String was input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparatorPreserveAllTokens#2321",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparatorPreserveAllTokens(java.lang.String, java.lang.String, int)",
    "snippet": "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n        return splitByWholeSeparatorWorker(str, separator, max, true);\n    }",
    "begin_line": 2321,
    "end_line": 2323,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator string specified. Returns a maximum of \u003ccode\u003emax\u003c/code\u003e substrings.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e separator splits on whitespace.\u003c/p\u003e \u003cpre\u003e StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               \u003d null StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *, *)                 \u003d [] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null, 0)      \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null, 0)    \u003d [\"ab\", \"\", \"\", \"de\", \"fg\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\", 2)       \u003d [\"ab\", \"cd:ef\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 5) \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 2) \u003d [\"ab\", \"cd-!-ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separator  String containing the String to be used as a delimiter,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @param max  the maximum number of elements to include in the returnedarray. A zero or negative value implies no limit.\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String was input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparatorWorker#2339",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparatorWorker(java.lang.String, java.lang.String, int, boolean)",
    "snippet": "private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, \n                                                        boolean preserveAllTokens) \n    {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n\n        int len \u003d str.length();\n\n        if (len \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n        if ((separator \u003d\u003d null) || (EMPTY.equals(separator))) {\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        int separatorLength \u003d separator.length();\n\n        ArrayList\u003cString\u003e substrings \u003d new ArrayList\u003cString\u003e();\n        int numberOfSubstrings \u003d 0;\n        int beg \u003d 0;\n        int end \u003d 0;\n        while (end \u003c len) {\n            end \u003d str.indexOf(separator, beg);\n\n            if (end \u003e -1) {\n                if (end \u003e beg) {\n                    numberOfSubstrings +\u003d 1;\n\n                    if (numberOfSubstrings \u003d\u003d max) {\n                        end \u003d len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position \u0027end\u0027.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg \u003d end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg \u003d end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings +\u003d 1;\n                        if (numberOfSubstrings \u003d\u003d max) {\n                            end \u003d len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg \u003d end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from \u0027beg\u0027 to the end of the String.\n                substrings.add(str.substring(beg));\n                end \u003d len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
    "begin_line": 2339,
    "end_line": 2404,
    "comment": "/** \n * Performs the logic for the \u003ccode\u003esplitByWholeSeparatorPreserveAllTokens\u003c/code\u003e methods.\n * @param str  the String to parse, may be \u003ccode\u003enull\u003c/code\u003e\n * @param separator  String containing the String to be used as a delimiter,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @param max  the maximum number of elements to include in the returnedarray. A zero or negative value implies no limit.\n * @param preserveAllTokens if \u003ccode\u003etrue\u003c/code\u003e, adjacent separators aretreated as empty token separators; if \u003ccode\u003efalse\u003c/code\u003e, adjacent separators are treated as one separator.\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitPreserveAllTokens#2431",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitPreserveAllTokens(java.lang.String)",
    "snippet": "public static String[] splitPreserveAllTokens(String str) {\n        return splitWorker(str, null, -1, true);\n    }",
    "begin_line": 2431,
    "end_line": 2433,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, using whitespace as the separator, preserving all tokens, including empty tokens created by  adjacent separators. This is an alternative to using StringTokenizer. Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.splitPreserveAllTokens(null)       \u003d null StringUtils.splitPreserveAllTokens(\"\")         \u003d [] StringUtils.splitPreserveAllTokens(\"abc def\")  \u003d [\"abc\", \"def\"] StringUtils.splitPreserveAllTokens(\"abc  def\") \u003d [\"abc\", \"\", \"def\"] StringUtils.splitPreserveAllTokens(\" abc \")    \u003d [\"\", \"abc\", \"\"] \u003c/pre\u003e\n * @param str  the String to parse, may be \u003ccode\u003enull\u003c/code\u003e\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitPreserveAllTokens#2467",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitPreserveAllTokens(java.lang.String, char)",
    "snippet": "public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, true);\n    }",
    "begin_line": 2467,
    "end_line": 2469,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator specified, preserving all tokens, including empty tokens created by adjacent separators. This is an alternative to using StringTokenizer.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.splitPreserveAllTokens(null, *)         \u003d null StringUtils.splitPreserveAllTokens(\"\", *)           \u003d [] StringUtils.splitPreserveAllTokens(\"a.b.c\", \u0027.\u0027)    \u003d [\"a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"a..b.c\", \u0027.\u0027)   \u003d [\"a\", \"\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"a:b:c\", \u0027.\u0027)    \u003d [\"a:b:c\"] StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) \u003d [\"a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"a b c\", \u0027 \u0027)    \u003d [\"a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"a b c \", \u0027 \u0027)   \u003d [\"a\", \"b\", \"c\", \"\"] StringUtils.splitPreserveAllTokens(\"a b c  \", \u0027 \u0027)   \u003d [\"a\", \"b\", \"c\", \"\", \"\"] StringUtils.splitPreserveAllTokens(\" a b c\", \u0027 \u0027)   \u003d [\"\", a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"  a b c\", \u0027 \u0027)  \u003d [\"\", \"\", a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\" a b c \", \u0027 \u0027)  \u003d [\"\", a\", \"b\", \"c\", \"\"] \u003c/pre\u003e\n * @param str  the String to parse, may be \u003ccode\u003enull\u003c/code\u003e\n * @param separatorChar  the character used as the delimiter,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitWorker#2483",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitWorker(java.lang.String, char, boolean)",
    "snippet": "private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        int len \u003d str.length();\n        if (len \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n        int i \u003d 0, start \u003d 0;\n        boolean match \u003d false;\n        boolean lastMatch \u003d false;\n        while (i \u003c len) {\n            if (str.charAt(i) \u003d\u003d separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match \u003d false;\n                    lastMatch \u003d true;\n                }\n                start \u003d ++i;\n                continue;\n            }\n            lastMatch \u003d false;\n            match \u003d true;\n            i++;\n        }\n        if (match || (preserveAllTokens \u0026\u0026 lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }",
    "begin_line": 2483,
    "end_line": 2515,
    "comment": "/** \n * Performs the logic for the \u003ccode\u003esplit\u003c/code\u003e and  \u003ccode\u003esplitPreserveAllTokens\u003c/code\u003e methods that do not return a maximum array length.\n * @param str  the String to parse, may be \u003ccode\u003enull\u003c/code\u003e\n * @param separatorChar the separate character\n * @param preserveAllTokens if \u003ccode\u003etrue\u003c/code\u003e, adjacent separators aretreated as empty token separators; if \u003ccode\u003efalse\u003c/code\u003e, adjacent separators are treated as one separator.\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitPreserveAllTokens#2550",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitPreserveAllTokens(java.lang.String, java.lang.String)",
    "snippet": "public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, true);\n    }",
    "begin_line": 2550,
    "end_line": 2552,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separators specified,  preserving all tokens, including empty tokens created by adjacent separators. This is an alternative to using StringTokenizer.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e separatorChars splits on whitespace.\u003c/p\u003e \u003cpre\u003e StringUtils.splitPreserveAllTokens(null, *)           \u003d null StringUtils.splitPreserveAllTokens(\"\", *)             \u003d [] StringUtils.splitPreserveAllTokens(\"abc def\", null)   \u003d [\"abc\", \"def\"] StringUtils.splitPreserveAllTokens(\"abc def\", \" \")    \u003d [\"abc\", \"def\"] StringUtils.splitPreserveAllTokens(\"abc  def\", \" \")   \u003d [\"abc\", \"\", def\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\")   \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef:\", \":\")  \u003d [\"ab\", \"cd\", \"ef\", \"\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef::\", \":\") \u003d [\"ab\", \"cd\", \"ef\", \"\", \"\"] StringUtils.splitPreserveAllTokens(\"ab::cd:ef\", \":\")  \u003d [\"ab\", \"\", cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\":cd:ef\", \":\")     \u003d [\"\", cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"::cd:ef\", \":\")    \u003d [\"\", \"\", cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\":cd:ef:\", \":\")    \u003d [\"\", cd\", \"ef\", \"\"] \u003c/pre\u003e\n * @param str  the String to parse, may be \u003ccode\u003enull\u003c/code\u003e\n * @param separatorChars  the characters used as the delimiters,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitPreserveAllTokens#2590",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitPreserveAllTokens(java.lang.String, java.lang.String, int)",
    "snippet": "public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, true);\n    }",
    "begin_line": 2590,
    "end_line": 2592,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array with a maximum length, separators specified, preserving all tokens, including empty tokens  created by adjacent separators.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. Adjacent separators are treated as one separator.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e. A \u003ccode\u003enull\u003c/code\u003e separatorChars splits on whitespace.\u003c/p\u003e \u003cp\u003eIf more than \u003ccode\u003emax\u003c/code\u003e delimited substrings are found, the last returned string includes all characters after the first \u003ccode\u003emax - 1\u003c/code\u003e returned strings (including separator characters).\u003c/p\u003e \u003cpre\u003e StringUtils.splitPreserveAllTokens(null, *, *)            \u003d null StringUtils.splitPreserveAllTokens(\"\", *, *)              \u003d [] StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    \u003d [\"ab\", \"cd:ef\"] StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) \u003d [\"ab\", \"  de fg\"] StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) \u003d [\"ab\", \"\", \" de fg\"] StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) \u003d [\"ab\", \"\", \"\", \"de fg\"] \u003c/pre\u003e\n * @param str  the String to parse, may be \u003ccode\u003enull\u003c/code\u003e\n * @param separatorChars  the characters used as the delimiters,\u003ccode\u003enull\u003c/code\u003e splits on whitespace\n * @param max  the maximum number of elements to include in thearray. A zero or negative value implies no limit\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitWorker#2608",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitWorker(java.lang.String, java.lang.String, int, boolean)",
    "snippet": "private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        int len \u003d str.length();\n        if (len \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n        int sizePlus1 \u003d 1;\n        int i \u003d 0, start \u003d 0;\n        boolean match \u003d false;\n        boolean lastMatch \u003d false;\n        if (separatorChars \u003d\u003d null) {\n            // Null separator means use whitespace\n            while (i \u003c len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch \u003d true;\n                        if (sizePlus1++ \u003d\u003d max) {\n                            i \u003d len;\n                            lastMatch \u003d false;\n                        }\n                        list.add(str.substring(start, i));\n                        match \u003d false;\n                    }\n                    start \u003d ++i;\n                    continue;\n                }\n                lastMatch \u003d false;\n                match \u003d true;\n                i++;\n            }\n        } else if (separatorChars.length() \u003d\u003d 1) {\n            // Optimise 1 character case\n            char sep \u003d separatorChars.charAt(0);\n            while (i \u003c len) {\n                if (str.charAt(i) \u003d\u003d sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch \u003d true;\n                        if (sizePlus1++ \u003d\u003d max) {\n                            i \u003d len;\n                            lastMatch \u003d false;\n                        }\n                        list.add(str.substring(start, i));\n                        match \u003d false;\n                    }\n                    start \u003d ++i;\n                    continue;\n                }\n                lastMatch \u003d false;\n                match \u003d true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i \u003c len) {\n                if (separatorChars.indexOf(str.charAt(i)) \u003e\u003d 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch \u003d true;\n                        if (sizePlus1++ \u003d\u003d max) {\n                            i \u003d len;\n                            lastMatch \u003d false;\n                        }\n                        list.add(str.substring(start, i));\n                        match \u003d false;\n                    }\n                    start \u003d ++i;\n                    continue;\n                }\n                lastMatch \u003d false;\n                match \u003d true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens \u0026\u0026 lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }",
    "begin_line": 2608,
    "end_line": 2691,
    "comment": "/** \n * Performs the logic for the \u003ccode\u003esplit\u003c/code\u003e and  \u003ccode\u003esplitPreserveAllTokens\u003c/code\u003e methods that return a maximum array  length.\n * @param str  the String to parse, may be \u003ccode\u003enull\u003c/code\u003e\n * @param separatorChars the separate character\n * @param max  the maximum number of elements to include in thearray. A zero or negative value implies no limit.\n * @param preserveAllTokens if \u003ccode\u003etrue\u003c/code\u003e, adjacent separators aretreated as empty token separators; if \u003ccode\u003efalse\u003c/code\u003e, adjacent separators are treated as one separator.\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByCharacterType#2712",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByCharacterType(java.lang.String)",
    "snippet": "public static String[] splitByCharacterType(String str) {\n        return splitByCharacterType(str, false);\n    }",
    "begin_line": 2712,
    "end_line": 2714,
    "comment": "/** \n * \u003cp\u003eSplits a String by Character type as returned by \u003ccode\u003ejava.lang.Character.getType(char)\u003c/code\u003e. Groups of contiguous characters of the same type are returned as complete tokens.  \u003cpre\u003e StringUtils.splitByCharacterType(null)         \u003d null StringUtils.splitByCharacterType(\"\")           \u003d [] StringUtils.splitByCharacterType(\"ab de fg\")   \u003d [\"ab\", \" \", \"de\", \" \", \"fg\"] StringUtils.splitByCharacterType(\"ab   de fg\") \u003d [\"ab\", \"   \", \"de\", \" \", \"fg\"] StringUtils.splitByCharacterType(\"ab:cd:ef\")   \u003d [\"ab\", \":\", \"cd\", \":\", \"ef\"] StringUtils.splitByCharacterType(\"number5\")    \u003d [\"number\", \"5\"] StringUtils.splitByCharacterType(\"fooBar\")     \u003d [\"foo\", \"B\", \"ar\"] StringUtils.splitByCharacterType(\"foo200Bar\")  \u003d [\"foo\", \"200\", \"B\", \"ar\"] StringUtils.splitByCharacterType(\"ASFRules\")   \u003d [\"ASFR\", \"ules\"] \u003c/pre\u003e\n * @param str the String to split, may be \u003ccode\u003enull\u003c/code\u003e\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByCharacterTypeCamelCase#2740",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByCharacterTypeCamelCase(java.lang.String)",
    "snippet": "public static String[] splitByCharacterTypeCamelCase(String str) {\n        return splitByCharacterType(str, true);\n    }",
    "begin_line": 2740,
    "end_line": 2742,
    "comment": "/** \n * \u003cp\u003eSplits a String by Character type as returned by \u003ccode\u003ejava.lang.Character.getType(char)\u003c/code\u003e. Groups of contiguous characters of the same type are returned as complete tokens, with the following exception: the character of type \u003ccode\u003eCharacter.UPPERCASE_LETTER\u003c/code\u003e, if any, immediately preceding a token of type \u003ccode\u003eCharacter.LOWERCASE_LETTER\u003c/code\u003e will belong to the following token rather than to the preceding, if any, \u003ccode\u003eCharacter.UPPERCASE_LETTER\u003c/code\u003e token.  \u003cpre\u003e StringUtils.splitByCharacterTypeCamelCase(null)         \u003d null StringUtils.splitByCharacterTypeCamelCase(\"\")           \u003d [] StringUtils.splitByCharacterTypeCamelCase(\"ab de fg\")   \u003d [\"ab\", \" \", \"de\", \" \", \"fg\"] StringUtils.splitByCharacterTypeCamelCase(\"ab   de fg\") \u003d [\"ab\", \"   \", \"de\", \" \", \"fg\"] StringUtils.splitByCharacterTypeCamelCase(\"ab:cd:ef\")   \u003d [\"ab\", \":\", \"cd\", \":\", \"ef\"] StringUtils.splitByCharacterTypeCamelCase(\"number5\")    \u003d [\"number\", \"5\"] StringUtils.splitByCharacterTypeCamelCase(\"fooBar\")     \u003d [\"foo\", \"Bar\"] StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\")  \u003d [\"foo\", \"200\", \"Bar\"] StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\")   \u003d [\"ASF\", \"Rules\"] \u003c/pre\u003e\n * @param str the String to split, may be \u003ccode\u003enull\u003c/code\u003e\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByCharacterType#2758",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByCharacterType(java.lang.String, boolean)",
    "snippet": "private static String[] splitByCharacterType(String str, boolean camelCase) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (str.length() \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] c \u003d str.toCharArray();\n        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n        int tokenStart \u003d 0;\n        int currentType \u003d Character.getType(c[tokenStart]);\n        for (int pos \u003d tokenStart + 1; pos \u003c c.length; pos++) {\n            int type \u003d Character.getType(c[pos]);\n            if (type \u003d\u003d currentType) {\n                continue;\n            }\n            if (camelCase \u0026\u0026 type \u003d\u003d Character.LOWERCASE_LETTER \u0026\u0026 currentType \u003d\u003d Character.UPPERCASE_LETTER) {\n                int newTokenStart \u003d pos - 1;\n                if (newTokenStart !\u003d tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart \u003d newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart \u003d pos;\n            }\n            currentType \u003d type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }",
    "begin_line": 2758,
    "end_line": 2788,
    "comment": "/** \n * \u003cp\u003eSplits a String by Character type as returned by \u003ccode\u003ejava.lang.Character.getType(char)\u003c/code\u003e. Groups of contiguous characters of the same type are returned as complete tokens, with the following exception: if \u003ccode\u003ecamelCase\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e, the character of type \u003ccode\u003eCharacter.UPPERCASE_LETTER\u003c/code\u003e, if any, immediately preceding a token of type \u003ccode\u003eCharacter.LOWERCASE_LETTER\u003c/code\u003e will belong to the following token rather than to the preceding, if any, \u003ccode\u003eCharacter.UPPERCASE_LETTER\u003c/code\u003e token. \n * @param str the String to split, may be \u003ccode\u003enull\u003c/code\u003e\n * @param camelCase whether to use so-called \"camel-case\" for letter types\n * @return an array of parsed Strings, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#2812",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Object[])",
    "snippet": "public static String join(Object[] array) {\n        return join(array, null);\n    }",
    "begin_line": 2812,
    "end_line": 2814,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo separator is added to the joined String. Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null)            \u003d null StringUtils.join([])              \u003d \"\" StringUtils.join([null])          \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"]) \u003d \"abc\" StringUtils.join([null, \"\", \"a\"]) \u003d \"a\" \u003c/pre\u003e\n * @param array  the array of values to join together, may be null\n * @return the joined String, \u003ccode\u003enull\u003c/code\u003e if null array input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#2838",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Object[], char)",
    "snippet": "public static String join(Object[] array, char separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 2838,
    "end_line": 2844,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"], \u0027;\u0027)  \u003d \"a;b;c\" StringUtils.join([\"a\", \"b\", \"c\"], null) \u003d \"abc\" StringUtils.join([null, \"\", \"a\"], \u0027;\u0027)  \u003d \";;a\" \u003c/pre\u003e\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use\n * @return the joined String, \u003ccode\u003enull\u003c/code\u003e if null array input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#2872",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Object[], char, int, int)",
    "snippet": "public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        int bufSize \u003d (endIndex - startIndex);\n        if (bufSize \u003c\u003d 0) {\n            return EMPTY;\n        }\n\n        bufSize *\u003d ((array[startIndex] \u003d\u003d null ? 16 : array[startIndex].toString().length()) + 1);\n        StringBuilder buf \u003d new StringBuilder(bufSize);\n\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] !\u003d null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }",
    "begin_line": 2872,
    "end_line": 2893,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"], \u0027;\u0027)  \u003d \"a;b;c\" StringUtils.join([\"a\", \"b\", \"c\"], null) \u003d \"abc\" StringUtils.join([null, \"\", \"a\"], \u0027;\u0027)  \u003d \";;a\" \u003c/pre\u003e\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use\n * @param startIndex the first index to start joining from.  It isan error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It isan error to pass in an end index past the end of the array\n * @return the joined String, \u003ccode\u003enull\u003c/code\u003e if null array input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#2919",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Object[], java.lang.String)",
    "snippet": "public static String join(Object[] array, String separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 2919,
    "end_line": 2924,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. A \u003ccode\u003enull\u003c/code\u003e separator is the same as an empty String (\"\"). Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)                \u003d null StringUtils.join([], *)                  \u003d \"\" StringUtils.join([null], *)              \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  \u003d \"a--b--c\" StringUtils.join([\"a\", \"b\", \"c\"], null)  \u003d \"abc\" StringUtils.join([\"a\", \"b\", \"c\"], \"\")    \u003d \"abc\" StringUtils.join([null, \"\", \"a\"], \u0027,\u0027)   \u003d \",,a\" \u003c/pre\u003e\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @return the joined String, \u003ccode\u003enull\u003c/code\u003e if null array input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#2953",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Object[], java.lang.String, int, int)",
    "snippet": "public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        if (separator \u003d\u003d null) {\n            separator \u003d EMPTY;\n        }\n\n        // endIndex - startIndex \u003e 0:   Len \u003d NofStrings *(len(firstString) + len(separator))\n        //           (Assuming that all Strings are roughly equally long)\n        int bufSize \u003d (endIndex - startIndex);\n        if (bufSize \u003c\u003d 0) {\n            return EMPTY;\n        }\n\n        bufSize *\u003d ((array[startIndex] \u003d\u003d null ? 16 : array[startIndex].toString().length())\n                        + separator.length());\n\n        StringBuilder buf \u003d new StringBuilder(bufSize);\n\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] !\u003d null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }",
    "begin_line": 2953,
    "end_line": 2982,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. A \u003ccode\u003enull\u003c/code\u003e separator is the same as an empty String (\"\"). Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)                \u003d null StringUtils.join([], *)                  \u003d \"\" StringUtils.join([null], *)              \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  \u003d \"a--b--c\" StringUtils.join([\"a\", \"b\", \"c\"], null)  \u003d \"abc\" StringUtils.join([\"a\", \"b\", \"c\"], \"\")    \u003d \"abc\" StringUtils.join([null, \"\", \"a\"], \u0027,\u0027)   \u003d \",,a\" \u003c/pre\u003e\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @param startIndex the first index to start joining from.  It isan error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It isan error to pass in an end index past the end of the array\n * @return the joined String, \u003ccode\u003enull\u003c/code\u003e if null array input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#2998",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.util.Iterator\u003c?\u003e, char)",
    "snippet": "public static String join(Iterator\u003c?\u003e iterator, char separator) {\n\n        // handle null, zero and one elements before building a buffer\n        if (iterator \u003d\u003d null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first \u003d iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        // two or more elements\n        StringBuilder buf \u003d new StringBuilder(256); // Java default is 16, probably too small\n        if (first !\u003d null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            Object obj \u003d iterator.next();\n            if (obj !\u003d null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }",
    "begin_line": 2998,
    "end_line": 3027,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided \u003ccode\u003eIterator\u003c/code\u003e into a single String containing the provided elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. Null objects or empty strings within the iteration are represented by empty strings.\u003c/p\u003e \u003cp\u003eSee the examples here:  {@link #join(Object[],char)}. \u003c/p\u003e\n * @param iterator  the \u003ccode\u003eIterator\u003c/code\u003e of values to join together, may be null\n * @param separator  the separator character to use\n * @return the joined String, \u003ccode\u003enull\u003c/code\u003e if null iterator input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3042",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.util.Iterator\u003c?\u003e, java.lang.String)",
    "snippet": "public static String join(Iterator\u003c?\u003e iterator, String separator) {\n\n        // handle null, zero and one elements before building a buffer\n        if (iterator \u003d\u003d null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first \u003d iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        // two or more elements\n        StringBuilder buf \u003d new StringBuilder(256); // Java default is 16, probably too small\n        if (first !\u003d null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator !\u003d null) {\n                buf.append(separator);\n            }\n            Object obj \u003d iterator.next();\n            if (obj !\u003d null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }",
    "begin_line": 3042,
    "end_line": 3072,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided \u003ccode\u003eIterator\u003c/code\u003e into a single String containing the provided elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. A \u003ccode\u003enull\u003c/code\u003e separator is the same as an empty String (\"\").\u003c/p\u003e \u003cp\u003eSee the examples here:  {@link #join(Object[],String)}. \u003c/p\u003e\n * @param iterator  the \u003ccode\u003eIterator\u003c/code\u003e of values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @return the joined String, \u003ccode\u003enull\u003c/code\u003e if null iterator input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3088",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Iterable\u003c?\u003e, char)",
    "snippet": "public static String join(Iterable\u003c?\u003e iterable, char separator) {\n        if (iterable \u003d\u003d null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }",
    "begin_line": 3088,
    "end_line": 3093,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided \u003ccode\u003eIterable\u003c/code\u003e into a single String containing the provided elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. Null objects or empty strings within the iteration are represented by empty strings.\u003c/p\u003e \u003cp\u003eSee the examples here:  {@link #join(Object[],char)}. \u003c/p\u003e\n * @param iterable  the \u003ccode\u003eIterable\u003c/code\u003e providing the values to join together, may be null\n * @param separator  the separator character to use\n * @return the joined String, \u003ccode\u003enull\u003c/code\u003e if null iterator input\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3109",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Iterable\u003c?\u003e, java.lang.String)",
    "snippet": "public static String join(Iterable\u003c?\u003e iterable, String separator) {\n        if (iterable \u003d\u003d null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }",
    "begin_line": 3109,
    "end_line": 3114,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided \u003ccode\u003eIterable\u003c/code\u003e into a single String containing the provided elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. A \u003ccode\u003enull\u003c/code\u003e separator is the same as an empty String (\"\").\u003c/p\u003e \u003cp\u003eSee the examples here:  {@link #join(Object[],String)}. \u003c/p\u003e\n * @param iterable  the \u003ccode\u003eIterable\u003c/code\u003e providing the values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @return the joined String, \u003ccode\u003enull\u003c/code\u003e if null iterator input\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.deleteWhitespace#3132",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.deleteWhitespace(java.lang.String)",
    "snippet": "public static String deleteWhitespace(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        int sz \u003d str.length();\n        char[] chs \u003d new char[sz];\n        int count \u003d 0;\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] \u003d str.charAt(i);\n            }\n        }\n        if (count \u003d\u003d sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
    "begin_line": 3132,
    "end_line": 3148,
    "comment": "/** \n * \u003cp\u003eDeletes all whitespaces from a String as defined by {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.deleteWhitespace(null)         \u003d null StringUtils.deleteWhitespace(\"\")           \u003d \"\" StringUtils.deleteWhitespace(\"abc\")        \u003d \"abc\" StringUtils.deleteWhitespace(\"   ab  c  \") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to delete whitespace from, may be null\n * @return the String without whitespaces, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.removeStart#3176",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.removeStart(java.lang.String, java.lang.String)",
    "snippet": "public static String removeStart(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)){\n            return str.substring(remove.length());\n        }\n        return str;\n    }",
    "begin_line": 3176,
    "end_line": 3184,
    "comment": "/** \n * \u003cp\u003eRemoves a substring only if it is at the begining of a source string, otherwise returns the source string.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e source string will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") source string will return the empty string. A \u003ccode\u003enull\u003c/code\u003e search string will return the source string.\u003c/p\u003e \u003cpre\u003e StringUtils.removeStart(null, *)      \u003d null StringUtils.removeStart(\"\", *)        \u003d \"\" StringUtils.removeStart(*, null)      \u003d  StringUtils.removeStart(\"www.domain.com\", \"www.\")   \u003d \"domain.com\" StringUtils.removeStart(\"domain.com\", \"www.\")       \u003d \"domain.com\" StringUtils.removeStart(\"www.domain.com\", \"domain\") \u003d \"www.domain.com\" StringUtils.removeStart(\"abc\", \"\")    \u003d \"abc\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for and remove, may be null\n * @return the substring with the string removed if found,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.removeStartIgnoreCase#3211",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.removeStartIgnoreCase(java.lang.String, java.lang.String)",
    "snippet": "public static String removeStartIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }",
    "begin_line": 3211,
    "end_line": 3219,
    "comment": "/** \n * \u003cp\u003eCase insensitive removal of a substring if it is at the begining of a source string, otherwise returns the source string.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e source string will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") source string will return the empty string. A \u003ccode\u003enull\u003c/code\u003e search string will return the source string.\u003c/p\u003e \u003cpre\u003e StringUtils.removeStartIgnoreCase(null, *)      \u003d null StringUtils.removeStartIgnoreCase(\"\", *)        \u003d \"\" StringUtils.removeStartIgnoreCase(*, null)      \u003d  StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"www.\")   \u003d \"domain.com\" StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"WWW.\")   \u003d \"domain.com\" StringUtils.removeStartIgnoreCase(\"domain.com\", \"www.\")       \u003d \"domain.com\" StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"domain\") \u003d \"www.domain.com\" StringUtils.removeStartIgnoreCase(\"abc\", \"\")    \u003d \"abc\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for (case insensitive) and remove, may be null\n * @return the substring with the string removed if found,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.removeEnd#3245",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.removeEnd(java.lang.String, java.lang.String)",
    "snippet": "public static String removeEnd(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }",
    "begin_line": 3245,
    "end_line": 3253,
    "comment": "/** \n * \u003cp\u003eRemoves a substring only if it is at the end of a source string, otherwise returns the source string.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e source string will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") source string will return the empty string. A \u003ccode\u003enull\u003c/code\u003e search string will return the source string.\u003c/p\u003e \u003cpre\u003e StringUtils.removeEnd(null, *)      \u003d null StringUtils.removeEnd(\"\", *)        \u003d \"\" StringUtils.removeEnd(*, null)      \u003d  StringUtils.removeEnd(\"www.domain.com\", \".com.\")  \u003d \"www.domain.com\" StringUtils.removeEnd(\"www.domain.com\", \".com\")   \u003d \"www.domain\" StringUtils.removeEnd(\"www.domain.com\", \"domain\") \u003d \"www.domain.com\" StringUtils.removeEnd(\"abc\", \"\")    \u003d \"abc\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for and remove, may be null\n * @return the substring with the string removed if found,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.removeEndIgnoreCase#3279",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.removeEndIgnoreCase(java.lang.String, java.lang.String)",
    "snippet": "public static String removeEndIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }",
    "begin_line": 3279,
    "end_line": 3287,
    "comment": "/** \n * \u003cp\u003eCase insensitive removal of a substring if it is at the end of a source string, otherwise returns the source string.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e source string will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") source string will return the empty string. A \u003ccode\u003enull\u003c/code\u003e search string will return the source string.\u003c/p\u003e \u003cpre\u003e StringUtils.removeEnd(null, *)      \u003d null StringUtils.removeEnd(\"\", *)        \u003d \"\" StringUtils.removeEnd(*, null)      \u003d  StringUtils.removeEnd(\"www.domain.com\", \".com.\")  \u003d \"www.domain.com.\" StringUtils.removeEnd(\"www.domain.com\", \".com\")   \u003d \"www.domain\" StringUtils.removeEnd(\"www.domain.com\", \"domain\") \u003d \"www.domain.com\" StringUtils.removeEnd(\"abc\", \"\")    \u003d \"abc\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for (case insensitive) and remove, may be null\n * @return the substring with the string removed if found,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.remove#3312",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.remove(java.lang.String, java.lang.String)",
    "snippet": "public static String remove(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        return replace(str, remove, EMPTY, -1);\n    }",
    "begin_line": 3312,
    "end_line": 3317,
    "comment": "/** \n * \u003cp\u003eRemoves all occurrences of a substring from within the source string.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e source string will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") source string will return the empty string. A \u003ccode\u003enull\u003c/code\u003e remove string will return the source string. An empty (\"\") remove string will return the source string.\u003c/p\u003e \u003cpre\u003e StringUtils.remove(null, *)        \u003d null StringUtils.remove(\"\", *)          \u003d \"\" StringUtils.remove(*, null)        \u003d  StringUtils.remove(*, \"\")          \u003d  StringUtils.remove(\"queued\", \"ue\") \u003d \"qd\" StringUtils.remove(\"queued\", \"zz\") \u003d \"queued\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for and remove, may be null\n * @return the substring with the string removed if found,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.remove#3338",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.remove(java.lang.String, char)",
    "snippet": "public static String remove(String str, char remove) {\n        if (isEmpty(str) || str.indexOf(remove) \u003d\u003d -1) {\n            return str;\n        }\n        char[] chars \u003d str.toCharArray();\n        int pos \u003d 0;\n        for (int i \u003d 0; i \u003c chars.length; i++) {\n            if (chars[i] !\u003d remove) {\n                chars[pos++] \u003d chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }",
    "begin_line": 3338,
    "end_line": 3350,
    "comment": "/** \n * \u003cp\u003eRemoves all occurrences of a character from within the source string.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e source string will return \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") source string will return the empty string.\u003c/p\u003e \u003cpre\u003e StringUtils.remove(null, *)       \u003d null StringUtils.remove(\"\", *)         \u003d \"\" StringUtils.remove(\"queued\", \u0027u\u0027) \u003d \"qeed\" StringUtils.remove(\"queued\", \u0027z\u0027) \u003d \"queued\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the char to search for and remove, may be null\n * @return the substring with the char removed if found,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceOnce#3377",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceOnce(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String replaceOnce(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, 1);\n    }",
    "begin_line": 3377,
    "end_line": 3379,
    "comment": "/** \n * \u003cp\u003eReplaces a String with another String inside a larger String, once.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op.\u003c/p\u003e \u003cpre\u003e StringUtils.replaceOnce(null, *, *)        \u003d null StringUtils.replaceOnce(\"\", *, *)          \u003d \"\" StringUtils.replaceOnce(\"any\", null, *)    \u003d \"any\" StringUtils.replaceOnce(\"any\", *, null)    \u003d \"any\" StringUtils.replaceOnce(\"any\", \"\", *)      \u003d \"any\" StringUtils.replaceOnce(\"aba\", \"a\", null)  \u003d \"aba\" StringUtils.replaceOnce(\"aba\", \"a\", \"\")    \u003d \"ba\" StringUtils.replaceOnce(\"aba\", \"a\", \"z\")   \u003d \"zba\" \u003c/pre\u003e\n * @see #replace(String text,String searchString,String replacement,int max)\n * @param text  text to search and replace in, may be null\n * @param searchString  the String to search for, may be null\n * @param replacement  the String to replace with, may be null\n * @return the text with any replacements processed,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replace#3404",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replace(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String replace(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }",
    "begin_line": 3404,
    "end_line": 3406,
    "comment": "/** \n * \u003cp\u003eReplaces all occurrences of a String within another String.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op.\u003c/p\u003e \u003cpre\u003e StringUtils.replace(null, *, *)        \u003d null StringUtils.replace(\"\", *, *)          \u003d \"\" StringUtils.replace(\"any\", null, *)    \u003d \"any\" StringUtils.replace(\"any\", *, null)    \u003d \"any\" StringUtils.replace(\"any\", \"\", *)      \u003d \"any\" StringUtils.replace(\"aba\", \"a\", null)  \u003d \"aba\" StringUtils.replace(\"aba\", \"a\", \"\")    \u003d \"b\" StringUtils.replace(\"aba\", \"a\", \"z\")   \u003d \"zbz\" \u003c/pre\u003e\n * @see #replace(String text,String searchString,String replacement,int max)\n * @param text  text to search and replace in, may be null\n * @param searchString  the String to search for, may be null\n * @param replacement  the String to replace it with, may be null\n * @return the text with any replacements processed,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replace#3436",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replace(java.lang.String, java.lang.String, java.lang.String, int)",
    "snippet": "public static String replace(String text, String searchString, String replacement, int max) {\n        if (isEmpty(text) || isEmpty(searchString) || replacement \u003d\u003d null || max \u003d\u003d 0) {\n            return text;\n        }\n        int start \u003d 0;\n        int end \u003d text.indexOf(searchString, start);\n        if (end \u003d\u003d -1) {\n            return text;\n        }\n        int replLength \u003d searchString.length();\n        int increase \u003d replacement.length() - replLength;\n        increase \u003d (increase \u003c 0 ? 0 : increase);\n        increase *\u003d (max \u003c 0 ? 16 : (max \u003e 64 ? 64 : max));\n        StringBuilder buf \u003d new StringBuilder(text.length() + increase);\n        while (end !\u003d -1) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start \u003d end + replLength;\n            if (--max \u003d\u003d 0) {\n                break;\n            }\n            end \u003d text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }",
    "begin_line": 3436,
    "end_line": 3460,
    "comment": "/** \n * \u003cp\u003eReplaces a String with another String inside a larger String, for the first \u003ccode\u003emax\u003c/code\u003e values of the search String.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op.\u003c/p\u003e \u003cpre\u003e StringUtils.replace(null, *, *, *)         \u003d null StringUtils.replace(\"\", *, *, *)           \u003d \"\" StringUtils.replace(\"any\", null, *, *)     \u003d \"any\" StringUtils.replace(\"any\", *, null, *)     \u003d \"any\" StringUtils.replace(\"any\", \"\", *, *)       \u003d \"any\" StringUtils.replace(\"any\", *, *, 0)        \u003d \"any\" StringUtils.replace(\"abaa\", \"a\", null, -1) \u003d \"abaa\" StringUtils.replace(\"abaa\", \"a\", \"\", -1)   \u003d \"b\" StringUtils.replace(\"abaa\", \"a\", \"z\", 0)   \u003d \"abaa\" StringUtils.replace(\"abaa\", \"a\", \"z\", 1)   \u003d \"zbaa\" StringUtils.replace(\"abaa\", \"a\", \"z\", 2)   \u003d \"zbza\" StringUtils.replace(\"abaa\", \"a\", \"z\", -1)  \u003d \"zbzz\" \u003c/pre\u003e\n * @param text  text to search and replace in, may be null\n * @param searchString  the String to search for, may be null\n * @param replacement  the String to replace it with, may be null\n * @param max  maximum number of values to replace, or \u003ccode\u003e-1\u003c/code\u003e if no maximum\n * @return the text with any replacements processed,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceEach#3501",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceEach(java.lang.String, java.lang.String[], java.lang.String[])",
    "snippet": "public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n        return replaceEach(text, searchList, replacementList, false, 0);\n    }",
    "begin_line": 3501,
    "end_line": 3503,
    "comment": "/** \n * \u003cp\u003e Replaces all occurrences of Strings within another String. \u003c/p\u003e \u003cp\u003e A \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if any \"search string\" or \"string to replace\" is null, that replace will be ignored. This will not repeat. For repeating replaces, call the overloaded method. \u003c/p\u003e \u003cpre\u003e StringUtils.replaceEach(null, *, *)        \u003d null StringUtils.replaceEach(\"\", *, *)          \u003d \"\" StringUtils.replaceEach(\"aba\", null, null) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[0], null) \u003d \"aba\" StringUtils.replaceEach(\"aba\", null, new String[0]) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null)  \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"})  \u003d \"b\" StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"})  \u003d \"aba\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"})  \u003d \"wcte\" (example of how it does not repeat) StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"})  \u003d \"dcte\" \u003c/pre\u003e\n * @param text text to search and replace in, no-op if null\n * @param searchList the Strings to search for, no-op if null\n * @param replacementList the Strings to replace them with, no-op if null\n * @return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e ifnull String input\n * @throws IndexOutOfBoundsException if the lengths of the arrays are not the same (null is ok, and/or size 0)\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceEachRepeatedly#3550",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceEachRepeatedly(java.lang.String, java.lang.String[], java.lang.String[])",
    "snippet": "public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n        // timeToLive should be 0 if not used or nothing to replace, else it\u0027s\n        // the length of the replace array\n        int timeToLive \u003d searchList \u003d\u003d null ? 0 : searchList.length;\n        return replaceEach(text, searchList, replacementList, true, timeToLive);\n    }",
    "begin_line": 3550,
    "end_line": 3555,
    "comment": "/** \n * \u003cp\u003e Replaces all occurrences of Strings within another String. \u003c/p\u003e \u003cp\u003e A \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if any \"search string\" or \"string to replace\" is null, that replace will be ignored. This will not repeat. For repeating replaces, call the overloaded method. \u003c/p\u003e \u003cpre\u003e StringUtils.replaceEach(null, *, *, *) \u003d null StringUtils.replaceEach(\"\", *, *, *) \u003d \"\" StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) \u003d \"b\" StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) \u003d \"aba\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) \u003d \"wcte\" (example of how it repeats) StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) \u003d \"dcte\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) \u003d \"tcte\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, true) \u003d IllegalArgumentException StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, false) \u003d \"dcabe\" \u003c/pre\u003e\n * @param text text to search and replace in, no-op if null\n * @param searchList the Strings to search for, no-op if null\n * @param replacementList the Strings to replace them with, no-op if null\n * @return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e ifnull String input\n * @throws IllegalArgumentException if the search is repeating and there is an endless loop due to outputs of one being inputs to another\n * @throws IndexOutOfBoundsException if the lengths of the arrays are not the same (null is ok, and/or size 0)\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceEach#3605",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceEach(java.lang.String, java.lang.String[], java.lang.String[], boolean, int)",
    "snippet": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || \n            searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive \u003c 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength \u003d searchList.length;\n        int replacementLength \u003d replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength !\u003d replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex \u003d -1;\n        int replaceIndex \u003d -1;\n        int tempIndex \u003d -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i \u003d 0; i \u003c searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || \n                searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) \n            {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex \u003d\u003d -1) {\n            return text;\n        }\n\n        int start \u003d 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase \u003d 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i \u003d 0; i \u003c searchList.length; i++) {\n            int greater \u003d replacementList[i].length() - searchList[i].length();\n            if (greater \u003e 0) {\n                increase +\u003d 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase \u003d Math.min(increase, text.length() / 5);\n\n        StringBuilder buf \u003d new StringBuilder(text.length() + increase);\n\n        while (textIndex !\u003d -1) {\n\n            for (int i \u003d start; i \u003c textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start \u003d textIndex + searchList[replaceIndex].length();\n\n            textIndex \u003d -1;\n            replaceIndex \u003d -1;\n            tempIndex \u003d -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i \u003d 0; i \u003c searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || \n                    searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) \n                {\n                    continue;\n                }\n                tempIndex \u003d text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex \u003d\u003d -1) {\n                    noMoreMatchesForReplIndex[i] \u003d true;\n                } else {\n                    if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                        textIndex \u003d tempIndex;\n                        replaceIndex \u003d i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength \u003d text.length();\n        for (int i \u003d start; i \u003c textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result \u003d buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }",
    "begin_line": 3605,
    "end_line": 3731,
    "comment": "/** \n * \u003cp\u003e Replaces all occurrences of Strings within another String. \u003c/p\u003e \u003cp\u003e A \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if any \"search string\" or \"string to replace\" is null, that replace will be ignored.  \u003c/p\u003e \u003cpre\u003e StringUtils.replaceEach(null, *, *, *) \u003d null StringUtils.replaceEach(\"\", *, *, *) \u003d \"\" StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) \u003d \"b\" StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) \u003d \"aba\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) \u003d \"wcte\" (example of how it repeats) StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) \u003d \"dcte\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) \u003d \"tcte\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) \u003d IllegalArgumentException \u003c/pre\u003e\n * @param text text to search and replace in, no-op if null\n * @param searchList the Strings to search for, no-op if null\n * @param replacementList the Strings to replace them with, no-op if null\n * @param repeat if true, then replace repeatedly until there are no more possible replacements or timeToLive \u003c 0\n * @param timeToLive if less than 0 then there is a circular reference and endless loop\n * @return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e ifnull String input\n * @throws IllegalArgumentException if the search is repeating and there is an endless loop due to outputs of one being inputs to another\n * @throws IndexOutOfBoundsException if the lengths of the arrays are not the same (null is ok, and/or size 0)\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceChars#3755",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceChars(java.lang.String, char, char)",
    "snippet": "public static String replaceChars(String str, char searchChar, char replaceChar) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }",
    "begin_line": 3755,
    "end_line": 3760,
    "comment": "/** \n * \u003cp\u003eReplaces all occurrences of a character in a String with another. This is a null-safe version of  {@link String#replace(char,char)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e string input returns \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") string input returns an empty string.\u003c/p\u003e \u003cpre\u003e StringUtils.replaceChars(null, *, *)        \u003d null StringUtils.replaceChars(\"\", *, *)          \u003d \"\" StringUtils.replaceChars(\"abcba\", \u0027b\u0027, \u0027y\u0027) \u003d \"aycya\" StringUtils.replaceChars(\"abcba\", \u0027z\u0027, \u0027y\u0027) \u003d \"abcba\" \u003c/pre\u003e\n * @param str  String to replace characters in, may be null\n * @param searchChar  the character to search for, may be null\n * @param replaceChar  the character to replace, may be null\n * @return modified String, \u003ccode\u003enull\u003c/code\u003e if null string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceChars#3798",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceChars(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String replaceChars(String str, String searchChars, String replaceChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars \u003d\u003d null) {\n            replaceChars \u003d EMPTY;\n        }\n        boolean modified \u003d false;\n        int replaceCharsLength \u003d replaceChars.length();\n        int strLength \u003d str.length();\n        StringBuilder buf \u003d new StringBuilder(strLength);\n        for (int i \u003d 0; i \u003c strLength; i++) {\n            char ch \u003d str.charAt(i);\n            int index \u003d searchChars.indexOf(ch);\n            if (index \u003e\u003d 0) {\n                modified \u003d true;\n                if (index \u003c replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }",
    "begin_line": 3798,
    "end_line": 3825,
    "comment": "/** \n * \u003cp\u003eReplaces multiple characters in a String in one go. This method can also be used to delete characters.\u003c/p\u003e \u003cp\u003eFor example:\u003cbr /\u003e \u003ccode\u003ereplaceChars(\u0026quot;hello\u0026quot;, \u0026quot;ho\u0026quot;, \u0026quot;jy\u0026quot;) \u003d jelly\u003c/code\u003e.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e string input returns \u003ccode\u003enull\u003c/code\u003e. An empty (\"\") string input returns an empty string. A null or empty set of search characters returns the input string.\u003c/p\u003e \u003cp\u003eThe length of the search characters should normally equal the length of the replace characters. If the search characters is longer, then the extra search characters are deleted. If the search characters is shorter, then the extra replace characters are ignored.\u003c/p\u003e \u003cpre\u003e StringUtils.replaceChars(null, *, *)           \u003d null StringUtils.replaceChars(\"\", *, *)             \u003d \"\" StringUtils.replaceChars(\"abc\", null, *)       \u003d \"abc\" StringUtils.replaceChars(\"abc\", \"\", *)         \u003d \"abc\" StringUtils.replaceChars(\"abc\", \"b\", null)     \u003d \"ac\" StringUtils.replaceChars(\"abc\", \"b\", \"\")       \u003d \"ac\" StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\")  \u003d \"ayzya\" StringUtils.replaceChars(\"abcba\", \"bc\", \"y\")   \u003d \"ayya\" StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\") \u003d \"ayzya\" \u003c/pre\u003e\n * @param str  String to replace characters in, may be null\n * @param searchChars  a set of characters to search for, may be null\n * @param replaceChars  a set of characters to replace, may be null\n * @return modified String, \u003ccode\u003enull\u003c/code\u003e if null string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.overlay#3858",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.overlay(java.lang.String, java.lang.String, int, int)",
    "snippet": "public static String overlay(String str, String overlay, int start, int end) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (overlay \u003d\u003d null) {\n            overlay \u003d EMPTY;\n        }\n        int len \u003d str.length();\n        if (start \u003c 0) {\n            start \u003d 0;\n        }\n        if (start \u003e len) {\n            start \u003d len;\n        }\n        if (end \u003c 0) {\n            end \u003d 0;\n        }\n        if (end \u003e len) {\n            end \u003d len;\n        }\n        if (start \u003e end) {\n            int temp \u003d start;\n            start \u003d end;\n            end \u003d temp;\n        }\n        return new StringBuilder(len + start - end + overlay.length() + 1)\n            .append(str.substring(0, start))\n            .append(overlay)\n            .append(str.substring(end))\n            .toString();\n    }",
    "begin_line": 3858,
    "end_line": 3888,
    "comment": "/** \n * \u003cp\u003eOverlays part of a String with another String.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e string input returns \u003ccode\u003enull\u003c/code\u003e. A negative index is treated as zero. An index greater than the string length is treated as the string length. The start index is always the smaller of the two indices.\u003c/p\u003e \u003cpre\u003e StringUtils.overlay(null, *, *, *)            \u003d null StringUtils.overlay(\"\", \"abc\", 0, 0)          \u003d \"abc\" StringUtils.overlay(\"abcdef\", null, 2, 4)     \u003d \"abef\" StringUtils.overlay(\"abcdef\", \"\", 2, 4)       \u003d \"abef\" StringUtils.overlay(\"abcdef\", \"\", 4, 2)       \u003d \"abef\" StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4)   \u003d \"abzzzzef\" StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2)   \u003d \"abzzzzef\" StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4)  \u003d \"zzzzef\" StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 8)   \u003d \"abzzzz\" StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -3) \u003d \"zzzzabcdef\" StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10)  \u003d \"abcdefzzzz\" \u003c/pre\u003e\n * @param str  the String to do overlaying in, may be null\n * @param overlay  the String to overlay, may be null\n * @param start  the position to start overlaying at\n * @param end  the position to stop overlaying before\n * @return overlayed String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.chomp#3917",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.chomp(java.lang.String)",
    "snippet": "public static String chomp(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n\n        if (str.length() \u003d\u003d 1) {\n            char ch \u003d str.charAt(0);\n            if (ch \u003d\u003d CharUtils.CR || ch \u003d\u003d CharUtils.LF) {\n                return EMPTY;\n            }\n            return str;\n        }\n\n        int lastIdx \u003d str.length() - 1;\n        char last \u003d str.charAt(lastIdx);\n\n        if (last \u003d\u003d CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) \u003d\u003d CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last !\u003d CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }",
    "begin_line": 3917,
    "end_line": 3941,
    "comment": "/** \n * \u003cp\u003eRemoves one newline from end of a String if it\u0027s there, otherwise leave it alone.  A newline is \u0026quot;\u003ccode\u003e\\n\u003c/code\u003e\u0026quot;, \u0026quot;\u003ccode\u003e\\r\u003c/code\u003e\u0026quot;, or \u0026quot;\u003ccode\u003e\\r\\n\u003c/code\u003e\u0026quot;.\u003c/p\u003e \u003cp\u003eNOTE: This method changed in 2.0. It now more closely matches Perl chomp.\u003c/p\u003e \u003cpre\u003e StringUtils.chomp(null)          \u003d null StringUtils.chomp(\"\")            \u003d \"\" StringUtils.chomp(\"abc \\r\")      \u003d \"abc \" StringUtils.chomp(\"abc\\n\")       \u003d \"abc\" StringUtils.chomp(\"abc\\r\\n\")     \u003d \"abc\" StringUtils.chomp(\"abc\\r\\n\\r\\n\") \u003d \"abc\\r\\n\" StringUtils.chomp(\"abc\\n\\r\")     \u003d \"abc\\n\" StringUtils.chomp(\"abc\\n\\rabc\")  \u003d \"abc\\n\\rabc\" StringUtils.chomp(\"\\r\")          \u003d \"\" StringUtils.chomp(\"\\n\")          \u003d \"\" StringUtils.chomp(\"\\r\\n\")        \u003d \"\" \u003c/pre\u003e\n * @param str  the String to chomp a newline from, may be null\n * @return String without newline, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.chomp#3969",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.chomp(java.lang.String, java.lang.String)",
    "snippet": "public static String chomp(String str, String separator) {\n        if (isEmpty(str) || separator \u003d\u003d null) {\n            return str;\n        }\n        if (str.endsWith(separator)) {\n            return str.substring(0, str.length() - separator.length());\n        }\n        return str;\n    }",
    "begin_line": 3969,
    "end_line": 3977,
    "comment": "/** \n * \u003cp\u003eRemoves \u003ccode\u003eseparator\u003c/code\u003e from the end of \u003ccode\u003estr\u003c/code\u003e if it\u0027s there, otherwise leave it alone.\u003c/p\u003e \u003cp\u003eNOTE: This method changed in version 2.0. It now more closely matches Perl chomp. For the previous behavior, use  {@link #substringBeforeLast(String,String)}. This method uses  {@link String#endsWith(String)}.\u003c/p\u003e \u003cpre\u003e StringUtils.chomp(null, *)         \u003d null StringUtils.chomp(\"\", *)           \u003d \"\" StringUtils.chomp(\"foobar\", \"bar\") \u003d \"foo\" StringUtils.chomp(\"foobar\", \"baz\") \u003d \"foobar\" StringUtils.chomp(\"foo\", \"foo\")    \u003d \"\" StringUtils.chomp(\"foo \", \"foo\")   \u003d \"foo \" StringUtils.chomp(\" foo\", \"foo\")   \u003d \" \" StringUtils.chomp(\"foo\", \"foooo\")  \u003d \"foo\" StringUtils.chomp(\"foo\", \"\")       \u003d \"foo\" StringUtils.chomp(\"foo\", null)     \u003d \"foo\" \u003c/pre\u003e\n * @param str  the String to chomp from, may be null\n * @param separator  separator String, may be null\n * @return String without trailing separator, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.chop#4004",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.chop(java.lang.String)",
    "snippet": "public static String chop(String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        int strLen \u003d str.length();\n        if (strLen \u003c 2) {\n            return EMPTY;\n        }\n        int lastIdx \u003d strLen - 1;\n        String ret \u003d str.substring(0, lastIdx);\n        char last \u003d str.charAt(lastIdx);\n        if (last \u003d\u003d CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) \u003d\u003d CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }",
    "begin_line": 4004,
    "end_line": 4021,
    "comment": "/** \n * \u003cp\u003eRemove the last character from a String.\u003c/p\u003e \u003cp\u003eIf the String ends in \u003ccode\u003e\\r\\n\u003c/code\u003e, then remove both of them.\u003c/p\u003e \u003cpre\u003e StringUtils.chop(null)          \u003d null StringUtils.chop(\"\")            \u003d \"\" StringUtils.chop(\"abc \\r\")      \u003d \"abc \" StringUtils.chop(\"abc\\n\")       \u003d \"abc\" StringUtils.chop(\"abc\\r\\n\")     \u003d \"abc\" StringUtils.chop(\"abc\")         \u003d \"ab\" StringUtils.chop(\"abc\\nabc\")    \u003d \"abc\\nab\" StringUtils.chop(\"a\")           \u003d \"\" StringUtils.chop(\"\\r\")          \u003d \"\" StringUtils.chop(\"\\n\")          \u003d \"\" StringUtils.chop(\"\\r\\n\")        \u003d \"\" \u003c/pre\u003e\n * @param str  the String to chop last character from, may be null\n * @return String without last character, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.repeat#4046",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.repeat(java.lang.String, int)",
    "snippet": "public static String repeat(String str, int repeat) {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (repeat \u003c\u003d 0) {\n            return EMPTY;\n        }\n        int inputLength \u003d str.length();\n        if (repeat \u003d\u003d 1 || inputLength \u003d\u003d 0) {\n            return str;\n        }\n        if (inputLength \u003d\u003d 1 \u0026\u0026 repeat \u003c\u003d PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        int outputLength \u003d inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch \u003d str.charAt(0);\n                char[] output1 \u003d new char[outputLength];\n                for (int i \u003d repeat - 1; i \u003e\u003d 0; i--) {\n                    output1[i] \u003d ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 \u003d str.charAt(0);\n                char ch1 \u003d str.charAt(1);\n                char[] output2 \u003d new char[outputLength];\n                for (int i \u003d repeat * 2 - 2; i \u003e\u003d 0; i--, i--) {\n                    output2[i] \u003d ch0;\n                    output2[i + 1] \u003d ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf \u003d new StringBuilder(outputLength);\n                for (int i \u003d 0; i \u003c repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
    "begin_line": 4046,
    "end_line": 4088,
    "comment": "/** \n * \u003cp\u003eRepeat a String \u003ccode\u003erepeat\u003c/code\u003e times to form a new String.\u003c/p\u003e \u003cpre\u003e StringUtils.repeat(null, 2) \u003d null StringUtils.repeat(\"\", 0)   \u003d \"\" StringUtils.repeat(\"\", 2)   \u003d \"\" StringUtils.repeat(\"a\", 3)  \u003d \"aaa\" StringUtils.repeat(\"ab\", 2) \u003d \"abab\" StringUtils.repeat(\"a\", -2) \u003d \"\" \u003c/pre\u003e\n * @param str  the String to repeat, may be null\n * @param repeat  number of times to repeat str, negative treated as zero\n * @return a new String consisting of the original String repeated,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.repeat#4109",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.repeat(java.lang.String, java.lang.String, int)",
    "snippet": "public static String repeat(String str, String separator, int repeat) {\n        if(str \u003d\u003d null || separator \u003d\u003d null) {\n            return repeat(str, repeat);\n        } else {\n            // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n            String result \u003d repeat(str + separator, repeat);\n            return removeEnd(result, separator);\n        }\n    }",
    "begin_line": 4109,
    "end_line": 4117,
    "comment": "/** \n * \u003cp\u003eRepeat a String \u003ccode\u003erepeat\u003c/code\u003e times to form a new String, with a String separator injected each time. \u003c/p\u003e \u003cpre\u003e StringUtils.repeat(null, null, 2) \u003d null StringUtils.repeat(null, \"x\", 2)  \u003d null StringUtils.repeat(\"\", null, 0)   \u003d \"\" StringUtils.repeat(\"\", \"\", 2)     \u003d \"\" StringUtils.repeat(\"\", \"x\", 3)    \u003d \"xxx\" StringUtils.repeat(\"?\", \", \", 3)  \u003d \"?, ?, ?\" \u003c/pre\u003e\n * @param str        the String to repeat, may be null\n * @param separator  the String to inject, may be null\n * @param repeat     number of times to repeat str, negative treated as zero\n * @return a new String consisting of the original String repeated,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.padding#4142",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.padding(int, char)",
    "snippet": "private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat \u003c 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final char[] buf \u003d new char[repeat];\n        for (int i \u003d 0; i \u003c buf.length; i++) {\n            buf[i] \u003d padChar;\n        }\n        return new String(buf);\n    }",
    "begin_line": 4142,
    "end_line": 4151,
    "comment": "/** \n * \u003cp\u003eReturns padding using the specified delimiter repeated to a given length.\u003c/p\u003e \u003cpre\u003e StringUtils.padding(0, \u0027e\u0027)  \u003d \"\" StringUtils.padding(3, \u0027e\u0027)  \u003d \"eee\" StringUtils.padding(-2, \u0027e\u0027) \u003d IndexOutOfBoundsException \u003c/pre\u003e \u003cp\u003eNote: this method doesn\u0027t not support padding with \u003ca href\u003d\"http://www.unicode.org/glossary/#supplementary_character\"\u003eUnicode Supplementary Characters\u003c/a\u003e as they require a pair of \u003ccode\u003echar\u003c/code\u003es to be represented. If you are needing to support full I18N of your applications consider using  {@link #repeat(String,int)} instead. \u003c/p\u003e\n * @param repeat  number of times to repeat delim\n * @param padChar  character to repeat\n * @return String with repeated character\n * @throws IndexOutOfBoundsException if \u003ccode\u003erepeat \u0026lt; 0\u003c/code\u003e\n * @see #repeat(String,int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.rightPad#4172",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.rightPad(java.lang.String, int)",
    "snippet": "public static String rightPad(String str, int size) {\n        return rightPad(str, size, \u0027 \u0027);\n    }",
    "begin_line": 4172,
    "end_line": 4174,
    "comment": "/** \n * \u003cp\u003eRight pad a String with spaces (\u0027 \u0027).\u003c/p\u003e \u003cp\u003eThe String is padded to the size of \u003ccode\u003esize\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.rightPad(null, *)   \u003d null StringUtils.rightPad(\"\", 3)     \u003d \"   \" StringUtils.rightPad(\"bat\", 3)  \u003d \"bat\" StringUtils.rightPad(\"bat\", 5)  \u003d \"bat  \" StringUtils.rightPad(\"bat\", 1)  \u003d \"bat\" StringUtils.rightPad(\"bat\", -1) \u003d \"bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @return right padded String or original String if no padding is necessary,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.rightPad#4197",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.rightPad(java.lang.String, int, char)",
    "snippet": "public static String rightPad(String str, int size, char padChar) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        int pads \u003d size - str.length();\n        if (pads \u003c\u003d 0) {\n            return str; // returns original String when possible\n        }\n        if (pads \u003e PAD_LIMIT) {\n            return rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(padding(pads, padChar));\n    }",
    "begin_line": 4197,
    "end_line": 4209,
    "comment": "/** \n * \u003cp\u003eRight pad a String with a specified character.\u003c/p\u003e \u003cp\u003eThe String is padded to the size of \u003ccode\u003esize\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.rightPad(null, *, *)     \u003d null StringUtils.rightPad(\"\", 3, \u0027z\u0027)     \u003d \"zzz\" StringUtils.rightPad(\"bat\", 3, \u0027z\u0027)  \u003d \"bat\" StringUtils.rightPad(\"bat\", 5, \u0027z\u0027)  \u003d \"batzz\" StringUtils.rightPad(\"bat\", 1, \u0027z\u0027)  \u003d \"bat\" StringUtils.rightPad(\"bat\", -1, \u0027z\u0027) \u003d \"bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padChar  the character to pad with\n * @return right padded String or original String if no padding is necessary,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.rightPad#4234",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.rightPad(java.lang.String, int, java.lang.String)",
    "snippet": "public static String rightPad(String str, int size, String padStr) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr \u003d \" \";\n        }\n        int padLen \u003d padStr.length();\n        int strLen \u003d str.length();\n        int pads \u003d size - strLen;\n        if (pads \u003c\u003d 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen \u003d\u003d 1 \u0026\u0026 pads \u003c\u003d PAD_LIMIT) {\n            return rightPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads \u003d\u003d padLen) {\n            return str.concat(padStr);\n        } else if (pads \u003c padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            char[] padding \u003d new char[pads];\n            char[] padChars \u003d padStr.toCharArray();\n            for (int i \u003d 0; i \u003c pads; i++) {\n                padding[i] \u003d padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }",
    "begin_line": 4234,
    "end_line": 4263,
    "comment": "/** \n * \u003cp\u003eRight pad a String with a specified String.\u003c/p\u003e \u003cp\u003eThe String is padded to the size of \u003ccode\u003esize\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.rightPad(null, *, *)      \u003d null StringUtils.rightPad(\"\", 3, \"z\")      \u003d \"zzz\" StringUtils.rightPad(\"bat\", 3, \"yz\")  \u003d \"bat\" StringUtils.rightPad(\"bat\", 5, \"yz\")  \u003d \"batyz\" StringUtils.rightPad(\"bat\", 8, \"yz\")  \u003d \"batyzyzy\" StringUtils.rightPad(\"bat\", 1, \"yz\")  \u003d \"bat\" StringUtils.rightPad(\"bat\", -1, \"yz\") \u003d \"bat\" StringUtils.rightPad(\"bat\", 5, null)  \u003d \"bat  \" StringUtils.rightPad(\"bat\", 5, \"\")    \u003d \"bat  \" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padStr  the String to pad with, null or empty treated as single space\n * @return right padded String or original String if no padding is necessary,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.leftPad#4284",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.leftPad(java.lang.String, int)",
    "snippet": "public static String leftPad(String str, int size) {\n        return leftPad(str, size, \u0027 \u0027);\n    }",
    "begin_line": 4284,
    "end_line": 4286,
    "comment": "/** \n * \u003cp\u003eLeft pad a String with spaces (\u0027 \u0027).\u003c/p\u003e \u003cp\u003eThe String is padded to the size of \u003ccode\u003esize\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.leftPad(null, *)   \u003d null StringUtils.leftPad(\"\", 3)     \u003d \"   \" StringUtils.leftPad(\"bat\", 3)  \u003d \"bat\" StringUtils.leftPad(\"bat\", 5)  \u003d \"  bat\" StringUtils.leftPad(\"bat\", 1)  \u003d \"bat\" StringUtils.leftPad(\"bat\", -1) \u003d \"bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @return left padded String or original String if no padding is necessary,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.leftPad#4309",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.leftPad(java.lang.String, int, char)",
    "snippet": "public static String leftPad(String str, int size, char padChar) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        int pads \u003d size - str.length();\n        if (pads \u003c\u003d 0) {\n            return str; // returns original String when possible\n        }\n        if (pads \u003e PAD_LIMIT) {\n            return leftPad(str, size, String.valueOf(padChar));\n        }\n        return padding(pads, padChar).concat(str);\n    }",
    "begin_line": 4309,
    "end_line": 4321,
    "comment": "/** \n * \u003cp\u003eLeft pad a String with a specified character.\u003c/p\u003e \u003cp\u003ePad to a size of \u003ccode\u003esize\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.leftPad(null, *, *)     \u003d null StringUtils.leftPad(\"\", 3, \u0027z\u0027)     \u003d \"zzz\" StringUtils.leftPad(\"bat\", 3, \u0027z\u0027)  \u003d \"bat\" StringUtils.leftPad(\"bat\", 5, \u0027z\u0027)  \u003d \"zzbat\" StringUtils.leftPad(\"bat\", 1, \u0027z\u0027)  \u003d \"bat\" StringUtils.leftPad(\"bat\", -1, \u0027z\u0027) \u003d \"bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padChar  the character to pad with\n * @return left padded String or original String if no padding is necessary,\u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.leftPad#4346",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.leftPad(java.lang.String, int, java.lang.String)",
    "snippet": "public static String leftPad(String str, int size, String padStr) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr \u003d \" \";\n        }\n        int padLen \u003d padStr.length();\n        int strLen \u003d str.length();\n        int pads \u003d size - strLen;\n        if (pads \u003c\u003d 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen \u003d\u003d 1 \u0026\u0026 pads \u003c\u003d PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads \u003d\u003d padLen) {\n            return padStr.concat(str);\n        } else if (pads \u003c padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            char[] padding \u003d new char[pads];\n            char[] padChars \u003d padStr.toCharArray();\n            for (int i \u003d 0; i \u003c pads; i++) {\n                padding[i] \u003d padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }",
    "begin_line": 4346,
    "end_line": 4375,
    "comment": "/** \n * \u003cp\u003eLeft pad a String with a specified String.\u003c/p\u003e \u003cp\u003ePad to a size of \u003ccode\u003esize\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.leftPad(null, *, *)      \u003d null StringUtils.leftPad(\"\", 3, \"z\")      \u003d \"zzz\" StringUtils.leftPad(\"bat\", 3, \"yz\")  \u003d \"bat\" StringUtils.leftPad(\"bat\", 5, \"yz\")  \u003d \"yzbat\" StringUtils.leftPad(\"bat\", 8, \"yz\")  \u003d \"yzyzybat\" StringUtils.leftPad(\"bat\", 1, \"yz\")  \u003d \"bat\" StringUtils.leftPad(\"bat\", -1, \"yz\") \u003d \"bat\" StringUtils.leftPad(\"bat\", 5, null)  \u003d \"  bat\" StringUtils.leftPad(\"bat\", 5, \"\")    \u003d \"  bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padStr  the String to pad with, null or empty treated as single space\n * @return left padded String or original String if no padding is necessary,\u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.length#4385",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.length(java.lang.String)",
    "snippet": "public static int length(String str) {\n        return str \u003d\u003d null ? 0 : str.length();\n    }",
    "begin_line": 4385,
    "end_line": 4387,
    "comment": "/** \n * Gets a String\u0027s length or \u003ccode\u003e0\u003c/code\u003e if the String is \u003ccode\u003enull\u003c/code\u003e.\n * @param str a String or \u003ccode\u003enull\u003c/code\u003e\n * @return String length or \u003ccode\u003e0\u003c/code\u003e if the String is \u003ccode\u003enull\u003c/code\u003e.\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.center#4414",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.center(java.lang.String, int)",
    "snippet": "public static String center(String str, int size) {\n        return center(str, size, \u0027 \u0027);\n    }",
    "begin_line": 4414,
    "end_line": 4416,
    "comment": "/** \n * \u003cp\u003eCenters a String in a larger String of size \u003ccode\u003esize\u003c/code\u003e using the space character (\u0027 \u0027).\u003cp\u003e \u003cp\u003eIf the size is less than the String length, the String is returned. A \u003ccode\u003enull\u003c/code\u003e String returns \u003ccode\u003enull\u003c/code\u003e. A negative size is treated as zero.\u003c/p\u003e \u003cp\u003eEquivalent to \u003ccode\u003ecenter(str, size, \" \")\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.center(null, *)   \u003d null StringUtils.center(\"\", 4)     \u003d \"    \" StringUtils.center(\"ab\", -1)  \u003d \"ab\" StringUtils.center(\"ab\", 4)   \u003d \" ab \" StringUtils.center(\"abcd\", 2) \u003d \"abcd\" StringUtils.center(\"a\", 4)    \u003d \" a  \" \u003c/pre\u003e\n * @param str  the String to center, may be null\n * @param size  the int size of new String, negative treated as zero\n * @return centered String, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.center#4442",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.center(java.lang.String, int, char)",
    "snippet": "public static String center(String str, int size, char padChar) {\n        if (str \u003d\u003d null || size \u003c\u003d 0) {\n            return str;\n        }\n        int strLen \u003d str.length();\n        int pads \u003d size - strLen;\n        if (pads \u003c\u003d 0) {\n            return str;\n        }\n        str \u003d leftPad(str, strLen + pads / 2, padChar);\n        str \u003d rightPad(str, size, padChar);\n        return str;\n    }",
    "begin_line": 4442,
    "end_line": 4454,
    "comment": "/** \n * \u003cp\u003eCenters a String in a larger String of size \u003ccode\u003esize\u003c/code\u003e. Uses a supplied character as the value to pad the String with.\u003c/p\u003e \u003cp\u003eIf the size is less than the String length, the String is returned. A \u003ccode\u003enull\u003c/code\u003e String returns \u003ccode\u003enull\u003c/code\u003e. A negative size is treated as zero.\u003c/p\u003e \u003cpre\u003e StringUtils.center(null, *, *)     \u003d null StringUtils.center(\"\", 4, \u0027 \u0027)     \u003d \"    \" StringUtils.center(\"ab\", -1, \u0027 \u0027)  \u003d \"ab\" StringUtils.center(\"ab\", 4, \u0027 \u0027)   \u003d \" ab\" StringUtils.center(\"abcd\", 2, \u0027 \u0027) \u003d \"abcd\" StringUtils.center(\"a\", 4, \u0027 \u0027)    \u003d \" a  \" StringUtils.center(\"a\", 4, \u0027y\u0027)    \u003d \"yayy\" \u003c/pre\u003e\n * @param str  the String to center, may be null\n * @param size  the int size of new String, negative treated as zero\n * @param padChar  the character to pad the new String with\n * @return centered String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.center#4482",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.center(java.lang.String, int, java.lang.String)",
    "snippet": "public static String center(String str, int size, String padStr) {\n        if (str \u003d\u003d null || size \u003c\u003d 0) {\n            return str;\n        }\n        if (isEmpty(padStr)) {\n            padStr \u003d \" \";\n        }\n        int strLen \u003d str.length();\n        int pads \u003d size - strLen;\n        if (pads \u003c\u003d 0) {\n            return str;\n        }\n        str \u003d leftPad(str, strLen + pads / 2, padStr);\n        str \u003d rightPad(str, size, padStr);\n        return str;\n    }",
    "begin_line": 4482,
    "end_line": 4497,
    "comment": "/** \n * \u003cp\u003eCenters a String in a larger String of size \u003ccode\u003esize\u003c/code\u003e. Uses a supplied String as the value to pad the String with.\u003c/p\u003e \u003cp\u003eIf the size is less than the String length, the String is returned. A \u003ccode\u003enull\u003c/code\u003e String returns \u003ccode\u003enull\u003c/code\u003e. A negative size is treated as zero.\u003c/p\u003e \u003cpre\u003e StringUtils.center(null, *, *)     \u003d null StringUtils.center(\"\", 4, \" \")     \u003d \"    \" StringUtils.center(\"ab\", -1, \" \")  \u003d \"ab\" StringUtils.center(\"ab\", 4, \" \")   \u003d \" ab\" StringUtils.center(\"abcd\", 2, \" \") \u003d \"abcd\" StringUtils.center(\"a\", 4, \" \")    \u003d \" a  \" StringUtils.center(\"a\", 4, \"yz\")   \u003d \"yayz\" StringUtils.center(\"abc\", 7, null) \u003d \"  abc  \" StringUtils.center(\"abc\", 7, \"\")   \u003d \"  abc  \" \u003c/pre\u003e\n * @param str  the String to center, may be null\n * @param size  the int size of new String, negative treated as zero\n * @param padStr  the String to pad the new String with, must not be null or empty\n * @return centered String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @throws IllegalArgumentException if padStr is \u003ccode\u003enull\u003c/code\u003e or empty\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.upperCase#4520",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.upperCase(java.lang.String)",
    "snippet": "public static String upperCase(String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }",
    "begin_line": 4520,
    "end_line": 4525,
    "comment": "/** \n * \u003cp\u003eConverts a String to upper case as per  {@link String#toUpperCase()}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.upperCase(null)  \u003d null StringUtils.upperCase(\"\")    \u003d \"\" StringUtils.upperCase(\"aBc\") \u003d \"ABC\" \u003c/pre\u003e \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e As described in the documentation for  {@link String#toUpperCase()}, the result of this method is affected by the current locale. For platform-independent case transformations, the method  {@link #lowerCase(String,Locale)}should be used with a specific locale (e.g.  {@link Locale#ENGLISH}).\u003c/p\u003e\n * @param str  the String to upper case, may be null\n * @return the upper cased String, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.upperCase#4543",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.upperCase(java.lang.String, java.util.Locale)",
    "snippet": "public static String upperCase(String str, Locale locale) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }",
    "begin_line": 4543,
    "end_line": 4548,
    "comment": "/** \n * \u003cp\u003eConverts a String to upper case as per  {@link String#toUpperCase(Locale)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.upperCase(null, Locale.ENGLISH)  \u003d null StringUtils.upperCase(\"\", Locale.ENGLISH)    \u003d \"\" StringUtils.upperCase(\"aBc\", Locale.ENGLISH) \u003d \"ABC\" \u003c/pre\u003e\n * @param str  the String to upper case, may be null\n * @param locale  the locale that defines the case transformation rules, must not be null\n * @return the upper cased String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lowerCase#4569",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lowerCase(java.lang.String)",
    "snippet": "public static String lowerCase(String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }",
    "begin_line": 4569,
    "end_line": 4574,
    "comment": "/** \n * \u003cp\u003eConverts a String to lower case as per  {@link String#toLowerCase()}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.lowerCase(null)  \u003d null StringUtils.lowerCase(\"\")    \u003d \"\" StringUtils.lowerCase(\"aBc\") \u003d \"abc\" \u003c/pre\u003e \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e As described in the documentation for  {@link String#toLowerCase()}, the result of this method is affected by the current locale. For platform-independent case transformations, the method  {@link #lowerCase(String,Locale)}should be used with a specific locale (e.g.  {@link Locale#ENGLISH}).\u003c/p\u003e\n * @param str  the String to lower case, may be null\n * @return the lower cased String, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lowerCase#4592",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lowerCase(java.lang.String, java.util.Locale)",
    "snippet": "public static String lowerCase(String str, Locale locale) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }",
    "begin_line": 4592,
    "end_line": 4597,
    "comment": "/** \n * \u003cp\u003eConverts a String to lower case as per  {@link String#toLowerCase(Locale)}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.lowerCase(null, Locale.ENGLISH)  \u003d null StringUtils.lowerCase(\"\", Locale.ENGLISH)    \u003d \"\" StringUtils.lowerCase(\"aBc\", Locale.ENGLISH) \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to lower case, may be null\n * @param locale  the locale that defines the case transformation rules, must not be null\n * @return the lower cased String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.capitalize#4619",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.capitalize(java.lang.String)",
    "snippet": "public static String capitalize(String str) {\n        int strLen;\n        if (str \u003d\u003d null || (strLen \u003d str.length()) \u003d\u003d 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toTitleCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }",
    "begin_line": 4619,
    "end_line": 4628,
    "comment": "/** \n * \u003cp\u003eCapitalizes a String changing the first letter to title case as per  {@link Character#toTitleCase(char)}. No other letters are changed.\u003c/p\u003e \u003cp\u003eFor a word based algorithm, see  {@link WordUtils#capitalize(String)}. A \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.capitalize(null)  \u003d null StringUtils.capitalize(\"\")    \u003d \"\" StringUtils.capitalize(\"cat\") \u003d \"Cat\" StringUtils.capitalize(\"cAt\") \u003d \"CAt\" \u003c/pre\u003e\n * @param str  the String to capitalize, may be null\n * @return the capitalized String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @see WordUtils#capitalize(String)\n * @see #uncapitalize(String)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.uncapitalize#4650",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.uncapitalize(java.lang.String)",
    "snippet": "public static String uncapitalize(String str) {\n        int strLen;\n        if (str \u003d\u003d null || (strLen \u003d str.length()) \u003d\u003d 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toLowerCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }",
    "begin_line": 4650,
    "end_line": 4659,
    "comment": "/** \n * \u003cp\u003eUncapitalizes a String changing the first letter to title case as per  {@link Character#toLowerCase(char)}. No other letters are changed.\u003c/p\u003e \u003cp\u003eFor a word based algorithm, see  {@link WordUtils#uncapitalize(String)}. A \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.uncapitalize(null)  \u003d null StringUtils.uncapitalize(\"\")    \u003d \"\" StringUtils.uncapitalize(\"Cat\") \u003d \"cat\" StringUtils.uncapitalize(\"CAT\") \u003d \"cAT\" \u003c/pre\u003e\n * @param str  the String to uncapitalize, may be null\n * @return the uncapitalized String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @see WordUtils#uncapitalize(String)\n * @see #capitalize(String)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.swapCase#4688",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.swapCase(java.lang.String)",
    "snippet": "public static String swapCase(String str) {\n        int strLen;\n        if (str \u003d\u003d null || (strLen \u003d str.length()) \u003d\u003d 0) {\n            return str;\n        }\n        StringBuilder buffer \u003d new StringBuilder(strLen);\n\n        char ch \u003d 0;\n        for (int i \u003d 0; i \u003c strLen; i++) {\n            ch \u003d str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch \u003d Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch \u003d Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch \u003d Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }",
    "begin_line": 4688,
    "end_line": 4708,
    "comment": "/** \n * \u003cp\u003eSwaps the case of a String changing upper and title case to lower case, and lower case to upper case.\u003c/p\u003e \u003cul\u003e \u003cli\u003eUpper case character converts to Lower case\u003c/li\u003e \u003cli\u003eTitle case character converts to Lower case\u003c/li\u003e \u003cli\u003eLower case character converts to Upper case\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eFor a word based algorithm, see  {@link WordUtils#swapCase(String)}. A \u003ccode\u003enull\u003c/code\u003e input String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.swapCase(null)                 \u003d null StringUtils.swapCase(\"\")                   \u003d \"\" StringUtils.swapCase(\"The dog has a BONE\") \u003d \"tHE DOG HAS A bone\" \u003c/pre\u003e \u003cp\u003eNOTE: This method changed in Lang version 2.0. It no longer performs a word based algorithm. If you only use ASCII, you will notice no change. That functionality is available in WordUtils.\u003c/p\u003e\n * @param str  the String to swap case, may be null\n * @return the changed String, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.countMatches#4731",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.countMatches(java.lang.String, java.lang.String)",
    "snippet": "public static int countMatches(String str, String sub) {\n        if (isEmpty(str) || isEmpty(sub)) {\n            return 0;\n        }\n        int count \u003d 0;\n        int idx \u003d 0;\n        while ((idx \u003d str.indexOf(sub, idx)) !\u003d -1) {\n            count++;\n            idx +\u003d sub.length();\n        }\n        return count;\n    }",
    "begin_line": 4731,
    "end_line": 4742,
    "comment": "/** \n * \u003cp\u003eCounts how many times the substring appears in the larger String.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e or empty (\"\") String input returns \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.countMatches(null, *)       \u003d 0 StringUtils.countMatches(\"\", *)         \u003d 0 StringUtils.countMatches(\"abba\", null)  \u003d 0 StringUtils.countMatches(\"abba\", \"\")    \u003d 0 StringUtils.countMatches(\"abba\", \"a\")   \u003d 2 StringUtils.countMatches(\"abba\", \"ab\")  \u003d 1 StringUtils.countMatches(\"abba\", \"xxx\") \u003d 0 \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param sub  the substring to count, may be null\n * @return the number of occurrences, 0 if either String is \u003ccode\u003enull\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAlpha#4764",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAlpha(java.lang.String)",
    "snippet": "public static boolean isAlpha(String str) {\n        if (str \u003d\u003d null) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isLetter(str.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 4764,
    "end_line": 4775,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only unicode letters.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") will return \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isAlpha(null)   \u003d false StringUtils.isAlpha(\"\")     \u003d true StringUtils.isAlpha(\"  \")   \u003d false StringUtils.isAlpha(\"abc\")  \u003d true StringUtils.isAlpha(\"ab2c\") \u003d false StringUtils.isAlpha(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if only contains letters, and is non-null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAlphaSpace#4798",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAlphaSpace(java.lang.String)",
    "snippet": "public static boolean isAlphaSpace(String str) {\n        if (str \u003d\u003d null) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if ((Character.isLetter(str.charAt(i)) \u003d\u003d false) \u0026\u0026 (str.charAt(i) !\u003d \u0027 \u0027)) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 4798,
    "end_line": 4809,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only unicode letters and space (\u0027 \u0027).\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e An empty String (\"\") will return \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isAlphaSpace(null)   \u003d false StringUtils.isAlphaSpace(\"\")     \u003d true StringUtils.isAlphaSpace(\"  \")   \u003d true StringUtils.isAlphaSpace(\"abc\")  \u003d true StringUtils.isAlphaSpace(\"ab c\") \u003d true StringUtils.isAlphaSpace(\"ab2c\") \u003d false StringUtils.isAlphaSpace(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if only contains letters and space,and is non-null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAlphanumeric#4831",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAlphanumeric(java.lang.String)",
    "snippet": "public static boolean isAlphanumeric(String str) {\n        if (str \u003d\u003d null) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isLetterOrDigit(str.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 4831,
    "end_line": 4842,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only unicode letters or digits.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") will return \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isAlphanumeric(null)   \u003d false StringUtils.isAlphanumeric(\"\")     \u003d true StringUtils.isAlphanumeric(\"  \")   \u003d false StringUtils.isAlphanumeric(\"abc\")  \u003d true StringUtils.isAlphanumeric(\"ab c\") \u003d false StringUtils.isAlphanumeric(\"ab2c\") \u003d true StringUtils.isAlphanumeric(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if only contains letters or digits,and is non-null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAlphanumericSpace#4865",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAlphanumericSpace(java.lang.String)",
    "snippet": "public static boolean isAlphanumericSpace(String str) {\n        if (str \u003d\u003d null) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if ((Character.isLetterOrDigit(str.charAt(i)) \u003d\u003d false) \u0026\u0026 (str.charAt(i) !\u003d \u0027 \u0027)) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 4865,
    "end_line": 4876,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only unicode letters, digits or space (\u003ccode\u003e\u0027 \u0027\u003c/code\u003e).\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") will return \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isAlphanumeric(null)   \u003d false StringUtils.isAlphanumeric(\"\")     \u003d true StringUtils.isAlphanumeric(\"  \")   \u003d true StringUtils.isAlphanumeric(\"abc\")  \u003d true StringUtils.isAlphanumeric(\"ab c\") \u003d true StringUtils.isAlphanumeric(\"ab2c\") \u003d true StringUtils.isAlphanumeric(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if only contains letters, digits or space,and is non-null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAsciiPrintable#4903",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAsciiPrintable(java.lang.String)",
    "snippet": "public static boolean isAsciiPrintable(String str) {\n        if (str \u003d\u003d null) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (CharUtils.isAsciiPrintable(str.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 4903,
    "end_line": 4914,
    "comment": "/** \n * \u003cp\u003eChecks if the string contains only ASCII printable characters.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") will return \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isAsciiPrintable(null)     \u003d false StringUtils.isAsciiPrintable(\"\")       \u003d true StringUtils.isAsciiPrintable(\" \")      \u003d true StringUtils.isAsciiPrintable(\"Ceki\")   \u003d true StringUtils.isAsciiPrintable(\"ab2c\")   \u003d true StringUtils.isAsciiPrintable(\"!ab-c~\") \u003d true StringUtils.isAsciiPrintable(\"\\u0020\") \u003d true StringUtils.isAsciiPrintable(\"\\u0021\") \u003d true StringUtils.isAsciiPrintable(\"\\u007e\") \u003d true StringUtils.isAsciiPrintable(\"\\u007f\") \u003d false StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") \u003d false \u003c/pre\u003e\n * @param str the string to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if every character is in the range32 thru 126\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNumeric#4937",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNumeric(java.lang.String)",
    "snippet": "public static boolean isNumeric(String str) {\n        if (str \u003d\u003d null) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isDigit(str.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 4937,
    "end_line": 4948,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only unicode digits. A decimal point is not a unicode digit and returns false.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") will return \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isNumeric(null)   \u003d false StringUtils.isNumeric(\"\")     \u003d true StringUtils.isNumeric(\"  \")   \u003d false StringUtils.isNumeric(\"123\")  \u003d true StringUtils.isNumeric(\"12 3\") \u003d false StringUtils.isNumeric(\"ab2c\") \u003d false StringUtils.isNumeric(\"12-3\") \u003d false StringUtils.isNumeric(\"12.3\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if only contains digits, and is non-null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNumericSpace#4973",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNumericSpace(java.lang.String)",
    "snippet": "public static boolean isNumericSpace(String str) {\n        if (str \u003d\u003d null) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if ((Character.isDigit(str.charAt(i)) \u003d\u003d false) \u0026\u0026 (str.charAt(i) !\u003d \u0027 \u0027)) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 4973,
    "end_line": 4984,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only unicode digits or space (\u003ccode\u003e\u0027 \u0027\u003c/code\u003e). A decimal point is not a unicode digit and returns false.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") will return \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isNumeric(null)   \u003d false StringUtils.isNumeric(\"\")     \u003d true StringUtils.isNumeric(\"  \")   \u003d true StringUtils.isNumeric(\"123\")  \u003d true StringUtils.isNumeric(\"12 3\") \u003d true StringUtils.isNumeric(\"ab2c\") \u003d false StringUtils.isNumeric(\"12-3\") \u003d false StringUtils.isNumeric(\"12.3\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if only contains digits or space,and is non-null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isWhitespace#5005",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isWhitespace(java.lang.String)",
    "snippet": "public static boolean isWhitespace(String str) {\n        if (str \u003d\u003d null) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if ((Character.isWhitespace(str.charAt(i)) \u003d\u003d false)) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 5005,
    "end_line": 5016,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only whitespace.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") will return \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isWhitespace(null)   \u003d false StringUtils.isWhitespace(\"\")     \u003d true StringUtils.isWhitespace(\"  \")   \u003d true StringUtils.isWhitespace(\"abc\")  \u003d false StringUtils.isWhitespace(\"ab2c\") \u003d false StringUtils.isWhitespace(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if only contains whitespace, and is non-null\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAllLowerCase#5035",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAllLowerCase(java.lang.String)",
    "snippet": "public static boolean isAllLowerCase(String str) {\n        if (str \u003d\u003d null || isEmpty(str)) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isLowerCase(str.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 5035,
    "end_line": 5046,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only lowercase characters.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") will return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isAllLowerCase(null)   \u003d false StringUtils.isAllLowerCase(\"\")     \u003d false StringUtils.isAllLowerCase(\"  \")   \u003d false StringUtils.isAllLowerCase(\"abc\")  \u003d true StringUtils.isAllLowerCase(\"abC\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if only contains lowercase characters, and is non-null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAllUpperCase#5065",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAllUpperCase(java.lang.String)",
    "snippet": "public static boolean isAllUpperCase(String str) {\n        if (str \u003d\u003d null || isEmpty(str)) {\n            return false;\n        }\n        int sz \u003d str.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isUpperCase(str.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 5065,
    "end_line": 5076,
    "comment": "/** \n * \u003cp\u003eChecks if the String contains only uppercase characters.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003e will return \u003ccode\u003efalse\u003c/code\u003e. An empty String (\"\") will return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.isAllUpperCase(null)   \u003d false StringUtils.isAllUpperCase(\"\")     \u003d false StringUtils.isAllUpperCase(\"  \")   \u003d false StringUtils.isAllUpperCase(\"ABC\")  \u003d true StringUtils.isAllUpperCase(\"aBC\") \u003d false \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if only contains uppercase characters, and is non-null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.defaultString#5096",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.defaultString(java.lang.String)",
    "snippet": "public static String defaultString(String str) {\n        return str \u003d\u003d null ? EMPTY : str;\n    }",
    "begin_line": 5096,
    "end_line": 5098,
    "comment": "/** \n * \u003cp\u003eReturns either the passed in String, or if the String is \u003ccode\u003enull\u003c/code\u003e, an empty String (\"\").\u003c/p\u003e \u003cpre\u003e StringUtils.defaultString(null)  \u003d \"\" StringUtils.defaultString(\"\")    \u003d \"\" StringUtils.defaultString(\"bat\") \u003d \"bat\" \u003c/pre\u003e\n * @see ObjectUtils#toString(Object)\n * @see String#valueOf(Object)\n * @param str  the String to check, may be null\n * @return the passed in String, or the empty String if itwas \u003ccode\u003enull\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.defaultString#5117",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.defaultString(java.lang.String, java.lang.String)",
    "snippet": "public static String defaultString(String str, String defaultStr) {\n        return str \u003d\u003d null ? defaultStr : str;\n    }",
    "begin_line": 5117,
    "end_line": 5119,
    "comment": "/** \n * \u003cp\u003eReturns either the passed in String, or if the String is \u003ccode\u003enull\u003c/code\u003e, the value of \u003ccode\u003edefaultStr\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.defaultString(null, \"NULL\")  \u003d \"NULL\" StringUtils.defaultString(\"\", \"NULL\")    \u003d \"\" StringUtils.defaultString(\"bat\", \"NULL\") \u003d \"bat\" \u003c/pre\u003e\n * @see ObjectUtils#toString(Object,String)\n * @see String#valueOf(Object)\n * @param str  the String to check, may be null\n * @param defaultStr  the default String to returnif the input is \u003ccode\u003enull\u003c/code\u003e, may be null\n * @return the passed in String, or the default if it was \u003ccode\u003enull\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.defaultIfEmpty#5138",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.defaultIfEmpty(java.lang.String, java.lang.String)",
    "snippet": "public static String defaultIfEmpty(String str, String defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }",
    "begin_line": 5138,
    "end_line": 5140,
    "comment": "/** \n * \u003cp\u003eReturns either the passed in String, or if the String is empty or \u003ccode\u003enull\u003c/code\u003e, the value of \u003ccode\u003edefaultStr\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.defaultIfEmpty(null, \"NULL\")  \u003d \"NULL\" StringUtils.defaultIfEmpty(\"\", \"NULL\")    \u003d \"NULL\" StringUtils.defaultIfEmpty(\"bat\", \"NULL\") \u003d \"bat\" StringUtils.defaultIfEmpty(\"\", null)      \u003d null \u003c/pre\u003e\n * @see StringUtils#defaultString(String,String)\n * @param str  the String to check, may be null\n * @param defaultStr  the default String to returnif the input is empty (\"\") or \u003ccode\u003enull\u003c/code\u003e, may be null\n * @return the passed in String, or the default\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.reverse#5158",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.reverse(java.lang.String)",
    "snippet": "public static String reverse(String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }",
    "begin_line": 5158,
    "end_line": 5163,
    "comment": "/** \n * \u003cp\u003eReverses a String as per  {@link StringBuilder#reverse()}.\u003c/p\u003e \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.reverse(null)  \u003d null StringUtils.reverse(\"\")    \u003d \"\" StringUtils.reverse(\"bat\") \u003d \"tab\" \u003c/pre\u003e\n * @param str  the String to reverse, may be null\n * @return the reversed String, \u003ccode\u003enull\u003c/code\u003e if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.reverseDelimited#5184",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.reverseDelimited(java.lang.String, char)",
    "snippet": "public static String reverseDelimited(String str, char separatorChar) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        // could implement manually, but simple way is to reuse other,\n        // probably slower, methods.\n        String[] strs \u003d split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }",
    "begin_line": 5184,
    "end_line": 5193,
    "comment": "/** \n * \u003cp\u003eReverses a String that is delimited by a specific character.\u003c/p\u003e \u003cp\u003eThe Strings between the delimiters are not reversed. Thus java.lang.String becomes String.lang.java (if the delimiter is \u003ccode\u003e\u0027.\u0027\u003c/code\u003e).\u003c/p\u003e \u003cpre\u003e StringUtils.reverseDelimited(null, *)      \u003d null StringUtils.reverseDelimited(\"\", *)        \u003d \"\" StringUtils.reverseDelimited(\"a.b.c\", \u0027x\u0027) \u003d \"a.b.c\" StringUtils.reverseDelimited(\"a.b.c\", \".\") \u003d \"c.b.a\" \u003c/pre\u003e\n * @param str  the String to reverse, may be null\n * @param separatorChar  the separator character to use\n * @return the reversed String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.abbreviate#5229",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.abbreviate(java.lang.String, int)",
    "snippet": "public static String abbreviate(String str, int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }",
    "begin_line": 5229,
    "end_line": 5231,
    "comment": "/** \n * \u003cp\u003eAbbreviates a String using ellipses. This will turn \"Now is the time for all good men\" into \"Now is the time for...\"\u003c/p\u003e \u003cp\u003eSpecifically: \u003cul\u003e \u003cli\u003eIf \u003ccode\u003estr\u003c/code\u003e is less than \u003ccode\u003emaxWidth\u003c/code\u003e characters long, return it.\u003c/li\u003e \u003cli\u003eElse abbreviate it to \u003ccode\u003e(substring(str, 0, max-3) + \"...\")\u003c/code\u003e.\u003c/li\u003e \u003cli\u003eIf \u003ccode\u003emaxWidth\u003c/code\u003e is less than \u003ccode\u003e4\u003c/code\u003e, throw an \u003ccode\u003eIllegalArgumentException\u003c/code\u003e.\u003c/li\u003e \u003cli\u003eIn no case will it return a String of length greater than \u003ccode\u003emaxWidth\u003c/code\u003e.\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e \u003cpre\u003e StringUtils.abbreviate(null, *)      \u003d null StringUtils.abbreviate(\"\", 4)        \u003d \"\" StringUtils.abbreviate(\"abcdefg\", 6) \u003d \"abc...\" StringUtils.abbreviate(\"abcdefg\", 7) \u003d \"abcdefg\" StringUtils.abbreviate(\"abcdefg\", 8) \u003d \"abcdefg\" StringUtils.abbreviate(\"abcdefg\", 4) \u003d \"a...\" StringUtils.abbreviate(\"abcdefg\", 3) \u003d IllegalArgumentException \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param maxWidth  maximum length of result String, must be at least 4\n * @return abbreviated String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @throws IllegalArgumentException if the width is too small\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.abbreviate#5268",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.abbreviate(java.lang.String, int, int)",
    "snippet": "public static String abbreviate(String str, int offset, int maxWidth) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (maxWidth \u003c 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() \u003c\u003d maxWidth) {\n            return str;\n        }\n        if (offset \u003e str.length()) {\n            offset \u003d str.length();\n        }\n        if ((str.length() - offset) \u003c (maxWidth - 3)) {\n            offset \u003d str.length() - (maxWidth - 3);\n        }\n        if (offset \u003c\u003d 4) {\n            return str.substring(0, maxWidth - 3) + \"...\";\n        }\n        if (maxWidth \u003c 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if ((offset + (maxWidth - 3)) \u003c str.length()) {\n            return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }",
    "begin_line": 5268,
    "end_line": 5294,
    "comment": "/** \n * \u003cp\u003eAbbreviates a String using ellipses. This will turn \"Now is the time for all good men\" into \"...is the time for...\"\u003c/p\u003e \u003cp\u003eWorks like \u003ccode\u003eabbreviate(String, int)\u003c/code\u003e, but allows you to specify a \"left edge\" offset.  Note that this left edge is not necessarily going to be the leftmost character in the result, or the first character following the ellipses, but it will appear somewhere in the result. \u003cp\u003eIn no case will it return a String of length greater than \u003ccode\u003emaxWidth\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.abbreviate(null, *, *)                \u003d null StringUtils.abbreviate(\"\", 0, 4)                  \u003d \"\" StringUtils.abbreviate(\"abcdefghijklmno\", -1, 10) \u003d \"abcdefg...\" StringUtils.abbreviate(\"abcdefghijklmno\", 0, 10)  \u003d \"abcdefg...\" StringUtils.abbreviate(\"abcdefghijklmno\", 1, 10)  \u003d \"abcdefg...\" StringUtils.abbreviate(\"abcdefghijklmno\", 4, 10)  \u003d \"abcdefg...\" StringUtils.abbreviate(\"abcdefghijklmno\", 5, 10)  \u003d \"...fghi...\" StringUtils.abbreviate(\"abcdefghijklmno\", 6, 10)  \u003d \"...ghij...\" StringUtils.abbreviate(\"abcdefghijklmno\", 8, 10)  \u003d \"...ijklmno\" StringUtils.abbreviate(\"abcdefghijklmno\", 10, 10) \u003d \"...ijklmno\" StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10) \u003d \"...ijklmno\" StringUtils.abbreviate(\"abcdefghij\", 0, 3)        \u003d IllegalArgumentException StringUtils.abbreviate(\"abcdefghij\", 5, 6)        \u003d IllegalArgumentException \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param offset  left edge of source String\n * @param maxWidth  maximum length of result String, must be at least 4\n * @return abbreviated String, \u003ccode\u003enull\u003c/code\u003e if null String input\n * @throws IllegalArgumentException if the width is too small\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.difference#5323",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.difference(java.lang.String, java.lang.String)",
    "snippet": "public static String difference(String str1, String str2) {\n        if (str1 \u003d\u003d null) {\n            return str2;\n        }\n        if (str2 \u003d\u003d null) {\n            return str1;\n        }\n        int at \u003d indexOfDifference(str1, str2);\n        if (at \u003d\u003d -1) {\n            return EMPTY;\n        }\n        return str2.substring(at);\n    }",
    "begin_line": 5323,
    "end_line": 5335,
    "comment": "/** \n * \u003cp\u003eCompares two Strings, and returns the portion where they differ. (More precisely, return the remainder of the second String, starting from where it\u0027s different from the first.)\u003c/p\u003e \u003cp\u003eFor example, \u003ccode\u003edifference(\"i am a machine\", \"i am a robot\") -\u003e \"robot\"\u003c/code\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.difference(null, null) \u003d null StringUtils.difference(\"\", \"\") \u003d \"\" StringUtils.difference(\"\", \"abc\") \u003d \"abc\" StringUtils.difference(\"abc\", \"\") \u003d \"\" StringUtils.difference(\"abc\", \"abc\") \u003d \"\" StringUtils.difference(\"ab\", \"abxyz\") \u003d \"xyz\" StringUtils.difference(\"abcde\", \"abxyz\") \u003d \"xyz\" StringUtils.difference(\"abcde\", \"xyz\") \u003d \"xyz\" \u003c/pre\u003e\n * @param str1  the first String, may be null\n * @param str2  the second String, may be null\n * @return the portion of str2 where it differs from str1; returns theempty String if they are equal\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfDifference#5360",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfDifference(java.lang.String, java.lang.String)",
    "snippet": "public static int indexOfDifference(String str1, String str2) {\n        if (str1 \u003d\u003d str2) {\n            return -1;\n        }\n        if (str1 \u003d\u003d null || str2 \u003d\u003d null) {\n            return 0;\n        }\n        int i;\n        for (i \u003d 0; i \u003c str1.length() \u0026\u0026 i \u003c str2.length(); ++i) {\n            if (str1.charAt(i) !\u003d str2.charAt(i)) {\n                break;\n            }\n        }\n        if (i \u003c str2.length() || i \u003c str1.length()) {\n            return i;\n        }\n        return -1;\n    }",
    "begin_line": 5360,
    "end_line": 5377,
    "comment": "/** \n * \u003cp\u003eCompares two Strings, and returns the index at which the Strings begin to differ.\u003c/p\u003e \u003cp\u003eFor example, \u003ccode\u003eindexOfDifference(\"i am a machine\", \"i am a robot\") -\u003e 7\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfDifference(null, null) \u003d -1 StringUtils.indexOfDifference(\"\", \"\") \u003d -1 StringUtils.indexOfDifference(\"\", \"abc\") \u003d 0 StringUtils.indexOfDifference(\"abc\", \"\") \u003d 0 StringUtils.indexOfDifference(\"abc\", \"abc\") \u003d -1 StringUtils.indexOfDifference(\"ab\", \"abxyz\") \u003d 2 StringUtils.indexOfDifference(\"abcde\", \"abxyz\") \u003d 2 StringUtils.indexOfDifference(\"abcde\", \"xyz\") \u003d 0 \u003c/pre\u003e\n * @param str1  the first String, may be null\n * @param str2  the second String, may be null\n * @return the index where str2 and str1 begin to differ; -1 if they are equal\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfDifference#5410",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfDifference(java.lang.String[])",
    "snippet": "public static int indexOfDifference(String[] strs) {\n        if (strs \u003d\u003d null || strs.length \u003c\u003d 1) {\n            return -1;\n        }\n        boolean anyStringNull \u003d false;\n        boolean allStringsNull \u003d true;\n        int arrayLen \u003d strs.length;\n        int shortestStrLen \u003d Integer.MAX_VALUE;\n        int longestStrLen \u003d 0;\n\n        // find the min and max string lengths; this avoids checking to make\n        // sure we are not exceeding the length of the string each time through\n        // the bottom loop.\n        for (int i \u003d 0; i \u003c arrayLen; i++) {\n            if (strs[i] \u003d\u003d null) {\n                anyStringNull \u003d true;\n                shortestStrLen \u003d 0;\n            } else {\n                allStringsNull \u003d false;\n                shortestStrLen \u003d Math.min(strs[i].length(), shortestStrLen);\n                longestStrLen \u003d Math.max(strs[i].length(), longestStrLen);\n            }\n        }\n\n        // handle lists containing all nulls or all empty strings\n        if (allStringsNull || (longestStrLen \u003d\u003d 0 \u0026\u0026 !anyStringNull)) {\n            return -1;\n        }\n\n        // handle lists containing some nulls or some empty strings\n        if (shortestStrLen \u003d\u003d 0) {\n            return 0;\n        }\n\n        // find the position with the first difference across all strings\n        int firstDiff \u003d -1;\n        for (int stringPos \u003d 0; stringPos \u003c shortestStrLen; stringPos++) {\n            char comparisonChar \u003d strs[0].charAt(stringPos);\n            for (int arrayPos \u003d 1; arrayPos \u003c arrayLen; arrayPos++) {\n                if (strs[arrayPos].charAt(stringPos) !\u003d comparisonChar) {\n                    firstDiff \u003d stringPos;\n                    break;\n                }\n            }\n            if (firstDiff !\u003d -1) {\n                break;\n            }\n        }\n\n        if (firstDiff \u003d\u003d -1 \u0026\u0026 shortestStrLen !\u003d longestStrLen) {\n            // we compared all of the characters up to the length of the\n            // shortest string and didn\u0027t find a match, but the string lengths\n            // vary, so return the length of the shortest string.\n            return shortestStrLen;\n        }\n        return firstDiff;\n    }",
    "begin_line": 5410,
    "end_line": 5466,
    "comment": "/** \n * \u003cp\u003eCompares all Strings in an array and returns the index at which the Strings begin to differ.\u003c/p\u003e \u003cp\u003eFor example, \u003ccode\u003eindexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) -\u003e 7\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfDifference(null) \u003d -1 StringUtils.indexOfDifference(new String[] {}) \u003d -1 StringUtils.indexOfDifference(new String[] {\"abc\"}) \u003d -1 StringUtils.indexOfDifference(new String[] {null, null}) \u003d -1 StringUtils.indexOfDifference(new String[] {\"\", \"\"}) \u003d -1 StringUtils.indexOfDifference(new String[] {\"\", null}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"abc\", null, null}) \u003d 0 StringUtils.indexOfDifference(new String[] {null, null, \"abc\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"\", \"abc\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"abc\", \"\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"abc\", \"abc\"}) \u003d -1 StringUtils.indexOfDifference(new String[] {\"abc\", \"a\"}) \u003d 1 StringUtils.indexOfDifference(new String[] {\"ab\", \"abxyz\"}) \u003d 2 StringUtils.indexOfDifference(new String[] {\"abcde\", \"abxyz\"}) \u003d 2 StringUtils.indexOfDifference(new String[] {\"abcde\", \"xyz\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"xyz\", \"abcde\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) \u003d 7 \u003c/pre\u003e\n * @param strs  array of strings, entries may be null\n * @return the index where the strings begin to differ; -1 if they are all equal\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.getCommonPrefix#5501",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.getCommonPrefix(java.lang.String[])",
    "snippet": "public static String getCommonPrefix(String[] strs) {\n        if (strs \u003d\u003d null || strs.length \u003d\u003d 0) {\n            return EMPTY;\n        }\n        int smallestIndexOfDiff \u003d indexOfDifference(strs);\n        if (smallestIndexOfDiff \u003d\u003d -1) {\n            // all strings were identical\n            if (strs[0] \u003d\u003d null) {\n                return EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff \u003d\u003d 0) {\n            // there were no common initial characters\n            return EMPTY;\n        } else {\n            // we found a common initial character sequence\n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }",
    "begin_line": 5501,
    "end_line": 5519,
    "comment": "/** \n * \u003cp\u003eCompares all Strings in an array and returns the initial sequence of  characters that is common to all of them.\u003c/p\u003e \u003cp\u003eFor example, \u003ccode\u003egetCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) -\u003e \"i am a \"\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e StringUtils.getCommonPrefix(null) \u003d \"\" StringUtils.getCommonPrefix(new String[] {}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"abc\"}) \u003d \"abc\" StringUtils.getCommonPrefix(new String[] {null, null}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"\", \"\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"\", null}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"abc\", null, null}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {null, null, \"abc\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"\", \"abc\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"abc\", \"\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"abc\", \"abc\"}) \u003d \"abc\" StringUtils.getCommonPrefix(new String[] {\"abc\", \"a\"}) \u003d \"a\" StringUtils.getCommonPrefix(new String[] {\"ab\", \"abxyz\"}) \u003d \"ab\" StringUtils.getCommonPrefix(new String[] {\"abcde\", \"abxyz\"}) \u003d \"ab\" StringUtils.getCommonPrefix(new String[] {\"abcde\", \"xyz\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"xyz\", \"abcde\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) \u003d \"i am a \" \u003c/pre\u003e\n * @param strs  array of String objects, entries may be null\n * @return the initial sequence of characters that are common to all Stringsin the array; empty String if the array is null, the elements are all null  or if there is no common prefix. \n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.getLevenshteinDistance#5557",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.getLevenshteinDistance(java.lang.String, java.lang.String)",
    "snippet": "public static int getLevenshteinDistance(String s, String t) {\n        if (s \u003d\u003d null || t \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        /*\n           The difference between this impl. and the previous is that, rather \n           than creating and retaining a matrix of size s.length()+1 by t.length()+1, \n           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n           is the \u0027current working\u0027 distance array that maintains the newest distance cost\n           counts as we iterate through the characters of String s.  Each time we increment\n           the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n           allows us to retain the previous cost counts as required by the algorithm (taking \n           the minimum of the cost count to the left, up one, and diagonally up and to the left\n           of the current cost count being calculated).  (Note that the arrays aren\u0027t really \n           copied anymore, just switched...this is clearly much better than cloning an array \n           or doing a System.arraycopy() each time  through the outer loop.)\n\n           Effectively, the difference between the two implementations is this one does not \n           cause an out of memory condition when calculating the LD over two very large strings.\n         */\n\n        int n \u003d s.length(); // length of s\n        int m \u003d t.length(); // length of t\n\n        if (n \u003d\u003d 0) {\n            return m;\n        } else if (m \u003d\u003d 0) {\n            return n;\n        }\n\n        if (n \u003e m) {\n            // swap the input strings to consume less memory\n            String tmp \u003d s;\n            s \u003d t;\n            t \u003d tmp;\n            n \u003d m;\n            m \u003d t.length();\n        }\n\n        int p[] \u003d new int[n+1]; //\u0027previous\u0027 cost array, horizontally\n        int d[] \u003d new int[n+1]; // cost array, horizontally\n        int _d[]; //placeholder to assist in swapping p and d\n\n        // indexes into strings s and t\n        int i; // iterates through s\n        int j; // iterates through t\n\n        char t_j; // jth character of t\n\n        int cost; // cost\n\n        for (i \u003d 0; i\u003c\u003dn; i++) {\n            p[i] \u003d i;\n        }\n\n        for (j \u003d 1; j\u003c\u003dm; j++) {\n            t_j \u003d t.charAt(j-1);\n            d[0] \u003d j;\n\n            for (i\u003d1; i\u003c\u003dn; i++) {\n                cost \u003d s.charAt(i-1)\u003d\u003dt_j ? 0 : 1;\n                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n                d[i] \u003d Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);\n            }\n\n            // copy current distance counts to \u0027previous row\u0027 distance counts\n            _d \u003d p;\n            p \u003d d;\n            d \u003d _d;\n        }\n\n        // our last action in the above loop was to switch d and p, so p now \n        // actually has the most recent cost counts\n        return p[n];\n    }",
    "begin_line": 5557,
    "end_line": 5632,
    "comment": "/** \n * \u003cp\u003eFind the Levenshtein distance between two Strings.\u003c/p\u003e \u003cp\u003eThis is the number of changes needed to change one String into another, where each change is a single character modification (deletion, insertion or substitution).\u003c/p\u003e \u003cp\u003eThe previous implementation of the Levenshtein distance algorithm was from \u003ca href\u003d\"http://www.merriampark.com/ld.htm\"\u003ehttp://www.merriampark.com/ld.htm\u003c/a\u003e\u003c/p\u003e \u003cp\u003eChas Emerick has written an implementation in Java, which avoids an OutOfMemoryError which can occur when my Java implementation is used with very large strings.\u003cbr\u003e This implementation of the Levenshtein distance algorithm is from \u003ca href\u003d\"http://www.merriampark.com/ldjava.htm\"\u003ehttp://www.merriampark.com/ldjava.htm\u003c/a\u003e\u003c/p\u003e \u003cpre\u003e StringUtils.getLevenshteinDistance(null, *)             \u003d IllegalArgumentException StringUtils.getLevenshteinDistance(*, null)             \u003d IllegalArgumentException StringUtils.getLevenshteinDistance(\"\",\"\")               \u003d 0 StringUtils.getLevenshteinDistance(\"\",\"a\")              \u003d 1 StringUtils.getLevenshteinDistance(\"aaapppp\", \"\")       \u003d 7 StringUtils.getLevenshteinDistance(\"frog\", \"fog\")       \u003d 1 StringUtils.getLevenshteinDistance(\"fly\", \"ant\")        \u003d 3 StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") \u003d 7 StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") \u003d 7 StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") \u003d 8 StringUtils.getLevenshteinDistance(\"hello\", \"hallo\")    \u003d 1 \u003c/pre\u003e\n * @param s  the first String, must not be null\n * @param t  the second String, must not be null\n * @return result distance\n * @throws IllegalArgumentException if either String input \u003ccode\u003enull\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.startsWith#5679",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.startsWith(java.lang.String, java.lang.String)",
    "snippet": "public static boolean startsWith(String str, String prefix) {\n        return startsWith(str, prefix, false);\n    }",
    "begin_line": 5679,
    "end_line": 5681,
    "comment": "/** \n * \u003cp\u003eCheck if a String starts with a specified prefix.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003es are handled without exceptions. Two \u003ccode\u003enull\u003c/code\u003e references are considered to be equal. The comparison is case sensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.startsWith(null, null)      \u003d true StringUtils.startsWith(null, \"abc\")     \u003d false StringUtils.startsWith(\"abcdef\", null)  \u003d false StringUtils.startsWith(\"abcdef\", \"abc\") \u003d true StringUtils.startsWith(\"ABCDEF\", \"abc\") \u003d false \u003c/pre\u003e\n * @see java.lang.String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String starts with the prefix, case sensitive, orboth \u003ccode\u003enull\u003c/code\u003e\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.startsWithIgnoreCase#5704",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.startsWithIgnoreCase(java.lang.String, java.lang.String)",
    "snippet": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return startsWith(str, prefix, true);\n    }",
    "begin_line": 5704,
    "end_line": 5706,
    "comment": "/** \n * \u003cp\u003eCase insensitive check if a String starts with a specified prefix.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003es are handled without exceptions. Two \u003ccode\u003enull\u003c/code\u003e references are considered to be equal. The comparison is case insensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.startsWithIgnoreCase(null, null)      \u003d true StringUtils.startsWithIgnoreCase(null, \"abc\")     \u003d false StringUtils.startsWithIgnoreCase(\"abcdef\", null)  \u003d false StringUtils.startsWithIgnoreCase(\"abcdef\", \"abc\") \u003d true StringUtils.startsWithIgnoreCase(\"ABCDEF\", \"abc\") \u003d true \u003c/pre\u003e\n * @see java.lang.String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String starts with the prefix, case insensitive, orboth \u003ccode\u003enull\u003c/code\u003e\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.startsWith#5719",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.startsWith(java.lang.String, java.lang.String, boolean)",
    "snippet": "private static boolean startsWith(String str, String prefix, boolean ignoreCase) {\n        if (str \u003d\u003d null || prefix \u003d\u003d null) {\n            return (str \u003d\u003d null \u0026\u0026 prefix \u003d\u003d null);\n        }\n        if (prefix.length() \u003e str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }",
    "begin_line": 5719,
    "end_line": 5727,
    "comment": "/** \n * \u003cp\u003eCheck if a String starts with a specified prefix (optionally case insensitive).\u003c/p\u003e\n * @see java.lang.String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String starts with the prefix orboth \u003ccode\u003enull\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.startsWithAny#5747",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.startsWithAny(java.lang.String, java.lang.String[])",
    "snippet": "public static boolean startsWithAny(String string, String[] searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c searchStrings.length; i++) {\n            String searchString \u003d searchStrings[i];\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "begin_line": 5747,
    "end_line": 5758,
    "comment": "/** \n * \u003cp\u003eCheck if a String starts with any of an array of specified strings.\u003c/p\u003e \u003cpre\u003e StringUtils.startsWithAny(null, null)      \u003d false StringUtils.startsWithAny(null, new String[] {\"abc\"})  \u003d false StringUtils.startsWithAny(\"abcxyz\", null)     \u003d false StringUtils.startsWithAny(\"abcxyz\", new String[] {\"\"}) \u003d false StringUtils.startsWithAny(\"abcxyz\", new String[] {\"abc\"}) \u003d true StringUtils.startsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) \u003d true \u003c/pre\u003e\n * @param string  the String to check, may be null\n * @param searchStrings the Strings to find, may be null or empty\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String starts with any of the the prefixes, case insensitive, orboth \u003ccode\u003enull\u003c/code\u003e\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.endsWith#5785",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.endsWith(java.lang.String, java.lang.String)",
    "snippet": "public static boolean endsWith(String str, String suffix) {\n        return endsWith(str, suffix, false);\n    }",
    "begin_line": 5785,
    "end_line": 5787,
    "comment": "/** \n * \u003cp\u003eCheck if a String ends with a specified suffix.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003es are handled without exceptions. Two \u003ccode\u003enull\u003c/code\u003e references are considered to be equal. The comparison is case sensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.endsWith(null, null)      \u003d true StringUtils.endsWith(null, \"def\")     \u003d false StringUtils.endsWith(\"abcdef\", null)  \u003d false StringUtils.endsWith(\"abcdef\", \"def\") \u003d true StringUtils.endsWith(\"ABCDEF\", \"def\") \u003d false StringUtils.endsWith(\"ABCDEF\", \"cde\") \u003d false \u003c/pre\u003e\n * @see java.lang.String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String ends with the suffix, case sensitive, orboth \u003ccode\u003enull\u003c/code\u003e\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.endsWithIgnoreCase#5811",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.endsWithIgnoreCase(java.lang.String, java.lang.String)",
    "snippet": "public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return endsWith(str, suffix, true);\n    }",
    "begin_line": 5811,
    "end_line": 5813,
    "comment": "/** \n * \u003cp\u003eCase insensitive check if a String ends with a specified suffix.\u003c/p\u003e \u003cp\u003e\u003ccode\u003enull\u003c/code\u003es are handled without exceptions. Two \u003ccode\u003enull\u003c/code\u003e references are considered to be equal. The comparison is case insensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.endsWithIgnoreCase(null, null)      \u003d true StringUtils.endsWithIgnoreCase(null, \"def\")     \u003d false StringUtils.endsWithIgnoreCase(\"abcdef\", null)  \u003d false StringUtils.endsWithIgnoreCase(\"abcdef\", \"def\") \u003d true StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"def\") \u003d true StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"cde\") \u003d false \u003c/pre\u003e\n * @see java.lang.String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String ends with the suffix, case insensitive, orboth \u003ccode\u003enull\u003c/code\u003e\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.endsWith#5826",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.endsWith(java.lang.String, java.lang.String, boolean)",
    "snippet": "private static boolean endsWith(String str, String suffix, boolean ignoreCase) {\n        if (str \u003d\u003d null || suffix \u003d\u003d null) {\n            return (str \u003d\u003d null \u0026\u0026 suffix \u003d\u003d null);\n        }\n        if (suffix.length() \u003e str.length()) {\n            return false;\n        }\n        int strOffset \u003d str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }",
    "begin_line": 5826,
    "end_line": 5835,
    "comment": "/** \n * \u003cp\u003eCheck if a String ends with a specified suffix (optionally case insensitive).\u003c/p\u003e\n * @see java.lang.String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return \u003ccode\u003etrue\u003c/code\u003e if the String starts with the prefix orboth \u003ccode\u003enull\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]