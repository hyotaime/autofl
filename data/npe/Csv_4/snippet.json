[
  {
    "name": "Assertions.Assertions#27",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Assertions.java",
    "class_name": "org.apache.commons.csv.Assertions",
    "signature": "org.apache.commons.csv.Assertions.Assertions()",
    "snippet": "private Assertions() {\n        // can not be instantiated\n    }",
    "begin_line": 27,
    "end_line": 29,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Assertions.notNull#31",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Assertions.java",
    "class_name": "org.apache.commons.csv.Assertions",
    "signature": "org.apache.commons.csv.Assertions.notNull(java.lang.Object, java.lang.String)",
    "snippet": "public static void notNull(Object parameter, String parameterName) {\n        if (parameter \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Parameter \u0027\" + parameterName + \"\u0027 must not be null!\");\n        }\n    }",
    "begin_line": 31,
    "end_line": 35,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.isLineBreak#237",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.isLineBreak(char)",
    "snippet": "private static boolean isLineBreak(final char c) {\n        return c \u003d\u003d LF || c \u003d\u003d CR;\n    }",
    "begin_line": 237,
    "end_line": 239,
    "comment": "/** \n * Returns true if the given character is a line break character.\n * @param c the character to check\n * @return true if \u003ccode\u003ec\u003c/code\u003e is a line break character\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.isLineBreak#249",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.isLineBreak(java.lang.Character)",
    "snippet": "private static boolean isLineBreak(final Character c) {\n        return c !\u003d null \u0026\u0026 isLineBreak(c.charValue());\n    }",
    "begin_line": 249,
    "end_line": 251,
    "comment": "/** \n * Returns true if the given character is a line break character.\n * @param c the character to check, may be null\n * @return true if \u003ccode\u003ec\u003c/code\u003e is a line break character (and not null)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.newFormat#261",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.newFormat(char)",
    "snippet": "public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false);\n    }",
    "begin_line": 261,
    "end_line": 263,
    "comment": "/** \n * Creates a new CSV format with the specified delimiter.\n * @param delimiter the char used for value separation, must not be a line break character\n * @return a new CSV format.\n * @throws IllegalArgumentException if the delimiter is a line break character\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.CSVFormat#292",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.CSVFormat(char, java.lang.Character, org.apache.commons.csv.Quote, java.lang.Character, java.lang.Character, boolean, boolean, java.lang.String, java.lang.String, java.lang.String[], boolean)",
    "snippet": " CSVFormat(final char delimiter, final Character quoteChar,\n            final Quote quotePolicy, final Character commentStart,\n            final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator,\n            final String nullString, final String[] header, boolean skipHeaderRecord) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter \u003d delimiter;\n        this.quoteChar \u003d quoteChar;\n        this.quotePolicy \u003d quotePolicy;\n        this.commentStart \u003d commentStart;\n        this.escape \u003d escape;\n        this.ignoreSurroundingSpaces \u003d ignoreSurroundingSpaces;\n        this.ignoreEmptyLines \u003d ignoreEmptyLines;\n        this.recordSeparator \u003d recordSeparator;\n        this.nullString \u003d nullString;\n        this.header \u003d header \u003d\u003d null ? null : header.clone();\n        this.skipHeaderRecord \u003d skipHeaderRecord;\n    }",
    "begin_line": 292,
    "end_line": 311,
    "comment": "/** \n * Creates a customized CSV format.\n * @param delimiter the char used for value separation, must not be a line break character\n * @param quoteChar the Character used as value encapsulation marker, may be  {@code null} to disable\n * @param quotePolicy the quote policy\n * @param commentStart the Character used for comment identification, may be  {@code null} to disable\n * @param escape the Character used to escape special characters in values, may be  {@code null} to disable\n * @param ignoreSurroundingSpaces \u003ctt\u003etrue\u003c/tt\u003e when whitespaces enclosing values should be ignored\n * @param ignoreEmptyLines \u003ctt\u003etrue\u003c/tt\u003e when the parser should skip empty lines\n * @param recordSeparator the line separator to use for output\n * @param nullString the line separator to use for output\n * @param header the header\n * @param skipHeaderRecord TODO\n * @throws IllegalArgumentException if the delimiter is a line break character\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.equals#314",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.equals(java.lang.Object)",
    "snippet": "@Override\n    public boolean equals(final Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj \u003d\u003d null) {\n            return false;\n        }\n        if (getClass() !\u003d obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other \u003d (CSVFormat) obj;\n        if (delimiter !\u003d other.delimiter) {\n            return false;\n        }\n        if (quotePolicy !\u003d other.quotePolicy) {\n            return false;\n        }\n        if (quoteChar \u003d\u003d null) {\n            if (other.quoteChar !\u003d null) {\n                return false;\n            }\n        } else if (!quoteChar.equals(other.quoteChar)) {\n            return false;\n        }\n        if (commentStart \u003d\u003d null) {\n            if (other.commentStart !\u003d null) {\n                return false;\n            }\n        } else if (!commentStart.equals(other.commentStart)) {\n            return false;\n        }\n        if (escape \u003d\u003d null) {\n            if (other.escape !\u003d null) {\n                return false;\n            }\n        } else if (!escape.equals(other.escape)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces !\u003d other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines !\u003d other.ignoreEmptyLines) {\n            return false;\n        }\n        if (recordSeparator \u003d\u003d null) {\n            if (other.recordSeparator !\u003d null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }",
    "begin_line": 314,
    "end_line": 370,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.format#379",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.format(java.lang.Object)",
    "snippet": "public String format(final Object... values) {\n        final StringWriter out \u003d new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }",
    "begin_line": 379,
    "end_line": 388,
    "comment": "/** \n * Formats the specified values.\n * @param values the values to format\n * @return the formatted values\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getCommentStart#395",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getCommentStart()",
    "snippet": "public Character getCommentStart() {\n        return commentStart;\n    }",
    "begin_line": 395,
    "end_line": 397,
    "comment": "/** \n * Returns the character marking the start of a line comment.\n * @return the comment start marker, may be {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getDelimiter#404",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getDelimiter()",
    "snippet": "public char getDelimiter() {\n        return delimiter;\n    }",
    "begin_line": 404,
    "end_line": 406,
    "comment": "/** \n * Returns the character delimiting the values (typically \u0027;\u0027, \u0027,\u0027 or \u0027\\t\u0027).\n * @return the delimiter character\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getEscape#413",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getEscape()",
    "snippet": "public Character getEscape() {\n        return escape;\n    }",
    "begin_line": 413,
    "end_line": 415,
    "comment": "/** \n * Returns the escape character.\n * @return the escape character, may be {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getHeader#422",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getHeader()",
    "snippet": "public String[] getHeader() {\n        return header !\u003d null ? header.clone() : null;\n    }",
    "begin_line": 422,
    "end_line": 424,
    "comment": "/** \n * Returns a copy of the header array.\n * @return a copy of the header array\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getIgnoreEmptyLines#432",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getIgnoreEmptyLines()",
    "snippet": "public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }",
    "begin_line": 432,
    "end_line": 434,
    "comment": "/** \n * Specifies whether empty lines between records are ignored when parsing input.\n * @return \u003ctt\u003etrue\u003c/tt\u003e if empty lines between records are ignored, \u003ctt\u003efalse\u003c/tt\u003e if they are turned into emptyrecords.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getIgnoreSurroundingSpaces#442",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getIgnoreSurroundingSpaces()",
    "snippet": "public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }",
    "begin_line": 442,
    "end_line": 444,
    "comment": "/** \n * Specifies whether spaces around values are ignored when parsing input.\n * @return \u003ctt\u003etrue\u003c/tt\u003e if spaces around values are ignored, \u003ctt\u003efalse\u003c/tt\u003e if they are treated as part of thevalue.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getNullString#459",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getNullString()",
    "snippet": "public String getNullString() {\n        return nullString;\n    }",
    "begin_line": 459,
    "end_line": 461,
    "comment": "/** \n * Gets the String to convert to and from  {@code null}. \u003cul\u003e \u003cli\u003e \u003cstrong\u003eReading:\u003c/strong\u003e Converts strings equal to the given  {@code nullString} to {@code null} when readingrecords. \u003c/li\u003e \u003cli\u003e \u003cstrong\u003eWriting:\u003c/strong\u003e Writes  {@code null} as the given {@code nullString} when writing records.\u003c/li\u003e\u003c/ul\u003e\n * @return the String to convert to and from {@code null}. No substitution occurs if  {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getQuoteChar#468",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getQuoteChar()",
    "snippet": "public Character getQuoteChar() {\n        return quoteChar;\n    }",
    "begin_line": 468,
    "end_line": 470,
    "comment": "/** \n * Returns the character used to encapsulate values containing special characters.\n * @return the quoteChar character, may be {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getQuotePolicy#477",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getQuotePolicy()",
    "snippet": "public Quote getQuotePolicy() {\n        return quotePolicy;\n    }",
    "begin_line": 477,
    "end_line": 479,
    "comment": "/** \n * Returns the quote policy output fields.\n * @return the quote policy\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getRecordSeparator#486",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getRecordSeparator()",
    "snippet": "public String getRecordSeparator() {\n        return recordSeparator;\n    }",
    "begin_line": 486,
    "end_line": 488,
    "comment": "/** \n * Returns the line separator delimiting output records.\n * @return the line separator\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.getSkipHeaderRecord#495",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.getSkipHeaderRecord()",
    "snippet": "public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }",
    "begin_line": 495,
    "end_line": 497,
    "comment": "/** \n * Returns whether to skip the header record.\n * @return whether to skip the header record.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.hashCode#500",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.hashCode()",
    "snippet": "@Override\n    public int hashCode()\n    {\n        final int prime \u003d 31;\n        int result \u003d 1;\n\n        result \u003d prime * result + delimiter;\n        result \u003d prime * result + ((quotePolicy \u003d\u003d null) ? 0 : quotePolicy.hashCode());\n        result \u003d prime * result + ((quoteChar \u003d\u003d null) ? 0 : quoteChar.hashCode());\n        result \u003d prime * result + ((commentStart \u003d\u003d null) ? 0 : commentStart.hashCode());\n        result \u003d prime * result + ((escape \u003d\u003d null) ? 0 : escape.hashCode());\n        result \u003d prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result \u003d prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result \u003d prime * result + ((recordSeparator \u003d\u003d null) ? 0 : recordSeparator.hashCode());\n        result \u003d prime * result + Arrays.hashCode(header);\n        return result;\n    }",
    "begin_line": 500,
    "end_line": 515,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.isCommentingEnabled#524",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.isCommentingEnabled()",
    "snippet": "public boolean isCommentingEnabled() {\n        return commentStart !\u003d null;\n    }",
    "begin_line": 524,
    "end_line": 526,
    "comment": "/** \n * Specifies whether comments are supported by this format. Note that the comment introducer character is only recognized at the start of a line.\n * @return \u003ctt\u003etrue\u003c/tt\u003e is comments are supported, \u003ctt\u003efalse\u003c/tt\u003e otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.isEscaping#533",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.isEscaping()",
    "snippet": "public boolean isEscaping() {\n        return escape !\u003d null;\n    }",
    "begin_line": 533,
    "end_line": 535,
    "comment": "/** \n * Returns whether escape are being processed.\n * @return {@code true} if escapes are processed\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.isNullHandling#542",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.isNullHandling()",
    "snippet": "public boolean isNullHandling() {\n        return nullString !\u003d null;\n    }",
    "begin_line": 542,
    "end_line": 544,
    "comment": "/** \n * Returns whether a nullString has been defined.\n * @return {@code true} if a nullString is defined\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.isQuoting#551",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.isQuoting()",
    "snippet": "public boolean isQuoting() {\n        return quoteChar !\u003d null;\n    }",
    "begin_line": 551,
    "end_line": 553,
    "comment": "/** \n * Returns whether a quoteChar has been defined.\n * @return {@code true} if a quoteChar is defined\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.parse#568",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.parse(java.io.Reader)",
    "snippet": "public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }",
    "begin_line": 568,
    "end_line": 570,
    "comment": "/** \n * Parses the specified content. \u003cp\u003e See also the various static parse methods on  {@link CSVParser}. \u003c/p\u003e\n * @param in the input stream\n * @return a parser over a stream of {@link CSVRecord}s.\n * @throws IOException If an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.toString#573",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.toString()",
    "snippet": "@Override\n    public String toString() {\n        final StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"Delimiter\u003d\u003c\").append(delimiter).append(\u0027\u003e\u0027);\n        if (isEscaping()) {\n            sb.append(\u0027 \u0027);\n            sb.append(\"Escape\u003d\u003c\").append(escape).append(\u0027\u003e\u0027);\n        }\n        if (isQuoting()) {\n            sb.append(\u0027 \u0027);\n            sb.append(\"QuoteChar\u003d\u003c\").append(quoteChar).append(\u0027\u003e\u0027);\n        }\n        if (isCommentingEnabled()) {\n            sb.append(\u0027 \u0027);\n            sb.append(\"CommentStart\u003d\u003c\").append(commentStart).append(\u0027\u003e\u0027);\n        }\n        if (isNullHandling()) {\n            sb.append(\u0027 \u0027);\n            sb.append(\"NullString\u003d\u003c\").append(nullString).append(\u0027\u003e\u0027);\n        }\n        if(recordSeparator !\u003d null) {\n            sb.append(\u0027 \u0027);\n            sb.append(\"RecordSeparator\u003d\u003c\").append(recordSeparator).append(\u0027\u003e\u0027);\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header !\u003d null) {\n            sb.append(\u0027 \u0027);\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }",
    "begin_line": 573,
    "end_line": 608,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.validate#615",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.validate()",
    "snippet": "void validate() throws IllegalStateException {\n        if (quoteChar !\u003d null \u0026\u0026 delimiter \u003d\u003d quoteChar.charValue()) {\n            throw new IllegalStateException(\n                    \"The quoteChar character and the delimiter cannot be the same (\u0027\" + quoteChar + \"\u0027)\");\n        }\n\n        if (escape !\u003d null \u0026\u0026 delimiter \u003d\u003d escape.charValue()) {\n            throw new IllegalStateException(\n                    \"The escape character and the delimiter cannot be the same (\u0027\" + escape + \"\u0027)\");\n        }\n\n        if (commentStart !\u003d null \u0026\u0026 delimiter \u003d\u003d commentStart.charValue()) {\n            throw new IllegalStateException(\n                    \"The comment start character and the delimiter cannot be the same (\u0027\" + commentStart + \"\u0027)\");\n        }\n\n        if (quoteChar !\u003d null \u0026\u0026 quoteChar.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start character and the quoteChar cannot be the same (\u0027\" + commentStart + \"\u0027)\");\n        }\n\n        if (escape !\u003d null \u0026\u0026 escape.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start and the escape character cannot be the same (\u0027\" + commentStart + \"\u0027)\");\n        }\n\n        if (escape \u003d\u003d null \u0026\u0026 quotePolicy \u003d\u003d Quote.NONE) {\n            throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n        }\n\n        if (header !\u003d null) {\n            final Set\u003cString\u003e set \u003d new HashSet\u003cString\u003e(header.length);\n            set.addAll(Arrays.asList(header));\n            if (set.size() !\u003d header.length) {\n                throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n            }\n        }\n    }",
    "begin_line": 615,
    "end_line": 652,
    "comment": "/** \n * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n * @throws IllegalStateException\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withCommentStart#665",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withCommentStart(char)",
    "snippet": "public CSVFormat withCommentStart(final char commentStart) {\n        return withCommentStart(Character.valueOf(commentStart));\n    }",
    "begin_line": 665,
    "end_line": 667,
    "comment": "/** \n * Sets the comment start marker of the format to the specified character. Note that the comment start character is only recognized at the start of a line.\n * @param commentStart the comment start marker\n * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n * @throws IllegalArgumentException thrown if the specified character is a line break\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withCommentStart#680",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withCommentStart(java.lang.Character)",
    "snippet": "public CSVFormat withCommentStart(final Character commentStart) {\n        if (isLineBreak(commentStart)) {\n            throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 680,
    "end_line": 686,
    "comment": "/** \n * Sets the comment start marker of the format to the specified character. Note that the comment start character is only recognized at the start of a line.\n * @param commentStart the comment start marker, use  {@code null} to disable\n * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n * @throws IllegalArgumentException thrown if the specified character is a line break\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withDelimiter#697",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withDelimiter(char)",
    "snippet": "public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 697,
    "end_line": 703,
    "comment": "/** \n * Sets the delimiter of the format to the specified character.\n * @param delimiter the delimiter character\n * @return A new CSVFormat that is equal to this with the specified character as delimiter\n * @throws IllegalArgumentException thrown if the specified character is a line break\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withEscape#714",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withEscape(char)",
    "snippet": "public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }",
    "begin_line": 714,
    "end_line": 716,
    "comment": "/** \n * Sets the escape character of the format to the specified character.\n * @param escape the escape character\n * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n * @throws IllegalArgumentException thrown if the specified character is a line break\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withEscape#727",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withEscape(java.lang.Character)",
    "snippet": "public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 727,
    "end_line": 733,
    "comment": "/** \n * Sets the escape character of the format to the specified character.\n * @param escape the escape character, use  {@code null} to disable\n * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n * @throws IllegalArgumentException thrown if the specified character is a line break\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withHeader#752",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withHeader(java.lang.String)",
    "snippet": "public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 752,
    "end_line": 755,
    "comment": "/** \n * Sets the header of the format. The header can either be parsed automatically from the input file with: \u003cpre\u003e CSVFormat format \u003d aformat.withHeader();\u003c/pre\u003e or specified manually with: \u003cpre\u003e CSVFormat format \u003d aformat.withHeader(\u0026quot;name\u0026quot;, \u0026quot;email\u0026quot;, \u0026quot;phone\u0026quot;);\u003c/pre\u003e\n * @param header the header, \u003ctt\u003enull\u003c/tt\u003e if disabled, empty if parsed automatically, user specified otherwise.\n * @return A new CSVFormat that is equal to this but with the specified header\n * @see #withSkipHeaderRecord(boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withIgnoreEmptyLines#765",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withIgnoreEmptyLines(boolean)",
    "snippet": "public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 765,
    "end_line": 768,
    "comment": "/** \n * Sets the empty line skipping behavior of the format.\n * @param ignoreEmptyLines the empty line skipping behavior, \u003ctt\u003etrue\u003c/tt\u003e to ignore the empty lines between the records, \u003ctt\u003efalse\u003c/tt\u003e to translate empty lines to empty records.\n * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withIgnoreSurroundingSpaces#778",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withIgnoreSurroundingSpaces(boolean)",
    "snippet": "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 778,
    "end_line": 781,
    "comment": "/** \n * Sets the trimming behavior of the format.\n * @param ignoreSurroundingSpaces the trimming behavior, \u003ctt\u003etrue\u003c/tt\u003e to remove the surrounding spaces, \u003ctt\u003efalse\u003c/tt\u003e to leave the spaces as is.\n * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withNullString#798",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withNullString(java.lang.String)",
    "snippet": "public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 798,
    "end_line": 801,
    "comment": "/** \n * Performs conversions to and from null for strings on input and output. \u003cul\u003e \u003cli\u003e \u003cstrong\u003eReading:\u003c/strong\u003e Converts strings equal to the given  {@code nullString} to {@code null} when readingrecords.\u003c/li\u003e \u003cli\u003e \u003cstrong\u003eWriting:\u003c/strong\u003e Writes  {@code null} as the given {@code nullString} when writing records.\u003c/li\u003e\u003c/ul\u003e\n * @param nullString the String to convert to and from  {@code null}. No substitution occurs if  {@code null}\n * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withQuoteChar#812",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withQuoteChar(char)",
    "snippet": "public CSVFormat withQuoteChar(final char quoteChar) {\n        return withQuoteChar(Character.valueOf(quoteChar));\n    }",
    "begin_line": 812,
    "end_line": 814,
    "comment": "/** \n * Sets the quoteChar of the format to the specified character.\n * @param quoteChar the quoteChar character\n * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n * @throws IllegalArgumentException thrown if the specified character is a line break\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withQuoteChar#825",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withQuoteChar(java.lang.Character)",
    "snippet": "public CSVFormat withQuoteChar(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 825,
    "end_line": 831,
    "comment": "/** \n * Sets the quoteChar of the format to the specified character.\n * @param quoteChar the quoteChar character, use  {@code null} to disable\n * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n * @throws IllegalArgumentException thrown if the specified character is a line break\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withQuotePolicy#841",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withQuotePolicy(org.apache.commons.csv.Quote)",
    "snippet": "public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 841,
    "end_line": 844,
    "comment": "/** \n * Sets the output quote policy of the format to the specified value.\n * @param quotePolicy the quote policy to use for output.\n * @return A new CSVFormat that is equal to this but with the specified quote policy\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withRecordSeparator#854",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withRecordSeparator(char)",
    "snippet": "public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }",
    "begin_line": 854,
    "end_line": 856,
    "comment": "/** \n * Sets the record separator of the format to the specified character.\n * @param recordSeparator the record separator to use for output.\n * @return A new CSVFormat that is equal to this but with the the specified output record separator\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withRecordSeparator#866",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withRecordSeparator(java.lang.String)",
    "snippet": "public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 866,
    "end_line": 869,
    "comment": "/** \n * Sets the record separator of the format to the specified String.\n * @param recordSeparator the record separator to use for output.\n * @return A new CSVFormat that is equal to this but with the the specified output record separator\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVFormat.withSkipHeaderRecord#880",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVFormat.java",
    "class_name": "org.apache.commons.csv.CSVFormat",
    "signature": "org.apache.commons.csv.CSVFormat.withSkipHeaderRecord(boolean)",
    "snippet": "public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
    "begin_line": 880,
    "end_line": 883,
    "comment": "/** \n * Sets whether to skip the header record.\n * @param skipHeaderRecord whether to skip the header record.\n * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n * @see #withHeader(String...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.parse#148",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.parse(java.io.File, org.apache.commons.csv.CSVFormat)",
    "snippet": "public static CSVParser parse(File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }",
    "begin_line": 148,
    "end_line": 153,
    "comment": "/** \n * Creates a parser for the given  {@link File}.\n * @param file a CSV file. Must not be null.\n * @param format the CSVFormat used for CSV parsing. Must not be null.\n * @return a new parser\n * @throws IllegalArgumentException If the parameters of the format are inconsistent or if either file or format are null.\n * @throws IOException If an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.parse#168",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.parse(java.lang.String, org.apache.commons.csv.CSVFormat)",
    "snippet": "public static CSVParser parse(String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }",
    "begin_line": 168,
    "end_line": 173,
    "comment": "/** \n * Creates a parser for the given  {@link String}.\n * @param string a CSV string. Must not be null.\n * @param format the CSVFormat used for CSV parsing. Must not be null.\n * @return a new parser\n * @throws IllegalArgumentException If the parameters of the format are inconsistent or if either string or format are null.\n * @throws IOException If an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.parse#195",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.parse(java.net.URL, java.nio.charset.Charset, org.apache.commons.csv.CSVFormat)",
    "snippet": "public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(),\n                             charset \u003d\u003d null ? Charset.forName(\"UTF-8\") : charset), format);\n    }",
    "begin_line": 195,
    "end_line": 202,
    "comment": "/** \n * Creates a parser for the given URL. \u003cp\u003e If you do not read all records from the given  {@code url}, you should call  {@link #close()} on the parser, unlessyou close the  {@code url}. \u003c/p\u003e\n * @param url a URL. Must not be null.\n * @param charset the charset for the resource. Must not be null.\n * @param format the CSVFormat used for CSV parsing. Must not be null.\n * @return a new parser\n * @throws IllegalArgumentException If the parameters of the format are inconsistent or if either url, charset or format are null.\n * @throws IOException If an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.CSVParser#237",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.CSVParser(java.io.Reader, org.apache.commons.csv.CSVFormat)",
    "snippet": "public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format \u003d format;\n        this.lexer \u003d new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap \u003d this.initializeHeader();\n    }",
    "begin_line": 237,
    "end_line": 245,
    "comment": "/** \n * Customized CSV parser using the given  {@link CSVFormat}\u003cp\u003e If you do not read all records from the given  {@code reader}, you should call  {@link #close()} on the parser,unless you close the  {@code reader}. \u003c/p\u003e\n * @param reader a Reader containing CSV-formatted input. Must not be null.\n * @param format the CSVFormat used for CSV parsing. Must not be null.\n * @throws IllegalArgumentException If the parameters of the format are inconsistent or if either reader or format are null.\n * @throws IOException If an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.addRecordValue#247",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.addRecordValue()",
    "snippet": "private void addRecordValue() {\n        final String input \u003d this.reusableToken.content.toString();\n        final String nullString \u003d this.format.getNullString();\n        if (nullString \u003d\u003d null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }",
    "begin_line": 247,
    "end_line": 255,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.close#263",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.close()",
    "snippet": "public void close() throws IOException {\n        if (this.lexer !\u003d null) {\n            this.lexer.close();\n        }\n    }",
    "begin_line": 263,
    "end_line": 267,
    "comment": "/** \n * Closes resources.\n * @throws IOException If an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.getCurrentLineNumber#276",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.getCurrentLineNumber()",
    "snippet": "public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }",
    "begin_line": 276,
    "end_line": 278,
    "comment": "/** \n * Returns the current line number in the input stream. \u003cp/\u003e ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n * @return current line number\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.getHeaderMap#287",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.getHeaderMap()",
    "snippet": "public Map\u003cString, Integer\u003e getHeaderMap() {\n        return new LinkedHashMap\u003cString, Integer\u003e(this.headerMap);\n    }",
    "begin_line": 287,
    "end_line": 289,
    "comment": "/** \n * Returns a copy of the header map that iterates in column order. \u003cp\u003e The map keys are column names. The map values are 0-based indices. \u003c/p\u003e\n * @return a copy of the header map that iterates in column order.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.getRecordNumber#298",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.getRecordNumber()",
    "snippet": "public long getRecordNumber() {\n        return this.recordNumber;\n    }",
    "begin_line": 298,
    "end_line": 300,
    "comment": "/** \n * Returns the current record number in the input stream. \u003cp/\u003e ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n * @return current line number\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.getRecords#312",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.getRecords()",
    "snippet": "public List\u003cCSVRecord\u003e getRecords() throws IOException {\n        final List\u003cCSVRecord\u003e records \u003d new ArrayList\u003cCSVRecord\u003e();\n        CSVRecord rec;\n        while ((rec \u003d this.nextRecord()) !\u003d null) {\n            records.add(rec);\n        }\n        return records;\n    }",
    "begin_line": 312,
    "end_line": 319,
    "comment": "/** \n * Parses the CSV input according to the given format and returns the content as a list of {@link CSVRecord CSVRecords}. \u003cp/\u003e The returned content starts at the current parse-position in the stream.\n * @return list of {@link CSVRecord CSVRecords}, may be empty\n * @throws IOException on parse error or input read-failure\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.initializeHeader#324",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.initializeHeader()",
    "snippet": "private Map\u003cString, Integer\u003e initializeHeader() throws IOException {\n        Map\u003cString, Integer\u003e hdrMap \u003d null;\n        final String[] formatHeader \u003d this.format.getHeader();\n        if (formatHeader !\u003d null) {\n            hdrMap \u003d new LinkedHashMap\u003cString, Integer\u003e();\n\n            String[] header \u003d null;\n            if (formatHeader.length \u003d\u003d 0) {\n                // read the header from the first line of the file\n                final CSVRecord record \u003d this.nextRecord();\n                if (record !\u003d null) {\n                    header \u003d record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header \u003d formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header !\u003d null) {\n                for (int i \u003d 0; i \u003c header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }",
    "begin_line": 324,
    "end_line": 352,
    "comment": "/** \n * Initializes the name to index mapping if the format defines a header.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.isClosed#354",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.isClosed()",
    "snippet": "public boolean isClosed() {\n        return this.lexer.isClosed();\n    }",
    "begin_line": 354,
    "end_line": 356,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.iterator#366",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.iterator()",
    "snippet": "public Iterator\u003cCSVRecord\u003e iterator() {\n        return new Iterator\u003cCSVRecord\u003e() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current \u003d\u003d null) {\n                    this.current \u003d this.getNextRecord();\n                }\n\n                return this.current !\u003d null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next \u003d this.current;\n                this.current \u003d null;\n\n                if (next \u003d\u003d null) {\n                    // hasNext() wasn\u0027t called before\n                    next \u003d this.getNextRecord();\n                    if (next \u003d\u003d null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
    "begin_line": 366,
    "end_line": 412,
    "comment": "/** \n * Returns an iterator on the records. \u003cp\u003eIOExceptions occurring during the iteration are wrapped in a RuntimeException. If the parser is closed a call to  {@code next()} will throw aNoSuchElementException.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.getNextRecord#370",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.getNextRecord()",
    "snippet": "private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }",
    "begin_line": 370,
    "end_line": 377,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.hasNext#379",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.hasNext()",
    "snippet": "public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current \u003d\u003d null) {\n                    this.current \u003d this.getNextRecord();\n                }\n\n                return this.current !\u003d null;\n            }",
    "begin_line": 379,
    "end_line": 388,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.next#390",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.next()",
    "snippet": "public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next \u003d this.current;\n                this.current \u003d null;\n\n                if (next \u003d\u003d null) {\n                    // hasNext() wasn\u0027t called before\n                    next \u003d this.getNextRecord();\n                    if (next \u003d\u003d null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }",
    "begin_line": 390,
    "end_line": 406,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.remove#408",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.remove()",
    "snippet": "public void remove() {\n                throw new UnsupportedOperationException();\n            }",
    "begin_line": 408,
    "end_line": 410,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CSVParser.nextRecord#421",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/CSVParser.java",
    "class_name": "org.apache.commons.csv.CSVParser",
    "signature": "org.apache.commons.csv.CSVParser.nextRecord()",
    "snippet": "CSVRecord nextRecord() throws IOException {\n        CSVRecord result \u003d null;\n        this.record.clear();\n        StringBuilder sb \u003d null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb \u003d\u003d null) { // first comment for this record\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type \u003d TOKEN; // Read another token\n                break;\n            }\n        } while (this.reusableToken.type \u003d\u003d TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n            result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }",
    "begin_line": 421,
    "end_line": 461,
    "comment": "/** \n * Parses the next record from the current point in the stream.\n * @return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n * @throws IOException on parse error or input read-failure\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExtendedBufferedReader.ExtendedBufferedReader#50",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/ExtendedBufferedReader.java",
    "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
    "signature": "org.apache.commons.csv.ExtendedBufferedReader.ExtendedBufferedReader(java.io.Reader)",
    "snippet": " ExtendedBufferedReader(final Reader reader) {\n        super(reader);\n    }",
    "begin_line": 50,
    "end_line": 52,
    "comment": "/** \n * Created extended buffered reader using default buffer-size\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExtendedBufferedReader.read#55",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/ExtendedBufferedReader.java",
    "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
    "signature": "org.apache.commons.csv.ExtendedBufferedReader.read()",
    "snippet": "@Override\n    public int read() throws IOException {\n        final int current \u003d super.read();\n        if (current \u003d\u003d CR || (current \u003d\u003d LF \u0026\u0026 lastChar !\u003d CR)) {\n            eolCounter++;\n        }\n        lastChar \u003d current;\n        return lastChar;\n    }",
    "begin_line": 55,
    "end_line": 62,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExtendedBufferedReader.getLastChar#72",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/ExtendedBufferedReader.java",
    "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
    "signature": "org.apache.commons.csv.ExtendedBufferedReader.getLastChar()",
    "snippet": "int getLastChar() {\n        return lastChar;\n    }",
    "begin_line": 72,
    "end_line": 74,
    "comment": "/** \n * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by any of the read methods. This will not include a character read using the  {@link #lookAhead()} method. If nocharacter has been read then this will return  {@link Constants#UNDEFINED}. If the end of the stream was reached on the last read then this will return  {@link Constants#END_OF_STREAM}.\n * @return the last character that was read\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExtendedBufferedReader.read#77",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/ExtendedBufferedReader.java",
    "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
    "signature": "org.apache.commons.csv.ExtendedBufferedReader.read(char[], int, int)",
    "snippet": "@Override\n    public int read(final char[] buf, final int offset, final int length) throws IOException {\n        if (length \u003d\u003d 0) {\n            return 0;\n        }\n\n        final int len \u003d super.read(buf, offset, length);\n\n        if (len \u003e 0) {\n\n            for (int i \u003d offset; i \u003c offset + len; i++) {\n                final char ch \u003d buf[i];\n                if (ch \u003d\u003d LF) {\n                    if (CR !\u003d (i \u003e 0 ? buf[i - 1] : lastChar)) {\n                        eolCounter++;\n                    }\n                } else if (ch \u003d\u003d CR) {\n                    eolCounter++;\n                }\n            }\n\n            lastChar \u003d buf[offset + len - 1];\n\n        } else if (len \u003d\u003d -1) {\n            lastChar \u003d END_OF_STREAM;\n        }\n\n        return len;\n    }",
    "begin_line": 77,
    "end_line": 104,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExtendedBufferedReader.readLine#117",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/ExtendedBufferedReader.java",
    "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
    "signature": "org.apache.commons.csv.ExtendedBufferedReader.readLine()",
    "snippet": "@Override\n    public String readLine() throws IOException {\n        final String line \u003d super.readLine();\n\n        if (line !\u003d null) {\n            lastChar \u003d LF; // needed for detecting start of line\n            eolCounter++;\n        } else {\n            lastChar \u003d END_OF_STREAM;\n        }\n\n        return line;\n    }",
    "begin_line": 117,
    "end_line": 128,
    "comment": "/** \n * Calls  {@link BufferedReader#readLine()} which drops the line terminator(s). This method should only be calledwhen processing a comment, otherwise information can be lost. \u003cp\u003e Increments  {@link #eolCounter}\u003cp\u003e Sets  {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise to LF\n * @return the line that was read, or null if reached EOF.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExtendedBufferedReader.lookAhead#139",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/ExtendedBufferedReader.java",
    "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
    "signature": "org.apache.commons.csv.ExtendedBufferedReader.lookAhead()",
    "snippet": "int lookAhead() throws IOException {\n        super.mark(1);\n        final int c \u003d super.read();\n        super.reset();\n\n        return c;\n    }",
    "begin_line": 139,
    "end_line": 145,
    "comment": "/** \n * Returns the next character in the current reader without consuming it. So the next call to  {@link #read()} willstill return this value. Does not affect line number or last character.\n * @return the next character\n * @throws IOException if there is an error in reading\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExtendedBufferedReader.getCurrentLineNumber#152",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/ExtendedBufferedReader.java",
    "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
    "signature": "org.apache.commons.csv.ExtendedBufferedReader.getCurrentLineNumber()",
    "snippet": "long getCurrentLineNumber() {\n        // Check if we are at EOL or EOF or just starting\n        if (lastChar \u003d\u003d CR || lastChar \u003d\u003d LF || lastChar \u003d\u003d UNDEFINED || lastChar \u003d\u003d END_OF_STREAM) {\n            return eolCounter; // counter is accurate\n        }\n        return eolCounter + 1; // Allow for counter being incremented only at EOL\n    }",
    "begin_line": 152,
    "end_line": 158,
    "comment": "/** \n * Returns the current line number\n * @return the current line number\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExtendedBufferedReader.isClosed#160",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/ExtendedBufferedReader.java",
    "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
    "signature": "org.apache.commons.csv.ExtendedBufferedReader.isClosed()",
    "snippet": "public boolean isClosed() {\n        return closed;\n    }",
    "begin_line": 160,
    "end_line": 162,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExtendedBufferedReader.close#171",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/ExtendedBufferedReader.java",
    "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
    "signature": "org.apache.commons.csv.ExtendedBufferedReader.close()",
    "snippet": "@Override\n    public void close() throws IOException {\n        // Set ivars before calling super close() in case close() throws an IOException.\n        closed \u003d true;\n        lastChar \u003d END_OF_STREAM;\n        super.close();\n    }",
    "begin_line": 171,
    "end_line": 176,
    "comment": "/** \n * Closes the stream.\n * @throws IOException If an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.Lexer#61",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.Lexer(org.apache.commons.csv.CSVFormat, org.apache.commons.csv.ExtendedBufferedReader)",
    "snippet": " Lexer(final CSVFormat format, final ExtendedBufferedReader in) {\n        this.in \u003d in;\n        this.delimiter \u003d format.getDelimiter();\n        this.escape \u003d mapNullToDisabled(format.getEscape());\n        this.quoteChar \u003d mapNullToDisabled(format.getQuoteChar());\n        this.commentStart \u003d mapNullToDisabled(format.getCommentStart());\n        this.ignoreSurroundingSpaces \u003d format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines \u003d format.getIgnoreEmptyLines();\n    }",
    "begin_line": 61,
    "end_line": 69,
    "comment": "/** \n * INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.nextToken#82",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.nextToken(org.apache.commons.csv.Token)",
    "snippet": "Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar \u003d in.getLastChar();\n\n        // read the next char and set eol\n        int c \u003d in.read();\n        /*\n         * Note: The following call will swallow LF if c \u003d\u003d CR. But we don\u0027t need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol \u003d readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol \u0026\u0026 isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar \u003d c;\n                c \u003d in.read();\n                eol \u003d readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type \u003d EOF;\n                    // don\u0027t set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) \u0026\u0026 isEndOfFile(c))) {\n            token.type \u003d EOF;\n            // don\u0027t set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) \u0026\u0026 isCommentStart(c)) {\n            final String line \u003d in.readLine();\n            if (line \u003d\u003d null) {\n                token.type \u003d EOF;\n                // don\u0027t set token.isReady here because no content\n                return token;\n            }\n            final String comment \u003d line.trim();\n            token.content.append(comment);\n            token.type \u003d COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type \u003d\u003d INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) \u0026\u0026 !eol) {\n                    c \u003d in.read();\n                    eol \u003d readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type \u003d TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type \u003d EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type \u003d EOF;\n                token.isReady \u003d true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }",
    "begin_line": 82,
    "end_line": 164,
    "comment": "/** \n * Returns the next token. \u003cp/\u003e A token corresponds to a term, a record change or an end-of-file indicator.\n * @param token an existing Token object to reuse. The caller is responsible to initialize the Token.\n * @return the next token found\n * @throws java.io.IOException on stream access error\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.parseSimpleToken#185",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.parseSimpleToken(org.apache.commons.csv.Token, int)",
    "snippet": "private Token parseSimpleToken(final Token token, int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type \u003d\u003d INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type \u003d EORECORD;\n                break;\n            } else if (isEndOfFile(ch)) {\n                token.type \u003d EOF;\n                token.isReady \u003d true; // There is data at EOF\n                break;\n            } else if (isDelimiter(ch)) {\n                token.type \u003d TOKEN;\n                break;\n            } else if (isEscape(ch)) {\n                final int unescaped \u003d readEscape();\n                if (unescaped \u003d\u003d Constants.END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) in.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n                ch \u003d in.read(); // continue\n            } else {\n                token.content.append((char) ch);\n                ch \u003d in.read(); // continue\n            }\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }",
    "begin_line": 185,
    "end_line": 217,
    "comment": "/** \n * Parses a simple token. \u003cp/\u003e Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped delimiters (as \\, or \\;). The token is finished when one of the following conditions become true: \u003cul\u003e \u003cli\u003eend of line has been reached (EORECORD)\u003c/li\u003e \u003cli\u003eend of stream has been reached (EOF)\u003c/li\u003e \u003cli\u003ean unescaped delimiter has been reached (TOKEN)\u003c/li\u003e \u003c/ul\u003e\n * @param token the current token\n * @param ch the current character\n * @return the filled token\n * @throws IOException on stream access error\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.parseEncapsulatedToken#239",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.parseEncapsulatedToken(org.apache.commons.csv.Token)",
    "snippet": "private Token parseEncapsulatedToken(final Token token) throws IOException {\n        // save current line number in case needed for IOE\n        final long startLineNumber \u003d getCurrentLineNumber();\n        int c;\n        while (true) {\n            c \u003d in.read();\n\n            if (isEscape(c)) {\n                final int unescaped \u003d readEscape();\n                if (unescaped \u003d\u003d Constants.END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) c).append((char) in.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else if (isQuoteChar(c)) {\n                if (isQuoteChar(in.lookAhead())) {\n                    // double or escaped encapsulator -\u003e add single encapsulator to token\n                    c \u003d in.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c \u003d in.read();\n                        if (isDelimiter(c)) {\n                            token.type \u003d TOKEN;\n                            return token;\n                        } else if (isEndOfFile(c)) {\n                            token.type \u003d EOF;\n                            token.isReady \u003d true; // There is data at EOF\n                            return token;\n                        } else if (readEndOfLine(c)) {\n                            token.type \u003d EORECORD;\n                            return token;\n                        } else if (!isWhitespace(c)) {\n                            // error invalid char between token and next delimiter\n                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                    \") invalid char between encapsulated token and delimiter\");\n                        }\n                    }\n                }\n            } else if (isEndOfFile(c)) {\n                // error condition (end of file before end of token)\n                throw new IOException(\"(startline \" + startLineNumber +\n                        \") EOF reached before encapsulated token finished\");\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }",
    "begin_line": 239,
    "end_line": 288,
    "comment": "/** \n * Parses an encapsulated token. \u003cp/\u003e Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included in the token using a doubling syntax (as \"\", \u0027\u0027) or using escaping (as in \\\", \\\u0027). Whitespaces before and after an encapsulated token are ignored. The token is finished when one of the following conditions become true: \u003cul\u003e \u003cli\u003ean unescaped encapsulator has been reached, and is followed by optional whitespace then:\u003c/li\u003e \u003cul\u003e \u003cli\u003edelimiter (TOKEN)\u003c/li\u003e \u003cli\u003eend of line (EORECORD)\u003c/li\u003e \u003c/ul\u003e \u003cli\u003eend of stream has been reached (EOF)\u003c/li\u003e \u003c/ul\u003e\n * @param token the current token\n * @return a valid token object\n * @throws IOException on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.mapNullToDisabled#290",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.mapNullToDisabled(java.lang.Character)",
    "snippet": "private char mapNullToDisabled(final Character c) {\n        return c \u003d\u003d null ? DISABLED : c.charValue();\n    }",
    "begin_line": 290,
    "end_line": 292,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.getCurrentLineNumber#299",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.getCurrentLineNumber()",
    "snippet": "long getCurrentLineNumber() {\n        return in.getCurrentLineNumber();\n    }",
    "begin_line": 299,
    "end_line": 301,
    "comment": "/** \n * Returns the current line number\n * @return the current line number\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.readEscape#315",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.readEscape()",
    "snippet": "int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch \u003d in.read();\n        switch (ch) {\n        case \u0027r\u0027:\n            return CR;\n        case \u0027n\u0027:\n            return LF;\n        case \u0027t\u0027:\n            return TAB;\n        case \u0027b\u0027:\n            return BACKSPACE;\n        case \u0027f\u0027:\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return ch;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }",
    "begin_line": 315,
    "end_line": 345,
    "comment": "/** \n * Handle an escape sequence. The current character must be the escape character. On return, the next character is available by calling  {@link ExtendedBufferedReader#getLastChar()}on the input stream.\n * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape isinvalid.\n * @throws IOException if there is a problem reading the stream or the end of stream is detected:the escape character is not allowed at end of strem\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.trimTrailingSpaces#347",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.trimTrailingSpaces(java.lang.StringBuilder)",
    "snippet": "void trimTrailingSpaces(final StringBuilder buffer) {\n        int length \u003d buffer.length();\n        while (length \u003e 0 \u0026\u0026 Character.isWhitespace(buffer.charAt(length - 1))) {\n            length \u003d length - 1;\n        }\n        if (length !\u003d buffer.length()) {\n            buffer.setLength(length);\n        }\n    }",
    "begin_line": 347,
    "end_line": 355,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.readEndOfLine#362",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.readEndOfLine(int)",
    "snippet": "boolean readEndOfLine(int ch) throws IOException {\n        // check if we have \\r\\n...\n        if (ch \u003d\u003d CR \u0026\u0026 in.lookAhead() \u003d\u003d LF) {\n            // note: does not change ch outside of this method!\n            ch \u003d in.read();\n        }\n        return ch \u003d\u003d LF || ch \u003d\u003d CR;\n    }",
    "begin_line": 362,
    "end_line": 369,
    "comment": "/** \n * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n * @return true if the given or next character is a line-terminator\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.isClosed#371",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.isClosed()",
    "snippet": "boolean isClosed() {\n        return in.isClosed();\n    }",
    "begin_line": 371,
    "end_line": 373,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.isWhitespace#378",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.isWhitespace(int)",
    "snippet": "boolean isWhitespace(final int ch) {\n        return !isDelimiter(ch) \u0026\u0026 Character.isWhitespace((char) ch);\n    }",
    "begin_line": 378,
    "end_line": 380,
    "comment": "/** \n * @return true if the given char is a whitespace character\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.isStartOfLine#388",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.isStartOfLine(int)",
    "snippet": "boolean isStartOfLine(final int ch) {\n        return ch \u003d\u003d LF || ch \u003d\u003d CR || ch \u003d\u003d UNDEFINED;\n    }",
    "begin_line": 388,
    "end_line": 390,
    "comment": "/** \n * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.\n * @param ch the character to check\n * @return true if the character is at the start of a line.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.isEndOfFile#395",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.isEndOfFile(int)",
    "snippet": "boolean isEndOfFile(final int ch) {\n        return ch \u003d\u003d END_OF_STREAM;\n    }",
    "begin_line": 395,
    "end_line": 397,
    "comment": "/** \n * @return true if the given character indicates end of file\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.isDelimiter#399",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.isDelimiter(int)",
    "snippet": "boolean isDelimiter(final int ch) {\n        return ch \u003d\u003d delimiter;\n    }",
    "begin_line": 399,
    "end_line": 401,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.isEscape#403",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.isEscape(int)",
    "snippet": "boolean isEscape(final int ch) {\n        return ch \u003d\u003d escape;\n    }",
    "begin_line": 403,
    "end_line": 405,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.isQuoteChar#407",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.isQuoteChar(int)",
    "snippet": "boolean isQuoteChar(final int ch) {\n        return ch \u003d\u003d quoteChar;\n    }",
    "begin_line": 407,
    "end_line": 409,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.isCommentStart#411",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.isCommentStart(int)",
    "snippet": "boolean isCommentStart(final int ch) {\n        return ch \u003d\u003d commentStart;\n    }",
    "begin_line": 411,
    "end_line": 413,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.isMetaChar#415",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.isMetaChar(int)",
    "snippet": "private boolean isMetaChar(final int ch) {\n        return ch \u003d\u003d delimiter ||\n               ch \u003d\u003d escape ||\n               ch \u003d\u003d quoteChar ||\n               ch \u003d\u003d commentStart;\n    }",
    "begin_line": 415,
    "end_line": 420,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Lexer.close#428",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Lexer.java",
    "class_name": "org.apache.commons.csv.Lexer",
    "signature": "org.apache.commons.csv.Lexer.close()",
    "snippet": "void close() throws IOException {\n        in.close();\n    }",
    "begin_line": 428,
    "end_line": 430,
    "comment": "/** \n * Closes resources.\n * @throws IOException If an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Token.reset#60",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Token.java",
    "class_name": "org.apache.commons.csv.Token",
    "signature": "org.apache.commons.csv.Token.reset()",
    "snippet": "void reset() {\n        content.setLength(0);\n        type \u003d INVALID;\n        isReady \u003d false;\n    }",
    "begin_line": 60,
    "end_line": 64,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Token.toString#72",
    "is_bug": true,
    "src_path": "org/apache/commons/csv/Token.java",
    "class_name": "org.apache.commons.csv.Token",
    "signature": "org.apache.commons.csv.Token.toString()",
    "snippet": "@Override\n    public String toString() {\n        return type.name() + \" [\" + content.toString() + \"]\";\n    }",
    "begin_line": 72,
    "end_line": 74,
    "comment": "/** \n * Eases IDE debugging.\n * @return a string helpful for debugging.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]