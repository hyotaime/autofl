[
  {
    "name": "DirectoryWalker.DirectoryWalker#282",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.DirectoryWalker()",
    "snippet": "protected DirectoryWalker() {\n        this(null, -1);\n    }",
    "begin_line": 282,
    "end_line": 284,
    "comment": "/** \n * Construct an instance with no filtering and unlimited \u003ci\u003edepth\u003c/i\u003e.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.DirectoryWalker#299",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.DirectoryWalker(java.io.FileFilter, int)",
    "snippet": "protected DirectoryWalker(final FileFilter filter, final int depthLimit) {\n        this.filter \u003d filter;\n        this.depthLimit \u003d depthLimit;\n    }",
    "begin_line": 299,
    "end_line": 302,
    "comment": "/** \n * Constructs an instance with a filter and limit the \u003ci\u003edepth\u003c/i\u003e navigated to. \u003cp\u003e The filter controls which files and directories will be navigated to as part of the walk. The  {@link FileFilterUtils} class is useful for combiningvarious filters together. A  {@code null} filter means that nofiltering should occur and all files and directories will be visited. \u003c/p\u003e\n * @param filter  the filter to apply, null means visit all files\n * @param depthLimit  controls how \u003ci\u003edeep\u003c/i\u003e the hierarchy isnavigated to (less than 0 means unlimited)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.DirectoryWalker#319",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.DirectoryWalker(org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter, int)",
    "snippet": "protected DirectoryWalker(IOFileFilter directoryFilter, IOFileFilter fileFilter, final int depthLimit) {\n        if (directoryFilter \u003d\u003d null \u0026\u0026 fileFilter \u003d\u003d null) {\n            this.filter \u003d null;\n        } else {\n            directoryFilter \u003d directoryFilter !\u003d null ? directoryFilter : TrueFileFilter.TRUE;\n            fileFilter \u003d fileFilter !\u003d null ? fileFilter : TrueFileFilter.TRUE;\n            directoryFilter \u003d FileFilterUtils.makeDirectoryOnly(directoryFilter);\n            fileFilter \u003d FileFilterUtils.makeFileOnly(fileFilter);\n            this.filter \u003d FileFilterUtils.or(directoryFilter, fileFilter);\n        }\n        this.depthLimit \u003d depthLimit;\n    }",
    "begin_line": 319,
    "end_line": 330,
    "comment": "/** \n * Constructs an instance with a directory and a file filter and an optional limit on the \u003ci\u003edepth\u003c/i\u003e navigated to. \u003cp\u003e The filters control which files and directories will be navigated to as part of the walk. This constructor uses  {@link FileFilterUtils#makeDirectoryOnly(IOFileFilter)}and  {@link FileFilterUtils#makeFileOnly(IOFileFilter)} internally to combine the filters.A  {@code null} filter means that no filtering should occur.\u003c/p\u003e\n * @param directoryFilter  the filter to apply to directories, null means visit all directories\n * @param fileFilter  the filter to apply to files, null means visit all files\n * @param depthLimit  controls how \u003ci\u003edeep\u003c/i\u003e the hierarchy isnavigated to (less than 0 means unlimited)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.walk#350",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.walk(java.io.File, java.util.Collection\u003cT\u003e)",
    "snippet": "protected final void walk(final File startDirectory, final Collection\u003cT\u003e results) throws IOException {\n        if (startDirectory \u003d\u003d null) {\n            throw new NullPointerException(\"Start Directory is null\");\n        }\n        try {\n            handleStart(startDirectory, results);\n            walk(startDirectory, 0, results);\n            handleEnd(results);\n        } catch(final CancelException cancel) {\n            handleCancelled(startDirectory, results, cancel);\n        }\n    }",
    "begin_line": 350,
    "end_line": 361,
    "comment": "/** \n * Internal method that walks the directory hierarchy in a depth-first manner. \u003cp\u003e Users of this class do not need to call this method. This method will be called automatically by another (public) method on the specific subclass. \u003c/p\u003e \u003cp\u003e Writers of subclasses should call this method to start the directory walk. Once called, this method will emit events as it walks the hierarchy. The event methods have the prefix \u003ccode\u003ehandle\u003c/code\u003e. \u003c/p\u003e\n * @param startDirectory  the directory to start from, not null\n * @param results  the collection of result objects, may be updated\n * @throws NullPointerException if the start directory is null\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.walk#371",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.walk(java.io.File, int, java.util.Collection\u003cT\u003e)",
    "snippet": "private void walk(final File directory, final int depth, final Collection\u003cT\u003e results) throws IOException {\n        checkIfCancelled(directory, depth, results);\n        if (handleDirectory(directory, depth, results)) {\n            handleDirectoryStart(directory, depth, results);\n            final int childDepth \u003d depth + 1;\n            if (depthLimit \u003c 0 || childDepth \u003c\u003d depthLimit) {\n                checkIfCancelled(directory, depth, results);\n                File[] childFiles \u003d filter \u003d\u003d null ? directory.listFiles() : directory.listFiles(filter);\n                childFiles \u003d filterDirectoryContents(directory, depth, childFiles);\n                if (childFiles \u003d\u003d null) {\n                    handleRestricted(directory, childDepth, results);\n                } else {\n                    for (final File childFile : childFiles) {\n                        if (childFile.isDirectory()) {\n                            walk(childFile, childDepth, results);\n                        } else {\n                            checkIfCancelled(childFile, childDepth, results);\n                            handleFile(childFile, childDepth, results);\n                            checkIfCancelled(childFile, childDepth, results);\n                        }\n                    }\n                }\n            }\n            handleDirectoryEnd(directory, depth, results);\n        }\n        checkIfCancelled(directory, depth, results);\n    }",
    "begin_line": 371,
    "end_line": 397,
    "comment": "/** \n * Main recursive method to examine the directory hierarchy.\n * @param directory  the directory to examine, not null\n * @param depth  the directory level (starting directory \u003d 0)\n * @param results  the collection of result objects, may be updated\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.checkIfCancelled#415",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.checkIfCancelled(java.io.File, int, java.util.Collection\u003cT\u003e)",
    "snippet": "protected final void checkIfCancelled(final File file, final int depth, final Collection\u003cT\u003e results) throws\n            IOException {\n        if (handleIsCancelled(file, depth, results)) {\n            throw new CancelException(file, depth);\n        }\n    }",
    "begin_line": 415,
    "end_line": 420,
    "comment": "/** \n * Checks whether the walk has been cancelled by calling  {@link #handleIsCancelled}, throwing a \u003ccode\u003eCancelException\u003c/code\u003e if it has. \u003cp\u003e Writers of subclasses should not normally call this method as it is called automatically by the walk of the tree. However, sometimes a single method, typically  {@link #handleFile}, may take a long time to run. In that case, you may wish to check for cancellation by calling this method. \u003c/p\u003e\n * @param file  the current file being processed\n * @param depth  the current file level (starting directory \u003d 0)\n * @param results  the collection of result objects, may be updated\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.handleIsCancelled#460",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.handleIsCancelled(java.io.File, int, java.util.Collection\u003cT\u003e)",
    "snippet": "protected boolean handleIsCancelled(\n            final File file, final int depth, final Collection\u003cT\u003e results) throws IOException {\n        // do nothing - overridable by subclass\n        return false;  // not cancelled\n    }",
    "begin_line": 460,
    "end_line": 464,
    "comment": "/** \n * Overridable callback method invoked to determine if the entire walk operation should be immediately cancelled. \u003cp\u003e This method should be implemented by those subclasses that want to provide a public \u003ccode\u003ecancel()\u003c/code\u003e method available from another thread. The design pattern for the subclass should be as follows: \u003c/p\u003e \u003cpre\u003e public class FooDirectoryWalker extends DirectoryWalker { private volatile boolean cancelled \u003d false; public void cancel() { cancelled \u003d true; } private void handleIsCancelled(File file, int depth, Collection results) { return cancelled; } protected void handleCancelled(File startDirectory, Collection results, CancelException cancel) { // implement processing required when a cancellation occurs } } \u003c/pre\u003e \u003cp\u003e If this method returns true, then the directory walk is immediately cancelled. The next callback method will be  {@link #handleCancelled}. \u003c/p\u003e \u003cp\u003e This implementation returns false. \u003c/p\u003e\n * @param file  the file or directory being processed\n * @param depth  the current directory level (starting directory \u003d 0)\n * @param results  the collection of result objects, may be updated\n * @return true if the walk has been cancelled\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.handleCancelled#480",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.handleCancelled(java.io.File, java.util.Collection\u003cT\u003e, org.apache.commons.io.DirectoryWalker.CancelException)",
    "snippet": "protected void handleCancelled(final File startDirectory, final Collection\u003cT\u003e results,\n                       final CancelException cancel) throws IOException {\n        // re-throw exception - overridable by subclass\n        throw cancel;\n    }",
    "begin_line": 480,
    "end_line": 484,
    "comment": "/** \n * Overridable callback method invoked when the operation is cancelled. The file being processed when the cancellation occurred can be obtained from the exception. \u003cp\u003e This implementation just re-throws the  {@link CancelException}. \u003c/p\u003e\n * @param startDirectory  the directory that the walk started from\n * @param results  the collection of result objects, may be updated\n * @param cancel  the exception throw to cancel further processingcontaining details at the point of cancellation.\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.handleStart#497",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.handleStart(java.io.File, java.util.Collection\u003cT\u003e)",
    "snippet": "protected void handleStart(final File startDirectory, final Collection\u003cT\u003e results) throws IOException {\n        // do nothing - overridable by subclass\n    }",
    "begin_line": 497,
    "end_line": 499,
    "comment": "/** \n * Overridable callback method invoked at the start of processing. \u003cp\u003e This implementation does nothing. \u003c/p\u003e\n * @param startDirectory  the directory to start from\n * @param results  the collection of result objects, may be updated\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.handleDirectory#518",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.handleDirectory(java.io.File, int, java.util.Collection\u003cT\u003e)",
    "snippet": "protected boolean handleDirectory(final File directory, final int depth, final Collection\u003cT\u003e results) throws\n            IOException {\n        // do nothing - overridable by subclass\n        return true;  // process directory\n    }",
    "begin_line": 518,
    "end_line": 522,
    "comment": "/** \n * Overridable callback method invoked to determine if a directory should be processed. \u003cp\u003e This method returns a boolean to indicate if the directory should be examined or not. If you return false, the entire directory and any subdirectories will be skipped. Note that this functionality is in addition to the filtering by file filter. \u003c/p\u003e \u003cp\u003e This implementation does nothing and returns true. \u003c/p\u003e\n * @param directory  the current directory being processed\n * @param depth  the current directory level (starting directory \u003d 0)\n * @param results  the collection of result objects, may be updated\n * @return true to process this directory, false to skip this directory\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.handleDirectoryStart#535",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.handleDirectoryStart(java.io.File, int, java.util.Collection\u003cT\u003e)",
    "snippet": "protected void handleDirectoryStart(final File directory, final int depth, final Collection\u003cT\u003e results) throws\n            IOException {\n        // do nothing - overridable by subclass\n    }",
    "begin_line": 535,
    "end_line": 538,
    "comment": "/** \n * Overridable callback method invoked at the start of processing each directory. \u003cp\u003e This implementation does nothing. \u003c/p\u003e\n * @param directory  the current directory being processed\n * @param depth  the current directory level (starting directory \u003d 0)\n * @param results  the collection of result objects, may be updated\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.filterDirectoryContents#553",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.filterDirectoryContents(java.io.File, int, java.io.File)",
    "snippet": "protected File[] filterDirectoryContents(final File directory, final int depth, final File... files) throws\n            IOException {\n        return files;\n    }",
    "begin_line": 553,
    "end_line": 556,
    "comment": "/** \n * Overridable callback method invoked with the contents of each directory. \u003cp\u003e This implementation returns the files unchanged \u003c/p\u003e\n * @param directory  the current directory being processed\n * @param depth  the current directory level (starting directory \u003d 0)\n * @param files the files (possibly filtered) in the directory, may be {@code null}\n * @return the filtered list of files\n * @throws IOException if an I/O Error occurs\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.handleFile#569",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.handleFile(java.io.File, int, java.util.Collection\u003cT\u003e)",
    "snippet": "protected void handleFile(final File file, final int depth, final Collection\u003cT\u003e results) throws IOException {\n        // do nothing - overridable by subclass\n    }",
    "begin_line": 569,
    "end_line": 571,
    "comment": "/** \n * Overridable callback method invoked for each (non-directory) file. \u003cp\u003e This implementation does nothing. \u003c/p\u003e\n * @param file  the current file being processed\n * @param depth  the current directory level (starting directory \u003d 0)\n * @param results  the collection of result objects, may be updated\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.handleRestricted#584",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.handleRestricted(java.io.File, int, java.util.Collection\u003cT\u003e)",
    "snippet": "protected void handleRestricted(final File directory, final int depth, final Collection\u003cT\u003e results) throws\n            IOException {\n        // do nothing - overridable by subclass\n    }",
    "begin_line": 584,
    "end_line": 587,
    "comment": "/** \n * Overridable callback method invoked for each restricted directory. \u003cp\u003e This implementation does nothing. \u003c/p\u003e\n * @param directory  the restricted directory\n * @param depth  the current directory level (starting directory \u003d 0)\n * @param results  the collection of result objects, may be updated\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.handleDirectoryEnd#600",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.handleDirectoryEnd(java.io.File, int, java.util.Collection\u003cT\u003e)",
    "snippet": "protected void handleDirectoryEnd(final File directory, final int depth, final Collection\u003cT\u003e results) throws\n            IOException {\n        // do nothing - overridable by subclass\n    }",
    "begin_line": 600,
    "end_line": 603,
    "comment": "/** \n * Overridable callback method invoked at the end of processing each directory. \u003cp\u003e This implementation does nothing. \u003c/p\u003e\n * @param directory  the directory being processed\n * @param depth  the current directory level (starting directory \u003d 0)\n * @param results  the collection of result objects, may be updated\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryWalker.handleEnd#614",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.handleEnd(java.util.Collection\u003cT\u003e)",
    "snippet": "protected void handleEnd(final Collection\u003cT\u003e results) throws IOException {\n        // do nothing - overridable by subclass\n    }",
    "begin_line": 614,
    "end_line": 616,
    "comment": "/** \n * Overridable callback method invoked at the end of processing. \u003cp\u003e This implementation does nothing. \u003c/p\u003e\n * @param results  the collection of result objects, may be updated\n * @throws IOException if an I/O Error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CancelException.CancelException#640",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.CancelException(java.io.File, int)",
    "snippet": "public CancelException(final File file, final int depth) {\n            this(\"Operation Cancelled\", file, depth);\n        }",
    "begin_line": 640,
    "end_line": 642,
    "comment": "/** \n * Constructs a \u003ccode\u003eCancelException\u003c/code\u003e with the file and depth when cancellation occurred.\n * @param file  the file when the operation was cancelled, may be null\n * @param depth  the depth when the operation was cancelled, may be null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CancelException.CancelException#653",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.CancelException(java.lang.String, java.io.File, int)",
    "snippet": "public CancelException(final String message, final File file, final int depth) {\n            super(message);\n            this.file \u003d file;\n            this.depth \u003d depth;\n        }",
    "begin_line": 653,
    "end_line": 657,
    "comment": "/** \n * Constructs a \u003ccode\u003eCancelException\u003c/code\u003e with an appropriate message and the file and depth when cancellation occurred.\n * @param message  the detail message\n * @param file  the file when the operation was cancelled\n * @param depth  the depth when the operation was cancelled\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CancelException.getFile#664",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.getFile()",
    "snippet": "public File getFile() {\n            return file;\n        }",
    "begin_line": 664,
    "end_line": 666,
    "comment": "/** \n * Returns the file when the operation was cancelled.\n * @return the file when the operation was cancelled\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CancelException.getDepth#673",
    "is_bug": true,
    "src_path": "org/apache/commons/io/DirectoryWalker.java",
    "class_name": "org.apache.commons.io.DirectoryWalker",
    "signature": "org.apache.commons.io.DirectoryWalker.getDepth()",
    "snippet": "public int getDepth() {\n            return depth;\n        }",
    "begin_line": 673,
    "end_line": 675,
    "comment": "/** \n * Returns the depth when the operation was cancelled.\n * @return the depth when the operation was cancelled\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.byteCountToDisplaySize#190",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.byteCountToDisplaySize(java.math.BigInteger)",
    "snippet": " byteCountToDisplaySize(final BigInteger size) {\n        String displaySize;\n\n        if (size.divide(ONE_EB_BI).compareTo(BigInteger.ZERO) \u003e 0) {\n            displaySize \u003d String.valueOf(size.divide(ONE_EB_BI)) + \" EB\";\n        } else if (size.divide(ONE_PB_BI).compareTo(BigInteger.ZERO) \u003e 0) {\n            displaySize \u003d String.valueOf(size.divide(ONE_PB_BI)) + \" PB\";\n        } else if (size.divide(ONE_TB_BI).compareTo(BigInteger.ZERO) \u003e 0) {\n            displaySize \u003d String.valueOf(size.divide(ONE_TB_BI)) + \" TB\";\n        } else if (size.divide(ONE_GB_BI).compareTo(BigInteger.ZERO) \u003e 0) {\n            displaySize \u003d String.valueOf(size.divide(ONE_GB_BI)) + \" GB\";\n        } else if (size.divide(ONE_MB_BI).compareTo(BigInteger.ZERO) \u003e 0) {\n            displaySize \u003d String.valueOf(size.divide(ONE_MB_BI)) + \" MB\";\n        } else if (size.divide(ONE_KB_BI).compareTo(BigInteger.ZERO) \u003e 0) {\n            displaySize \u003d String.valueOf(size.divide(ONE_KB_BI)) + \" KB\";\n        } else {\n            displaySize \u003d String.valueOf(size) + \" bytes\";\n        }\n        return displaySize;\n    }",
    "begin_line": 190,
    "end_line": 209,
    "comment": "/** \n * Returns a human-readable version of the file size, where the input represents a specific number of bytes. \u003cp\u003e If the size is over 1GB, the size is returned as the number of whole GB, i.e. the size is rounded down to the nearest GB boundary. \u003c/p\u003e \u003cp\u003e Similarly for the 1MB and 1KB boundaries. \u003c/p\u003e\n * @param size the number of bytes\n * @return a human-readable display value (includes units - EB, PB, TB, GB, MB, KB or bytes)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-226\"\u003eIO-226 - should the rounding be changed?\u003c/a\u003e\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.byteCountToDisplaySize#226",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.byteCountToDisplaySize(long)",
    "snippet": " byteCountToDisplaySize(final long size) {\n        return byteCountToDisplaySize(BigInteger.valueOf(size));\n    }",
    "begin_line": 226,
    "end_line": 228,
    "comment": "/** \n * Returns a human-readable version of the file size, where the input represents a specific number of bytes. \u003cp\u003e If the size is over 1GB, the size is returned as the number of whole GB, i.e. the size is rounded down to the nearest GB boundary. \u003c/p\u003e \u003cp\u003e Similarly for the 1MB and 1KB boundaries. \u003c/p\u003e\n * @param size the number of bytes\n * @return a human-readable display value (includes units - EB, PB, TB, GB, MB, KB or bytes)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-226\"\u003eIO-226 - should the rounding be changed?\u003c/a\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.checkDirectory#236",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.checkDirectory(java.io.File)",
    "snippet": "private static void checkDirectory(final File directory) {\n        if (!directory.exists()) {\n            throw new IllegalArgumentException(directory + \" does not exist\");\n        }\n        if (!directory.isDirectory()) {\n            throw new IllegalArgumentException(directory + \" is not a directory\");\n        }\n    }",
    "begin_line": 236,
    "end_line": 243,
    "comment": "/** \n * Checks that the given  {@code File} exists and is a directory.\n * @param directory The {@code File} to check.\n * @throws IllegalArgumentException if the given {@code File} does not exist or is not a directory.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.checkEqualSizes#254",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.checkEqualSizes(java.io.File, java.io.File, long, long)",
    "snippet": "private static void checkEqualSizes(final File srcFile, final File destFile, final long srcLen, final long dstLen)\n            throws IOException {\n        if (srcLen !\u003d dstLen) {\n            throw new IOException(\"Failed to copy full contents from \u0027\" + srcFile + \"\u0027 to \u0027\" + destFile\n                    + \"\u0027 Expected length: \" + srcLen + \" Actual: \" + dstLen);\n        }\n    }",
    "begin_line": 254,
    "end_line": 260,
    "comment": "/** \n * Checks that two file lengths are equal.\n * @param srcFile Source file.\n * @param destFile Destination file.\n * @param srcLen Source file length.\n * @param dstLen Destination file length\n * @throws IOException Thrown when the given sizes are not equal.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.checkFileRequirements#269",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.checkFileRequirements(java.io.File, java.io.File)",
    "snippet": "private static void checkFileRequirements(final File src, final File dest) throws FileNotFoundException {\n        if (src \u003d\u003d null) {\n            throw new NullPointerException(\"Source must not be null\");\n        }\n        if (dest \u003d\u003d null) {\n            throw new NullPointerException(\"Destination must not be null\");\n        }\n        if (!src.exists()) {\n            throw new FileNotFoundException(\"Source \u0027\" + src + \"\u0027 does not exist\");\n        }\n    }",
    "begin_line": 269,
    "end_line": 279,
    "comment": "/** \n * Checks requirements for file copy.\n * @param src the source file\n * @param dest the destination\n * @throws FileNotFoundException if the destination does not exist\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.checksum#298",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.checksum(java.io.File, java.util.zip.Checksum)",
    "snippet": "public static Checksum checksum(final File file, final Checksum checksum) throws IOException {\n        if (file.isDirectory()) {\n            throw new IllegalArgumentException(\"Checksums can\u0027t be computed on directories\");\n        }\n        try (InputStream in \u003d new CheckedInputStream(new FileInputStream(file), checksum)) {\n            IOUtils.copy(in, NullOutputStream.NULL_OUTPUT_STREAM);\n        }\n        return checksum;\n    }",
    "begin_line": 298,
    "end_line": 306,
    "comment": "/** \n * Computes the checksum of a file using the specified checksum object. Multiple files may be checked using one \u003ccode\u003eChecksum\u003c/code\u003e instance if desired simply by reusing the same checksum object. For example: \u003cpre\u003e long csum \u003d FileUtils.checksum(file, new CRC32()).getValue(); \u003c/pre\u003e\n * @param file     the file to checksum, must not be {@code null}\n * @param checksum the checksum object to be used, must not be {@code null}\n * @return the checksum specified, updated with the content of the file\n * @throws NullPointerException     if the file or checksum is {@code null}\n * @throws IllegalArgumentException if the file is a directory\n * @throws IOException              if an IO error occurs reading the file\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.checksumCRC32#320",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.checksumCRC32(java.io.File)",
    "snippet": "public static long checksumCRC32(final File file) throws IOException {\n        return checksum(file, new CRC32()).getValue();\n    }",
    "begin_line": 320,
    "end_line": 322,
    "comment": "/** \n * Computes the checksum of a file using the CRC32 checksum routine. The value of the checksum is returned.\n * @param file the file to checksum, must not be {@code null}\n * @return the checksum value\n * @throws NullPointerException     if the file or checksum is {@code null}\n * @throws IllegalArgumentException if the file is a directory\n * @throws IOException              if an IO error occurs reading the file\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.cleanDirectory#331",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.cleanDirectory(java.io.File)",
    "snippet": "public static void cleanDirectory(final File directory) throws IOException {\n        final File[] files \u003d verifiedListFiles(directory);\n\n        IOException exception \u003d null;\n        for (final File file : files) {\n            try {\n                forceDelete(file);\n            } catch (final IOException ioe) {\n                exception \u003d ioe;\n            }\n        }\n\n        if (null !\u003d exception) {\n            throw exception;\n        }\n    }",
    "begin_line": 331,
    "end_line": 346,
    "comment": "/** \n * Cleans a directory without deleting it.\n * @param directory directory to clean\n * @throws IOException              in case cleaning is unsuccessful\n * @throws IllegalArgumentException if {@code directory} does not exist or is not a directory\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.cleanDirectoryOnExit#355",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.cleanDirectoryOnExit(java.io.File)",
    "snippet": "private static void cleanDirectoryOnExit(final File directory) throws IOException {\n        final File[] files \u003d verifiedListFiles(directory);\n\n        IOException exception \u003d null;\n        for (final File file : files) {\n            try {\n                forceDeleteOnExit(file);\n            } catch (final IOException ioe) {\n                exception \u003d ioe;\n            }\n        }\n\n        if (null !\u003d exception) {\n            throw exception;\n        }\n    }",
    "begin_line": 355,
    "end_line": 370,
    "comment": "/** \n * Cleans a directory without deleting it.\n * @param directory directory to clean, must not be {@code null}\n * @throws NullPointerException if the directory is {@code null}\n * @throws IOException          in case cleaning is unsuccessful\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.contentEquals#390",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.contentEquals(java.io.File, java.io.File)",
    "snippet": "public static boolean contentEquals(final File file1, final File file2) throws IOException {\n        final boolean file1Exists \u003d file1.exists();\n        if (file1Exists !\u003d file2.exists()) {\n            return false;\n        }\n\n        if (!file1Exists) {\n            // two not existing files are equal\n            return true;\n        }\n\n        if (file1.isDirectory() || file2.isDirectory()) {\n            // don\u0027t want to compare directory contents\n            throw new IOException(\"Can\u0027t compare directories, only files\");\n        }\n\n        if (file1.length() !\u003d file2.length()) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n\n        if (file1.getCanonicalFile().equals(file2.getCanonicalFile())) {\n            // same file\n            return true;\n        }\n\n        try (InputStream input1 \u003d new FileInputStream(file1);\n             InputStream input2 \u003d new FileInputStream(file2)) {\n            return IOUtils.contentEquals(input1, input2);\n        }\n    }",
    "begin_line": 390,
    "end_line": 420,
    "comment": "/** \n * Compares the contents of two files to determine if they are equal or not. \u003cp\u003e This method checks to see if the two files are different lengths or if they point to the same file, before resorting to byte-by-byte comparison of the contents. \u003c/p\u003e \u003cp\u003e Code origin: Avalon \u003c/p\u003e\n * @param file1 the first file\n * @param file2 the second file\n * @return true if the content of the files are equal or they both don\u0027texist, false otherwise\n * @throws IOException in case of an I/O error\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.contentEqualsIgnoreEOL#440",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.contentEqualsIgnoreEOL(java.io.File, java.io.File, java.lang.String)",
    "snippet": "public static boolean contentEqualsIgnoreEOL(final File file1, final File file2, final String charsetName)\n            throws IOException {\n        final boolean file1Exists \u003d file1.exists();\n        if (file1Exists !\u003d file2.exists()) {\n            return false;\n        }\n\n        if (!file1Exists) {\n            // two not existing files are equal\n            return true;\n        }\n\n        if (file1.isDirectory() || file2.isDirectory()) {\n            // don\u0027t want to compare directory contents\n            throw new IOException(\"Can\u0027t compare directories, only files\");\n        }\n\n        if (file1.getCanonicalFile().equals(file2.getCanonicalFile())) {\n            // same file\n            return true;\n        }\n\n        try (Reader input1 \u003d charsetName \u003d\u003d null\n                                 ? new InputStreamReader(new FileInputStream(file1), Charset.defaultCharset())\n                                 : new InputStreamReader(new FileInputStream(file1), charsetName);\n             Reader input2 \u003d charsetName \u003d\u003d null\n                                 ? new InputStreamReader(new FileInputStream(file2), Charset.defaultCharset())\n                                 : new InputStreamReader(new FileInputStream(file2), charsetName)) {\n            return IOUtils.contentEqualsIgnoreEOL(input1, input2);\n        }\n    }",
    "begin_line": 440,
    "end_line": 470,
    "comment": "/** \n * Compares the contents of two files to determine if they are equal or not. \u003cp\u003e This method checks to see if the two files point to the same file, before resorting to line-by-line comparison of the contents. \u003c/p\u003e\n * @param file1       the first file\n * @param file2       the second file\n * @param charsetName the character encoding to be used.May be null, in which case the platform default is used\n * @return true if the content of the files are equal or neither exists,false otherwise\n * @throws IOException in case of an I/O error\n * @see IOUtils#contentEqualsIgnoreEOL(Reader,Reader)\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.convertFileCollectionToFileArray#481",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.convertFileCollectionToFileArray(java.util.Collection\u003cjava.io.File\u003e)",
    "snippet": "public static File[] convertFileCollectionToFileArray(final Collection\u003cFile\u003e files) {\n        return files.toArray(new File[files.size()]);\n    }",
    "begin_line": 481,
    "end_line": 483,
    "comment": "/** \n * Converts a Collection containing java.io.File instanced into array representation. This is to account for the difference between File.listFiles() and FileUtils.listFiles().\n * @param files a Collection containing java.io.File instances\n * @return an array of java.io.File\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyDirectory#512",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyDirectory(java.io.File, java.io.File)",
    "snippet": "public static void copyDirectory(final File srcDir, final File destDir) throws IOException {\n        copyDirectory(srcDir, destDir, true);\n    }",
    "begin_line": 512,
    "end_line": 514,
    "comment": "/** \n * Copies a whole directory to a new location preserving the file dates. \u003cp\u003e This method copies the specified directory and all its child directories and files to the specified destination. The destination is the new location and name of the directory. \u003c/p\u003e \u003cp\u003e The destination directory is created if it does not exist. If the destination directory did exist, then this method merges the source with the destination, with the source taking precedence. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e This method tries to preserve the files\u0027 last modified date/times using  {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e\n * @param srcDir  an existing directory to copy, must not be {@code null}\n * @param destDir the new directory, must not be {@code null}\n * @throws NullPointerException if source or destination is {@code null}\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs during copying\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyDirectory#545",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyDirectory(java.io.File, java.io.File, boolean)",
    "snippet": "public static void copyDirectory(final File srcDir, final File destDir,\n                                     final boolean preserveFileDate) throws IOException {\n        copyDirectory(srcDir, destDir, null, preserveFileDate);\n    }",
    "begin_line": 545,
    "end_line": 548,
    "comment": "/** \n * Copies a whole directory to a new location. \u003cp\u003e This method copies the contents of the specified source directory to within the specified destination directory. \u003c/p\u003e \u003cp\u003e The destination directory is created if it does not exist. If the destination directory did exist, then this method merges the source with the destination, with the source taking precedence. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e Setting \u003ccode\u003epreserveFileDate\u003c/code\u003e to {@code true} tries to preserve the files\u0027 last modifieddate/times using  {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e\n * @param srcDir           an existing directory to copy, must not be {@code null}\n * @param destDir          the new directory, must not be {@code null}\n * @param preserveFileDate true if the file date of the copyshould be the same as the original\n * @throws NullPointerException if source or destination is {@code null}\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs during copying\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyDirectory#596",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyDirectory(java.io.File, java.io.File, java.io.FileFilter)",
    "snippet": "public static void copyDirectory(final File srcDir, final File destDir,\n                                     final FileFilter filter) throws IOException {\n        copyDirectory(srcDir, destDir, filter, true);\n    }",
    "begin_line": 596,
    "end_line": 599,
    "comment": "/** \n * Copies a filtered directory to a new location preserving the file dates. \u003cp\u003e This method copies the contents of the specified source directory to within the specified destination directory. \u003c/p\u003e \u003cp\u003e The destination directory is created if it does not exist. If the destination directory did exist, then this method merges the source with the destination, with the source taking precedence. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e This method tries to preserve the files\u0027 last modified date/times using  {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e \u003cb\u003eExample: Copy directories only\u003c/b\u003e \u003cpre\u003e // only copy the directory structure FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY); \u003c/pre\u003e \u003cb\u003eExample: Copy directories and txt files\u003c/b\u003e \u003cpre\u003e // Create a filter for \".txt\" files IOFileFilter txtSuffixFilter \u003d FileFilterUtils.suffixFileFilter(\".txt\"); IOFileFilter txtFiles \u003d FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter); // Create a filter for either directories or \".txt\" files FileFilter filter \u003d FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles); // Copy using the filter FileUtils.copyDirectory(srcDir, destDir, filter); \u003c/pre\u003e\n * @param srcDir  an existing directory to copy, must not be {@code null}\n * @param destDir the new directory, must not be {@code null}\n * @param filter  the filter to apply, null means copy all directories and filesshould be the same as the original\n * @throws NullPointerException if source or destination is {@code null}\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs during copying\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyDirectory#649",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyDirectory(java.io.File, java.io.File, java.io.FileFilter, boolean)",
    "snippet": "public static void copyDirectory(final File srcDir, final File destDir,\n                                     final FileFilter filter, final boolean preserveFileDate) throws IOException {\n        checkFileRequirements(srcDir, destDir);\n        if (!srcDir.isDirectory()) {\n            throw new IOException(\"Source \u0027\" + srcDir + \"\u0027 exists but is not a directory\");\n        }\n        if (srcDir.getCanonicalPath().equals(destDir.getCanonicalPath())) {\n            throw new IOException(\"Source \u0027\" + srcDir + \"\u0027 and destination \u0027\" + destDir + \"\u0027 are the same\");\n        }\n\n        // Cater for destination being directory within the source directory (see IO-141)\n        List\u003cString\u003e exclusionList \u003d null;\n        if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath())) {\n            final File[] srcFiles \u003d filter \u003d\u003d null ? srcDir.listFiles() : srcDir.listFiles(filter);\n            if (srcFiles !\u003d null \u0026\u0026 srcFiles.length \u003e 0) {\n                exclusionList \u003d new ArrayList\u003c\u003e(srcFiles.length);\n                for (final File srcFile : srcFiles) {\n                    final File copiedFile \u003d new File(destDir, srcFile.getName());\n                    exclusionList.add(copiedFile.getCanonicalPath());\n                }\n            }\n        }\n        doCopyDirectory(srcDir, destDir, filter, preserveFileDate, exclusionList);\n    }",
    "begin_line": 649,
    "end_line": 672,
    "comment": "/** \n * Copies a filtered directory to a new location. \u003cp\u003e This method copies the contents of the specified source directory to within the specified destination directory. \u003c/p\u003e \u003cp\u003e The destination directory is created if it does not exist. If the destination directory did exist, then this method merges the source with the destination, with the source taking precedence. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e Setting \u003ccode\u003epreserveFileDate\u003c/code\u003e to {@code true} tries to preserve the files\u0027 last modifieddate/times using  {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e \u003cb\u003eExample: Copy directories only\u003c/b\u003e \u003cpre\u003e // only copy the directory structure FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY, false); \u003c/pre\u003e \u003cb\u003eExample: Copy directories and txt files\u003c/b\u003e \u003cpre\u003e // Create a filter for \".txt\" files IOFileFilter txtSuffixFilter \u003d FileFilterUtils.suffixFileFilter(\".txt\"); IOFileFilter txtFiles \u003d FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter); // Create a filter for either directories or \".txt\" files FileFilter filter \u003d FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles); // Copy using the filter FileUtils.copyDirectory(srcDir, destDir, filter, false); \u003c/pre\u003e\n * @param srcDir           an existing directory to copy, must not be {@code null}\n * @param destDir          the new directory, must not be {@code null}\n * @param filter           the filter to apply, null means copy all directories and files\n * @param preserveFileDate true if the file date of the copyshould be the same as the original\n * @throws NullPointerException if source or destination is {@code null}\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs during copying\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyDirectoryToDirectory#702",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyDirectoryToDirectory(java.io.File, java.io.File)",
    "snippet": "public static void copyDirectoryToDirectory(final File srcDir, final File destDir) throws IOException {\n        if (srcDir \u003d\u003d null) {\n            throw new NullPointerException(\"Source must not be null\");\n        }\n        if (srcDir.exists() \u0026\u0026 srcDir.isDirectory() \u003d\u003d false) {\n            throw new IllegalArgumentException(\"Source \u0027\" + srcDir + \"\u0027 is not a directory\");\n        }\n        if (destDir \u003d\u003d null) {\n            throw new NullPointerException(\"Destination must not be null\");\n        }\n        if (destDir.exists() \u0026\u0026 destDir.isDirectory() \u003d\u003d false) {\n            throw new IllegalArgumentException(\"Destination \u0027\" + destDir + \"\u0027 is not a directory\");\n        }\n        copyDirectory(srcDir, new File(destDir, srcDir.getName()), true);\n    }",
    "begin_line": 702,
    "end_line": 716,
    "comment": "/** \n * Copies a directory to within another directory preserving the file dates. \u003cp\u003e This method copies the source directory and all its contents to a directory of the same name in the specified destination directory. \u003c/p\u003e \u003cp\u003e The destination directory is created if it does not exist. If the destination directory did exist, then this method merges the source with the destination, with the source taking precedence. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e This method tries to preserve the files\u0027 last modified date/times using  {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e\n * @param srcDir  an existing directory to copy, must not be {@code null}\n * @param destDir the directory to place the copy in, must not be {@code null}\n * @throws NullPointerException if source or destination is {@code null}\n * @throws IllegalArgumentException if {@code srcDir} or {@code destDir} is not a directory\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs during copying\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyFile#744",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File)",
    "snippet": "public static void copyFile(final File srcFile, final File destFile) throws IOException {\n        copyFile(srcFile, destFile, true);\n    }",
    "begin_line": 744,
    "end_line": 746,
    "comment": "/** \n * Copies a file to a new location preserving the file date. \u003cp\u003e This method copies the contents of the specified source file to the specified destination file. The directory holding the destination file is created if it does not exist. If the destination file exists, then this method will overwrite it. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e This method tries to preserve the file\u0027s last modified date/times using  {@link File#setLastModified(long)}, however it is not guaranteed that the operation will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e\n * @param srcFile  an existing file to copy, must not be {@code null}\n * @param destFile the new file, must not be {@code null}\n * @throws NullPointerException if source or destination is {@code null}\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs during copying\n * @throws IOException          if the output file length is not the same as the input file length after the copycompletes\n * @see #copyFileToDirectory(File,File)\n * @see #copyFile(File,File,boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyFile#777",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File, boolean)",
    "snippet": "public static void copyFile(final File srcFile, final File destFile,\n                                final boolean preserveFileDate) throws IOException {\n        checkFileRequirements(srcFile, destFile);\n        if (srcFile.isDirectory()) {\n            throw new IOException(\"Source \u0027\" + srcFile + \"\u0027 exists but is a directory\");\n        }\n        if (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath())) {\n            throw new IOException(\"Source \u0027\" + srcFile + \"\u0027 and destination \u0027\" + destFile + \"\u0027 are the same\");\n        }\n        final File parentFile \u003d destFile.getParentFile();\n        if (parentFile !\u003d null) {\n            if (!parentFile.mkdirs() \u0026\u0026 !parentFile.isDirectory()) {\n                throw new IOException(\"Destination \u0027\" + parentFile + \"\u0027 directory cannot be created\");\n            }\n        }\n        if (destFile.exists() \u0026\u0026 destFile.canWrite() \u003d\u003d false) {\n            throw new IOException(\"Destination \u0027\" + destFile + \"\u0027 exists but is read-only\");\n        }\n        doCopyFile(srcFile, destFile, preserveFileDate);\n    }",
    "begin_line": 777,
    "end_line": 796,
    "comment": "/** \n * Copies a file to a new location. \u003cp\u003e This method copies the contents of the specified source file to the specified destination file. The directory holding the destination file is created if it does not exist. If the destination file exists, then this method will overwrite it. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e Setting \u003ccode\u003epreserveFileDate\u003c/code\u003e to {@code true} tries to preserve the file\u0027s last modifieddate/times using  {@link File#setLastModified(long)}, however it is not guaranteed that the operation will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e\n * @param srcFile          an existing file to copy, must not be {@code null}\n * @param destFile         the new file, must not be {@code null}\n * @param preserveFileDate true if the file date of the copyshould be the same as the original\n * @throws NullPointerException if source or destination is {@code null}\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs during copying\n * @throws IOException          if the output file length is not the same as the input file length after the copycompletes\n * @see #copyFileToDirectory(File,File,boolean)\n * @see #doCopyFile(File,File,boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyFile#811",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.OutputStream)",
    "snippet": "public static long copyFile(final File input, final OutputStream output) throws IOException {\n        try (FileInputStream fis \u003d new FileInputStream(input)) {\n            return IOUtils.copyLarge(fis, output);\n        }\n    }",
    "begin_line": 811,
    "end_line": 815,
    "comment": "/** \n * Copy bytes from a \u003ccode\u003eFile\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003c/p\u003e\n * @param input  the \u003ccode\u003eFile\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyFileToDirectory#841",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File)",
    "snippet": "public static void copyFileToDirectory(final File srcFile, final File destDir) throws IOException {\n        copyFileToDirectory(srcFile, destDir, true);\n    }",
    "begin_line": 841,
    "end_line": 843,
    "comment": "/** \n * Copies a file to a directory preserving the file date. \u003cp\u003e This method copies the contents of the specified source file to a file of the same name in the specified destination directory. The destination directory is created if it does not exist. If the destination file exists, then this method will overwrite it. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e This method tries to preserve the file\u0027s last modified date/times using  {@link File#setLastModified(long)}, however it is not guaranteed that the operation will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e\n * @param srcFile an existing file to copy, must not be {@code null}\n * @param destDir the directory to place the copy in, must not be {@code null}\n * @throws NullPointerException if source or destination is null\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs during copying\n * @see #copyFile(File,File,boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyFileToDirectory#874",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File, boolean)",
    "snippet": "public static void copyFileToDirectory(final File srcFile, final File destDir, final boolean preserveFileDate)\n            throws IOException {\n        if (destDir \u003d\u003d null) {\n            throw new NullPointerException(\"Destination must not be null\");\n        }\n        if (destDir.exists() \u0026\u0026 destDir.isDirectory() \u003d\u003d false) {\n            throw new IllegalArgumentException(\"Destination \u0027\" + destDir + \"\u0027 is not a directory\");\n        }\n        final File destFile \u003d new File(destDir, srcFile.getName());\n        copyFile(srcFile, destFile, preserveFileDate);\n    }",
    "begin_line": 874,
    "end_line": 884,
    "comment": "/** \n * Copies a file to a directory optionally preserving the file date. \u003cp\u003e This method copies the contents of the specified source file to a file of the same name in the specified destination directory. The destination directory is created if it does not exist. If the destination file exists, then this method will overwrite it. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e Setting \u003ccode\u003epreserveFileDate\u003c/code\u003e to {@code true} tries to preserve the file\u0027s last modifieddate/times using  {@link File#setLastModified(long)}, however it is not guaranteed that the operation will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e\n * @param srcFile          an existing file to copy, must not be {@code null}\n * @param destDir          the directory to place the copy in, must not be {@code null}\n * @param preserveFileDate true if the file date of the copyshould be the same as the original\n * @throws NullPointerException if source or destination is {@code null}\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs during copying\n * @throws IOException          if the output file length is not the same as the input file length after the copycompletes\n * @see #copyFile(File,File,boolean)\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyInputStreamToFile#903",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyInputStreamToFile(java.io.InputStream, java.io.File)",
    "snippet": "public static void copyInputStreamToFile(final InputStream source, final File destination) throws IOException {\n        try (InputStream in \u003d source) {\n            copyToFile(in, destination);\n        }\n    }",
    "begin_line": 903,
    "end_line": 907,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} \u003ccode\u003esource\u003c/code\u003e to a file\u003ccode\u003edestination\u003c/code\u003e. The directories up to \u003ccode\u003edestination\u003c/code\u003e will be created if they don\u0027t already exist. \u003ccode\u003edestination\u003c/code\u003e will be overwritten if it already exists. The  {@code source} stream is closed.See  {@link #copyToFile(InputStream,File)} for a method that does not close the input stream.\n * @param source      the \u003ccode\u003eInputStream\u003c/code\u003e to copy bytes from, must not be {@code null}, will be closed\n * @param destination the non-directory \u003ccode\u003eFile\u003c/code\u003e to write bytes to(possibly overwriting), must not be  {@code null}\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e is a directory\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e cannot be written\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e needs creating but can\u0027t be\n * @throws IOException if an IO error occurs during copying\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyToDirectory#937",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyToDirectory(java.io.File, java.io.File)",
    "snippet": "public static void copyToDirectory(final File src, final File destDir) throws IOException {\n        if (src \u003d\u003d null) {\n            throw new NullPointerException(\"Source must not be null\");\n        }\n        if (src.isFile()) {\n            copyFileToDirectory(src, destDir);\n        } else if (src.isDirectory()) {\n            copyDirectoryToDirectory(src, destDir);\n        } else {\n            throw new IOException(\"The source \" + src + \" does not exist\");\n        }\n    }",
    "begin_line": 937,
    "end_line": 948,
    "comment": "/** \n * Copies a file or directory to within another directory preserving the file dates. \u003cp\u003e This method copies the source file or directory, along all its contents, to a directory of the same name in the specified destination directory. \u003c/p\u003e \u003cp\u003e The destination directory is created if it does not exist. If the destination directory did exist, then this method merges the source with the destination, with the source taking precedence. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e This method tries to preserve the files\u0027 last modified date/times using  {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e\n * @param src      an existing file or directory to copy, must not be {@code null}\n * @param destDir  the directory to place the copy in, must not be {@code null}\n * @throws NullPointerException if source or destination is {@code null}\n * @throws IOException if source or destination is invalid\n * @throws IOException if an IO error occurs during copying\n * @see #copyDirectoryToDirectory(File,File)\n * @see #copyFileToDirectory(File,File)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyToDirectory#975",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyToDirectory(java.lang.Iterable\u003cjava.io.File\u003e, java.io.File)",
    "snippet": "public static void copyToDirectory(final Iterable\u003cFile\u003e srcs, final File destDir) throws IOException {\n        if (srcs \u003d\u003d null) {\n            throw new NullPointerException(\"Sources must not be null\");\n        }\n        for (final File src : srcs) {\n            copyFileToDirectory(src, destDir);\n        }\n    }",
    "begin_line": 975,
    "end_line": 982,
    "comment": "/** \n * Copies a files to a directory preserving each file\u0027s date. \u003cp\u003e This method copies the contents of the specified source files to a file of the same name in the specified destination directory. The destination directory is created if it does not exist. If the destination file exists, then this method will overwrite it. \u003c/p\u003e \u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e This method tries to preserve the file\u0027s last modified date/times using  {@link File#setLastModified(long)}, however it is not guaranteed that the operation will succeed. If the modification operation fails, no indication is provided. \u003c/p\u003e\n * @param srcs     a existing files to copy, must not be {@code null}\n * @param destDir  the directory to place the copy in, must not be {@code null}\n * @throws NullPointerException if source or destination is null\n * @throws IOException if source or destination is invalid\n * @throws IOException if an IO error occurs during copying\n * @see #copyFileToDirectory(File,File)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyToFile#1001",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyToFile(java.io.InputStream, java.io.File)",
    "snippet": "public static void copyToFile(final InputStream source, final File destination) throws IOException {\n        try (OutputStream out \u003d openOutputStream(destination)) {\n            IOUtils.copy(source, out);\n        }\n    }",
    "begin_line": 1001,
    "end_line": 1005,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} \u003ccode\u003esource\u003c/code\u003e to a file\u003ccode\u003edestination\u003c/code\u003e. The directories up to \u003ccode\u003edestination\u003c/code\u003e will be created if they don\u0027t already exist. \u003ccode\u003edestination\u003c/code\u003e will be overwritten if it already exists. The  {@code source} stream is left open, e.g. for use with {@link java.util.zip.ZipInputStream ZipInputStream}. See  {@link #copyInputStreamToFile(InputStream,File)} for a method that closes the input stream.\n * @param source      the \u003ccode\u003eInputStream\u003c/code\u003e to copy bytes from, must not be {@code null}\n * @param destination the non-directory \u003ccode\u003eFile\u003c/code\u003e to write bytes to(possibly overwriting), must not be  {@code null}\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e is a directory\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e cannot be written\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e needs creating but can\u0027t be\n * @throws IOException if an IO error occurs during copying\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyURLToFile#1028",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyURLToFile(java.net.URL, java.io.File)",
    "snippet": "public static void copyURLToFile(final URL source, final File destination) throws IOException {\n        copyInputStreamToFile(source.openStream(), destination);\n    }",
    "begin_line": 1028,
    "end_line": 1030,
    "comment": "/** \n * Copies bytes from the URL \u003ccode\u003esource\u003c/code\u003e to a file \u003ccode\u003edestination\u003c/code\u003e. The directories up to \u003ccode\u003edestination\u003c/code\u003e will be created if they don\u0027t already exist. \u003ccode\u003edestination\u003c/code\u003e will be overwritten if it already exists. \u003cp\u003e Warning: this method does not set a connection or read timeout and thus might block forever. Use  {@link #copyURLToFile(URL,File,int,int)}with reasonable timeouts to prevent this. \u003c/p\u003e\n * @param source      the \u003ccode\u003eURL\u003c/code\u003e to copy bytes from, must not be {@code null}\n * @param destination the non-directory \u003ccode\u003eFile\u003c/code\u003e to write bytes to(possibly overwriting), must not be  {@code null}\n * @throws IOException if \u003ccode\u003esource\u003c/code\u003e URL cannot be opened\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e is a directory\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e cannot be written\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e needs creating but can\u0027t be\n * @throws IOException if an IO error occurs during copying\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.copyURLToFile#1052",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.copyURLToFile(java.net.URL, java.io.File, int, int)",
    "snippet": "public static void copyURLToFile(final URL source, final File destination,\n                                     final int connectionTimeout, final int readTimeout) throws IOException {\n        final URLConnection connection \u003d source.openConnection();\n        connection.setConnectTimeout(connectionTimeout);\n        connection.setReadTimeout(readTimeout);\n        copyInputStreamToFile(connection.getInputStream(), destination);\n    }",
    "begin_line": 1052,
    "end_line": 1058,
    "comment": "/** \n * Copies bytes from the URL \u003ccode\u003esource\u003c/code\u003e to a file \u003ccode\u003edestination\u003c/code\u003e. The directories up to \u003ccode\u003edestination\u003c/code\u003e will be created if they don\u0027t already exist. \u003ccode\u003edestination\u003c/code\u003e will be overwritten if it already exists.\n * @param source            the \u003ccode\u003eURL\u003c/code\u003e to copy bytes from, must not be {@code null}\n * @param destination       the non-directory \u003ccode\u003eFile\u003c/code\u003e to write bytes to(possibly overwriting), must not be  {@code null}\n * @param connectionTimeout the number of milliseconds until this methodwill timeout if no connection could be established to the \u003ccode\u003esource\u003c/code\u003e\n * @param readTimeout       the number of milliseconds until this method willtimeout if no data could be read from the \u003ccode\u003esource\u003c/code\u003e\n * @throws IOException if \u003ccode\u003esource\u003c/code\u003e URL cannot be opened\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e is a directory\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e cannot be written\n * @throws IOException if \u003ccode\u003edestination\u003c/code\u003e needs creating but can\u0027t be\n * @throws IOException if an IO error occurs during copying\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.decodeUrl#1074",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.decodeUrl(java.lang.String)",
    "snippet": "static String decodeUrl(final String url) {\n        String decoded \u003d url;\n        if (url !\u003d null \u0026\u0026 url.indexOf(\u0027%\u0027) \u003e\u003d 0) {\n            final int n \u003d url.length();\n            final StringBuilder buffer \u003d new StringBuilder();\n            final ByteBuffer bytes \u003d ByteBuffer.allocate(n);\n            for (int i \u003d 0; i \u003c n; ) {\n                if (url.charAt(i) \u003d\u003d \u0027%\u0027) {\n                    try {\n                        do {\n                            final byte octet \u003d (byte) Integer.parseInt(url.substring(i + 1, i + 3), 16);\n                            bytes.put(octet);\n                            i +\u003d 3;\n                        } while (i \u003c n \u0026\u0026 url.charAt(i) \u003d\u003d \u0027%\u0027);\n                        continue;\n                    } catch (final RuntimeException e) {\n                        // malformed percent-encoded octet, fall through and\n                        // append characters literally\n                    } finally {\n                        if (bytes.position() \u003e 0) {\n                            bytes.flip();\n                            buffer.append(StandardCharsets.UTF_8.decode(bytes).toString());\n                            bytes.clear();\n                        }\n                    }\n                }\n                buffer.append(url.charAt(i++));\n            }\n            decoded \u003d buffer.toString();\n        }\n        return decoded;\n    }",
    "begin_line": 1074,
    "end_line": 1105,
    "comment": "/** \n * Decodes the specified URL as per RFC 3986, i.e. transforms percent-encoded octets to characters by decoding with the UTF-8 character set. This function is primarily intended for usage with {@link java.net.URL} which unfortunately does not enforce proper URLs. Assuch, this method will leniently accept invalid characters or malformed percent-encoded octets and simply pass them literally through to the result string. Except for rare edge cases, this will make unencoded URLs pass through unaltered.\n * @param url The URL to decode, may be {@code null}.\n * @return The decoded URL or {@code null} if the input was{@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.deleteDirectory#1115",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.deleteDirectory(java.io.File)",
    "snippet": "public static void deleteDirectory(final File directory) throws IOException {\n        if (!directory.exists()) {\n            return;\n        }\n\n        if (!isSymlink(directory)) {\n            cleanDirectory(directory);\n        }\n\n        if (!directory.delete()) {\n            final String message \u003d\n                    \"Unable to delete directory \" + directory + \".\";\n            throw new IOException(message);\n        }\n    }",
    "begin_line": 1115,
    "end_line": 1129,
    "comment": "/** \n * Deletes a directory recursively.\n * @param directory directory to delete\n * @throws IOException              in case deletion is unsuccessful\n * @throws IllegalArgumentException if {@code directory} does not exist or is not a directory\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.deleteDirectoryOnExit#1138",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.deleteDirectoryOnExit(java.io.File)",
    "snippet": "private static void deleteDirectoryOnExit(final File directory) throws IOException {\n        if (!directory.exists()) {\n            return;\n        }\n\n        directory.deleteOnExit();\n        if (!isSymlink(directory)) {\n            cleanDirectoryOnExit(directory);\n        }\n    }",
    "begin_line": 1138,
    "end_line": 1147,
    "comment": "/** \n * Schedules a directory recursively for deletion on JVM exit.\n * @param directory directory to delete, must not be {@code null}\n * @throws NullPointerException if the directory is {@code null}\n * @throws IOException          in case deletion is unsuccessful\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.deleteQuietly#1165",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.deleteQuietly(java.io.File)",
    "snippet": "public static boolean deleteQuietly(final File file) {\n        if (file \u003d\u003d null) {\n            return false;\n        }\n        try {\n            if (file.isDirectory()) {\n                cleanDirectory(file);\n            }\n        } catch (final Exception ignored) {\n            // ignore\n        }\n\n        try {\n            return file.delete();\n        } catch (final Exception ignored) {\n            return false;\n        }\n    }",
    "begin_line": 1165,
    "end_line": 1182,
    "comment": "/** \n * Deletes a file, never throwing an exception. If file is a directory, delete it and all sub-directories. \u003cp\u003e The difference between File.delete() and this method are: \u003c/p\u003e \u003cul\u003e \u003cli\u003eA directory to be deleted does not have to be empty.\u003c/li\u003e \u003cli\u003eNo exceptions are thrown when a file or directory cannot be deleted.\u003c/li\u003e \u003c/ul\u003e\n * @param file file or directory to delete, can be {@code null}\n * @return {@code true} if the file or directory was deleted, otherwise{@code false}\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.directoryContains#1206",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.directoryContains(java.io.File, java.io.File)",
    "snippet": "public static boolean directoryContains(final File directory, final File child) throws IOException {\n\n        // Fail fast against NullPointerException\n        if (directory \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Directory must not be null\");\n        }\n\n        if (!directory.isDirectory()) {\n            throw new IllegalArgumentException(\"Not a directory: \" + directory);\n        }\n\n        if (child \u003d\u003d null) {\n            return false;\n        }\n\n        if (!directory.exists() || !child.exists()) {\n            return false;\n        }\n\n        // Canonicalize paths (normalizes relative paths)\n        final String canonicalParent \u003d directory.getCanonicalPath();\n        final String canonicalChild \u003d child.getCanonicalPath();\n\n        return FilenameUtils.directoryContains(canonicalParent, canonicalChild);\n    }",
    "begin_line": 1206,
    "end_line": 1230,
    "comment": "/** \n * Determines whether the  {@code parent} directory contains the {@code child} element (a file or directory).\u003cp\u003e Files are normalized before comparison. \u003c/p\u003e Edge cases: \u003cul\u003e \u003cli\u003eA  {@code directory} must not be null: if null, throw IllegalArgumentException\u003c/li\u003e\u003cli\u003eA  {@code directory} must be a directory: if not a directory, throw IllegalArgumentException\u003c/li\u003e\u003cli\u003eA directory does not contain itself: return false\u003c/li\u003e \u003cli\u003eA null child file is not contained in any parent: return false\u003c/li\u003e \u003c/ul\u003e\n * @param directory the file to consider as the parent.\n * @param child     the file to consider as the child.\n * @return true is the candidate leaf is under by the specified composite. False otherwise.\n * @throws IOException              if an IO error occurs while checking the files.\n * @throws IllegalArgumentException if {@code directory} is null or not a directory.\n * @see FilenameUtils#directoryContains(String,String)\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.doCopyDirectory#1243",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.doCopyDirectory(java.io.File, java.io.File, java.io.FileFilter, boolean, java.util.List\u003cjava.lang.String\u003e)",
    "snippet": "private static void doCopyDirectory(final File srcDir, final File destDir, final FileFilter filter,\n                                        final boolean preserveFileDate, final List\u003cString\u003e exclusionList)\n            throws IOException {\n        // recurse\n        final File[] srcFiles \u003d filter \u003d\u003d null ? srcDir.listFiles() : srcDir.listFiles(filter);\n        if (srcFiles \u003d\u003d null) {  // null if abstract pathname does not denote a directory, or if an I/O error occurs\n            throw new IOException(\"Failed to list contents of \" + srcDir);\n        }\n        if (destDir.exists()) {\n            if (destDir.isDirectory() \u003d\u003d false) {\n                throw new IOException(\"Destination \u0027\" + destDir + \"\u0027 exists but is not a directory\");\n            }\n        } else {\n            if (!destDir.mkdirs() \u0026\u0026 !destDir.isDirectory()) {\n                throw new IOException(\"Destination \u0027\" + destDir + \"\u0027 directory cannot be created\");\n            }\n        }\n        if (destDir.canWrite() \u003d\u003d false) {\n            throw new IOException(\"Destination \u0027\" + destDir + \"\u0027 cannot be written to\");\n        }\n        for (final File srcFile : srcFiles) {\n            final File dstFile \u003d new File(destDir, srcFile.getName());\n            if (exclusionList \u003d\u003d null || !exclusionList.contains(srcFile.getCanonicalPath())) {\n                if (srcFile.isDirectory()) {\n                    doCopyDirectory(srcFile, dstFile, filter, preserveFileDate, exclusionList);\n                } else {\n                    doCopyFile(srcFile, dstFile, preserveFileDate);\n                }\n            }\n        }\n\n        // Do this last, as the above has probably affected directory metadata\n        if (preserveFileDate) {\n            destDir.setLastModified(srcDir.lastModified());\n        }\n    }",
    "begin_line": 1243,
    "end_line": 1278,
    "comment": "/** \n * Internal copy directory method.\n * @param srcDir           the validated source directory, must not be {@code null}\n * @param destDir          the validated destination directory, must not be {@code null}\n * @param filter           the filter to apply, null means copy all directories and files\n * @param preserveFileDate whether to preserve the file date\n * @param exclusionList    List of files and directories to exclude from the copy, may be null\n * @throws IOException if an error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.doCopyFile#1297",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.doCopyFile(java.io.File, java.io.File, boolean)",
    "snippet": "private static void doCopyFile(final File srcFile, final File destFile, final boolean preserveFileDate)\n            throws IOException {\n        if (destFile.exists() \u0026\u0026 destFile.isDirectory()) {\n            throw new IOException(\"Destination \u0027\" + destFile + \"\u0027 exists but is a directory\");\n        }\n\n        final Path srcPath \u003d srcFile.toPath();\n        final Path destPath \u003d destFile.toPath();\n        final long newLastModifed \u003d preserveFileDate ? srcFile.lastModified() : destFile.lastModified();\n        Files.copy(srcPath, destPath, StandardCopyOption.REPLACE_EXISTING);\n\n        // TODO IO-386: Do we still need this check?\n        checkEqualSizes(srcFile, destFile, Files.size(srcPath), Files.size(destPath));\n        // TODO IO-386: Do we still need this check?\n        checkEqualSizes(srcFile, destFile, srcFile.length(), destFile.length());\n\n        destFile.setLastModified(newLastModifed);\n    }",
    "begin_line": 1297,
    "end_line": 1314,
    "comment": "/** \n * Internal copy file method. This uses the original file length, and throws an IOException if the output file length is different from the current input file length. So it may fail if the file changes size. It may also fail with \"IllegalArgumentException: Negative size\" if the input file is truncated part way through copying the data and the new file size is less than the current position.\n * @param srcFile          the validated source file, must not be {@code null}\n * @param destFile         the validated destination file, must not be {@code null}\n * @param preserveFileDate whether to preserve the file date\n * @throws IOException              if an error occurs\n * @throws IOException              if the output file length is not the same as the input file length after thecopy completes\n * @throws IllegalArgumentException \"Negative size\" if the file is truncated so that the size is less than theposition\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.forceDelete#1333",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.forceDelete(java.io.File)",
    "snippet": "public static void forceDelete(final File file) throws IOException {\n        final Counters.PathCounters deleteCounters;\n        try {\n            deleteCounters \u003d PathUtils.delete(file.toPath());\n        } catch (IOException e) {\n            throw new IOException(\"Unable to delete file: \" + file, e);\n        }\n\n        if (deleteCounters.getFileCounter().get() \u003c 1 \u0026\u0026 deleteCounters.getDirectoryCounter().get() \u003c 1) {\n            // didn\u0027t find a file to delete.\n            throw new FileNotFoundException(\"File does not exist: \" + file);\n        }\n    }",
    "begin_line": 1333,
    "end_line": 1345,
    "comment": "/** \n * Deletes a file. If file is a directory, delete it and all sub-directories. \u003cp\u003e The difference between File.delete() and this method are: \u003c/p\u003e \u003cul\u003e \u003cli\u003eThe directory does not have to be empty.\u003c/li\u003e \u003cli\u003eYou get exceptions when a file or directory cannot be delete; {@link java.io.File#delete()} returns a boolean.\u003c/li\u003e\u003c/ul\u003e\n * @param file file or directory to delete, must not be {@code null}\n * @throws NullPointerException  if the directory is {@code null}\n * @throws FileNotFoundException if the file was not found\n * @throws IOException           in case deletion is unsuccessful\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.forceDeleteOnExit#1355",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.forceDeleteOnExit(java.io.File)",
    "snippet": "public static void forceDeleteOnExit(final File file) throws IOException {\n        if (file.isDirectory()) {\n            deleteDirectoryOnExit(file);\n        } else {\n            file.deleteOnExit();\n        }\n    }",
    "begin_line": 1355,
    "end_line": 1361,
    "comment": "/** \n * Schedules a file to be deleted when JVM exits. If file is directory delete it and all sub-directories.\n * @param file file or directory to delete, must not be {@code null}\n * @throws NullPointerException if the file is {@code null}\n * @throws IOException          in case deletion is unsuccessful\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.forceMkdir#1374",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.forceMkdir(java.io.File)",
    "snippet": "public static void forceMkdir(final File directory) throws IOException {\n        if (directory.exists()) {\n            if (!directory.isDirectory()) {\n                final String message \u003d\n                        \"File \"\n                                + directory\n                                + \" exists and is \"\n                                + \"not a directory. Unable to create directory.\";\n                throw new IOException(message);\n            }\n        } else {\n            if (!directory.mkdirs()) {\n                // Double-check that some other thread or process hasn\u0027t made\n                // the directory in the background\n                if (!directory.isDirectory()) {\n                    final String message \u003d\n                            \"Unable to create directory \" + directory;\n                    throw new IOException(message);\n                }\n            }\n        }\n    }",
    "begin_line": 1374,
    "end_line": 1395,
    "comment": "/** \n * Makes a directory, including any necessary but nonexistent parent directories. If a file already exists with specified name but it is not a directory then an IOException is thrown. If the directory cannot be created (or the file already exists but is not a directory) then an IOException is thrown.\n * @param directory directory to create, must not be {@code null}\n * @throws NullPointerException if the directory is {@code null}\n * @throws IOException          if the directory cannot be created or the file already exists but is not a directory\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.forceMkdirParent#1406",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.forceMkdirParent(java.io.File)",
    "snippet": "public static void forceMkdirParent(final File file) throws IOException {\n        final File parent \u003d file.getParentFile();\n        if (parent \u003d\u003d null) {\n            return;\n        }\n        forceMkdir(parent);\n    }",
    "begin_line": 1406,
    "end_line": 1412,
    "comment": "/** \n * Makes any necessary but nonexistent parent directories for a given File. If the parent directory cannot be created then an IOException is thrown.\n * @param file file with parent to create, must not be {@code null}\n * @throws NullPointerException if the file is {@code null}\n * @throws IOException          if the parent directory cannot be created\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.getFile#1423",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.getFile(java.io.File, java.lang.String)",
    "snippet": "public static File getFile(final File directory, final String... names) {\n        if (directory \u003d\u003d null) {\n            throw new NullPointerException(\"directory must not be null\");\n        }\n        if (names \u003d\u003d null) {\n            throw new NullPointerException(\"names must not be null\");\n        }\n        File file \u003d directory;\n        for (final String name : names) {\n            file \u003d new File(file, name);\n        }\n        return file;\n    }",
    "begin_line": 1423,
    "end_line": 1435,
    "comment": "/** \n * Construct a file from the set of name elements.\n * @param directory the parent directory\n * @param names the name elements\n * @return the file\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.getFile#1444",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.getFile(java.lang.String)",
    "snippet": "public static File getFile(final String... names) {\n        if (names \u003d\u003d null) {\n            throw new NullPointerException(\"names must not be null\");\n        }\n        File file \u003d null;\n        for (final String name : names) {\n            if (file \u003d\u003d null) {\n                file \u003d new File(name);\n            } else {\n                file \u003d new File(file, name);\n            }\n        }\n        return file;\n    }",
    "begin_line": 1444,
    "end_line": 1457,
    "comment": "/** \n * Construct a file from the set of name elements.\n * @param names the name elements\n * @return the file\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.getTempDirectory#1466",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.getTempDirectory()",
    "snippet": "public static File getTempDirectory() {\n        return new File(getTempDirectoryPath());\n    }",
    "begin_line": 1466,
    "end_line": 1468,
    "comment": "/** \n * Returns a  {@link File} representing the system temporary directory.\n * @return the system temporary directory.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.getTempDirectoryPath#1477",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.getTempDirectoryPath()",
    "snippet": "public static String getTempDirectoryPath() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }",
    "begin_line": 1477,
    "end_line": 1479,
    "comment": "/** \n * Returns the path to the system temporary directory.\n * @return the path to the system temporary directory.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.getUserDirectory#1488",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.getUserDirectory()",
    "snippet": "public static File getUserDirectory() {\n        return new File(getUserDirectoryPath());\n    }",
    "begin_line": 1488,
    "end_line": 1490,
    "comment": "/** \n * Returns a  {@link File} representing the user\u0027s home directory.\n * @return the user\u0027s home directory.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.getUserDirectoryPath#1499",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.getUserDirectoryPath()",
    "snippet": "public static String getUserDirectoryPath() {\n        return System.getProperty(\"user.home\");\n    }",
    "begin_line": 1499,
    "end_line": 1501,
    "comment": "/** \n * Returns the path to the user\u0027s home directory.\n * @return the path to the user\u0027s home directory.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.innerListFiles#1513",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.innerListFiles(java.util.Collection\u003cjava.io.File\u003e, java.io.File, org.apache.commons.io.filefilter.IOFileFilter, boolean)",
    "snippet": "private static void innerListFiles(final Collection\u003cFile\u003e files, final File directory,\n                                       final IOFileFilter filter, final boolean includeSubDirectories) {\n        final File[] found \u003d directory.listFiles((FileFilter) filter);\n\n        if (found !\u003d null) {\n            for (final File file : found) {\n                if (file.isDirectory()) {\n                    if (includeSubDirectories) {\n                        files.add(file);\n                    }\n                    innerListFiles(files, file, filter, includeSubDirectories);\n                } else {\n                    files.add(file);\n                }\n            }\n        }\n    }",
    "begin_line": 1513,
    "end_line": 1529,
    "comment": "/** \n * Finds files within a given directory (and optionally its subdirectories). All files found are filtered by an IOFileFilter.\n * @param files                 the collection of files found.\n * @param directory             the directory to search in.\n * @param filter                the filter to apply to files and directories.\n * @param includeSubDirectories indicates if will include the subdirectories themselves\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.innerListFilesOrDirectories#1546",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.innerListFilesOrDirectories(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter, boolean)",
    "snippet": "private static Collection\u003cFile\u003e innerListFilesOrDirectories(\n            final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter,\n            final boolean includeSubDirectories) {\n        validateListFilesParameters(directory, fileFilter);\n\n        final IOFileFilter effFileFilter \u003d setUpEffectiveFileFilter(fileFilter);\n        final IOFileFilter effDirFilter \u003d setUpEffectiveDirFilter(dirFilter);\n\n        //Find files\n        final Collection\u003cFile\u003e files \u003d new java.util.LinkedList\u003c\u003e();\n        if (includeSubDirectories) {\n            files.add(directory);\n        }\n        innerListFiles(files, directory,\n                FileFilterUtils.or(effFileFilter, effDirFilter), includeSubDirectories);\n        return files;\n    }",
    "begin_line": 1546,
    "end_line": 1562,
    "comment": "/** \n * Finds files within a given directory (and optionally its subdirectories). All files found are filtered by an IOFileFilter.\n * @param directory             the directory to search in\n * @param fileFilter            filter to apply when finding files.\n * @param dirFilter             optional filter to apply when finding subdirectories.If this parameter is  {@code null}, subdirectories will not be included in the search. Use TrueFileFilter.INSTANCE to match all directories.\n * @param includeSubDirectories indicates if will include the subdirectories themselves\n * @return a collection of java.io.File with the matching files\n * @see org.apache.commons.io.FileUtils#listFiles\n * @see org.apache.commons.io.filefilter.FileFilterUtils\n * @see org.apache.commons.io.filefilter.NameFileFilter\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.isFileNewer#1576",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.isFileNewer(java.io.File, java.util.Date)",
    "snippet": "public static boolean isFileNewer(final File file, final Date date) {\n        if (date \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No specified date\");\n        }\n        return isFileNewer(file, date.getTime());\n    }",
    "begin_line": 1576,
    "end_line": 1581,
    "comment": "/** \n * Tests if the specified \u003ccode\u003eFile\u003c/code\u003e is newer than the specified \u003ccode\u003eDate\u003c/code\u003e.\n * @param file the \u003ccode\u003eFile\u003c/code\u003e of which the modification datemust be compared, must not be  {@code null}\n * @param date the date reference, must not be {@code null}\n * @return true if the \u003ccode\u003eFile\u003c/code\u003e exists and has been modifiedafter the given \u003ccode\u003eDate\u003c/code\u003e.\n * @throws IllegalArgumentException if the file is {@code null}\n * @throws IllegalArgumentException if the date is {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.isFileNewer#1597",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.isFileNewer(java.io.File, java.io.File)",
    "snippet": "public static boolean isFileNewer(final File file, final File reference) {\n        if (reference \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No specified reference file\");\n        }\n        if (!reference.exists()) {\n            throw new IllegalArgumentException(\"The reference file \u0027\"\n                    + reference + \"\u0027 doesn\u0027t exist\");\n        }\n        return isFileNewer(file, reference.lastModified());\n    }",
    "begin_line": 1597,
    "end_line": 1606,
    "comment": "/** \n * Tests if the specified \u003ccode\u003eFile\u003c/code\u003e is newer than the reference \u003ccode\u003eFile\u003c/code\u003e.\n * @param file      the \u003ccode\u003eFile\u003c/code\u003e of which the modification date mustbe compared, must not be  {@code null}\n * @param reference the \u003ccode\u003eFile\u003c/code\u003e of which the modification dateis used, must not be  {@code null}\n * @return true if the \u003ccode\u003eFile\u003c/code\u003e exists and has been modified morerecently than the reference \u003ccode\u003eFile\u003c/code\u003e\n * @throws IllegalArgumentException if the file is {@code null}\n * @throws IllegalArgumentException if the reference file is {@code null} or doesn\u0027t exist\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.isFileNewer#1620",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.isFileNewer(java.io.File, long)",
    "snippet": "public static boolean isFileNewer(final File file, final long timeMillis) {\n        if (file \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No specified file\");\n        }\n        if (!file.exists()) {\n            return false;\n        }\n        return file.lastModified() \u003e timeMillis;\n    }",
    "begin_line": 1620,
    "end_line": 1628,
    "comment": "/** \n * Tests if the specified \u003ccode\u003eFile\u003c/code\u003e is newer than the specified time reference.\n * @param file       the \u003ccode\u003eFile\u003c/code\u003e of which the modification date mustbe compared, must not be  {@code null}\n * @param timeMillis the time reference measured in milliseconds since theepoch (00:00:00 GMT, January 1, 1970)\n * @return true if the \u003ccode\u003eFile\u003c/code\u003e exists and has been modified afterthe given time reference.\n * @throws IllegalArgumentException if the file is {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.isFileOlder#1642",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.isFileOlder(java.io.File, java.util.Date)",
    "snippet": "public static boolean isFileOlder(final File file, final Date date) {\n        if (date \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No specified date\");\n        }\n        return isFileOlder(file, date.getTime());\n    }",
    "begin_line": 1642,
    "end_line": 1647,
    "comment": "/** \n * Tests if the specified \u003ccode\u003eFile\u003c/code\u003e is older than the specified \u003ccode\u003eDate\u003c/code\u003e.\n * @param file the \u003ccode\u003eFile\u003c/code\u003e of which the modification datemust be compared, must not be  {@code null}\n * @param date the date reference, must not be {@code null}\n * @return true if the \u003ccode\u003eFile\u003c/code\u003e exists and has been modifiedbefore the given \u003ccode\u003eDate\u003c/code\u003e.\n * @throws IllegalArgumentException if the file is {@code null}\n * @throws IllegalArgumentException if the date is {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.isFileOlder#1663",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.isFileOlder(java.io.File, java.io.File)",
    "snippet": "public static boolean isFileOlder(final File file, final File reference) {\n        if (reference \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No specified reference file\");\n        }\n        if (!reference.exists()) {\n            throw new IllegalArgumentException(\"The reference file \u0027\"\n                    + reference + \"\u0027 doesn\u0027t exist\");\n        }\n        return isFileOlder(file, reference.lastModified());\n    }",
    "begin_line": 1663,
    "end_line": 1672,
    "comment": "/** \n * Tests if the specified \u003ccode\u003eFile\u003c/code\u003e is older than the reference \u003ccode\u003eFile\u003c/code\u003e.\n * @param file      the \u003ccode\u003eFile\u003c/code\u003e of which the modification date mustbe compared, must not be  {@code null}\n * @param reference the \u003ccode\u003eFile\u003c/code\u003e of which the modification dateis used, must not be  {@code null}\n * @return true if the \u003ccode\u003eFile\u003c/code\u003e exists and has been modified beforethe reference \u003ccode\u003eFile\u003c/code\u003e\n * @throws IllegalArgumentException if the file is {@code null}\n * @throws IllegalArgumentException if the reference file is {@code null} or doesn\u0027t exist\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.isFileOlder#1686",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.isFileOlder(java.io.File, long)",
    "snippet": "public static boolean isFileOlder(final File file, final long timeMillis) {\n        if (file \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No specified file\");\n        }\n        if (!file.exists()) {\n            return false;\n        }\n        return file.lastModified() \u003c timeMillis;\n    }",
    "begin_line": 1686,
    "end_line": 1694,
    "comment": "/** \n * Tests if the specified \u003ccode\u003eFile\u003c/code\u003e is older than the specified time reference.\n * @param file       the \u003ccode\u003eFile\u003c/code\u003e of which the modification date mustbe compared, must not be  {@code null}\n * @param timeMillis the time reference measured in milliseconds since theepoch (00:00:00 GMT, January 1, 1970)\n * @return true if the \u003ccode\u003eFile\u003c/code\u003e exists and has been modified beforethe given time reference.\n * @throws IllegalArgumentException if the file is {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.isSymlink#1719",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.isSymlink(java.io.File)",
    "snippet": "public static boolean isSymlink(final File file) {\n        if (file \u003d\u003d null) {\n            throw new NullPointerException(\"File must not be null\");\n        }\n        return Files.isSymbolicLink(file.toPath());\n    }",
    "begin_line": 1719,
    "end_line": 1724,
    "comment": "/** \n * Determines whether the specified file is a Symbolic Link rather than an actual file. \u003cp\u003e Will not return true if there is a Symbolic Link anywhere in the path, only if the specific file is. \u003c/p\u003e \u003cp\u003e When using jdk1.7, this method delegates to  {@code boolean java.nio.file.Files.isSymbolicLink(Path path)}\u003c/p\u003e \u003cp\u003e \u003cb\u003eNote:\u003c/b\u003e the current implementation always returns  {@code false} if running onjkd1.6 and the system is detected as Windows using  {@link FilenameUtils#isSystemWindows()}\u003c/p\u003e \u003cp\u003e For code that runs on Java 1.7 or later, use the following method instead: \u003c/p\u003e {@code boolean java.nio.file.Files.isSymbolicLink(Path path)}\n * @param file the file to check\n * @return true if the file is a Symbolic Link\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.iterateFiles#1745",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.iterateFiles(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static Iterator\u003cFile\u003e iterateFiles(\n            final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n        return listFiles(directory, fileFilter, dirFilter).iterator();\n    }",
    "begin_line": 1745,
    "end_line": 1748,
    "comment": "/** \n * Allows iteration over the files in given directory (and optionally its subdirectories). \u003cp\u003e All files found are filtered by an IOFileFilter. This method is based on  {@link #listFiles(File,IOFileFilter,IOFileFilter)}, which supports Iterable (\u0027foreach\u0027 loop). \u003c/p\u003e\n * @param directory  the directory to search in\n * @param fileFilter filter to apply when finding files.\n * @param dirFilter  optional filter to apply when finding subdirectories.If this parameter is  {@code null}, subdirectories will not be included in the search. Use TrueFileFilter.INSTANCE to match all directories.\n * @return an iterator of java.io.File for the matching files\n * @see org.apache.commons.io.filefilter.FileFilterUtils\n * @see org.apache.commons.io.filefilter.NameFileFilter\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.iterateFiles#1763",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.iterateFiles(java.io.File, java.lang.String[], boolean)",
    "snippet": "public static Iterator\u003cFile\u003e iterateFiles(\n            final File directory, final String[] extensions, final boolean recursive) {\n        return listFiles(directory, extensions, recursive).iterator();\n    }",
    "begin_line": 1763,
    "end_line": 1766,
    "comment": "/** \n * Allows iteration over the files in a given directory (and optionally its subdirectories) which match an array of extensions. This method is based on  {@link #listFiles(File,String[],boolean)}, which supports Iterable (\u0027foreach\u0027 loop).\n * @param directory  the directory to search in\n * @param extensions an array of extensions, ex. {\"java\",\"xml\"}. If thisparameter is  {@code null}, all files are returned.\n * @param recursive  if true all subdirectories are searched as well\n * @return an iterator of java.io.File with the matching files\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.iterateFilesAndDirs#1790",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.iterateFilesAndDirs(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static Iterator\u003cFile\u003e iterateFilesAndDirs(final File directory, final IOFileFilter fileFilter,\n                                                     final IOFileFilter dirFilter) {\n        return listFilesAndDirs(directory, fileFilter, dirFilter).iterator();\n    }",
    "begin_line": 1790,
    "end_line": 1793,
    "comment": "/** \n * Allows iteration over the files in given directory (and optionally its subdirectories). \u003cp\u003e All files found are filtered by an IOFileFilter. This method is based on  {@link #listFilesAndDirs(File,IOFileFilter,IOFileFilter)}, which supports Iterable (\u0027foreach\u0027 loop). \u003c/p\u003e \u003cp\u003e The resulting iterator includes the subdirectories themselves. \u003c/p\u003e\n * @param directory  the directory to search in\n * @param fileFilter filter to apply when finding files.\n * @param dirFilter  optional filter to apply when finding subdirectories.If this parameter is  {@code null}, subdirectories will not be included in the search. Use TrueFileFilter.INSTANCE to match all directories.\n * @return an iterator of java.io.File for the matching files\n * @see org.apache.commons.io.filefilter.FileFilterUtils\n * @see org.apache.commons.io.filefilter.NameFileFilter\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.lineIterator#1804",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.lineIterator(java.io.File)",
    "snippet": "public static LineIterator lineIterator(final File file) throws IOException {\n        return lineIterator(file, null);\n    }",
    "begin_line": 1804,
    "end_line": 1806,
    "comment": "/** \n * Returns an Iterator for the lines in a \u003ccode\u003eFile\u003c/code\u003e using the default encoding for the VM.\n * @param file the file to open for input, must not be {@code null}\n * @return an Iterator of the lines in the file, never {@code null}\n * @throws IOException in case of an I/O error (file closed)\n * @see #lineIterator(File,String)\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.lineIterator#1842",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.lineIterator(java.io.File, java.lang.String)",
    "snippet": "public static LineIterator lineIterator(final File file, final String encoding) throws IOException {\n        InputStream inputStream \u003d null;\n        try {\n            inputStream \u003d openInputStream(file);\n            return IOUtils.lineIterator(inputStream, encoding);\n        } catch (final IOException | RuntimeException ex) {\n            IOUtils.closeQuietly(inputStream, e -\u003e ex.addSuppressed(e));\n            throw ex;\n        }\n    }",
    "begin_line": 1842,
    "end_line": 1851,
    "comment": "/** \n * Returns an Iterator for the lines in a \u003ccode\u003eFile\u003c/code\u003e. \u003cp\u003e This method opens an \u003ccode\u003eInputStream\u003c/code\u003e for the file. When you have finished with the iterator you should close the stream to free internal resources. This can be done by calling the {@link LineIterator#close()} or{@link LineIterator#closeQuietly(LineIterator)} method.\u003c/p\u003e \u003cp\u003e The recommended usage pattern is: \u003c/p\u003e \u003cpre\u003e LineIterator it \u003d FileUtils.lineIterator(file, \"UTF-8\"); try { while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { LineIterator.closeQuietly(iterator); } \u003c/pre\u003e \u003cp\u003e If an exception occurs during the creation of the iterator, the underlying stream is closed. \u003c/p\u003e\n * @param file     the file to open for input, must not be {@code null}\n * @param encoding the encoding to use, {@code null} means platform default\n * @return an Iterator of the lines in the file, never {@code null}\n * @throws IOException in case of an I/O error (file closed)\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.listFiles#1882",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static Collection\u003cFile\u003e listFiles(\n            final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n        return innerListFilesOrDirectories(directory, fileFilter, dirFilter, false);\n    }",
    "begin_line": 1882,
    "end_line": 1885,
    "comment": "/** \n * Finds files within a given directory (and optionally its subdirectories). All files found are filtered by an IOFileFilter. \u003cp\u003e If your search should recurse into subdirectories you can pass in an IOFileFilter for directories. You don\u0027t need to bind a DirectoryFileFilter (via logical AND) to this filter. This method does that for you. \u003c/p\u003e \u003cp\u003e An example: If you want to search through all directories called \"temp\" you pass in \u003ccode\u003eFileFilterUtils.NameFileFilter(\"temp\")\u003c/code\u003e \u003c/p\u003e \u003cp\u003e Another common usage of this method is find files in a directory tree but ignoring the directories generated CVS. You can simply pass in \u003ccode\u003eFileFilterUtils.makeCVSAware(null)\u003c/code\u003e. \u003c/p\u003e\n * @param directory  the directory to search in\n * @param fileFilter filter to apply when finding files. Must not be {@code null}, use  {@link TrueFileFilter#INSTANCE} to match all files in selected directories.\n * @param dirFilter  optional filter to apply when finding subdirectories.If this parameter is  {@code null}, subdirectories will not be included in the search. Use  {@link TrueFileFilter#INSTANCE} to match all directories.\n * @return a collection of java.io.File with the matching files\n * @see org.apache.commons.io.filefilter.FileFilterUtils\n * @see org.apache.commons.io.filefilter.NameFileFilter\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.listFiles#1898",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, java.lang.String[], boolean)",
    "snippet": "public static Collection\u003cFile\u003e listFiles(\n            final File directory, final String[] extensions, final boolean recursive) {\n        IOFileFilter filter;\n        if (extensions \u003d\u003d null) {\n            filter \u003d TrueFileFilter.INSTANCE;\n        } else {\n            final String[] suffixes \u003d toSuffixes(extensions);\n            filter \u003d new SuffixFileFilter(suffixes);\n        }\n        return listFiles(directory, filter,\n                recursive ? TrueFileFilter.INSTANCE : FalseFileFilter.INSTANCE);\n    }",
    "begin_line": 1898,
    "end_line": 1909,
    "comment": "/** \n * Finds files within a given directory (and optionally its subdirectories) which match an array of extensions.\n * @param directory  the directory to search in\n * @param extensions an array of extensions, ex. {\"java\",\"xml\"}. If thisparameter is  {@code null}, all files are returned.\n * @param recursive  if true all subdirectories are searched as well\n * @return a collection of java.io.File with the matching files\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.listFilesAndDirs#1930",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.listFilesAndDirs(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static Collection\u003cFile\u003e listFilesAndDirs(\n            final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n        return innerListFilesOrDirectories(directory, fileFilter, dirFilter, true);\n    }",
    "begin_line": 1930,
    "end_line": 1933,
    "comment": "/** \n * Finds files within a given directory (and optionally its subdirectories). All files found are filtered by an IOFileFilter. \u003cp\u003e The resulting collection includes the starting directory and any subdirectories that match the directory filter. \u003c/p\u003e\n * @param directory  the directory to search in\n * @param fileFilter filter to apply when finding files.\n * @param dirFilter  optional filter to apply when finding subdirectories.If this parameter is  {@code null}, subdirectories will not be included in the search. Use TrueFileFilter.INSTANCE to match all directories.\n * @return a collection of java.io.File with the matching files\n * @see org.apache.commons.io.FileUtils#listFiles\n * @see org.apache.commons.io.filefilter.FileFilterUtils\n * @see org.apache.commons.io.filefilter.NameFileFilter\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.moveDirectory#1949",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
    "snippet": "public static void moveDirectory(final File srcDir, final File destDir) throws IOException {\n        validateMoveParameters(srcDir, destDir);\n        if (!srcDir.isDirectory()) {\n            throw new IOException(\"Source \u0027\" + srcDir + \"\u0027 is not a directory\");\n        }\n        if (destDir.exists()) {\n            throw new FileExistsException(\"Destination \u0027\" + destDir + \"\u0027 already exists\");\n        }\n        final boolean rename \u003d srcDir.renameTo(destDir);\n        if (!rename) {\n            if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator)) {\n                throw new IOException(\"Cannot move directory: \" + srcDir + \" to a subdirectory of itself: \" + destDir);\n            }\n            copyDirectory(srcDir, destDir);\n            deleteDirectory(srcDir);\n            if (srcDir.exists()) {\n                throw new IOException(\"Failed to delete original directory \u0027\" + srcDir +\n                        \"\u0027 after copy to \u0027\" + destDir + \"\u0027\");\n            }\n        }\n    }",
    "begin_line": 1949,
    "end_line": 1969,
    "comment": "/** \n * Moves a directory. \u003cp\u003e When the destination directory is on another file system, do a \"copy and delete\". \u003c/p\u003e\n * @param srcDir  the directory to be moved\n * @param destDir the destination directory\n * @throws NullPointerException if source or destination is {@code null}\n * @throws FileExistsException  if the destination directory exists\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs moving the file\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.moveDirectoryToDirectory#1984",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.moveDirectoryToDirectory(java.io.File, java.io.File, boolean)",
    "snippet": "public static void moveDirectoryToDirectory(final File src, final File destDir, final boolean createDestDir)\n            throws IOException {\n        validateMoveParameters(src, destDir);\n        if (!destDir.exists() \u0026\u0026 createDestDir) {\n            destDir.mkdirs();\n        }\n        if (!destDir.exists()) {\n            throw new FileNotFoundException(\"Destination directory \u0027\" + destDir +\n                    \"\u0027 does not exist [createDestDir\u003d\" + createDestDir + \"]\");\n        }\n        if (!destDir.isDirectory()) {\n            throw new IOException(\"Destination \u0027\" + destDir + \"\u0027 is not a directory\");\n        }\n        moveDirectory(src, new File(destDir, src.getName()));\n    }",
    "begin_line": 1984,
    "end_line": 1998,
    "comment": "/** \n * Moves a directory to another directory.\n * @param src           the file to be moved\n * @param destDir       the destination file\n * @param createDestDir If {@code true} create the destination directory,otherwise if  {@code false} throw an IOException\n * @throws NullPointerException if source or destination is {@code null}\n * @throws FileExistsException  if the directory exists in the destination directory\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs moving the file\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.moveFile#2014",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.moveFile(java.io.File, java.io.File)",
    "snippet": "public static void moveFile(final File srcFile, final File destFile) throws IOException {\n        validateMoveParameters(srcFile, destFile);\n        if (srcFile.isDirectory()) {\n            throw new IOException(\"Source \u0027\" + srcFile + \"\u0027 is a directory\");\n        }\n        if (destFile.exists()) {\n            throw new FileExistsException(\"Destination \u0027\" + destFile + \"\u0027 already exists\");\n        }\n        if (destFile.isDirectory()) {\n            throw new IOException(\"Destination \u0027\" + destFile + \"\u0027 is a directory\");\n        }\n        final boolean rename \u003d srcFile.renameTo(destFile);\n        if (!rename) {\n            copyFile(srcFile, destFile);\n            if (!srcFile.delete()) {\n                FileUtils.deleteQuietly(destFile);\n                throw new IOException(\"Failed to delete original file \u0027\" + srcFile +\n                        \"\u0027 after copy to \u0027\" + destFile + \"\u0027\");\n            }\n        }\n    }",
    "begin_line": 2014,
    "end_line": 2034,
    "comment": "/** \n * Moves a file. \u003cp\u003e When the destination file is on another file system, do a \"copy and delete\". \u003c/p\u003e\n * @param srcFile  the file to be moved\n * @param destFile the destination file\n * @throws NullPointerException if source or destination is {@code null}\n * @throws FileExistsException  if the destination file exists\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs moving the file\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.moveFileToDirectory#2049",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.moveFileToDirectory(java.io.File, java.io.File, boolean)",
    "snippet": "public static void moveFileToDirectory(final File srcFile, final File destDir, final boolean createDestDir)\n            throws IOException {\n        validateMoveParameters(srcFile, destDir);\n        if (!destDir.exists() \u0026\u0026 createDestDir) {\n            destDir.mkdirs();\n        }\n        if (!destDir.exists()) {\n            throw new FileNotFoundException(\"Destination directory \u0027\" + destDir +\n                    \"\u0027 does not exist [createDestDir\u003d\" + createDestDir + \"]\");\n        }\n        if (!destDir.isDirectory()) {\n            throw new IOException(\"Destination \u0027\" + destDir + \"\u0027 is not a directory\");\n        }\n        moveFile(srcFile, new File(destDir, srcFile.getName()));\n    }",
    "begin_line": 2049,
    "end_line": 2063,
    "comment": "/** \n * Moves a file to a directory.\n * @param srcFile       the file to be moved\n * @param destDir       the destination file\n * @param createDestDir If {@code true} create the destination directory,otherwise if  {@code false} throw an IOException\n * @throws NullPointerException if source or destination is {@code null}\n * @throws FileExistsException  if the destination file exists\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs moving the file\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.moveToDirectory#2081",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.moveToDirectory(java.io.File, java.io.File, boolean)",
    "snippet": "public static void moveToDirectory(final File src, final File destDir, final boolean createDestDir)\n            throws IOException {\n        validateMoveParameters(src, destDir);\n        if (src.isDirectory()) {\n            moveDirectoryToDirectory(src, destDir, createDestDir);\n        } else {\n            moveFileToDirectory(src, destDir, createDestDir);\n        }\n    }",
    "begin_line": 2081,
    "end_line": 2089,
    "comment": "/** \n * Moves a file or directory to the destination directory. \u003cp\u003e When the destination is on another file system, do a \"copy and delete\". \u003c/p\u003e\n * @param src           the file or directory to be moved\n * @param destDir       the destination directory\n * @param createDestDir If {@code true} create the destination directory,otherwise if  {@code false} throw an IOException\n * @throws NullPointerException if source or destination is {@code null}\n * @throws FileExistsException  if the directory or file exists in the destination directory\n * @throws IOException          if source or destination is invalid\n * @throws IOException          if an IO error occurs moving the file\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.openInputStream#2114",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.openInputStream(java.io.File)",
    "snippet": "public static FileInputStream openInputStream(final File file) throws IOException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                throw new IOException(\"File \u0027\" + file + \"\u0027 exists but is a directory\");\n            }\n            if (file.canRead() \u003d\u003d false) {\n                throw new IOException(\"File \u0027\" + file + \"\u0027 cannot be read\");\n            }\n        } else {\n            throw new FileNotFoundException(\"File \u0027\" + file + \"\u0027 does not exist\");\n        }\n        return new FileInputStream(file);\n    }",
    "begin_line": 2114,
    "end_line": 2126,
    "comment": "/** \n * Opens a  {@link FileInputStream} for the specified file, providing bettererror messages than simply calling \u003ccode\u003enew FileInputStream(file)\u003c/code\u003e. \u003cp\u003e At the end of the method either the stream will be successfully opened, or an exception will have been thrown. \u003c/p\u003e \u003cp\u003e An exception is thrown if the file does not exist. An exception is thrown if the file object exists but is a directory. An exception is thrown if the file exists but cannot be read. \u003c/p\u003e\n * @param file the file to open for input, must not be {@code null}\n * @return a new {@link FileInputStream} for the specified file\n * @throws FileNotFoundException if the file does not exist\n * @throws IOException           if the file object is a directory\n * @throws IOException           if the file cannot be read\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.openOutputStream#2151",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.openOutputStream(java.io.File)",
    "snippet": "public static FileOutputStream openOutputStream(final File file) throws IOException {\n        return openOutputStream(file, false);\n    }",
    "begin_line": 2151,
    "end_line": 2153,
    "comment": "/** \n * Opens a  {@link FileOutputStream} for the specified file, checking andcreating the parent directory if it does not exist. \u003cp\u003e At the end of the method either the stream will be successfully opened, or an exception will have been thrown. \u003c/p\u003e \u003cp\u003e The parent directory will be created if it does not exist. The file will be created if it does not exist. An exception is thrown if the file object exists but is a directory. An exception is thrown if the file exists but cannot be written to. An exception is thrown if the parent directory cannot be created. \u003c/p\u003e\n * @param file the file to open for output, must not be {@code null}\n * @return a new {@link FileOutputStream} for the specified file\n * @throws IOException if the file object is a directory\n * @throws IOException if the file cannot be written to\n * @throws IOException if a parent directory needs creating but that fails\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.openOutputStream#2179",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.openOutputStream(java.io.File, boolean)",
    "snippet": "public static FileOutputStream openOutputStream(final File file, final boolean append) throws IOException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                throw new IOException(\"File \u0027\" + file + \"\u0027 exists but is a directory\");\n            }\n            if (file.canWrite() \u003d\u003d false) {\n                throw new IOException(\"File \u0027\" + file + \"\u0027 cannot be written to\");\n            }\n        } else {\n            final File parent \u003d file.getParentFile();\n            if (parent !\u003d null) {\n                if (!parent.mkdirs() \u0026\u0026 !parent.isDirectory()) {\n                    throw new IOException(\"Directory \u0027\" + parent + \"\u0027 could not be created\");\n                }\n            }\n        }\n        return new FileOutputStream(file, append);\n    }",
    "begin_line": 2179,
    "end_line": 2196,
    "comment": "/** \n * Opens a  {@link FileOutputStream} for the specified file, checking andcreating the parent directory if it does not exist. \u003cp\u003e At the end of the method either the stream will be successfully opened, or an exception will have been thrown. \u003c/p\u003e \u003cp\u003e The parent directory will be created if it does not exist. The file will be created if it does not exist. An exception is thrown if the file object exists but is a directory. An exception is thrown if the file exists but cannot be written to. An exception is thrown if the parent directory cannot be created. \u003c/p\u003e\n * @param file   the file to open for output, must not be {@code null}\n * @param append if {@code true}, then bytes will be added to the end of the file rather than overwriting\n * @return a new {@link FileOutputStream} for the specified file\n * @throws IOException if the file object is a directory\n * @throws IOException if the file cannot be written to\n * @throws IOException if a parent directory needs creating but that fails\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.readFileToByteArray#2207",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.readFileToByteArray(java.io.File)",
    "snippet": "public static byte[] readFileToByteArray(final File file) throws IOException {\n        try (InputStream in \u003d openInputStream(file)) {\n            final long fileLength \u003d file.length();\n            // file.length() may return 0 for system-dependent entities, treat 0 as unknown length - see IO-453\n            return fileLength \u003e 0 ? IOUtils.toByteArray(in, fileLength) : IOUtils.toByteArray(in);\n        }\n    }",
    "begin_line": 2207,
    "end_line": 2213,
    "comment": "/** \n * Reads the contents of a file into a byte array. The file is always closed.\n * @param file the file to read, must not be {@code null}\n * @return the file contents, never {@code null}\n * @throws IOException in case of an I/O error\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.readFileToString#2226",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.readFileToString(java.io.File)",
    "snippet": "@Deprecated\n    public static String readFileToString(final File file) throws IOException {\n        return readFileToString(file, Charset.defaultCharset());\n    }",
    "begin_line": 2226,
    "end_line": 2228,
    "comment": "/** \n * Reads the contents of a file into a String using the default encoding for the VM. The file is always closed.\n * @param file the file to read, must not be {@code null}\n * @return the file contents, never {@code null}\n * @throws IOException in case of an I/O error\n * @since 1.3.1\n * @deprecated 2.5 use {@link #readFileToString(File,Charset)} instead (and specify the appropriate encoding)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.readFileToString#2241",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.readFileToString(java.io.File, java.nio.charset.Charset)",
    "snippet": "public static String readFileToString(final File file, final Charset encoding) throws IOException {\n        try (InputStream in \u003d openInputStream(file)) {\n            return IOUtils.toString(in, Charsets.toCharset(encoding));\n        }\n    }",
    "begin_line": 2241,
    "end_line": 2245,
    "comment": "/** \n * Reads the contents of a file into a String. The file is always closed.\n * @param file     the file to read, must not be {@code null}\n * @param encoding the encoding to use, {@code null} means platform default\n * @return the file contents, never {@code null}\n * @throws IOException in case of an I/O error\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.readFileToString#2258",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.readFileToString(java.io.File, java.lang.String)",
    "snippet": "public static String readFileToString(final File file, final String encoding) throws IOException {\n        return readFileToString(file, Charsets.toCharset(encoding));\n    }",
    "begin_line": 2258,
    "end_line": 2260,
    "comment": "/** \n * Reads the contents of a file into a String. The file is always closed.\n * @param file     the file to read, must not be {@code null}\n * @param encoding the encoding to use, {@code null} means platform default\n * @return the file contents, never {@code null}\n * @throws IOException                 in case of an I/O error\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.readLines#2273",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.readLines(java.io.File)",
    "snippet": "@Deprecated\n    public static List\u003cString\u003e readLines(final File file) throws IOException {\n        return readLines(file, Charset.defaultCharset());\n    }",
    "begin_line": 2273,
    "end_line": 2275,
    "comment": "/** \n * Reads the contents of a file line by line to a List of Strings using the default encoding for the VM. The file is always closed.\n * @param file the file to read, must not be {@code null}\n * @return the list of Strings representing each line in the file, never {@code null}\n * @throws IOException in case of an I/O error\n * @since 1.3\n * @deprecated 2.5 use {@link #readLines(File,Charset)} instead (and specify the appropriate encoding)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.readLines#2287",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.readLines(java.io.File, java.nio.charset.Charset)",
    "snippet": "public static List\u003cString\u003e readLines(final File file, final Charset encoding) throws IOException {\n        try (InputStream in \u003d openInputStream(file)) {\n            return IOUtils.readLines(in, Charsets.toCharset(encoding));\n        }\n    }",
    "begin_line": 2287,
    "end_line": 2291,
    "comment": "/** \n * Reads the contents of a file line by line to a List of Strings. The file is always closed.\n * @param file     the file to read, must not be {@code null}\n * @param encoding the encoding to use, {@code null} means platform default\n * @return the list of Strings representing each line in the file, never {@code null}\n * @throws IOException in case of an I/O error\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.readLines#2304",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.readLines(java.io.File, java.lang.String)",
    "snippet": "public static List\u003cString\u003e readLines(final File file, final String encoding) throws IOException {\n        return readLines(file, Charsets.toCharset(encoding));\n    }",
    "begin_line": 2304,
    "end_line": 2306,
    "comment": "/** \n * Reads the contents of a file line by line to a List of Strings. The file is always closed.\n * @param file     the file to read, must not be {@code null}\n * @param encoding the encoding to use, {@code null} means platform default\n * @return the list of Strings representing each line in the file, never {@code null}\n * @throws IOException                 in case of an I/O error\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.setUpEffectiveDirFilter#2314",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.setUpEffectiveDirFilter(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "private static IOFileFilter setUpEffectiveDirFilter(final IOFileFilter dirFilter) {\n        return dirFilter \u003d\u003d null ? FalseFileFilter.INSTANCE : FileFilterUtils.and(dirFilter,\n                DirectoryFileFilter.INSTANCE);\n    }",
    "begin_line": 2314,
    "end_line": 2317,
    "comment": "/** \n * Returns a filter that accepts directories in addition to the  {@link File} objects accepted by the given filter.\n * @param dirFilter a base filter to add to\n * @return a filter that accepts directories\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.setUpEffectiveFileFilter#2325",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.setUpEffectiveFileFilter(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "private static IOFileFilter setUpEffectiveFileFilter(final IOFileFilter fileFilter) {\n        return FileFilterUtils.and(fileFilter, FileFilterUtils.notFileFilter(DirectoryFileFilter.INSTANCE));\n    }",
    "begin_line": 2325,
    "end_line": 2327,
    "comment": "/** \n * Returns a filter that accepts files in addition to the  {@link File} objects accepted by the given filter.\n * @param fileFilter a base filter to add to\n * @return a filter that accepts files\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.sizeOf#2353",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.sizeOf(java.io.File)",
    "snippet": "public static long sizeOf(final File file) {\n\n        if (!file.exists()) {\n            final String message \u003d file + \" does not exist\";\n            throw new IllegalArgumentException(message);\n        }\n\n        if (file.isDirectory()) {\n            return sizeOfDirectory0(file); // private method; expects directory\n        }\n        return file.length();\n\n    }",
    "begin_line": 2353,
    "end_line": 2365,
    "comment": "/** \n * Returns the size of the specified file or directory. If the provided {@link File} is a regular file, then the file\u0027s length is returned.If the argument is a directory, then the size of the directory is calculated recursively. If a directory or subdirectory is security restricted, its size will not be included. \u003cp\u003e Note that overflow is not detected, and the return value may be negative if overflow occurs. See  {@link #sizeOfAsBigInteger(File)} for an alternativemethod that does not overflow. \u003c/p\u003e\n * @param file the regular file or directory to return the sizeof (must not be  {@code null}).\n * @return the length of the file, or recursive size of the directory,provided (in bytes).\n * @throws NullPointerException     if the file is {@code null}\n * @throws IllegalArgumentException if the file does not exist.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.sizeOf0#2372",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.sizeOf0(java.io.File)",
    "snippet": "private static long sizeOf0(final File file) {\n        if (file.isDirectory()) {\n            return sizeOfDirectory0(file);\n        }\n        return file.length(); // will be 0 if file does not exist\n    }",
    "begin_line": 2372,
    "end_line": 2377,
    "comment": "/** \n * the size of a file\n * @param file the file to check\n * @return the size of the file\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.sizeOfAsBigInteger#2397",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.sizeOfAsBigInteger(java.io.File)",
    "snippet": "public static BigInteger sizeOfAsBigInteger(final File file) {\n\n        if (!file.exists()) {\n            final String message \u003d file + \" does not exist\";\n            throw new IllegalArgumentException(message);\n        }\n\n        if (file.isDirectory()) {\n            return sizeOfDirectoryBig0(file); // internal method\n        }\n        return BigInteger.valueOf(file.length());\n\n    }",
    "begin_line": 2397,
    "end_line": 2409,
    "comment": "/** \n * Returns the size of the specified file or directory. If the provided {@link File} is a regular file, then the file\u0027s length is returned.If the argument is a directory, then the size of the directory is calculated recursively. If a directory or subdirectory is security restricted, its size will not be included.\n * @param file the regular file or directory to return the sizeof (must not be  {@code null}).\n * @return the length of the file, or recursive size of the directory,provided (in bytes).\n * @throws NullPointerException     if the file is {@code null}\n * @throws IllegalArgumentException if the file does not exist.\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.sizeOfBig0#2416",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.sizeOfBig0(java.io.File)",
    "snippet": "private static BigInteger sizeOfBig0(final File fileOrDir) {\n        if (fileOrDir.isDirectory()) {\n            return sizeOfDirectoryBig0(fileOrDir);\n        }\n        return BigInteger.valueOf(fileOrDir.length());\n    }",
    "begin_line": 2416,
    "end_line": 2421,
    "comment": "/** \n * Returns the size of a file\n * @param fileOrDir The file\n * @return the size\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.sizeOfDirectory#2436",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.sizeOfDirectory(java.io.File)",
    "snippet": "public static long sizeOfDirectory(final File directory) {\n        checkDirectory(directory);\n        return sizeOfDirectory0(directory);\n    }",
    "begin_line": 2436,
    "end_line": 2439,
    "comment": "/** \n * Counts the size of a directory recursively (sum of the length of all files). \u003cp\u003e Note that overflow is not detected, and the return value may be negative if overflow occurs. See  {@link #sizeOfDirectoryAsBigInteger(File)} for an alternativemethod that does not overflow. \u003c/p\u003e\n * @param directory directory to inspect, must not be {@code null}\n * @return size of directory in bytes, 0 if directory is security restricted, a negative number when the real totalis greater than  {@link Long#MAX_VALUE}.\n * @throws NullPointerException if the directory is {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.sizeOfDirectory0#2446",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.sizeOfDirectory0(java.io.File)",
    "snippet": "private static long sizeOfDirectory0(final File directory) {\n        final File[] files \u003d directory.listFiles();\n        if (files \u003d\u003d null) {  // null if security restricted\n            return 0L;\n        }\n        long size \u003d 0;\n\n        for (final File file : files) {\n            if (!isSymlink(file)) {\n                size +\u003d sizeOf0(file); // internal method\n                if (size \u003c 0) {\n                    break;\n                }\n            }\n        }\n\n        return size;\n    }",
    "begin_line": 2446,
    "end_line": 2463,
    "comment": "/** \n * the size of a director\n * @param directory the directory to check\n * @return the size\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.sizeOfDirectoryAsBigInteger#2473",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.sizeOfDirectoryAsBigInteger(java.io.File)",
    "snippet": "public static BigInteger sizeOfDirectoryAsBigInteger(final File directory) {\n        checkDirectory(directory);\n        return sizeOfDirectoryBig0(directory);\n    }",
    "begin_line": 2473,
    "end_line": 2476,
    "comment": "/** \n * Counts the size of a directory recursively (sum of the length of all files).\n * @param directory directory to inspect, must not be {@code null}\n * @return size of directory in bytes, 0 if directory is security restricted.\n * @throws NullPointerException if the directory is {@code null}\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.sizeOfDirectoryBig0#2484",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.sizeOfDirectoryBig0(java.io.File)",
    "snippet": "private static BigInteger sizeOfDirectoryBig0(final File directory) {\n        final File[] files \u003d directory.listFiles();\n        if (files \u003d\u003d null) {  // null if security restricted\n            return BigInteger.ZERO;\n        }\n        BigInteger size \u003d BigInteger.ZERO;\n\n        for (final File file : files) {\n            if (!isSymlink(file)) {\n                size \u003d size.add(sizeOfBig0(file));\n            }\n        }\n\n        return size;\n    }",
    "begin_line": 2484,
    "end_line": 2498,
    "comment": "/** \n * Finds the size of a directory\n * @param directory The directory\n * @return the size\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.toFile#2516",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.toFile(java.net.URL)",
    "snippet": "public static File toFile(final URL url) {\n        if (url \u003d\u003d null || !\"file\".equalsIgnoreCase(url.getProtocol())) {\n            return null;\n        }\n        String filename \u003d url.getFile().replace(\u0027/\u0027, File.separatorChar);\n        filename \u003d decodeUrl(filename);\n        return new File(filename);\n    }",
    "begin_line": 2516,
    "end_line": 2523,
    "comment": "/** \n * Convert from a \u003ccode\u003eURL\u003c/code\u003e to a \u003ccode\u003eFile\u003c/code\u003e. \u003cp\u003e From version 1.1 this method will decode the URL. Syntax such as \u003ccode\u003efile:///my%20docs/file.txt\u003c/code\u003e will be correctly decoded to \u003ccode\u003e/my docs/file.txt\u003c/code\u003e. Starting with version 1.5, this method uses UTF-8 to decode percent-encoded octets to characters. Additionally, malformed percent-encoded octets are handled leniently by passing them through literally. \u003c/p\u003e\n * @param url the file URL to convert, {@code null} returns {@code null}\n * @return the equivalent \u003ccode\u003eFile\u003c/code\u003e object, or {@code null}if the URL\u0027s protocol is not \u003ccode\u003efile\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.toFiles#2546",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.toFiles(java.net.URL)",
    "snippet": "public static File[] toFiles(final URL... urls) {\n        if (urls \u003d\u003d null || urls.length \u003d\u003d 0) {\n            return EMPTY_FILE_ARRAY;\n        }\n        final File[] files \u003d new File[urls.length];\n        for (int i \u003d 0; i \u003c urls.length; i++) {\n            final URL url \u003d urls[i];\n            if (url !\u003d null) {\n                if (url.getProtocol().equals(\"file\") \u003d\u003d false) {\n                    throw new IllegalArgumentException(\n                            \"URL could not be converted to a File: \" + url);\n                }\n                files[i] \u003d toFile(url);\n            }\n        }\n        return files;\n    }",
    "begin_line": 2546,
    "end_line": 2562,
    "comment": "/** \n * Converts each of an array of \u003ccode\u003eURL\u003c/code\u003e to a \u003ccode\u003eFile\u003c/code\u003e. \u003cp\u003e Returns an array of the same size as the input. If the input is  {@code null}, an empty array is returned. If the input contains  {@code null}, the output array contains  {@code null} at the sameindex. \u003c/p\u003e \u003cp\u003e This method will decode the URL. Syntax such as \u003ccode\u003efile:///my%20docs/file.txt\u003c/code\u003e will be correctly decoded to \u003ccode\u003e/my docs/file.txt\u003c/code\u003e. \u003c/p\u003e\n * @param urls the file URLs to convert, {@code null} returns empty array\n * @return a non-{@code null} array of Files matching the input, with a {@code null} itemif there was a  {@code null} at that index in the input array\n * @throws IllegalArgumentException if any file is not a URL file\n * @throws IllegalArgumentException if any file is incorrectly encoded\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.toSuffixes#2572",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.toSuffixes(java.lang.String)",
    "snippet": "private static String[] toSuffixes(final String... extensions) {\n        final String[] suffixes \u003d new String[extensions.length];\n        for (int i \u003d 0; i \u003c extensions.length; i++) {\n            suffixes[i] \u003d \".\" + extensions[i];\n        }\n        return suffixes;\n    }",
    "begin_line": 2572,
    "end_line": 2578,
    "comment": "/** \n * Converts an array of file extensions to suffixes for use with IOFileFilters.\n * @param extensions an array of extensions. Format: {\"java\", \"xml\"}\n * @return an array of suffixes. Format: {\".java\", \".xml\"}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.touch#2594",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.touch(java.io.File)",
    "snippet": "public static void touch(final File file) throws IOException {\n        if (!file.exists()) {\n            openOutputStream(file).close();\n        }\n        final boolean success \u003d file.setLastModified(System.currentTimeMillis());\n        if (!success) {\n            throw new IOException(\"Unable to set the last modification time for \" + file);\n        }\n    }",
    "begin_line": 2594,
    "end_line": 2602,
    "comment": "/** \n * Implements the same behavior as the \"touch\" utility on Unix. It creates a new file with size 0 or, if the file exists already, it is opened and closed without modifying it, but updating the file date and time. \u003cp\u003e NOTE: As from v1.3, this method throws an IOException if the last modified date of the file cannot be set. Also, as from v1.3 this method creates parent directories if they do not exist. \u003c/p\u003e\n * @param file the File to touch\n * @throws IOException If an I/O problem occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.toURLs#2615",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.toURLs(java.io.File)",
    "snippet": "public static URL[] toURLs(final File... files) throws IOException {\n        final URL[] urls \u003d new URL[files.length];\n\n        for (int i \u003d 0; i \u003c urls.length; i++) {\n            urls[i] \u003d files[i].toURI().toURL();\n        }\n\n        return urls;\n    }",
    "begin_line": 2615,
    "end_line": 2623,
    "comment": "/** \n * Converts each of an array of \u003ccode\u003eFile\u003c/code\u003e to a \u003ccode\u003eURL\u003c/code\u003e. \u003cp\u003e Returns an array of the same size as the input. \u003c/p\u003e\n * @param files the files to convert, must not be {@code null}\n * @return an array of URLs matching the input\n * @throws IOException          if a file cannot be converted\n * @throws NullPointerException if the parameter is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.validateListFilesParameters#2635",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.validateListFilesParameters(java.io.File, org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "private static void validateListFilesParameters(final File directory, final IOFileFilter fileFilter) {\n        if (!directory.isDirectory()) {\n            throw new IllegalArgumentException(\"Parameter \u0027directory\u0027 is not a directory: \" + directory);\n        }\n        if (fileFilter \u003d\u003d null) {\n            throw new NullPointerException(\"Parameter \u0027fileFilter\u0027 is null\");\n        }\n    }",
    "begin_line": 2635,
    "end_line": 2642,
    "comment": "/** \n * Validates the given arguments. \u003cul\u003e \u003cli\u003eThrows  {@link IllegalArgumentException} if {@code directory} is not a directory\u003c/li\u003e\u003cli\u003eThrows  {@link NullPointerException} if {@code fileFilter} is null\u003c/li\u003e\u003c/ul\u003e\n * @param directory  The File to test\n * @param fileFilter The IOFileFilter to test\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.validateMoveParameters#2656",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.validateMoveParameters(java.io.File, java.io.File)",
    "snippet": "private static void validateMoveParameters(final File src, final File dest) throws FileNotFoundException {\n        if (src \u003d\u003d null) {\n            throw new NullPointerException(\"Source must not be null\");\n        }\n        if (dest \u003d\u003d null) {\n            throw new NullPointerException(\"Destination must not be null\");\n        }\n        if (!src.exists()) {\n            throw new FileNotFoundException(\"Source \u0027\" + src + \"\u0027 does not exist\");\n        }\n    }",
    "begin_line": 2656,
    "end_line": 2666,
    "comment": "/** \n * Validates the given arguments. \u003cul\u003e \u003cli\u003eThrows  {@link NullPointerException} if {@code src} is null\u003c/li\u003e\u003cli\u003eThrows  {@link NullPointerException} if {@code dest} is null\u003c/li\u003e\u003cli\u003eThrows  {@link FileNotFoundException} if {@code src} does not exist\u003c/li\u003e\u003c/ul\u003e\n * @param src                       the file or directory to be moved\n * @param dest                      the destination file or directory\n * @throws FileNotFoundException    if {@code src} file does not exist\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.verifiedListFiles#2675",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.verifiedListFiles(java.io.File)",
    "snippet": "private static File[] verifiedListFiles(final File directory) throws IOException {\n        if (!directory.exists()) {\n            final String message \u003d directory + \" does not exist\";\n            throw new IllegalArgumentException(message);\n        }\n\n        if (!directory.isDirectory()) {\n            final String message \u003d directory + \" is not a directory\";\n            throw new IllegalArgumentException(message);\n        }\n\n        final File[] files \u003d directory.listFiles();\n        if (files \u003d\u003d null) {  // null if security restricted\n            throw new IOException(\"Failed to list contents of \" + directory);\n        }\n        return files;\n    }",
    "begin_line": 2675,
    "end_line": 2691,
    "comment": "/** \n * Lists files in a directory, asserting that the supplied directory satisfies exists and is a directory.\n * @param directory The directory to list\n * @return The files in the directory, never null.\n * @throws IOException if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.waitFor#2706",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.waitFor(java.io.File, int)",
    "snippet": "public static boolean waitFor(final File file, final int seconds) {\n        final long finishAt \u003d System.currentTimeMillis() + (seconds * 1000L);\n        boolean wasInterrupted \u003d false;\n        try {\n            while (!file.exists()) {\n                final long remaining \u003d finishAt -  System.currentTimeMillis();\n                if (remaining \u003c 0){\n                    return false;\n                }\n                try {\n                    Thread.sleep(Math.min(100, remaining));\n                } catch (final InterruptedException ignore) {\n                    wasInterrupted \u003d true;\n                } catch (final Exception ex) {\n                    break;\n                }\n            }\n        } finally {\n            if (wasInterrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        return true;\n    }",
    "begin_line": 2706,
    "end_line": 2729,
    "comment": "/** \n * Waits for NFS to propagate a file creation, imposing a timeout. \u003cp\u003e This method repeatedly tests  {@link File#exists()} until it returnstrue up to the maximum time specified in seconds. \u003c/p\u003e\n * @param file    the file to check, must not be {@code null}\n * @param seconds the maximum time in seconds to wait\n * @return true if file exists\n * @throws NullPointerException if the file is {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.write#2741",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.write(java.io.File, java.lang.CharSequence)",
    "snippet": "@Deprecated\n    public static void write(final File file, final CharSequence data) throws IOException {\n        write(file, data, Charset.defaultCharset(), false);\n    }",
    "begin_line": 2741,
    "end_line": 2743,
    "comment": "/** \n * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.\n * @param file the file to write\n * @param data the content to write to the file\n * @throws IOException in case of an I/O error\n * @since 2.0\n * @deprecated 2.5 use {@link #write(File,CharSequence,Charset)} instead (and specify the appropriate encoding)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.write#2757",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.write(java.io.File, java.lang.CharSequence, boolean)",
    "snippet": "@Deprecated\n    public static void write(final File file, final CharSequence data, final boolean append) throws IOException {\n        write(file, data, Charset.defaultCharset(), append);\n    }",
    "begin_line": 2757,
    "end_line": 2759,
    "comment": "/** \n * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.\n * @param file   the file to write\n * @param data   the content to write to the file\n * @param append if {@code true}, then the data will be added to the end of the file rather than overwriting\n * @throws IOException in case of an I/O error\n * @since 2.1\n * @deprecated 2.5 use {@link #write(File,CharSequence,Charset,boolean)} instead (and specify the appropriate encoding)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.write#2770",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.write(java.io.File, java.lang.CharSequence, java.nio.charset.Charset)",
    "snippet": "public static void write(final File file, final CharSequence data, final Charset encoding) throws IOException {\n        write(file, data, encoding, false);\n    }",
    "begin_line": 2770,
    "end_line": 2772,
    "comment": "/** \n * Writes a CharSequence to a file creating the file if it does not exist.\n * @param file     the file to write\n * @param data     the content to write to the file\n * @param encoding the encoding to use, {@code null} means platform default\n * @throws IOException in case of an I/O error\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.write#2785",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.write(java.io.File, java.lang.CharSequence, java.nio.charset.Charset, boolean)",
    "snippet": "public static void write(final File file, final CharSequence data, final Charset encoding, final boolean append)\n            throws IOException {\n        final String str \u003d data \u003d\u003d null ? null : data.toString();\n        writeStringToFile(file, str, encoding, append);\n    }",
    "begin_line": 2785,
    "end_line": 2789,
    "comment": "/** \n * Writes a CharSequence to a file creating the file if it does not exist.\n * @param file     the file to write\n * @param data     the content to write to the file\n * @param encoding the encoding to use, {@code null} means platform default\n * @param append   if {@code true}, then the data will be added to the end of the file rather than overwriting\n * @throws IOException in case of an I/O error\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.write#2803",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.write(java.io.File, java.lang.CharSequence, java.lang.String)",
    "snippet": "public static void write(final File file, final CharSequence data, final String encoding) throws IOException {\n        write(file, data, encoding, false);\n    }",
    "begin_line": 2803,
    "end_line": 2805,
    "comment": "/** \n * Writes a CharSequence to a file creating the file if it does not exist.\n * @param file     the file to write\n * @param data     the content to write to the file\n * @param encoding the encoding to use, {@code null} means platform default\n * @throws IOException                          in case of an I/O error\n * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.write#2822",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.write(java.io.File, java.lang.CharSequence, java.lang.String, boolean)",
    "snippet": "public static void write(final File file, final CharSequence data, final String encoding, final boolean append)\n            throws IOException {\n        write(file, data, Charsets.toCharset(encoding), append);\n    }",
    "begin_line": 2822,
    "end_line": 2825,
    "comment": "/** \n * Writes a CharSequence to a file creating the file if it does not exist.\n * @param file     the file to write\n * @param data     the content to write to the file\n * @param encoding the encoding to use, {@code null} means platform default\n * @param append   if {@code true}, then the data will be added to the end of the file rather than overwriting\n * @throws IOException                 in case of an I/O error\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported by the VM\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeByteArrayToFile#2839",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeByteArrayToFile(java.io.File, byte[])",
    "snippet": "public static void writeByteArrayToFile(final File file, final byte[] data) throws IOException {\n        writeByteArrayToFile(file, data, false);\n    }",
    "begin_line": 2839,
    "end_line": 2841,
    "comment": "/** \n * Writes a byte array to a file creating the file if it does not exist. \u003cp\u003e NOTE: As from v1.3, the parent directories of the file will be created if they do not exist. \u003c/p\u003e\n * @param file the file to write to\n * @param data the content to write to the file\n * @throws IOException in case of an I/O error\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeByteArrayToFile#2855",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeByteArrayToFile(java.io.File, byte[], boolean)",
    "snippet": "public static void writeByteArrayToFile(final File file, final byte[] data, final boolean append)\n            throws IOException {\n        writeByteArrayToFile(file, data, 0, data.length, append);\n    }",
    "begin_line": 2855,
    "end_line": 2858,
    "comment": "/** \n * Writes a byte array to a file creating the file if it does not exist.\n * @param file   the file to write to\n * @param data   the content to write to the file\n * @param append if {@code true}, then bytes will be added to the end of the file rather than overwriting\n * @throws IOException in case of an I/O error\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeByteArrayToFile#2874",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeByteArrayToFile(java.io.File, byte[], int, int)",
    "snippet": "public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len)\n            throws IOException {\n        writeByteArrayToFile(file, data, off, len, false);\n    }",
    "begin_line": 2874,
    "end_line": 2877,
    "comment": "/** \n * Writes  {@code len} bytes from the specified byte array startingat offset  {@code off} to a file, creating the file if it doesnot exist.\n * @param file the file to write to\n * @param data the content to write to the file\n * @param off  the start offset in the data\n * @param len  the number of bytes to write\n * @throws IOException in case of an I/O error\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeByteArrayToFile#2893",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeByteArrayToFile(java.io.File, byte[], int, int, boolean)",
    "snippet": "public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len,\n                                            final boolean append) throws IOException {\n        try (OutputStream out \u003d openOutputStream(file, append)) {\n            out.write(data, off, len);\n        }\n    }",
    "begin_line": 2893,
    "end_line": 2898,
    "comment": "/** \n * Writes  {@code len} bytes from the specified byte array startingat offset  {@code off} to a file, creating the file if it doesnot exist.\n * @param file   the file to write to\n * @param data   the content to write to the file\n * @param off    the start offset in the data\n * @param len    the number of bytes to write\n * @param append if {@code true}, then bytes will be added to the end of the file rather than overwriting\n * @throws IOException in case of an I/O error\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeLines#2910",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeLines(java.io.File, java.util.Collection\u003c?\u003e)",
    "snippet": "public static void writeLines(final File file, final Collection\u003c?\u003e lines) throws IOException {\n        writeLines(file, null, lines, null, false);\n    }",
    "begin_line": 2910,
    "end_line": 2912,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to the specified \u003ccode\u003eFile\u003c/code\u003e line by line. The default VM encoding and the default line ending will be used.\n * @param file  the file to write to\n * @param lines the lines to write, {@code null} entries produce blank lines\n * @throws IOException in case of an I/O error\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeLines#2926",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeLines(java.io.File, java.util.Collection\u003c?\u003e, boolean)",
    "snippet": "public static void writeLines(final File file, final Collection\u003c?\u003e lines, final boolean append) throws IOException {\n        writeLines(file, null, lines, null, append);\n    }",
    "begin_line": 2926,
    "end_line": 2928,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to the specified \u003ccode\u003eFile\u003c/code\u003e line by line. The default VM encoding and the default line ending will be used.\n * @param file   the file to write to\n * @param lines  the lines to write, {@code null} entries produce blank lines\n * @param append if {@code true}, then the lines will be added to the end of the file rather than overwriting\n * @throws IOException in case of an I/O error\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeLines#2941",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeLines(java.io.File, java.util.Collection\u003c?\u003e, java.lang.String)",
    "snippet": "public static void writeLines(final File file, final Collection\u003c?\u003e lines, final String lineEnding)\n            throws IOException {\n        writeLines(file, null, lines, lineEnding, false);\n    }",
    "begin_line": 2941,
    "end_line": 2944,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to the specified \u003ccode\u003eFile\u003c/code\u003e line by line. The default VM encoding and the specified line ending will be used.\n * @param file       the file to write to\n * @param lines      the lines to write, {@code null} entries produce blank lines\n * @param lineEnding the line separator to use, {@code null} is system default\n * @throws IOException in case of an I/O error\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeLines#2960",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeLines(java.io.File, java.util.Collection\u003c?\u003e, java.lang.String, boolean)",
    "snippet": "public static void writeLines(final File file, final Collection\u003c?\u003e lines, final String lineEnding,\n                                  final boolean append) throws IOException {\n        writeLines(file, null, lines, lineEnding, append);\n    }",
    "begin_line": 2960,
    "end_line": 2963,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to the specified \u003ccode\u003eFile\u003c/code\u003e line by line. The default VM encoding and the specified line ending will be used.\n * @param file       the file to write to\n * @param lines      the lines to write, {@code null} entries produce blank lines\n * @param lineEnding the line separator to use, {@code null} is system default\n * @param append     if {@code true}, then the lines will be added to the end of the file rather than overwriting\n * @throws IOException in case of an I/O error\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeLines#2981",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeLines(java.io.File, java.lang.String, java.util.Collection\u003c?\u003e)",
    "snippet": "public static void writeLines(final File file, final String encoding, final Collection\u003c?\u003e lines)\n            throws IOException {\n        writeLines(file, encoding, lines, null, false);\n    }",
    "begin_line": 2981,
    "end_line": 2984,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to the specified \u003ccode\u003eFile\u003c/code\u003e line by line. The specified character encoding and the default line ending will be used. \u003cp\u003e NOTE: As from v1.3, the parent directories of the file will be created if they do not exist. \u003c/p\u003e\n * @param file     the file to write to\n * @param encoding the encoding to use, {@code null} means platform default\n * @param lines    the lines to write, {@code null} entries produce blank lines\n * @throws IOException                          in case of an I/O error\n * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeLines#3000",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeLines(java.io.File, java.lang.String, java.util.Collection\u003c?\u003e, boolean)",
    "snippet": "public static void writeLines(final File file, final String encoding, final Collection\u003c?\u003e lines,\n                                  final boolean append) throws IOException {\n        writeLines(file, encoding, lines, null, append);\n    }",
    "begin_line": 3000,
    "end_line": 3003,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to the specified \u003ccode\u003eFile\u003c/code\u003e line by line, optionally appending. The specified character encoding and the default line ending will be used.\n * @param file     the file to write to\n * @param encoding the encoding to use, {@code null} means platform default\n * @param lines    the lines to write, {@code null} entries produce blank lines\n * @param append   if {@code true}, then the lines will be added to the end of the file rather than overwriting\n * @throws IOException                          in case of an I/O error\n * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeLines#3022",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeLines(java.io.File, java.lang.String, java.util.Collection\u003c?\u003e, java.lang.String)",
    "snippet": "public static void writeLines(final File file, final String encoding, final Collection\u003c?\u003e lines,\n                                  final String lineEnding) throws IOException {\n        writeLines(file, encoding, lines, lineEnding, false);\n    }",
    "begin_line": 3022,
    "end_line": 3025,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to the specified \u003ccode\u003eFile\u003c/code\u003e line by line. The specified character encoding and the line ending will be used. \u003cp\u003e NOTE: As from v1.3, the parent directories of the file will be created if they do not exist. \u003c/p\u003e\n * @param file       the file to write to\n * @param encoding   the encoding to use, {@code null} means platform default\n * @param lines      the lines to write, {@code null} entries produce blank lines\n * @param lineEnding the line separator to use, {@code null} is system default\n * @throws IOException                          in case of an I/O error\n * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeLines#3042",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeLines(java.io.File, java.lang.String, java.util.Collection\u003c?\u003e, java.lang.String, boolean)",
    "snippet": "public static void writeLines(final File file, final String encoding, final Collection\u003c?\u003e lines,\n                                  final String lineEnding, final boolean append) throws IOException {\n        try (OutputStream out \u003d new BufferedOutputStream(openOutputStream(file, append))) {\n            IOUtils.writeLines(lines, lineEnding, out, encoding);\n        }\n    }",
    "begin_line": 3042,
    "end_line": 3047,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to the specified \u003ccode\u003eFile\u003c/code\u003e line by line. The specified character encoding and the line ending will be used.\n * @param file       the file to write to\n * @param encoding   the encoding to use, {@code null} means platform default\n * @param lines      the lines to write, {@code null} entries produce blank lines\n * @param lineEnding the line separator to use, {@code null} is system default\n * @param append     if {@code true}, then the lines will be added to the end of the file rather than overwriting\n * @throws IOException                          in case of an I/O error\n * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeStringToFile#3058",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeStringToFile(java.io.File, java.lang.String)",
    "snippet": "@Deprecated\n    public static void writeStringToFile(final File file, final String data) throws IOException {\n        writeStringToFile(file, data, Charset.defaultCharset(), false);\n    }",
    "begin_line": 3058,
    "end_line": 3060,
    "comment": "/** \n * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.\n * @param file the file to write\n * @param data the content to write to the file\n * @throws IOException in case of an I/O error\n * @deprecated 2.5 use {@link #writeStringToFile(File,String,Charset)} instead (and specify the appropriate encoding)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeStringToFile#3074",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeStringToFile(java.io.File, java.lang.String, boolean)",
    "snippet": "@Deprecated\n    public static void writeStringToFile(final File file, final String data, final boolean append) throws IOException {\n        writeStringToFile(file, data, Charset.defaultCharset(), append);\n    }",
    "begin_line": 3074,
    "end_line": 3076,
    "comment": "/** \n * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.\n * @param file   the file to write\n * @param data   the content to write to the file\n * @param append if {@code true}, then the String will be added to the end of the file rather than overwriting\n * @throws IOException in case of an I/O error\n * @since 2.1\n * @deprecated 2.5 use {@link #writeStringToFile(File,String,Charset,boolean)} instead (and specify the appropriate encoding)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeStringToFile#3092",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeStringToFile(java.io.File, java.lang.String, java.nio.charset.Charset)",
    "snippet": "public static void writeStringToFile(final File file, final String data, final Charset encoding)\n            throws IOException {\n        writeStringToFile(file, data, encoding, false);\n    }",
    "begin_line": 3092,
    "end_line": 3095,
    "comment": "/** \n * Writes a String to a file creating the file if it does not exist. \u003cp\u003e NOTE: As from v1.3, the parent directories of the file will be created if they do not exist. \u003c/p\u003e\n * @param file     the file to write\n * @param data     the content to write to the file\n * @param encoding the encoding to use, {@code null} means platform default\n * @throws IOException                          in case of an I/O error\n * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeStringToFile#3108",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeStringToFile(java.io.File, java.lang.String, java.nio.charset.Charset, boolean)",
    "snippet": "public static void writeStringToFile(final File file, final String data, final Charset encoding,\n                                         final boolean append) throws IOException {\n        try (OutputStream out \u003d openOutputStream(file, append)) {\n            IOUtils.write(data, out, encoding);\n        }\n    }",
    "begin_line": 3108,
    "end_line": 3113,
    "comment": "/** \n * Writes a String to a file creating the file if it does not exist.\n * @param file     the file to write\n * @param data     the content to write to the file\n * @param encoding the encoding to use, {@code null} means platform default\n * @param append   if {@code true}, then the String will be added to the end of the file rather than overwriting\n * @throws IOException in case of an I/O error\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeStringToFile#3128",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeStringToFile(java.io.File, java.lang.String, java.lang.String)",
    "snippet": "public static void writeStringToFile(final File file, final String data, final String encoding) throws IOException {\n        writeStringToFile(file, data, encoding, false);\n    }",
    "begin_line": 3128,
    "end_line": 3130,
    "comment": "/** \n * Writes a String to a file creating the file if it does not exist. \u003cp\u003e NOTE: As from v1.3, the parent directories of the file will be created if they do not exist. \u003c/p\u003e\n * @param file     the file to write\n * @param data     the content to write to the file\n * @param encoding the encoding to use, {@code null} means platform default\n * @throws IOException                          in case of an I/O error\n * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.writeStringToFile#3145",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.writeStringToFile(java.io.File, java.lang.String, java.lang.String, boolean)",
    "snippet": "public static void writeStringToFile(final File file, final String data, final String encoding,\n                                         final boolean append) throws IOException {\n        writeStringToFile(file, data, Charsets.toCharset(encoding), append);\n    }",
    "begin_line": 3145,
    "end_line": 3148,
    "comment": "/** \n * Writes a String to a file creating the file if it does not exist.\n * @param file     the file to write\n * @param data     the content to write to the file\n * @param encoding the encoding to use, {@code null} means platform default\n * @param append   if {@code true}, then the String will be added to the end of the file rather than overwriting\n * @throws IOException                 in case of an I/O error\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported by the VM\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileUtils.FileUtils#3153",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileUtils.java",
    "class_name": "org.apache.commons.io.FileUtils",
    "signature": "org.apache.commons.io.FileUtils.FileUtils()",
    "snippet": "public FileUtils() {\n        super();\n    }",
    "begin_line": 3153,
    "end_line": 3155,
    "comment": "/** \n * Instances should NOT be constructed in standard programming.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractPathCounters.AbstractPathCounters#45",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.AbstractPathCounters(org.apache.commons.io.file.Counters.Counter, org.apache.commons.io.file.Counters.Counter, org.apache.commons.io.file.Counters.Counter)",
    "snippet": "protected AbstractPathCounters(final Counter byteCounter, final Counter directoryCounter,\n                final Counter fileCounter) {\n            super();\n            this.byteCounter \u003d byteCounter;\n            this.directoryCounter \u003d directoryCounter;\n            this.fileCounter \u003d fileCounter;\n        }",
    "begin_line": 45,
    "end_line": 51,
    "comment": "/** \n * Constructs a new instance.\n * @param byteCounter the byte counter.\n * @param directoryCounter the directory counter.\n * @param fileCounter the file counter.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractPathCounters.getByteCounter#54",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getByteCounter()",
    "snippet": "@Override\n        public Counter getByteCounter() {\n            return byteCounter;\n        }",
    "begin_line": 54,
    "end_line": 56,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractPathCounters.getDirectoryCounter#59",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getDirectoryCounter()",
    "snippet": "@Override\n        public Counter getDirectoryCounter() {\n            return directoryCounter;\n        }",
    "begin_line": 59,
    "end_line": 61,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractPathCounters.getFileCounter#69",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getFileCounter()",
    "snippet": "@Override\n        public Counter getFileCounter() {\n            return this.fileCounter;\n        }",
    "begin_line": 69,
    "end_line": 71,
    "comment": "/** \n * Gets the count of visited files.\n * @return the byte count of visited files.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractPathCounters.toString#74",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.toString()",
    "snippet": "@Override\n        public String toString() {\n            return String.format(\"%,d files, %,d directories, %,d bytes\", Long.valueOf(fileCounter.get()),\n                    Long.valueOf(directoryCounter.get()), Long.valueOf(byteCounter.get()));\n        }",
    "begin_line": 74,
    "end_line": 77,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigIntegerCounter.add#89",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.add(long)",
    "snippet": "@Override\n        public void add(final long val) {\n            value \u003d value.add(BigInteger.valueOf(val));\n\n        }",
    "begin_line": 89,
    "end_line": 92,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigIntegerCounter.get#95",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.get()",
    "snippet": "@Override\n        public long get() {\n            return value.longValueExact();\n        }",
    "begin_line": 95,
    "end_line": 97,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigIntegerCounter.getBigInteger#100",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getBigInteger()",
    "snippet": "@Override\n        public BigInteger getBigInteger() {\n            return value;\n        }",
    "begin_line": 100,
    "end_line": 102,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigIntegerCounter.getLong#105",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getLong()",
    "snippet": "@Override\n        public Long getLong() {\n            return Long.valueOf(value.longValueExact());\n        }",
    "begin_line": 105,
    "end_line": 107,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigIntegerCounter.increment#110",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.increment()",
    "snippet": "@Override\n        public void increment() {\n            value \u003d value.add(BigInteger.ONE);\n        }",
    "begin_line": 110,
    "end_line": 112,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigIntegerCounter.toString#115",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.toString()",
    "snippet": "@Override\n        public String toString() {\n            return value.toString();\n        }",
    "begin_line": 115,
    "end_line": 117,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigIntegerPathCounters.BigIntegerPathCounters#128",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.BigIntegerPathCounters()",
    "snippet": "protected BigIntegerPathCounters() {\n            super(Counters.bigIntegerCounter(), Counters.bigIntegerCounter(), Counters.bigIntegerCounter());\n        }",
    "begin_line": 128,
    "end_line": 130,
    "comment": "/** \n * Constructs a new initialized instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Counter.add#144",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.add(long)",
    "snippet": "void add(long val);",
    "begin_line": 144,
    "end_line": 144,
    "comment": "/** \n * Adds the given number to this counter.\n * @param val the value to add.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Counter.get#151",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.get()",
    "snippet": "long get();",
    "begin_line": 151,
    "end_line": 151,
    "comment": "/** \n * Gets the counter as a long.\n * @return the counter as a long.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Counter.getBigInteger#158",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getBigInteger()",
    "snippet": "BigInteger getBigInteger();",
    "begin_line": 158,
    "end_line": 158,
    "comment": "/** \n * Gets the counter as a BigInteger.\n * @return the counter as a BigInteger.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Counter.getLong#165",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getLong()",
    "snippet": "Long getLong();",
    "begin_line": 165,
    "end_line": 165,
    "comment": "/** \n * Gets the counter as a Long.\n * @return the counter as a Long.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Counter.increment#170",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.increment()",
    "snippet": "void increment();",
    "begin_line": 170,
    "end_line": 170,
    "comment": "/** \n * Adds one to this counter.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LongCounter.add#182",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.add(long)",
    "snippet": "@Override\n        public void add(final long add) {\n            value +\u003d add;\n\n        }",
    "begin_line": 182,
    "end_line": 185,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LongCounter.get#188",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.get()",
    "snippet": "@Override\n        public long get() {\n            return value;\n        }",
    "begin_line": 188,
    "end_line": 190,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LongCounter.getBigInteger#193",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getBigInteger()",
    "snippet": "@Override\n        public BigInteger getBigInteger() {\n            return BigInteger.valueOf(value);\n        }",
    "begin_line": 193,
    "end_line": 195,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LongCounter.getLong#198",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getLong()",
    "snippet": "@Override\n        public Long getLong() {\n            return Long.valueOf(value);\n        }",
    "begin_line": 198,
    "end_line": 200,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LongCounter.increment#203",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.increment()",
    "snippet": "@Override\n        public void increment() {\n            value++;\n        }",
    "begin_line": 203,
    "end_line": 205,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LongCounter.toString#208",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.toString()",
    "snippet": "@Override\n        public String toString() {\n            return Long.toString(value);\n        }",
    "begin_line": 208,
    "end_line": 210,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LongPathCounters.LongPathCounters#221",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.LongPathCounters()",
    "snippet": "protected LongPathCounters() {\n            super(Counters.longCounter(), Counters.longCounter(), Counters.longCounter());\n        }",
    "begin_line": 221,
    "end_line": 223,
    "comment": "/** \n * Constructs a new initialized instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathCounters.getByteCounter#237",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getByteCounter()",
    "snippet": "Counter getByteCounter();",
    "begin_line": 237,
    "end_line": 237,
    "comment": "/** \n * Gets the byte counter.\n * @return the byte counter.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathCounters.getDirectoryCounter#244",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getDirectoryCounter()",
    "snippet": "Counter getDirectoryCounter();",
    "begin_line": 244,
    "end_line": 244,
    "comment": "/** \n * Gets the directory counter.\n * @return the directory counter.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathCounters.getFileCounter#251",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.getFileCounter()",
    "snippet": "Counter getFileCounter();",
    "begin_line": 251,
    "end_line": 251,
    "comment": "/** \n * Gets the file counter.\n * @return the file counter.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathCounters.bigIntegerCounter#260",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.bigIntegerCounter()",
    "snippet": "public static Counter bigIntegerCounter() {\n        return new BigIntegerCounter();\n    }",
    "begin_line": 260,
    "end_line": 262,
    "comment": "/** \n * Returns a new BigInteger Counter.\n * @return a new BigInteger Counter.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathCounters.bigIntegerPathCounters#269",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.bigIntegerPathCounters()",
    "snippet": "public static PathCounters bigIntegerPathCounters() {\n        return new BigIntegerPathCounters();\n    }",
    "begin_line": 269,
    "end_line": 271,
    "comment": "/** \n * Returns a new BigInteger PathCounters.\n * @return a new BigInteger PathCounters.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathCounters.longCounter#278",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.longCounter()",
    "snippet": "public static Counter longCounter() {\n        return new LongCounter();\n    }",
    "begin_line": 278,
    "end_line": 280,
    "comment": "/** \n * Returns a new long Counter.\n * @return a new long Counter.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathCounters.longPathCounters#287",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/Counters.java",
    "class_name": "org.apache.commons.io.file.Counters",
    "signature": "org.apache.commons.io.file.Counters.longPathCounters()",
    "snippet": "public static PathCounters longPathCounters() {\n        return new LongPathCounters();\n    }",
    "begin_line": 287,
    "end_line": 289,
    "comment": "/** \n * Returns a new BigInteger PathCounters.\n * @return a new BigInteger PathCounters.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.cleanDirectory#46",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.cleanDirectory(java.nio.file.Path)",
    "snippet": "public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return visitFileTree(CleaningPathVisitor.withLongCounters(), directory).getPathCounters();\n    }",
    "begin_line": 46,
    "end_line": 48,
    "comment": "/** \n * Cleans a directory including sub-directories without deleting directories.\n * @param directory directory to clean.\n * @return The visitation path counters.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.copyDirectory#59",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.copyDirectory(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption)",
    "snippet": "public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory,\n            final CopyOption... copyOptions) throws IOException {\n        return visitFileTree(\n                new CopyDirectoryVisitor(Counters.longPathCounters(), sourceDirectory, targetDirectory, copyOptions),\n                sourceDirectory).getPathCounters();\n    }",
    "begin_line": 59,
    "end_line": 64,
    "comment": "/** \n * Copies a directory to another directory.\n * @param sourceDirectory The source directory.\n * @param targetDirectory The target directory.\n * @param copyOptions Specifies how the copying should be done.\n * @return The visitation path counters.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.copyFileToDirectory#76",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.copyFileToDirectory(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption)",
    "snippet": "public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory,\n            final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n\n    }",
    "begin_line": 76,
    "end_line": 80,
    "comment": "/** \n * Copies a file to a directory.\n * @param sourceFile The source file\n * @param targetDirectory The target directory.\n * @param copyOptions Specifies how the copying should be done.\n * @return The target file\n * @throws IOException if an I/O error occurs\n * @see Files#copy(Path,Path,CopyOption...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.countDirectory#89",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.countDirectory(java.nio.file.Path)",
    "snippet": "public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory).getPathCounters();\n    }",
    "begin_line": 89,
    "end_line": 91,
    "comment": "/** \n * Counts aspects of a directory including sub-directories.\n * @param directory directory to delete.\n * @return The visitor used to count the given directory.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.delete#109",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.delete(java.nio.file.Path)",
    "snippet": "public static PathCounters delete(final Path path) throws IOException {\n        return Files.isDirectory(path) ? deleteDirectory(path) : deleteFile(path);\n    }",
    "begin_line": 109,
    "end_line": 111,
    "comment": "/** \n * Deletes a file or directory. If the path is a directory, delete it and all sub-directories. \u003cp\u003e The difference between File.delete() and this method are: \u003c/p\u003e \u003cul\u003e \u003cli\u003eA directory to delete does not have to be empty.\u003c/li\u003e \u003cli\u003eYou get exceptions when a file or directory cannot be deleted;  {@link java.io.File#delete()} returns aboolean. \u003c/ul\u003e\n * @param path file or directory to delete, must not be {@code null}\n * @return The visitor used to delete the given directory.\n * @throws NullPointerException if the directory is {@code null}\n * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.deleteDirectory#120",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.deleteDirectory(java.nio.file.Path)",
    "snippet": "public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return visitFileTree(DeletingPathVisitor.withLongCounters(), directory).getPathCounters();\n    }",
    "begin_line": 120,
    "end_line": 122,
    "comment": "/** \n * Deletes a directory including sub-directories.\n * @param directory directory to delete.\n * @return The visitor used to delete the given directory.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.deleteFile#132",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.deleteFile(java.nio.file.Path)",
    "snippet": "public static PathCounters deleteFile(final Path file) throws IOException {\n        if (Files.isDirectory(file)) {\n            throw new NotDirectoryException(file.toString());\n        }\n        final PathCounters pathCounts \u003d Counters.longPathCounters();\n        final long size \u003d Files.exists(file) ? Files.size(file) : 0;\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }",
    "begin_line": 132,
    "end_line": 143,
    "comment": "/** \n * Deletes the given file.\n * @param file The file to delete.\n * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n * @throws IOException if an I/O error occurs.\n * @throws NotDirectoryException if the file is a directory.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.isEmpty#152",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isEmpty(java.nio.file.Path)",
    "snippet": "public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }",
    "begin_line": 152,
    "end_line": 154,
    "comment": "/** \n * Returns whether the given file or directory is empty.\n * @param path the the given file or directory to query.\n * @return whether the given file or directory is empty.\n * @throws IOException if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.isEmptyDirectory#163",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isEmptyDirectory(java.nio.file.Path)",
    "snippet": "public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream\u003cPath\u003e directoryStream \u003d Files.newDirectoryStream(directory)) {\n            if (directoryStream.iterator().hasNext()) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 163,
    "end_line": 170,
    "comment": "/** \n * Returns whether the directory is empty.\n * @param directory the the given directory to query.\n * @return whether the given directory is empty.\n * @throws IOException if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.isEmptyFile#179",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isEmptyFile(java.nio.file.Path)",
    "snippet": "public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) \u003c\u003d 0;\n    }",
    "begin_line": 179,
    "end_line": 181,
    "comment": "/** \n * Returns whether the given file is empty.\n * @param file the the given file to query.\n * @return whether the given file is empty.\n * @throws IOException if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.visitFileTree#196",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.visitFileTree(T, java.nio.file.Path)",
    "snippet": "public static \u003cT extends FileVisitor\u003c? super Path\u003e\u003e T visitFileTree(final T visitor, final Path directory)\n            throws IOException {\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }",
    "begin_line": 196,
    "end_line": 200,
    "comment": "/** \n * Performs  {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.Note that  {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @param \u003c T \u003e See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @return the given visitor.\n * @throws IOException if an I/O error is thrown by a visitor method\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.visitFileTree#215",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.visitFileTree(T, java.lang.String, java.lang.String)",
    "snippet": "public static \u003cT extends FileVisitor\u003c? super Path\u003e\u003e T visitFileTree(final T visitor, final String first,\n            final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }",
    "begin_line": 215,
    "end_line": 218,
    "comment": "/** \n * Performs  {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.Note that  {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @param first See {@link Paths#get(String,String[])}.\n * @param more See {@link Paths#get(String,String[])}.\n * @param \u003c T \u003e See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @return the given visitor.\n * @throws IOException if an I/O error is thrown by a visitor method\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.visitFileTree#232",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.visitFileTree(T, java.net.URI)",
    "snippet": "public static \u003cT extends FileVisitor\u003c? super Path\u003e\u003e T visitFileTree(final T visitor, final URI uri)\n            throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }",
    "begin_line": 232,
    "end_line": 235,
    "comment": "/** \n * Performs  {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.Note that  {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @param uri See {@link Paths#get(URI)}.\n * @param \u003c T \u003e See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @return the given visitor.\n * @throws IOException if an I/O error is thrown by a visitor method\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PathUtils.PathUtils#240",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.PathUtils()",
    "snippet": "private PathUtils() {\n        // do not instantiate.\n    }",
    "begin_line": 240,
    "end_line": 242,
    "comment": "/** \n * Does allow to instantiate.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]