[
  {
    "name": "MockitoAnnotations.initMocks#89",
    "is_bug": true,
    "src_path": "org/mockito/MockitoAnnotations.java",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.initMocks(java.lang.Object)",
    "snippet": "public static void initMocks(Object testClass) {\n        if (testClass \u003d\u003d null) {\n            throw new MockitoException(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\");\n        }\n\n        AnnotationEngine annotationEngine \u003d new GlobalConfiguration().getAnnotationEngine();\n        Class\u003c?\u003e clazz \u003d testClass.getClass();\n\n        //below can be removed later, when we get read rid of deprecated stuff\n        if (annotationEngine.getClass() !\u003d new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n            //this means user has his own annotation engine and we have to respect that.\n            //we will do annotation processing the old way so that we are backwards compatible\n            while (clazz !\u003d Object.class) {\n                scanDeprecatedWay(annotationEngine, testClass, clazz);\n                clazz \u003d clazz.getSuperclass();\n            }\n        }\n\n        //anyway act \u0027the new\u0027 way\n        annotationEngine.process(testClass.getClass(), testClass);\n    }",
    "begin_line": 89,
    "end_line": 109,
    "comment": "/** \n * Initializes objects annotated with Mockito annotations for given testClass: \u0026#064; {@link org.mockito.Mock}, \u0026#064; {@link Spy}, \u0026#064; {@link Captor}, \u0026#064; {@link InjectMocks} \u003cp\u003e See examples in javadoc for  {@link MockitoAnnotations} class.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockitoAnnotations.scanDeprecatedWay#111",
    "is_bug": true,
    "src_path": "org/mockito/MockitoAnnotations.java",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.scanDeprecatedWay(org.mockito.configuration.AnnotationEngine, java.lang.Object, java.lang.Class\u003c?\u003e)",
    "snippet": "static void scanDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Class\u003c?\u003e clazz) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n\n        for (Field field : fields) {\n            processAnnotationDeprecatedWay(annotationEngine, testClass, field);\n        }\n    }",
    "begin_line": 111,
    "end_line": 117,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockitoAnnotations.processAnnotationDeprecatedWay#120",
    "is_bug": true,
    "src_path": "org/mockito/MockitoAnnotations.java",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.processAnnotationDeprecatedWay(org.mockito.configuration.AnnotationEngine, java.lang.Object, java.lang.reflect.Field)",
    "snippet": "@SuppressWarnings(\"deprecation\")\n    static void processAnnotationDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Field field) {\n        boolean alreadyAssigned \u003d false;\n        for(Annotation annotation : field.getAnnotations()) {\n            Object mock \u003d annotationEngine.createMockFor(annotation, field);\n            if (mock !\u003d null) {\n                throwIfAlreadyAssigned(field, alreadyAssigned);\n                alreadyAssigned \u003d true;                \n                try {\n                    new FieldSetter(testClass, field).set(mock);\n                } catch (Exception e) {\n                    throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                            + annotation, e);\n                }\n            }\n        }\n    }",
    "begin_line": 120,
    "end_line": 135,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockitoAnnotations.throwIfAlreadyAssigned#137",
    "is_bug": true,
    "src_path": "org/mockito/MockitoAnnotations.java",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.throwIfAlreadyAssigned(java.lang.reflect.Field, boolean)",
    "snippet": "static void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n        if (alreadyAssigned) {\n            new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n        }\n    }",
    "begin_line": 137,
    "end_line": 141,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultMockitoConfiguration.getReturnValues#26",
    "is_bug": true,
    "src_path": "org/mockito/configuration/DefaultMockitoConfiguration.java",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getReturnValues()",
    "snippet": "@Deprecated\n    public ReturnValues getReturnValues() {\n        throw new RuntimeException(\"\\n\" + \"This method should not be used by the framework because it was deprecated\"\n                + \"\\n\" + \"Please report the failure to the Mockito mailing list\");\n    }",
    "begin_line": 26,
    "end_line": 29,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultMockitoConfiguration.getDefaultAnswer#31",
    "is_bug": true,
    "src_path": "org/mockito/configuration/DefaultMockitoConfiguration.java",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getDefaultAnswer()",
    "snippet": "public Answer\u003cObject\u003e getDefaultAnswer() {\n        return new ReturnsEmptyValues();\n    }",
    "begin_line": 31,
    "end_line": 33,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultMockitoConfiguration.getAnnotationEngine#38",
    "is_bug": true,
    "src_path": "org/mockito/configuration/DefaultMockitoConfiguration.java",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getAnnotationEngine()",
    "snippet": "public AnnotationEngine getAnnotationEngine() {\n        return new InjectingAnnotationEngine();\n    }",
    "begin_line": 38,
    "end_line": 40,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultMockitoConfiguration.cleansStackTrace#45",
    "is_bug": true,
    "src_path": "org/mockito/configuration/DefaultMockitoConfiguration.java",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.cleansStackTrace()",
    "snippet": "public boolean cleansStackTrace() {\n        return true;\n    }",
    "begin_line": 45,
    "end_line": 47,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultMockitoConfiguration.enableClassCache#52",
    "is_bug": true,
    "src_path": "org/mockito/configuration/DefaultMockitoConfiguration.java",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.enableClassCache()",
    "snippet": "public boolean enableClassCache() {\n        return true;\n    }",
    "begin_line": 52,
    "end_line": 54,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.checkedExceptionInvalid#56",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.checkedExceptionInvalid(java.lang.Throwable)",
    "snippet": "public void checkedExceptionInvalid(Throwable t) {\n        throw new MockitoException(join(\n                \"Checked exception is invalid for this method!\",\n                \"Invalid: \" + t\n        ));\n    }",
    "begin_line": 56,
    "end_line": 61,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.cannotStubWithNullThrowable#63",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.cannotStubWithNullThrowable()",
    "snippet": "public void cannotStubWithNullThrowable() {\n        throw new MockitoException(join(\n                \"Cannot stub with null throwable!\"\n        ));\n\n    }",
    "begin_line": 63,
    "end_line": 68,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.unfinishedStubbing#70",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.unfinishedStubbing(org.mockito.invocation.Location)",
    "snippet": "public void unfinishedStubbing(Location location) {\n        throw new UnfinishedStubbingException(join(\n                \"Unfinished stubbing detected here:\",\n                location,\n                \"\",\n                \"E.g. thenReturn() may be missing.\",\n                \"Examples of correct stubbing:\",\n                \"    when(mock.isOk()).thenReturn(true);\",\n                \"    when(mock.isOk()).thenThrow(exception);\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"Hints:\",\n                \" 1. missing thenReturn()\",\n                \" 2. you are trying to stub a final method, you naughty developer!\",\n                \" 3: you are stubbing the behaviour of another mock inside before \u0027thenReturn\u0027 instruction if completed\",\n                \"\"\n        ));\n    }",
    "begin_line": 70,
    "end_line": 86,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.incorrectUseOfApi#88",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.incorrectUseOfApi()",
    "snippet": "public void incorrectUseOfApi() {\n        throw new MockitoException(join(\n                \"Incorrect use of API detected here:\",\n                new LocationImpl(),\n                \"\",\n                \"You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.\",\n                \"Examples of correct usage:\",\n                \"    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);\",\n                \"    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);\",\n                \"\"\n        ));\n    }",
    "begin_line": 88,
    "end_line": 99,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.missingMethodInvocation#101",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.missingMethodInvocation()",
    "snippet": "public void missingMethodInvocation() {\n        throw new MissingMethodInvocationException(join(\n                \"when() requires an argument which has to be \u0027a method call on a mock\u0027.\",\n                \"For example:\",\n                \"    when(mock.getArticles()).thenReturn(articles);\",\n                \"\",\n                \"Also, this error might show up because:\",\n                \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                \"   Those methods *cannot* be stubbed/verified.\",\n                \"   \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"2. inside when() you don\u0027t call method on mock but on some other object.\",\n                \"\"\n        ));\n    }",
    "begin_line": 101,
    "end_line": 114,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.unfinishedVerificationException#116",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.unfinishedVerificationException(org.mockito.invocation.Location)",
    "snippet": "public void unfinishedVerificationException(Location location) {\n        UnfinishedVerificationException exception \u003d new UnfinishedVerificationException(join(\n                \"Missing method call for verify(mock) here:\",\n                location,\n                \"\",\n                \"Example of correct verification:\",\n                \"    verify(mock).doSomething()\",\n                \"\",\n                \"Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.\",\n                \"Those methods *cannot* be stubbed/verified.\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n\n        throw exception;\n    }",
    "begin_line": 116,
    "end_line": 131,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.notAMockPassedToVerify#133",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.notAMockPassedToVerify(java.lang.Class)",
    "snippet": "public void notAMockPassedToVerify(Class type) {\n        throw new NotAMockException(join(\n                \"Argument passed to verify() is of type \" + type.getSimpleName() + \" and is not a mock!\",\n                \"Make sure you place the parenthesis correctly!\",\n                \"See the examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\"\n        ));\n    }",
    "begin_line": 133,
    "end_line": 142,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.nullPassedToVerify#144",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.nullPassedToVerify()",
    "snippet": "public void nullPassedToVerify() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to verify() should be a mock but is null!\",\n                \"Examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\",\n                \"    not: verify(mock.someMethod());\",\n                \"Also, if you use @Mock annotation don\u0027t miss initMocks()\"\n        ));\n    }",
    "begin_line": 144,
    "end_line": 154,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.notAMockPassedToWhenMethod#156",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.notAMockPassedToWhenMethod()",
    "snippet": "public void notAMockPassedToWhenMethod() {\n        throw new NotAMockException(join(\n                \"Argument passed to when() is not a mock!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\"\n        ));\n    }",
    "begin_line": 156,
    "end_line": 162,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.nullPassedToWhenMethod#164",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.nullPassedToWhenMethod()",
    "snippet": "public void nullPassedToWhenMethod() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to when() is null!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",\n                \"Also, if you use @Mock annotation don\u0027t miss initMocks()\"\n        ));\n    }",
    "begin_line": 164,
    "end_line": 171,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.mocksHaveToBePassedToVerifyNoMoreInteractions#173",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.mocksHaveToBePassedToVerifyNoMoreInteractions()",
    "snippet": "public void mocksHaveToBePassedToVerifyNoMoreInteractions() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that should be verified, e.g:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));\n    }",
    "begin_line": 173,
    "end_line": 181,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.notAMockPassedToVerifyNoMoreInteractions#183",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.notAMockPassedToVerifyNoMoreInteractions()",
    "snippet": "public void notAMockPassedToVerifyNoMoreInteractions() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));\n    }",
    "begin_line": 183,
    "end_line": 191,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.nullPassedToVerifyNoMoreInteractions#193",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.nullPassedToVerifyNoMoreInteractions()",
    "snippet": "public void nullPassedToVerifyNoMoreInteractions() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));\n    }",
    "begin_line": 193,
    "end_line": 200,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.notAMockPassedWhenCreatingInOrder#202",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.notAMockPassedWhenCreatingInOrder()",
    "snippet": "public void notAMockPassedWhenCreatingInOrder() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder \u003d inOrder(mockOne, mockTwo);\"\n        ));\n    }",
    "begin_line": 202,
    "end_line": 209,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.nullPassedWhenCreatingInOrder#211",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.nullPassedWhenCreatingInOrder()",
    "snippet": "public void nullPassedWhenCreatingInOrder() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder \u003d inOrder(mockOne, mockTwo);\"\n        ));\n    }",
    "begin_line": 211,
    "end_line": 218,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.mocksHaveToBePassedWhenCreatingInOrder#220",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.mocksHaveToBePassedWhenCreatingInOrder()",
    "snippet": "public void mocksHaveToBePassedWhenCreatingInOrder() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder \u003d inOrder(mockOne, mockTwo);\"\n        ));\n    }",
    "begin_line": 220,
    "end_line": 227,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.inOrderRequiresFamiliarMock#229",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.inOrderRequiresFamiliarMock()",
    "snippet": "public void inOrderRequiresFamiliarMock() {\n        throw new MockitoException(join(\n                \"InOrder can only verify mocks that were passed in during creation of InOrder.\",\n                \"For example:\",\n                \"    InOrder inOrder \u003d inOrder(mockOne);\",\n                \"    inOrder.verify(mockOne).doStuff();\"\n        ));\n    }",
    "begin_line": 229,
    "end_line": 236,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.invalidUseOfMatchers#238",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.invalidUseOfMatchers(int, java.util.List\u003corg.mockito.internal.matchers.LocalizedMatcher\u003e)",
    "snippet": "public void invalidUseOfMatchers(int expectedMatchersCount, List\u003cLocalizedMatcher\u003e recordedMatchers) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers!\",\n                expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size() + \" recorded:\" +\n                        locationsOf(recordedMatchers),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers class.\",\n                \"\"\n        ));\n    }",
    "begin_line": 238,
    "end_line": 255,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.incorrectUseOfAdditionalMatchers#257",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.incorrectUseOfAdditionalMatchers(java.lang.String, int, java.util.Collection\u003corg.mockito.internal.matchers.LocalizedMatcher\u003e)",
    "snippet": "public void incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection\u003cLocalizedMatcher\u003e matcherStack) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers inside additional matcher \" + additionalMatcherName + \" !\",\n                new LocationImpl(),\n                \"\",\n                expectedSubMatchersCount + \" sub matchers expected, \" + matcherStack.size() + \" recorded:\",\n                locationsOf(matcherStack),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), eq(\\\"raw String\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers and AdditionalMatchers classes.\",\n                \"\"\n        ));\n    }",
    "begin_line": 257,
    "end_line": 276,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.stubPassedToVerify#278",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.stubPassedToVerify()",
    "snippet": "public void stubPassedToVerify() {\n        throw new CannotVerifyStubOnlyMock(join(\n                \"Argument passed to verify() is a stubOnly() mock, not a full blown mock!\",\n                \"If you intend to verify invocations on a mock, don\u0027t use stubOnly() in its MockSettings.\"\n        ));\n    }",
    "begin_line": 278,
    "end_line": 283,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.reportNoSubMatchersFound#285",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.reportNoSubMatchersFound(java.lang.String)",
    "snippet": "public void reportNoSubMatchersFound(String additionalMatcherName) {\n        throw new InvalidUseOfMatchersException(join(\n                \"No matchers found for additional matcher \" + additionalMatcherName,\n                new LocationImpl(),\n                \"\"\n        ));\n    }",
    "begin_line": 285,
    "end_line": 291,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.locationsOf#294",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.locationsOf(java.util.Collection\u003corg.mockito.internal.matchers.LocalizedMatcher\u003e)",
    "snippet": "private Object locationsOf(Collection\u003cLocalizedMatcher\u003e matchers) {\n        List\u003cString\u003e description \u003d new ArrayList\u003cString\u003e();\n        for (LocalizedMatcher matcher : matchers)\n            description.add(matcher.getLocation().toString());\n        return join(description.toArray());\n    }",
    "begin_line": 294,
    "end_line": 299,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.argumentsAreDifferent#301",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.argumentsAreDifferent(java.lang.String, java.lang.String, org.mockito.invocation.Location)",
    "snippet": "public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n        String message \u003d join(\"Argument(s) are different! Wanted:\",\n                wanted,\n                new LocationImpl(),\n                \"Actual invocation has different arguments:\",\n                actual,\n                actualLocation,\n                \"\"\n        );\n\n        throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n    }",
    "begin_line": 301,
    "end_line": 312,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.wantedButNotInvoked#314",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.wantedButNotInvoked(org.mockito.invocation.DescribedInvocation)",
    "snippet": "public void wantedButNotInvoked(DescribedInvocation wanted) {\n        throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));\n    }",
    "begin_line": 314,
    "end_line": 316,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.wantedButNotInvoked#318",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.wantedButNotInvoked(org.mockito.invocation.DescribedInvocation, java.util.List\u003c? extends org.mockito.invocation.DescribedInvocation\u003e)",
    "snippet": "public void wantedButNotInvoked(DescribedInvocation wanted, List\u003c? extends DescribedInvocation\u003e invocations) {\n        String allInvocations;\n        if (invocations.isEmpty()) {\n            allInvocations \u003d \"Actually, there were zero interactions with this mock.\\n\";\n        } else {\n            StringBuilder sb \u003d new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");\n            for (DescribedInvocation i : invocations) {\n                sb.append(i.toString())\n                        .append(\"\\n\")\n                        .append(i.getLocation())\n                        .append(\"\\n\\n\");\n            }\n            allInvocations \u003d sb.toString();\n        }\n\n        String message \u003d createWantedButNotInvokedMessage(wanted);\n        throw new WantedButNotInvoked(message + allInvocations);\n    }",
    "begin_line": 318,
    "end_line": 335,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.createWantedButNotInvokedMessage#337",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.createWantedButNotInvokedMessage(org.mockito.invocation.DescribedInvocation)",
    "snippet": "private String createWantedButNotInvokedMessage(DescribedInvocation wanted) {\n        return join(\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"\"\n        );\n    }",
    "begin_line": 337,
    "end_line": 344,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.wantedButNotInvokedInOrder#346",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.wantedButNotInvokedInOrder(org.mockito.invocation.DescribedInvocation, org.mockito.invocation.DescribedInvocation)",
    "snippet": "public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure\",\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"Wanted anywhere AFTER following interaction:\",\n                previous.toString(),\n                previous.getLocation(),\n                \"\"\n        ));\n    }",
    "begin_line": 346,
    "end_line": 357,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.tooManyActualInvocations#359",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.tooManyActualInvocations(int, int, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
    "snippet": "public void tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n        String message \u003d createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new TooManyActualInvocations(message);\n    }",
    "begin_line": 359,
    "end_line": 362,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.createTooManyInvocationsMessage#364",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.createTooManyInvocationsMessage(int, int, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
    "snippet": "private String createTooManyInvocationsMessage(int wantedCount, int actualCount, DescribedInvocation wanted,\n                                                   Location firstUndesired) {\n        return join(\n                wanted.toString(),\n                \"Wanted \" + pluralize(wantedCount) + \":\",\n                new LocationImpl(),\n                \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                firstUndesired,\n                \"\"\n        );\n    }",
    "begin_line": 364,
    "end_line": 374,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.neverWantedButInvoked#376",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.neverWantedButInvoked(org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
    "snippet": "public void neverWantedButInvoked(DescribedInvocation wanted, Location firstUndesired) {\n        throw new NeverWantedButInvoked(join(\n                wanted.toString(),\n                \"Never wanted here:\",\n                new LocationImpl(),\n                \"But invoked here:\",\n                firstUndesired,\n                \"\"\n        ));\n    }",
    "begin_line": 376,
    "end_line": 385,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.tooManyActualInvocationsInOrder#387",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.tooManyActualInvocationsInOrder(int, int, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
    "snippet": "public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n        String message \u003d createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));\n    }",
    "begin_line": 387,
    "end_line": 392,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.createTooLittleInvocationsMessage#394",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
    "snippet": "private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,\n                                                     Location lastActualInvocation) {\n        String ending \u003d\n                (lastActualInvocation !\u003d null) ? lastActualInvocation + \"\\n\" : \"\\n\";\n\n        String message \u003d join(\n                wanted.toString(),\n                \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n                new LocationImpl(),\n                \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                ending\n        );\n        return message;\n    }",
    "begin_line": 394,
    "end_line": 407,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.tooLittleActualInvocations#409",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
    "snippet": "public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n        String message \u003d createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new TooLittleActualInvocations(message);\n    }",
    "begin_line": 409,
    "end_line": 413,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.tooLittleActualInvocationsInOrder#415",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
    "snippet": "public void tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n        String message \u003d createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));\n    }",
    "begin_line": 415,
    "end_line": 421,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.noMoreInteractionsWanted#423",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.noMoreInteractionsWanted(org.mockito.invocation.Invocation, java.util.List\u003corg.mockito.internal.exceptions.VerificationAwareInvocation\u003e)",
    "snippet": "public void noMoreInteractionsWanted(Invocation undesired, List\u003cVerificationAwareInvocation\u003e invocations) {\n        ScenarioPrinter scenarioPrinter \u003d new ScenarioPrinter();\n        String scenario \u003d scenarioPrinter.print(invocations);\n\n        throw new NoInteractionsWanted(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock \u0027\" + safelyGetMockName(undesired.getMock()) + \"\u0027:\",\n                undesired.getLocation(),\n                scenario\n        ));\n    }",
    "begin_line": 423,
    "end_line": 434,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.noMoreInteractionsWantedInOrder#436",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.noMoreInteractionsWantedInOrder(org.mockito.invocation.Invocation)",
    "snippet": "public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n        throw new VerificationInOrderFailure(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock \u0027\" + safelyGetMockName(undesired.getMock()) + \"\u0027:\",\n                undesired.getLocation()\n        ));\n    }",
    "begin_line": 436,
    "end_line": 443,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.cannotMockFinalClass#445",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.cannotMockFinalClass(java.lang.Class\u003c?\u003e)",
    "snippet": "public void cannotMockFinalClass(Class\u003c?\u003e clazz) {\n        throw new MockitoException(join(\n                \"Cannot mock/spy \" + clazz.toString(),\n                \"Mockito cannot mock/spy following:\",\n                \"  - final classes\",\n                \"  - anonymous classes\",\n                \"  - primitive types\"\n        ));\n    }",
    "begin_line": 445,
    "end_line": 453,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.cannotStubVoidMethodWithAReturnValue#455",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.cannotStubVoidMethodWithAReturnValue(java.lang.String)",
    "snippet": "public void cannotStubVoidMethodWithAReturnValue(String methodName) {\n        throw new CannotStubVoidMethodWithReturnValue(join(\n                \"\u0027\" + methodName + \"\u0027 is a *void method* and it *cannot* be stubbed with a *return value*!\",\n                \"Voids are usually stubbed with Throwables:\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"***\",\n                \"If you\u0027re unsure why you\u0027re getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.\",\n                \"2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.\",\n                \"3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"4. \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n    }",
    "begin_line": 455,
    "end_line": 470,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.onlyVoidMethodsCanBeSetToDoNothing#472",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.onlyVoidMethodsCanBeSetToDoNothing()",
    "snippet": "public void onlyVoidMethodsCanBeSetToDoNothing() {\n        throw new MockitoException(join(\n                \"Only void methods can doNothing()!\",\n                \"Example of correct use of doNothing():\",\n                \"    doNothing().\",\n                \"    doThrow(new RuntimeException())\",\n                \"    .when(mock).someVoidMethod();\",\n                \"Above means:\",\n                \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n        ));\n    }",
    "begin_line": 472,
    "end_line": 482,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.wrongTypeOfReturnValue#484",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.wrongTypeOfReturnValue(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {\n        throw new WrongTypeOfReturnValue(join(\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"***\",\n                \"If you\u0027re unsure why you\u0027re getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));\n    }",
    "begin_line": 484,
    "end_line": 497,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.wrongTypeReturnedByDefaultAnswer#499",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.wrongTypeReturnedByDefaultAnswer(java.lang.Object, java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public void wrongTypeReturnedByDefaultAnswer(Object mock, String expectedType, String actualType, String methodName) {\n        throw new WrongTypeOfReturnValue(join(\n                \"Default answer returned a result with the wrong type:\",\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"\",\n                \"The default answer of \" + safelyGetMockName(mock) + \" that was configured on the mock is probably incorrectly implemented.\",\n                \"\"\n        ));\n    }",
    "begin_line": 499,
    "end_line": 508,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.wantedAtMostX#511",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.wantedAtMostX(int, int)",
    "snippet": "public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {\n        throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));\n    }",
    "begin_line": 511,
    "end_line": 513,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.misplacedArgumentMatcher#515",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.misplacedArgumentMatcher(java.util.List\u003corg.mockito.internal.matchers.LocalizedMatcher\u003e)",
    "snippet": "public void misplacedArgumentMatcher(List\u003cLocalizedMatcher\u003e lastMatchers) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Misplaced argument matcher detected here:\",\n                locationsOf(lastMatchers),\n                \"\",\n                \"You cannot use argument matchers outside of verification or stubbing.\",\n                \"Examples of correct usage of argument matchers:\",\n                \"    when(mock.get(anyInt())).thenReturn(null);\",\n                \"    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());\",\n                \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                \"\",\n                \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n    }",
    "begin_line": 515,
    "end_line": 531,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.smartNullPointerException#533",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.smartNullPointerException(java.lang.String, org.mockito.invocation.Location)",
    "snippet": "public void smartNullPointerException(String invocation, Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new LocationImpl(),\n                \"because this method call was *not* stubbed correctly:\",\n                location,\n                invocation,\n                \"\"\n        ));\n    }",
    "begin_line": 533,
    "end_line": 542,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.noArgumentValueWasCaptured#544",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.noArgumentValueWasCaptured()",
    "snippet": "public void noArgumentValueWasCaptured() {\n        throw new MockitoException(join(\n                \"No argument value was captured!\",\n                \"You might have forgotten to use argument.capture() in verify()...\",\n                \"...or you used capture() in stubbing but stubbed method was not called.\",\n                \"Be aware that it is recommended to use capture() only with verify()\",\n                \"\",\n                \"Examples of correct argument capturing:\",\n                \"    ArgumentCaptor\u003cPerson\u003e argument \u003d ArgumentCaptor.forClass(Person.class);\",\n                \"    verify(mock).doSomething(argument.capture());\",\n                \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                \"\"\n        ));\n    }",
    "begin_line": 544,
    "end_line": 557,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.extraInterfacesDoesNotAcceptNullParameters#559",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.extraInterfacesDoesNotAcceptNullParameters()",
    "snippet": "public void extraInterfacesDoesNotAcceptNullParameters() {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept null parameters.\"\n        ));\n    }",
    "begin_line": 559,
    "end_line": 563,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.extraInterfacesAcceptsOnlyInterfaces#565",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.extraInterfacesAcceptsOnlyInterfaces(java.lang.Class\u003c?\u003e)",
    "snippet": "public void extraInterfacesAcceptsOnlyInterfaces(Class\u003c?\u003e wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() accepts only interfaces.\",\n                \"You passed following type: \" + wrongType.getSimpleName() + \" which is not an interface.\"\n        ));\n    }",
    "begin_line": 565,
    "end_line": 570,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.extraInterfacesCannotContainMockedType#572",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.extraInterfacesCannotContainMockedType(java.lang.Class\u003c?\u003e)",
    "snippet": "public void extraInterfacesCannotContainMockedType(Class\u003c?\u003e wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept the same type as the mocked type.\",\n                \"You mocked following type: \" + wrongType.getSimpleName(),\n                \"and you passed the same very interface to the extraInterfaces()\"\n        ));\n    }",
    "begin_line": 572,
    "end_line": 578,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.extraInterfacesRequiresAtLeastOneInterface#580",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.extraInterfacesRequiresAtLeastOneInterface()",
    "snippet": "public void extraInterfacesRequiresAtLeastOneInterface() {\n        throw new MockitoException(join(\n                \"extraInterfaces() requires at least one interface.\"\n        ));\n    }",
    "begin_line": 580,
    "end_line": 584,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.mockedTypeIsInconsistentWithSpiedInstanceType#586",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.mockedTypeIsInconsistentWithSpiedInstanceType(java.lang.Class\u003c?\u003e, java.lang.Object)",
    "snippet": "public void mockedTypeIsInconsistentWithSpiedInstanceType(Class\u003c?\u003e mockedType, Object spiedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your spied instance.\",\n                \"Mocked type must be: \" + spiedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct spying:\",\n                \"  spy \u003d mock( -\u003eArrayList.class\u003c- , withSettings().spiedInstance( -\u003enew ArrayList()\u003c- );\",\n                \"  //incorrect - types don\u0027t match:\",\n                \"  spy \u003d mock( -\u003eList.class\u003c- , withSettings().spiedInstance( -\u003enew ArrayList()\u003c- );\"\n        ));\n    }",
    "begin_line": 586,
    "end_line": 595,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.cannotCallAbstractRealMethod#597",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.cannotCallAbstractRealMethod()",
    "snippet": "public void cannotCallAbstractRealMethod() {\n        throw new MockitoException(join(\n                \"Cannot call abstract real method on java object!\",\n                \"Calling real methods is only possible when mocking non abstract method.\",\n                \"  //correct example:\",\n                \"  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();\"\n        ));\n    }",
    "begin_line": 597,
    "end_line": 604,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.cannotVerifyToString#606",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.cannotVerifyToString()",
    "snippet": "public void cannotVerifyToString() {\n        throw new MockitoException(join(\n                \"Mockito cannot verify toString()\",\n                \"toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). \" +\n                        \"Verifying it may give inconsistent or hard to understand results. \" +\n                        \"Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\",\n                \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n        ));\n    }",
    "begin_line": 606,
    "end_line": 614,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.moreThanOneAnnotationNotAllowed#616",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.moreThanOneAnnotationNotAllowed(java.lang.String)",
    "snippet": "public void moreThanOneAnnotationNotAllowed(String fieldName) {\n        throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n                \"The field \u0027\" + fieldName + \"\u0027 has multiple Mockito annotations.\\n\" +\n                \"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");\n    }",
    "begin_line": 616,
    "end_line": 620,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.unsupportedCombinationOfAnnotations#622",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.unsupportedCombinationOfAnnotations(java.lang.String, java.lang.String)",
    "snippet": "public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {\n        throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);\n    }",
    "begin_line": 622,
    "end_line": 625,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.cannotInitializeForSpyAnnotation#627",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.cannotInitializeForSpyAnnotation(java.lang.String, java.lang.Exception)",
    "snippet": "public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instantiate a @Spy for \u0027\" + fieldName + \"\u0027 field.\",\n                \"You haven\u0027t provided the instance for spying at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @Spy:\",\n                \"   @Spy List mock \u003d new LinkedList();\",\n                \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n                \"   //also, don\u0027t forget about MockitoAnnotations.initMocks();\",\n                \"\"), details);\n    }",
    "begin_line": 627,
    "end_line": 636,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.cannotInitializeForInjectMocksAnnotation#638",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.cannotInitializeForInjectMocksAnnotation(java.lang.String, java.lang.Exception)",
    "snippet": "public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named \u0027\" + fieldName + \"\u0027.\",\n                \"You haven\u0027t provided the instance at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @InjectMocks:\",\n                \"   @InjectMocks Service service \u003d new Service();\",\n                \"   @InjectMocks Service service;\",\n                \"   //also, don\u0027t forget about MockitoAnnotations.initMocks();\",\n                \"   //and... don\u0027t forget about some @Mocks for injection :)\",\n                \"\"), details);\n    }",
    "begin_line": 638,
    "end_line": 648,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.atMostAndNeverShouldNotBeUsedWithTimeout#650",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.atMostAndNeverShouldNotBeUsedWithTimeout()",
    "snippet": "public void atMostAndNeverShouldNotBeUsedWithTimeout() {\n        throw new FriendlyReminderException(join(\"\",\n                \"Don\u0027t panic! I\u0027m just a friendly reminder!\",\n                \"timeout() should not be used with atMost() or never() because...\",\n                \"...it does not make much sense - the test would have passed immediately in concurency\",\n                \"We kept this method only to avoid compilation errors when upgrading Mockito.\",\n                \"In future release we will remove timeout(x).atMost(y) from the API.\",\n                \"If you want to find out more please refer to issue 235\",\n                \"\"));\n    }",
    "begin_line": 650,
    "end_line": 659,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.fieldInitialisationThrewException#661",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.fieldInitialisationThrewException(java.lang.reflect.Field, java.lang.Throwable)",
    "snippet": "public void fieldInitialisationThrewException(Field field, Throwable details) {\n        throw new MockitoException(join(\n                \"Cannot instantiate @InjectMocks field named \u0027\" + field.getName() + \"\u0027 of type \u0027\" + field.getType() + \"\u0027.\",\n                \"You haven\u0027t provided the instance at field declaration so I tried to construct the instance.\",\n                \"However the constructor or the initialization block threw an exception : \" + details.getMessage(),\n                \"\"), details);\n\n    }",
    "begin_line": 661,
    "end_line": 668,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.invocationListenerDoesNotAcceptNullParameters#670",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.invocationListenerDoesNotAcceptNullParameters()",
    "snippet": "public void invocationListenerDoesNotAcceptNullParameters() {\n        throw new MockitoException(\"invocationListeners() does not accept null parameters\");\n    }",
    "begin_line": 670,
    "end_line": 672,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.invocationListenersRequiresAtLeastOneListener#674",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.invocationListenersRequiresAtLeastOneListener()",
    "snippet": "public void invocationListenersRequiresAtLeastOneListener() {\n        throw new MockitoException(\"invocationListeners() requires at least one listener\");\n    }",
    "begin_line": 674,
    "end_line": 676,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.invocationListenerThrewException#678",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.invocationListenerThrewException(org.mockito.listeners.InvocationListener, java.lang.Throwable)",
    "snippet": "public void invocationListenerThrewException(InvocationListener listener, Throwable listenerThrowable) {\n        throw new MockitoException(StringJoiner.join(\n                \"The invocation listener with type \" + listener.getClass().getName(),\n                \"threw an exception : \" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);\n    }",
    "begin_line": 678,
    "end_line": 682,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.cannotInjectDependency#684",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.cannotInjectDependency(java.lang.reflect.Field, java.lang.Object, java.lang.Exception)",
    "snippet": "public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {\n        throw new MockitoException(join(\n                \"Mockito couldn\u0027t inject mock dependency \u0027\" + safelyGetMockName(matchingMock) + \"\u0027 on field \",\n                \"\u0027\" + field + \"\u0027\",\n                \"whose type \u0027\" + field.getDeclaringClass().getCanonicalName() + \"\u0027 was annotated by @InjectMocks in your test.\",\n                \"Also I failed because: \" + exceptionCauseMessageIfAvailable(details),\n                \"\"\n        ), details);\n    }",
    "begin_line": 684,
    "end_line": 692,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.exceptionCauseMessageIfAvailable#694",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.exceptionCauseMessageIfAvailable(java.lang.Exception)",
    "snippet": "private String exceptionCauseMessageIfAvailable(Exception details) {\n        if (details.getCause() \u003d\u003d null) {\n            return details.getMessage();\n        }\n        return details.getCause().getMessage();\n    }",
    "begin_line": 694,
    "end_line": 699,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.mockedTypeIsInconsistentWithDelegatedInstanceType#701",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.mockedTypeIsInconsistentWithDelegatedInstanceType(java.lang.Class, java.lang.Object)",
    "snippet": "public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your delegated instance.\",\n                \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct delegate:\",\n                \"  spy \u003d mock( -\u003eList.class\u003c- , withSettings().delegatedInstance( -\u003enew ArrayList()\u003c- );\",\n                \"  //incorrect - types don\u0027t match:\",\n                \"  spy \u003d mock( -\u003eList.class\u003c- , withSettings().delegatedInstance( -\u003enew HashSet()\u003c- );\"\n        ));\n    }",
    "begin_line": 701,
    "end_line": 710,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.spyAndDelegateAreMutuallyExclusive#712",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.spyAndDelegateAreMutuallyExclusive()",
    "snippet": "public void spyAndDelegateAreMutuallyExclusive() {\n        throw new MockitoException(join(\n                \"Settings should not define a spy instance and a delegated instance at the same time.\"\n        ));\n    }",
    "begin_line": 712,
    "end_line": 716,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime#718",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime()",
    "snippet": "public void invalidArgumentRangeAtIdentityAnswerCreationTime() {\n        throw new MockitoException(join(\"Invalid argument index.\",\n                \"The index need to be a positive number that indicates the position of the argument to return.\",\n                \"However it is possible to use the -1 value to indicates that the last argument should be\",\n                \"returned.\"));\n    }",
    "begin_line": 718,
    "end_line": 723,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.invalidArgumentPositionRangeAtInvocationTime#725",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime(org.mockito.invocation.InvocationOnMock, boolean, int)",
    "snippet": "public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n        throw new MockitoException(\n                join(\"Invalid argument index for the current invocation of method : \",\n                        \" -\u003e \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                        \"\",\n                        (willReturnLastParameter ?\n                                \"Last parameter wanted\" :\n                                \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n                        \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n                        \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n                        \"\"));\n    }",
    "begin_line": 725,
    "end_line": 736,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.possibleArgumentTypesOf#738",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.possibleArgumentTypesOf(org.mockito.invocation.InvocationOnMock)",
    "snippet": "private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {\n        Class\u003c?\u003e[] parameterTypes \u003d invocation.getMethod().getParameterTypes();\n        if (parameterTypes.length \u003d\u003d 0) {\n            return new StringBuilder(\"the method has no arguments.\\n\");\n        }\n\n        StringBuilder stringBuilder \u003d new StringBuilder(\"the possible argument indexes for this method are :\\n\");\n        for (int i \u003d 0, parameterTypesLength \u003d parameterTypes.length; i \u003c parameterTypesLength; i++) {\n            stringBuilder.append(\"    [\").append(i);\n\n            if (invocation.getMethod().isVarArgs() \u0026\u0026 i \u003d\u003d parameterTypesLength - 1) {\n                stringBuilder.append(\"+] \").append(parameterTypes[i].getComponentType().getSimpleName()).append(\"  \u003c- Vararg\").append(\"\\n\");\n            } else {\n                stringBuilder.append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");\n            }\n        }\n        return stringBuilder;\n    }",
    "begin_line": 738,
    "end_line": 755,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.wrongTypeOfArgumentToReturn#757",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.wrongTypeOfArgumentToReturn(org.mockito.invocation.InvocationOnMock, java.lang.String, java.lang.Class, int)",
    "snippet": "public void wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class actualType, int argumentIndex) {\n        throw new WrongTypeOfReturnValue(join(\n                \"The argument of type \u0027\" + actualType.getSimpleName() + \"\u0027 cannot be returned because the following \",\n                \"method should return the type \u0027\" + expectedType + \"\u0027\",\n                \" -\u003e \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                \"\",\n                \"The reason for this error can be :\",\n                \"1. The wanted argument position is incorrect.\",\n                \"2. The answer is used on the wrong interaction.\",\n                \"\",\n                \"Position of the wanted argument is \" + argumentIndex + \" and \" + possibleArgumentTypesOf(invocation),\n                \"***\",\n                \"However if you\u0027re still unsure why you\u0027re getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));\n    }",
    "begin_line": 757,
    "end_line": 777,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.defaultAnswerDoesNotAcceptNullParameter#779",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.defaultAnswerDoesNotAcceptNullParameter()",
    "snippet": "public void defaultAnswerDoesNotAcceptNullParameter() {\n        throw new MockitoException(\"defaultAnswer() does not accept null parameter\");\n    }",
    "begin_line": 779,
    "end_line": 781,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.serializableWontWorkForObjectsThatDontImplementSerializable#783",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.serializableWontWorkForObjectsThatDontImplementSerializable(java.lang.Class)",
    "snippet": "public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n        throw new MockitoException(join(\n                \"You are using the setting \u0027withSettings().serializable()\u0027 however the type you are trying to mock \u0027\" + classToMock.getSimpleName() + \"\u0027\",\n                \"do not implement Serializable AND do not have a no-arg constructor.\",\n                \"This combination is requested, otherwise you will get an \u0027java.io.InvalidClassException\u0027 when the mock will be serialized\",\n                \"\",\n                \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n                \"i.e. the top-most superclass has to implements Serializable.\",\n                \"\"\n        ));\n    }",
    "begin_line": 783,
    "end_line": 793,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.delegatedMethodHasWrongReturnType#795",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.delegatedMethodHasWrongReturnType(java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object, java.lang.Object)",
    "snippet": "public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {\n        throw new MockitoException(join(\n                \"Methods called on delegated instance must have compatible return types with the mock.\",\n                \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n                \"return type should be: \" + mockMethod.getReturnType().getSimpleName() + \", but was: \" + delegateMethod.getReturnType().getSimpleName(),\n                \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n                \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n        ));\n    }",
    "begin_line": 795,
    "end_line": 803,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.delegatedMethodDoesNotExistOnDelegate#805",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.delegatedMethodDoesNotExistOnDelegate(java.lang.reflect.Method, java.lang.Object, java.lang.Object)",
    "snippet": "public void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {\n        throw new MockitoException(join(\n                \"Methods called on mock must exist in delegated instance.\",\n                \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n                \"no such method was found.\",\n                \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n                \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n        ));\n    }",
    "begin_line": 805,
    "end_line": 813,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.usingConstructorWithFancySerializable#815",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.usingConstructorWithFancySerializable(org.mockito.mock.SerializableMode)",
    "snippet": "public void usingConstructorWithFancySerializable(SerializableMode mode) {\n        throw new MockitoException(\"Mocks instantiated with constructor cannot be combined with \" + mode + \" serialization mode.\");\n    }",
    "begin_line": 815,
    "end_line": 817,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.cannotCreateTimerWithNegativeDurationTime#819",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.cannotCreateTimerWithNegativeDurationTime(long)",
    "snippet": "public void cannotCreateTimerWithNegativeDurationTime(long durationMillis) {\n        throw new FriendlyReminderException(join(\"\",\n                \"Don\u0027t panic! I\u0027m just a friendly reminder!\",\n                \"It is impossible for time to go backward, therefore...\",\n                \"You cannot put negative value of duration: (\" +  durationMillis +  \")\",\n                \"as argument of timer methods (after(), timeout())\",\n                \"\"));\n    }",
    "begin_line": 819,
    "end_line": 826,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Reporter.safelyGetMockName#828",
    "is_bug": true,
    "src_path": "org/mockito/exceptions/Reporter.java",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.safelyGetMockName(java.lang.Object)",
    "snippet": "private MockName safelyGetMockName(Object mock) {\n        return new MockUtil().getMockName(mock);\n    }",
    "begin_line": 828,
    "end_line": 830,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CaptorAnnotationProcessor.process#18",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/CaptorAnnotationProcessor.java",
    "class_name": "org.mockito.internal.configuration.CaptorAnnotationProcessor",
    "signature": "org.mockito.internal.configuration.CaptorAnnotationProcessor.process(org.mockito.Captor, java.lang.reflect.Field)",
    "snippet": "public Object process(Captor annotation, Field field) {\n        Class\u003c?\u003e type \u003d field.getType();\n        if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n            throw new MockitoException(\"@Captor field must be of the type ArgumentCaptor.\\n\" + \"Field: \u0027\"\n               + field.getName() + \"\u0027 has wrong type\\n\"\n               + \"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n        }\n        Class cls \u003d new GenericMaster().getGenericType(field);\n        return ArgumentCaptor.forClass(cls);\n    }",
    "begin_line": 18,
    "end_line": 27,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassPathLoader.loadConfiguration#64",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/ClassPathLoader.java",
    "class_name": "org.mockito.internal.configuration.ClassPathLoader",
    "signature": "org.mockito.internal.configuration.ClassPathLoader.loadConfiguration()",
    "snippet": "@SuppressWarnings({\"unchecked\"})\n    public IMockitoConfiguration loadConfiguration() {\n        //Trying to get config from classpath\n        Class configClass;\n        try {\n            configClass \u003d (Class) Class.forName(MOCKITO_CONFIGURATION_CLASS_NAME);\n        } catch (ClassNotFoundException e) {\n            //that\u0027s ok, it means there is no global config, using default one.\n            return null;\n        }\n\n        try {\n            return (IMockitoConfiguration) configClass.newInstance();\n        } catch (ClassCastException e) {\n            throw new MockitoConfigurationException(\"MockitoConfiguration class must implement \" + IMockitoConfiguration.class.getName() + \" interface.\", e);\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\"Unable to instantiate \" + MOCKITO_CONFIGURATION_CLASS_NAME +\" class. Does it have a safe, no-arg constructor?\", e);\n        }\n    }",
    "begin_line": 64,
    "end_line": 81,
    "comment": "/** \n * @return configuration loaded from classpath or null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultAnnotationEngine.DefaultAnnotationEngine#32",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/DefaultAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.DefaultAnnotationEngine()",
    "snippet": "public DefaultAnnotationEngine() {\n        registerAnnotationProcessor(Mock.class, new MockAnnotationProcessor());\n        registerAnnotationProcessor(MockitoAnnotations.Mock.class, new MockitoAnnotationsMockAnnotationProcessor());\n        registerAnnotationProcessor(Captor.class, new CaptorAnnotationProcessor());\n    }",
    "begin_line": 32,
    "end_line": 36,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultAnnotationEngine.createMockFor#42",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/DefaultAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)",
    "snippet": "@SuppressWarnings(\"deprecation\")\n    public Object createMockFor(Annotation annotation, Field field) {\n        return forAnnotation(annotation).process(annotation, field);\n    }",
    "begin_line": 42,
    "end_line": 44,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultAnnotationEngine.forAnnotation#46",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/DefaultAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.forAnnotation(A)",
    "snippet": "private \u003cA extends Annotation\u003e FieldAnnotationProcessor\u003cA\u003e forAnnotation(A annotation) {\n        if (annotationProcessorMap.containsKey(annotation.annotationType())) {\n            return (FieldAnnotationProcessor\u003cA\u003e) annotationProcessorMap.get(annotation.annotationType());\n        }\n        return new FieldAnnotationProcessor\u003cA\u003e() {\n            public Object process(A annotation, Field field) {\n                return null;\n            }\n        };\n    }",
    "begin_line": 46,
    "end_line": 55,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultAnnotationEngine.process#51",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/DefaultAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.process(A, java.lang.reflect.Field)",
    "snippet": "public Object process(A annotation, Field field) {\n                return null;\n            }",
    "begin_line": 51,
    "end_line": 53,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultAnnotationEngine.registerAnnotationProcessor#57",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/DefaultAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.registerAnnotationProcessor(java.lang.Class\u003cA\u003e, org.mockito.internal.configuration.FieldAnnotationProcessor\u003cA\u003e)",
    "snippet": "private \u003cA extends Annotation\u003e void registerAnnotationProcessor(Class\u003cA\u003e annotationClass, FieldAnnotationProcessor\u003cA\u003e fieldAnnotationProcessor) {\n        annotationProcessorMap.put(annotationClass, fieldAnnotationProcessor);\n    }",
    "begin_line": 57,
    "end_line": 59,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultAnnotationEngine.process#61",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/DefaultAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.process(java.lang.Class\u003c?\u003e, java.lang.Object)",
    "snippet": "public void process(Class\u003c?\u003e clazz, Object testInstance) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        for (Field field : fields) {\n            boolean alreadyAssigned \u003d false;\n            for(Annotation annotation : field.getAnnotations()) {           \n                Object mock \u003d createMockFor(annotation, field);\n                if (mock !\u003d null) {\n                    throwIfAlreadyAssigned(field, alreadyAssigned);                    \n                    alreadyAssigned \u003d true;                    \n                    try {\n                        new FieldSetter(testInstance, field).set(mock);\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                                + annotation, e);\n                    }\n                }        \n            }\n        }\n    }",
    "begin_line": 61,
    "end_line": 79,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultAnnotationEngine.throwIfAlreadyAssigned#81",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/DefaultAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.throwIfAlreadyAssigned(java.lang.reflect.Field, boolean)",
    "snippet": "void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n        if (alreadyAssigned) {\n            new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n        }\n    }",
    "begin_line": 81,
    "end_line": 85,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultInjectionEngine.injectMocksOnFields#19",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/DefaultInjectionEngine.java",
    "class_name": "org.mockito.internal.configuration.DefaultInjectionEngine",
    "signature": "org.mockito.internal.configuration.DefaultInjectionEngine.injectMocksOnFields(java.util.Set\u003cjava.lang.reflect.Field\u003e, java.util.Set\u003cjava.lang.Object\u003e, java.lang.Object)",
    "snippet": "public void injectMocksOnFields(Set\u003cField\u003e needingInjection, Set\u003cObject\u003e mocks, Object testClassInstance) {\n        MockInjection.onFields(needingInjection, testClassInstance)\n                .withMocks(mocks)\n                .tryConstructorInjection()\n                .tryPropertyOrFieldInjection()\n                .handleSpyAnnotation()\n                .apply();\n    }",
    "begin_line": 19,
    "end_line": 26,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GlobalConfiguration.getIt#25",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/GlobalConfiguration.java",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getIt()",
    "snippet": "IMockitoConfiguration getIt() {\n        return GLOBAL_CONFIGURATION.get();\n    }",
    "begin_line": 25,
    "end_line": 27,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GlobalConfiguration.GlobalConfiguration#29",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/GlobalConfiguration.java",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.GlobalConfiguration()",
    "snippet": "public GlobalConfiguration() {\n        //Configuration should be loaded only once but I cannot really test it\n        if (GLOBAL_CONFIGURATION.get() \u003d\u003d null) {\n            GLOBAL_CONFIGURATION.set(createConfig());\n        }\n    }",
    "begin_line": 29,
    "end_line": 34,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GlobalConfiguration.createConfig#36",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/GlobalConfiguration.java",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.createConfig()",
    "snippet": "private IMockitoConfiguration createConfig() {\n        IMockitoConfiguration defaultConfiguration \u003d new DefaultMockitoConfiguration();\n        IMockitoConfiguration config \u003d new ClassPathLoader().loadConfiguration();\n        if (config !\u003d null) {\n            return config;\n        } else {\n            return defaultConfiguration;\n        }\n    }",
    "begin_line": 36,
    "end_line": 44,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GlobalConfiguration.validate#46",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/GlobalConfiguration.java",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.validate()",
    "snippet": "public static void validate() {\n        new GlobalConfiguration();\n    }",
    "begin_line": 46,
    "end_line": 48,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GlobalConfiguration.getReturnValues#50",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/GlobalConfiguration.java",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getReturnValues()",
    "snippet": "public ReturnValues getReturnValues() {\n        return GLOBAL_CONFIGURATION.get().getReturnValues();\n    }",
    "begin_line": 50,
    "end_line": 52,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GlobalConfiguration.getAnnotationEngine#54",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/GlobalConfiguration.java",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getAnnotationEngine()",
    "snippet": "public AnnotationEngine getAnnotationEngine() {\n        return GLOBAL_CONFIGURATION.get().getAnnotationEngine();\n    }",
    "begin_line": 54,
    "end_line": 56,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GlobalConfiguration.cleansStackTrace#58",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/GlobalConfiguration.java",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.cleansStackTrace()",
    "snippet": "public boolean cleansStackTrace() {\n        return GLOBAL_CONFIGURATION.get().cleansStackTrace();\n    }",
    "begin_line": 58,
    "end_line": 60,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GlobalConfiguration.enableClassCache#62",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/GlobalConfiguration.java",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.enableClassCache()",
    "snippet": "public boolean enableClassCache() {\n        return GLOBAL_CONFIGURATION.get().enableClassCache();\n    }",
    "begin_line": 62,
    "end_line": 64,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GlobalConfiguration.getDefaultAnswer#66",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/GlobalConfiguration.java",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getDefaultAnswer()",
    "snippet": "public Answer\u003cObject\u003e getDefaultAnswer() {\n        return GLOBAL_CONFIGURATION.get().getDefaultAnswer();\n    }",
    "begin_line": 66,
    "end_line": 68,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InjectingAnnotationEngine.createMockFor#34",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/InjectingAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)",
    "snippet": "@Deprecated\n    public Object createMockFor(Annotation annotation, Field field) {\n        return delegate.createMockFor(annotation, field);\n    }",
    "begin_line": 34,
    "end_line": 36,
    "comment": "/** \n * Create a mock using  {@link DefaultAnnotationEngine}\n * @see org.mockito.internal.configuration.DefaultAnnotationEngine\n * @see org.mockito.configuration.AnnotationEngine#createMockFor(java.lang.annotation.Annotation,java.lang.reflect.Field)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InjectingAnnotationEngine.process#54",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/InjectingAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.process(java.lang.Class\u003c?\u003e, java.lang.Object)",
    "snippet": "public void process(Class\u003c?\u003e clazz, Object testInstance) {\n        processIndependentAnnotations(testInstance.getClass(), testInstance);\n        processInjectMocks(testInstance.getClass(), testInstance);\n    }",
    "begin_line": 54,
    "end_line": 57,
    "comment": "/** \n * Process the fields of the test instance and create Mocks, Spies, Captors and inject them on fields annotated \u0026#64;InjectMocks. \u003cp\u003e This code process the test class and the super classes. \u003col\u003e \u003cli\u003eFirst create Mocks, Spies, Captors.\u003c/li\u003e \u003cli\u003eThen try to inject them.\u003c/li\u003e \u003c/ol\u003e\n * @param clazz Not used\n * @param testInstance The instance of the test, should not be null.\n * @see org.mockito.configuration.AnnotationEngine#process(Class,Object)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InjectingAnnotationEngine.processInjectMocks#59",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/InjectingAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.processInjectMocks(java.lang.Class\u003c?\u003e, java.lang.Object)",
    "snippet": "private void processInjectMocks(final Class\u003c?\u003e clazz, final Object testInstance) {\n        Class\u003c?\u003e classContext \u003d clazz;\n        while (classContext !\u003d Object.class) {\n            injectMocks(testInstance);\n            classContext \u003d classContext.getSuperclass();\n        }\n    }",
    "begin_line": 59,
    "end_line": 65,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InjectingAnnotationEngine.processIndependentAnnotations#67",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/InjectingAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(java.lang.Class\u003c?\u003e, java.lang.Object)",
    "snippet": "private void processIndependentAnnotations(final Class\u003c?\u003e clazz, final Object testInstance) {\n        Class\u003c?\u003e classContext \u003d clazz;\n        while (classContext !\u003d Object.class) {\n            //this will create @Mocks, @Captors, etc:\n            delegate.process(classContext, testInstance);\n            //this will create @Spies:\n            spyAnnotationEngine.process(classContext, testInstance);\n\n            classContext \u003d classContext.getSuperclass();\n        }\n    }",
    "begin_line": 67,
    "end_line": 77,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InjectingAnnotationEngine.injectMocks#89",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/InjectingAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.injectMocks(java.lang.Object)",
    "snippet": "public void injectMocks(final Object testClassInstance) {\n        Class\u003c?\u003e clazz \u003d testClassInstance.getClass();\n        Set\u003cField\u003e mockDependentFields \u003d new HashSet\u003cField\u003e();\n        Set\u003cObject\u003e mocks \u003d newMockSafeHashSet();\n        \n        while (clazz !\u003d Object.class) {\n            new InjectMocksScanner(clazz).addTo(mockDependentFields);\n            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);\n            clazz \u003d clazz.getSuperclass();\n        }\n        \n        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);\n    }",
    "begin_line": 89,
    "end_line": 101,
    "comment": "/** \n * Initializes mock/spies dependencies for objects annotated with \u0026#064;InjectMocks for given testClassInstance. \u003cp\u003e See examples in javadoc for  {@link MockitoAnnotations} class.\n * @param testClassInstance Test class, usually \u003ccode\u003ethis\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockAnnotationProcessor.process#17",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/MockAnnotationProcessor.java",
    "class_name": "org.mockito.internal.configuration.MockAnnotationProcessor",
    "signature": "org.mockito.internal.configuration.MockAnnotationProcessor.process(org.mockito.Mock, java.lang.reflect.Field)",
    "snippet": "public Object process(Mock annotation, Field field) {\n        MockSettings mockSettings \u003d Mockito.withSettings();\n        if (annotation.extraInterfaces().length \u003e 0) { // never null\n            mockSettings.extraInterfaces(annotation.extraInterfaces());\n        }\n        if (\"\".equals(annotation.name())) {\n            mockSettings.name(field.getName());\n        } else {\n            mockSettings.name(annotation.name());\n        }\n        if(annotation.serializable()){\n            mockSettings.serializable();\n        }\n\n        // see @Mock answer default value\n        mockSettings.defaultAnswer(annotation.answer());\n        return Mockito.mock(field.getType(), mockSettings);\n    }",
    "begin_line": 17,
    "end_line": 34,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockitoAnnotationsMockAnnotationProcessor.process#18",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/MockitoAnnotationsMockAnnotationProcessor.java",
    "class_name": "org.mockito.internal.configuration.MockitoAnnotationsMockAnnotationProcessor",
    "signature": "org.mockito.internal.configuration.MockitoAnnotationsMockAnnotationProcessor.process(org.mockito.MockitoAnnotations.Mock, java.lang.reflect.Field)",
    "snippet": "public Object process(Mock annotation, Field field) {\n        return Mockito.mock(field.getType(), field.getName());\n    }",
    "begin_line": 18,
    "end_line": 20,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SpyAnnotationEngine.createMockFor#42",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/SpyAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)",
    "snippet": "public Object createMockFor(Annotation annotation, Field field) {\n        return null;\n    }",
    "begin_line": 42,
    "end_line": 44,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SpyAnnotationEngine.process#47",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/SpyAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.process(java.lang.Class\u003c?\u003e, java.lang.Object)",
    "snippet": "@SuppressWarnings(\"deprecation\") process(Class\u003c?\u003e context, Object testInstance) {\n        Field[] fields \u003d context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class) \u0026\u0026 !field.isAnnotationPresent(InjectMocks.class)) {\n                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                field.setAccessible(true);\n                Object instance;\n                try {\n                    instance \u003d field.get(testInstance);\n                    assertNotInterface(instance, field.getType());\n                    if (new MockUtil().isMock(instance)) {\n                        // instance has been spied earlier\n                        // for example happens when MockitoAnnotations.initMocks is called two times.\n                        Mockito.reset(instance);\n                    } else if (instance !\u003d null) {\n                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()\n                                .spiedInstance(instance)\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                .name(field.getName())));\n                    } else {\n                        field.set(testInstance, newSpyInstance(testInstance, field));\n                    }\n                } catch (Exception e) {\n                    throw new MockitoException(\"Unable to initialize @Spy annotated field \u0027\" + field.getName() + \"\u0027.\\n\" + e.getMessage(), e);\n                }\n            }\n        }\n    }",
    "begin_line": 47,
    "end_line": 74,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SpyAnnotationEngine.assertNotInterface#76",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/SpyAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.assertNotInterface(java.lang.Object, java.lang.Class\u003c?\u003e)",
    "snippet": "private static void assertNotInterface(Object testInstance, Class\u003c?\u003e type) {\n        type \u003d testInstance !\u003d null? testInstance.getClass() : type;\n        if (type.isInterface()) {\n            throw new MockitoException(\"Type \u0027\" + type.getSimpleName() + \"\u0027 is an interface and it cannot be spied on.\");\n        }\n    }",
    "begin_line": 76,
    "end_line": 81,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SpyAnnotationEngine.newSpyInstance#83",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/SpyAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.newSpyInstance(java.lang.Object, java.lang.reflect.Field)",
    "snippet": "private static Object newSpyInstance(Object testInstance, Field field)\n            throws InstantiationException, IllegalAccessException, InvocationTargetException {\n        MockSettings settings \u003d withSettings()\n                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                .name(field.getName());\n        Class\u003c?\u003e type \u003d field.getType();\n        if (type.isInterface()) {\n            return Mockito.mock(type, settings.useConstructor());\n        }\n        if (!Modifier.isStatic(type.getModifiers())) {\n            Class\u003c?\u003e enclosing \u003d type.getEnclosingClass();\n            if (enclosing !\u003d null) {\n                if (!enclosing.isInstance(testInstance)) {\n                    throw new MockitoException(\"@Spy annotation can only initialize inner classes declared in the test. \"\n                            + \"Inner class: \u0027\" + type.getSimpleName() + \"\u0027, \"\n                            + \"outer class: \u0027\" + enclosing.getSimpleName() + \"\u0027.\");\n                }\n                return Mockito.mock(type, settings\n                        .useConstructor()\n                        .outerInstance(testInstance));\n            }\n        }\n        Constructor\u003c?\u003e constructor;\n        try {\n            constructor \u003d type.getDeclaredConstructor();\n        } catch (NoSuchMethodException e) {\n            throw new MockitoException(\"Please ensure that the type \u0027\" + type.getSimpleName() + \"\u0027 has 0-arg constructor.\");\n        }\n\n        if (Modifier.isPrivate(constructor.getModifiers())) {\n            constructor.setAccessible(true);\n            return Mockito.mock(type, settings\n                    .spiedInstance(constructor.newInstance()));\n        } else {\n            return Mockito.mock(type, settings.useConstructor());\n        }\n    }",
    "begin_line": 83,
    "end_line": 119,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SpyAnnotationEngine.assertNoIncompatibleAnnotations#122",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/SpyAnnotationEngine.java",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.assertNoIncompatibleAnnotations(java.lang.Class, java.lang.reflect.Field, java.lang.Class)",
    "snippet": "void assertNoIncompatibleAnnotations(Class annotation, Field field, Class... undesiredAnnotations) {\n        for (Class u : undesiredAnnotations) {\n            if (field.isAnnotationPresent(u)) {\n                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n            }\n        }\n    }",
    "begin_line": 122,
    "end_line": 128,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorInjection.ConstructorInjection#42",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/ConstructorInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
    "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.ConstructorInjection()",
    "snippet": "public ConstructorInjection() { }",
    "begin_line": 42,
    "end_line": 42,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorInjection.ConstructorInjection#45",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/ConstructorInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
    "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.ConstructorInjection(org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver)",
    "snippet": " ConstructorInjection(ConstructorArgumentResolver argResolver) {\n        this.argResolver \u003d argResolver;\n    }",
    "begin_line": 45,
    "end_line": 47,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorInjection.processInjection#49",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/ConstructorInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
    "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "public boolean processInjection(Field field, Object fieldOwner, Set\u003cObject\u003e mockCandidates) {\n        try {\n            SimpleArgumentResolver simpleArgumentResolver \u003d new SimpleArgumentResolver(mockCandidates);\n            FieldInitializationReport report \u003d new FieldInitializer(fieldOwner, field, simpleArgumentResolver).initialize();\n\n            return report.fieldWasInitializedUsingContructorArgs();\n        } catch (MockitoException e) {\n            if(e.getCause() instanceof InvocationTargetException) {\n                Throwable realCause \u003d e.getCause().getCause();\n                new Reporter().fieldInitialisationThrewException(field, realCause);\n            }\n            // other causes should be fine\n            return false;\n        }\n\n    }",
    "begin_line": 49,
    "end_line": 64,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SimpleArgumentResolver.SimpleArgumentResolver#72",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/ConstructorInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
    "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.SimpleArgumentResolver(java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "public SimpleArgumentResolver(Set\u003cObject\u003e objects) {\n            this.objects \u003d objects;\n        }",
    "begin_line": 72,
    "end_line": 74,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SimpleArgumentResolver.resolveTypeInstances#76",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/ConstructorInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
    "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.resolveTypeInstances(java.lang.Class\u003c?\u003e)",
    "snippet": "public Object[] resolveTypeInstances(Class\u003c?\u003e... argTypes) {\n            List\u003cObject\u003e argumentInstances \u003d new ArrayList\u003cObject\u003e(argTypes.length);\n            for (Class\u003c?\u003e argType : argTypes) {\n                argumentInstances.add(objectThatIsAssignableFrom(argType));\n            }\n            return argumentInstances.toArray();\n        }",
    "begin_line": 76,
    "end_line": 82,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SimpleArgumentResolver.objectThatIsAssignableFrom#84",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/ConstructorInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
    "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.objectThatIsAssignableFrom(java.lang.Class\u003c?\u003e)",
    "snippet": "private Object objectThatIsAssignableFrom(Class\u003c?\u003e argType) {\n            for (Object object : objects) {\n                if(argType.isAssignableFrom(object.getClass())) return object;\n            }\n            return null;\n        }",
    "begin_line": 84,
    "end_line": 89,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockInjection.onField#35",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.onField(java.lang.reflect.Field, java.lang.Object)",
    "snippet": "public static OngoingMockInjection onField(Field field, Object ofInstance) {\n        return new OngoingMockInjection(field, ofInstance);\n    }",
    "begin_line": 35,
    "end_line": 37,
    "comment": "/** \n * Create a new configuration setup for a field\n * @param field Field needing mock injection\n * @param ofInstance Instance owning the \u003ccode\u003efield\u003c/code\u003e\n * @return New configuration builder\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockInjection.onFields#47",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.onFields(java.util.Set\u003cjava.lang.reflect.Field\u003e, java.lang.Object)",
    "snippet": "public static OngoingMockInjection onFields(Set\u003cField\u003e fields, Object ofInstance) {\n        return new OngoingMockInjection(fields, ofInstance);\n    }",
    "begin_line": 47,
    "end_line": 49,
    "comment": "/** \n * Create a new configuration setup for fields\n * @param fields Fields needing mock injection\n * @param ofInstance Instance owning the \u003ccode\u003efield\u003c/code\u003e\n * @return New configuration builder\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OngoingMockInjection.OngoingMockInjection#61",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.OngoingMockInjection(java.lang.reflect.Field, java.lang.Object)",
    "snippet": "private OngoingMockInjection(Field field, Object fieldOwner) {\n            this(Collections.singleton(field), fieldOwner);\n        }",
    "begin_line": 61,
    "end_line": 63,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OngoingMockInjection.OngoingMockInjection#65",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.OngoingMockInjection(java.util.Set\u003cjava.lang.reflect.Field\u003e, java.lang.Object)",
    "snippet": "private OngoingMockInjection(Set\u003cField\u003e fields, Object fieldOwner) {\n            this.fieldOwner \u003d checkNotNull(fieldOwner, \"fieldOwner\");\n            this.fields.addAll(checkItemsNotNull(fields, \"fields\"));\n        }",
    "begin_line": 65,
    "end_line": 68,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OngoingMockInjection.withMocks#70",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.withMocks(java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "public OngoingMockInjection withMocks(Set\u003cObject\u003e mocks) {\n            this.mocks.addAll(checkNotNull(mocks, \"mocks\"));\n            return this;\n        }",
    "begin_line": 70,
    "end_line": 73,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OngoingMockInjection.tryConstructorInjection#75",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.tryConstructorInjection()",
    "snippet": "public OngoingMockInjection tryConstructorInjection() {\n            injectionStrategies.thenTry(new ConstructorInjection());\n            return this;\n        }",
    "begin_line": 75,
    "end_line": 78,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OngoingMockInjection.tryPropertyOrFieldInjection#80",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.tryPropertyOrFieldInjection()",
    "snippet": "public OngoingMockInjection tryPropertyOrFieldInjection() {\n            injectionStrategies.thenTry(new PropertyAndSetterInjection());\n            return this;\n        }",
    "begin_line": 80,
    "end_line": 83,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OngoingMockInjection.handleSpyAnnotation#85",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.handleSpyAnnotation()",
    "snippet": "public OngoingMockInjection handleSpyAnnotation() {\n            postInjectionStrategies.thenTry(new SpyOnInjectedFieldsHandler());\n            return this;\n        }",
    "begin_line": 85,
    "end_line": 88,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OngoingMockInjection.apply#90",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.apply()",
    "snippet": "public void apply() {\n            for (Field field : fields) {\n                injectionStrategies.process(field, fieldOwner, mocks);\n                postInjectionStrategies.process(field, fieldOwner, mocks);\n            }\n        }",
    "begin_line": 90,
    "end_line": 95,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockInjectionStrategy.nop#19",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.nop()",
    "snippet": "public static final MockInjectionStrategy nop() {\n        return new MockInjectionStrategy() {\n            protected boolean processInjection(Field field, Object fieldOwner, Set\u003cObject\u003e mockCandidates) {\n                return false;\n            }\n        };\n    }",
    "begin_line": 19,
    "end_line": 25,
    "comment": "/** \n * NOP Strategy that will always try the next strategy.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockInjectionStrategy.processInjection#21",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "protected boolean processInjection(Field field, Object fieldOwner, Set\u003cObject\u003e mockCandidates) {\n                return false;\n            }",
    "begin_line": 21,
    "end_line": 23,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockInjectionStrategy.thenTry#40",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.thenTry(org.mockito.internal.configuration.injection.MockInjectionStrategy)",
    "snippet": "public MockInjectionStrategy thenTry(MockInjectionStrategy strategy) {\n        if(nextStrategy !\u003d null) {\n            nextStrategy.thenTry(strategy);\n        } else {\n            nextStrategy \u003d strategy;\n        }\n        return strategy;\n    }",
    "begin_line": 40,
    "end_line": 47,
    "comment": "/** \n * Enqueue next injection strategy. \u003cp\u003e The implementation should take care of the actual calling if required. \u003c/p\u003e\n * @param strategy Queued strategy.\n * @return The passed strategy instance to allow chaining.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockInjectionStrategy.process#67",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.process(java.lang.reflect.Field, java.lang.Object, java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "public boolean process(Field onField, Object fieldOwnedBy, Set\u003cObject\u003e mockCandidates) {\n        if(processInjection(onField, fieldOwnedBy, mockCandidates)) {\n            return true;\n        }\n        return relayProcessToNextStrategy(onField, fieldOwnedBy, mockCandidates);\n    }",
    "begin_line": 67,
    "end_line": 72,
    "comment": "/** \n * Actually inject mockCandidates on field. \u003cp\u003e Actual algorithm is defined in the implementations of  {@link #processInjection(Field,Object,Set)}. However if injection occurred successfully, the process should return \u003ccode\u003etrue\u003c/code\u003e, and \u003ccode\u003efalse\u003c/code\u003e otherwise. \u003c/p\u003e \u003cp\u003e The code takes care of calling the next strategy if available and if of course if required \u003c/p\u003e\n * @param onField Field needing injection.\n * @param fieldOwnedBy The owning instance of the field.\n * @param mockCandidates A set of mock candidate, that might be injected.\n * @return \u003ccode\u003etrue\u003c/code\u003e if successful, \u003ccode\u003efalse\u003c/code\u003e otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockInjectionStrategy.processInjection#86",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "protected abstract boolean processInjection(Field field, Object fieldOwner, Set\u003cObject\u003e mockCandidates);",
    "begin_line": 86,
    "end_line": 86,
    "comment": "/** \n * Process actual injection. \u003cp\u003e Don\u0027t call this method directly, instead call  {@link #process(Field,Object,Set)}\u003c/p\u003e\n * @param field Field needing injection\n * @param fieldOwner Field owner instance.\n * @param mockCandidates Pool of mocks to inject.\n * @return \u003ccode\u003etrue\u003c/code\u003e if injection occurred, \u003ccode\u003efalse\u003c/code\u003e otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockInjectionStrategy.relayProcessToNextStrategy#88",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(java.lang.reflect.Field, java.lang.Object, java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "private boolean relayProcessToNextStrategy(Field field, Object fieldOwner, Set\u003cObject\u003e mockCandidates) {\n        return nextStrategy !\u003d null \u0026\u0026 nextStrategy.process(field, fieldOwner, mockCandidates);\n    }",
    "begin_line": 88,
    "end_line": 90,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PropertyAndSetterInjection.isOut#65",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
    "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.isOut(java.lang.reflect.Field)",
    "snippet": "public boolean isOut(Field object) {\n            return Modifier.isFinal(object.getModifiers()) || Modifier.isStatic(object.getModifiers());\n        }",
    "begin_line": 65,
    "end_line": 67,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PropertyAndSetterInjection.processInjection#71",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
    "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set\u003cObject\u003e mockCandidates) {\n        // Set\u003cObject\u003e mocksToBeInjected \u003d new HashSet\u003cObject\u003e(mockCandidates);\n        FieldInitializationReport report \u003d initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);\n\n        // for each field in the class hierarchy\n        boolean injectionOccurred \u003d false;\n        Class\u003c?\u003e fieldClass \u003d report.fieldClass();\n        Object fieldInstanceNeedingInjection \u003d report.fieldInstance();\n        while (fieldClass !\u003d Object.class) {\n            injectionOccurred |\u003d injectMockCandidates(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n            fieldClass \u003d fieldClass.getSuperclass();\n        }\n        return injectionOccurred;\n    }",
    "begin_line": 71,
    "end_line": 84,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PropertyAndSetterInjection.initializeInjectMocksField#86",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
    "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.initializeInjectMocksField(java.lang.reflect.Field, java.lang.Object)",
    "snippet": "private FieldInitializationReport initializeInjectMocksField(Field field, Object fieldOwner) {\n        FieldInitializationReport report \u003d null;\n        try {\n            report \u003d new FieldInitializer(fieldOwner, field).initialize();\n        } catch (MockitoException e) {\n            if(e.getCause() instanceof InvocationTargetException) {\n                Throwable realCause \u003d e.getCause().getCause();\n                new Reporter().fieldInitialisationThrewException(field, realCause);\n            }\n            new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n        }\n        return report; // never null\n    }",
    "begin_line": 86,
    "end_line": 98,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PropertyAndSetterInjection.injectMockCandidates#101",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
    "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.injectMockCandidates(java.lang.Class\u003c?\u003e, java.util.Set\u003cjava.lang.Object\u003e, java.lang.Object)",
    "snippet": "private boolean injectMockCandidates(Class\u003c?\u003e awaitingInjectionClazz, Set\u003cObject\u003e mocks, Object instance) {\n        boolean injectionOccurred \u003d false;\n        List\u003cField\u003e orderedInstanceFields \u003d orderedInstanceFieldsFrom(awaitingInjectionClazz);\n        // pass 1\n        injectionOccurred |\u003d injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n        // pass 2\n        injectionOccurred |\u003d injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n        return injectionOccurred;\n    }",
    "begin_line": 101,
    "end_line": 109,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PropertyAndSetterInjection.injectMockCandidatesOnFields#111",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
    "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.injectMockCandidatesOnFields(java.util.Set\u003cjava.lang.Object\u003e, java.lang.Object, boolean, java.util.List\u003cjava.lang.reflect.Field\u003e)",
    "snippet": "private boolean injectMockCandidatesOnFields(Set\u003cObject\u003e mocks, Object instance, boolean injectionOccurred, List\u003cField\u003e orderedInstanceFields) {\n        for (Iterator\u003cField\u003e it \u003d orderedInstanceFields.iterator(); it.hasNext(); ) {\n            Field field \u003d it.next();\n            Object injected \u003d mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n            if (injected !\u003d null) {\n                injectionOccurred |\u003d true;\n                mocks.remove(injected);\n                it.remove();\n            }\n        }\n        return injectionOccurred;\n    }",
    "begin_line": 111,
    "end_line": 122,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PropertyAndSetterInjection.orderedInstanceFieldsFrom#124",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
    "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
    "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.orderedInstanceFieldsFrom(java.lang.Class\u003c?\u003e)",
    "snippet": "private List\u003cField\u003e orderedInstanceFieldsFrom(Class\u003c?\u003e awaitingInjectionClazz) {\n        List\u003cField\u003e declaredFields \u003d Arrays.asList(awaitingInjectionClazz.getDeclaredFields());\n        declaredFields \u003d ListUtil.filter(declaredFields, notFinalOrStatic);\n\n        return new SuperTypesLastSorter().sort(declaredFields);\n    }",
    "begin_line": 124,
    "end_line": 129,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SpyOnInjectedFieldsHandler.processInjection#31",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java",
    "class_name": "org.mockito.internal.configuration.injection.SpyOnInjectedFieldsHandler",
    "signature": "org.mockito.internal.configuration.injection.SpyOnInjectedFieldsHandler.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "@Override\n    protected boolean processInjection(Field field, Object fieldOwner, Set\u003cObject\u003e mockCandidates) {\n        FieldReader fieldReader \u003d new FieldReader(fieldOwner, field);\n\n        // TODO refoctor : code duplicated in SpyAnnotationEngine\n        if(!fieldReader.isNull() \u0026\u0026 field.isAnnotationPresent(Spy.class)) {\n            try {\n                Object instance \u003d fieldReader.read();\n                if (new MockUtil().isMock(instance)) {\n                    // A. instance has been spied earlier\n                    // B. protect against multiple use of MockitoAnnotations.initMocks()\n                    Mockito.reset(instance);\n                } else {\n                    new FieldSetter(fieldOwner, field).set(\n                        Mockito.mock(instance.getClass(), withSettings()\n                            .spiedInstance(instance)\n                            .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                            .name(field.getName()))\n                    );\n                }\n            } catch (Exception e) {\n                throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n            }\n        }\n\n        return false;\n    }",
    "begin_line": 31,
    "end_line": 56,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FinalMockCandidateFilter.filterCandidate#23",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java",
    "class_name": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter.filterCandidate(java.util.Collection\u003cjava.lang.Object\u003e, java.lang.reflect.Field, java.lang.Object)",
    "snippet": "public OngoingInjecter filterCandidate(final Collection\u003cObject\u003e mocks, final Field field, final Object fieldInstance) {\n        if(mocks.size() \u003d\u003d 1) {\n            final Object matchingMock \u003d mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public Object thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (RuntimeException e) {\n                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                    }\n                    return matchingMock;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public Object thenInject() {\n                return null;\n            }\n        };\n\n    }",
    "begin_line": 23,
    "end_line": 47,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FinalMockCandidateFilter.thenInject#28",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java",
    "class_name": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter.thenInject()",
    "snippet": "public Object thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (RuntimeException e) {\n                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                    }\n                    return matchingMock;\n                }",
    "begin_line": 28,
    "end_line": 37,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FinalMockCandidateFilter.thenInject#42",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java",
    "class_name": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter.thenInject()",
    "snippet": "public Object thenInject() {\n                return null;\n            }",
    "begin_line": 42,
    "end_line": 44,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameBasedCandidateFilter.NameBasedCandidateFilter#18",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java",
    "class_name": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter.NameBasedCandidateFilter(org.mockito.internal.configuration.injection.filter.MockCandidateFilter)",
    "snippet": "public NameBasedCandidateFilter(MockCandidateFilter next) {\n        this.next \u003d next;\n    }",
    "begin_line": 18,
    "end_line": 20,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameBasedCandidateFilter.filterCandidate#22",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java",
    "class_name": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter.filterCandidate(java.util.Collection\u003cjava.lang.Object\u003e, java.lang.reflect.Field, java.lang.Object)",
    "snippet": "public OngoingInjecter filterCandidate(Collection\u003cObject\u003e mocks, Field field, Object fieldInstance) {\n        List\u003cObject\u003e mockNameMatches \u003d new ArrayList\u003cObject\u003e();\n        if(mocks.size() \u003e 1) {\n            for (Object mock : mocks) {\n                if (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n                    mockNameMatches.add(mock);\n                }\n            }\n            return next.filterCandidate(mockNameMatches, field, fieldInstance);\n        }\n        return next.filterCandidate(mocks, field, fieldInstance);\n    }",
    "begin_line": 22,
    "end_line": 33,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeBasedCandidateFilter.TypeBasedCandidateFilter#16",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java",
    "class_name": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter.TypeBasedCandidateFilter(org.mockito.internal.configuration.injection.filter.MockCandidateFilter)",
    "snippet": "public TypeBasedCandidateFilter(MockCandidateFilter next) {\n        this.next \u003d next;\n    }",
    "begin_line": 16,
    "end_line": 18,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeBasedCandidateFilter.filterCandidate#20",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java",
    "class_name": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter.filterCandidate(java.util.Collection\u003cjava.lang.Object\u003e, java.lang.reflect.Field, java.lang.Object)",
    "snippet": "public OngoingInjecter filterCandidate(Collection\u003cObject\u003e mocks, Field field, Object fieldInstance) {\n        List\u003cObject\u003e mockTypeMatches \u003d new ArrayList\u003cObject\u003e();\n        for (Object mock : mocks) {\n            if (field.getType().isAssignableFrom(mock.getClass())) {\n                mockTypeMatches.add(mock);\n            }\n        }\n\n        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n    }",
    "begin_line": 20,
    "end_line": 29,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InjectMocksScanner.InjectMocksScanner#29",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.InjectMocksScanner(java.lang.Class\u003c?\u003e)",
    "snippet": "public InjectMocksScanner(Class\u003c?\u003e clazz) {\n        this.clazz \u003d clazz;\n    }",
    "begin_line": 29,
    "end_line": 31,
    "comment": "/** \n * Create a new InjectMocksScanner for the given clazz on the given instance\n * @param clazz    Current class in the hierarchy of the test\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InjectMocksScanner.addTo#39",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.addTo(java.util.Set\u003cjava.lang.reflect.Field\u003e)",
    "snippet": "public void addTo(Set\u003cField\u003e mockDependentFields) {\n        mockDependentFields.addAll(scan());\n    }",
    "begin_line": 39,
    "end_line": 41,
    "comment": "/** \n * Add the fields annotated by @ {@link InjectMocks}\n * @param mockDependentFields Set of fields annotated by  @{@link InjectMocks}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InjectMocksScanner.scan#48",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.scan()",
    "snippet": "private Set\u003cField\u003e scan() {\n        Set\u003cField\u003e mockDependentFields \u003d new HashSet\u003cField\u003e();\n        Field[] fields \u003d clazz.getDeclaredFields();\n        for (Field field : fields) {\n            if (null !\u003d field.getAnnotation(InjectMocks.class)) {\n                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n                mockDependentFields.add(field);\n            }\n        }\n\n        return mockDependentFields;\n    }",
    "begin_line": 48,
    "end_line": 59,
    "comment": "/** \n * Scan fields annotated by \u0026#064;InjectMocks\n * @return Fields that depends on Mock\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InjectMocksScanner.assertNoAnnotations#61",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.assertNoAnnotations(java.lang.reflect.Field, java.lang.Class)",
    "snippet": "void assertNoAnnotations(final Field field, final Class... annotations) {\n        for (Class annotation : annotations) {\n            if (field.isAnnotationPresent(annotation)) {\n                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());\n            }\n        }\n    }",
    "begin_line": 61,
    "end_line": 67,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockScanner.MockScanner#32",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/MockScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.MockScanner(java.lang.Object, java.lang.Class\u003c?\u003e)",
    "snippet": "public MockScanner(Object instance, Class\u003c?\u003e clazz) {\n        this.instance \u003d instance;\n        this.clazz \u003d clazz;\n    }",
    "begin_line": 32,
    "end_line": 35,
    "comment": "/** \n * Creates a MockScanner.\n * @param instance The test instance\n * @param clazz    The class in the type hierarchy of this instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockScanner.addPreparedMocks#46",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/MockScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.addPreparedMocks(java.util.Set\u003cjava.lang.Object\u003e)",
    "snippet": "public void addPreparedMocks(Set\u003cObject\u003e mocks) {\n        mocks.addAll(scan());\n    }",
    "begin_line": 46,
    "end_line": 48,
    "comment": "/** \n * Add the scanned and prepared mock instance to the given collection. \u003cp\u003e The preparation of mocks consists only in defining a MockName if not already set. \u003c/p\u003e\n * @param mocks Set of mocks\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockScanner.scan#55",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/MockScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.scan()",
    "snippet": "private Set\u003cObject\u003e scan() {\n        Set\u003cObject\u003e mocks \u003d newMockSafeHashSet();\n        for (Field field : clazz.getDeclaredFields()) {\n            // mock or spies only\n            FieldReader fieldReader \u003d new FieldReader(instance, field);\n\n            Object mockInstance \u003d preparedMock(fieldReader.read(), field);\n            if (mockInstance !\u003d null) {\n                mocks.add(mockInstance);\n            }\n        }\n        return mocks;\n    }",
    "begin_line": 55,
    "end_line": 67,
    "comment": "/** \n * Scan and prepare mocks for the given \u003ccode\u003etestClassInstance\u003c/code\u003e and \u003ccode\u003eclazz\u003c/code\u003e in the type hierarchy.\n * @return A prepared set of mock\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockScanner.preparedMock#69",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/MockScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.preparedMock(java.lang.Object, java.lang.reflect.Field)",
    "snippet": "private Object preparedMock(Object instance, Field field) {\n        if (isAnnotatedByMockOrSpy(field)) {\n            return instance;\n        } else if (isMockOrSpy(instance)) {\n            mockUtil.maybeRedefineMockName(instance, field.getName());\n            return instance;\n        }\n        return null;\n    }",
    "begin_line": 69,
    "end_line": 77,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockScanner.isAnnotatedByMockOrSpy#79",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/MockScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.isAnnotatedByMockOrSpy(java.lang.reflect.Field)",
    "snippet": "private boolean isAnnotatedByMockOrSpy(Field field) {\n        return null !\u003d field.getAnnotation(Spy.class)\n                || null !\u003d field.getAnnotation(Mock.class)\n                || null !\u003d field.getAnnotation(MockitoAnnotations.Mock.class);\n    }",
    "begin_line": 79,
    "end_line": 83,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockScanner.isMockOrSpy#85",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/injection/scanner/MockScanner.java",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.isMockOrSpy(java.lang.Object)",
    "snippet": "private boolean isMockOrSpy(Object instance) {\n        return mockUtil.isMock(instance)\n                || mockUtil.isSpy(instance);\n    }",
    "begin_line": 85,
    "end_line": 88,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultPluginSwitch.isEnabled#6",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/DefaultPluginSwitch.java",
    "class_name": "org.mockito.internal.configuration.plugins.DefaultPluginSwitch",
    "signature": "org.mockito.internal.configuration.plugins.DefaultPluginSwitch.isEnabled(java.lang.String)",
    "snippet": "public boolean isEnabled(String pluginClassName) {\n        return true;\n    }",
    "begin_line": 6,
    "end_line": 8,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PluginFinder.PluginFinder#14",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/PluginFinder.java",
    "class_name": "org.mockito.internal.configuration.plugins.PluginFinder",
    "signature": "org.mockito.internal.configuration.plugins.PluginFinder.PluginFinder(org.mockito.plugins.PluginSwitch)",
    "snippet": "public PluginFinder(PluginSwitch pluginSwitch) {\n        this.pluginSwitch \u003d pluginSwitch;\n    }",
    "begin_line": 14,
    "end_line": 16,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PluginFinder.findPluginClass#18",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/PluginFinder.java",
    "class_name": "org.mockito.internal.configuration.plugins.PluginFinder",
    "signature": "org.mockito.internal.configuration.plugins.PluginFinder.findPluginClass(java.lang.Iterable\u003cjava.net.URL\u003e)",
    "snippet": "String findPluginClass(Iterable\u003cURL\u003e resources) {\n        for (URL resource : resources) {\n            InputStream s \u003d null;\n            try {\n                s \u003d resource.openStream();\n                String pluginClassName \u003d new PluginFileReader().readPluginClass(s);\n                if (pluginClassName \u003d\u003d null) {\n                    //For backwards compatibility\n                    //If the resource does not have plugin class name we\u0027re ignoring it\n                    continue;\n                }\n                if (!pluginSwitch.isEnabled(pluginClassName)) {\n                    continue;\n                }\n                return pluginClassName;\n            } catch(Exception e) {\n                throw new MockitoException(\"Problems reading plugin implementation from: \" + resource, e);\n            } finally {\n                IOUtil.closeQuietly(s);\n            }\n        }\n        return null;\n    }",
    "begin_line": 18,
    "end_line": 40,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PluginLoader.PluginLoader#16",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/PluginLoader.java",
    "class_name": "org.mockito.internal.configuration.plugins.PluginLoader",
    "signature": "org.mockito.internal.configuration.plugins.PluginLoader.PluginLoader(org.mockito.plugins.PluginSwitch)",
    "snippet": "public PluginLoader(PluginSwitch pluginSwitch) {\n        this.pluginSwitch \u003d pluginSwitch;\n    }",
    "begin_line": 16,
    "end_line": 18,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PluginLoader.loadPlugin#23",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/PluginLoader.java",
    "class_name": "org.mockito.internal.configuration.plugins.PluginLoader",
    "signature": "org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(java.lang.Class\u003cT\u003e, java.lang.String)",
    "snippet": "\u003cT\u003e T loadPlugin(Class\u003cT\u003e pluginType, String defaultPluginClassName) {\n        T plugin \u003d loadImpl(pluginType);\n        if (plugin !\u003d null) {\n            return plugin;\n        }\n\n        try {\n            // Default implementation. Use our own ClassLoader instead of the context\n            // ClassLoader, as the default implementation is assumed to be part of\n            // Mockito and may not be available via the context ClassLoader.\n            return pluginType.cast(Class.forName(defaultPluginClassName).newInstance());\n        } catch (Exception e) {\n            throw new MockitoException(\"Internal problem occurred, please report it. \" +\n                    \"Mockito is unable to load the default implementation of class that is a part of Mockito distribution. \" +\n                    \"Failed to load \" + pluginType, e);\n        }\n    }",
    "begin_line": 23,
    "end_line": 39,
    "comment": "/** \n * Scans the classpath for given pluginType. If not found, default class is used.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PluginLoader.loadImpl#45",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/PluginLoader.java",
    "class_name": "org.mockito.internal.configuration.plugins.PluginLoader",
    "signature": "org.mockito.internal.configuration.plugins.PluginLoader.loadImpl(java.lang.Class\u003cT\u003e)",
    "snippet": "\u003cT\u003e T loadImpl(Class\u003cT\u003e service) {\n        ClassLoader loader \u003d Thread.currentThread().getContextClassLoader();\n        if (loader \u003d\u003d null) {\n            loader \u003d ClassLoader.getSystemClassLoader();\n        }\n        Enumeration\u003cURL\u003e resources;\n        try {\n            resources \u003d loader.getResources(\"mockito-extensions/\" + service.getName());\n        } catch (IOException e) {\n            throw new MockitoException(\"Failed to load \" + service, e);\n        }\n\n        try {\n            String foundPluginClass \u003d new PluginFinder(pluginSwitch).findPluginClass(Iterables.toIterable(resources));\n            if (foundPluginClass !\u003d null) {\n                Class\u003c?\u003e pluginClass \u003d loader.loadClass(foundPluginClass);\n                Object plugin \u003d pluginClass.newInstance();\n                return service.cast(plugin);\n            }\n            return null;\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\n                    \"Failed to load \" + service + \" implementation declared in \" + resources, e);\n        }\n    }",
    "begin_line": 45,
    "end_line": 69,
    "comment": "/** \n * Equivalent to  {@link java.util.ServiceLoader#load} but without requiringJava 6 / Android 2.3 (Gingerbread).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PluginRegistry.getStackTraceCleanerProvider#21",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/PluginRegistry.java",
    "class_name": "org.mockito.internal.configuration.plugins.PluginRegistry",
    "signature": "org.mockito.internal.configuration.plugins.PluginRegistry.getStackTraceCleanerProvider()",
    "snippet": "StackTraceCleanerProvider getStackTraceCleanerProvider() {\n        //TODO we should throw some sensible exception if this is null.\n        return stackTraceCleanerProvider;\n    }",
    "begin_line": 21,
    "end_line": 24,
    "comment": "/** \n * The implementation of the stack trace cleaner\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "PluginRegistry.getMockMaker#32",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/PluginRegistry.java",
    "class_name": "org.mockito.internal.configuration.plugins.PluginRegistry",
    "signature": "org.mockito.internal.configuration.plugins.PluginRegistry.getMockMaker()",
    "snippet": "MockMaker getMockMaker() {\n        return mockMaker;\n    }",
    "begin_line": 32,
    "end_line": 34,
    "comment": "/** \n * Returns the implementation of the mock maker available for the current runtime. \u003cp\u003eReturns  {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no{@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Plugins.getStackTraceCleanerProvider#16",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/Plugins.java",
    "class_name": "org.mockito.internal.configuration.plugins.Plugins",
    "signature": "org.mockito.internal.configuration.plugins.Plugins.getStackTraceCleanerProvider()",
    "snippet": "public static StackTraceCleanerProvider getStackTraceCleanerProvider() {\n        return registry.getStackTraceCleanerProvider();\n    }",
    "begin_line": 16,
    "end_line": 18,
    "comment": "/** \n * The implementation of the stack trace cleaner\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Plugins.getMockMaker#26",
    "is_bug": true,
    "src_path": "org/mockito/internal/configuration/plugins/Plugins.java",
    "class_name": "org.mockito.internal.configuration.plugins.Plugins",
    "signature": "org.mockito.internal.configuration.plugins.Plugins.getMockMaker()",
    "snippet": "public static MockMaker getMockMaker() {\n        return registry.getMockMaker();\n    }",
    "begin_line": 26,
    "end_line": 28,
    "comment": "/** \n * Returns the implementation of the mock maker available for the current runtime. \u003cp\u003eReturns default mock maker if no {@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DefaultStackTraceCleanerProvider.getStackTraceCleaner#11",
    "is_bug": true,
    "src_path": "org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleanerProvider.java",
    "class_name": "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider",
    "signature": "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider.getStackTraceCleaner(org.mockito.exceptions.stacktrace.StackTraceCleaner)",
    "snippet": "public StackTraceCleaner getStackTraceCleaner(StackTraceCleaner defaultCleaner) {\n        return defaultCleaner;\n    }",
    "begin_line": 11,
    "end_line": 13,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.reportMatcher#31",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reportMatcher(Matcher)",
    "snippet": "public HandyReturnValues reportMatcher(Matcher matcher) {\n        matcherStack.push(new LocalizedMatcher(matcher));\n        return new HandyReturnValues();\n    }",
    "begin_line": 31,
    "end_line": 34,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.pullLocalizedMatchers#39",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.pullLocalizedMatchers()",
    "snippet": "public List\u003cLocalizedMatcher\u003e pullLocalizedMatchers() {\n        if (matcherStack.isEmpty()) {\n            return Collections.emptyList();\n        }\n        \n        List\u003cLocalizedMatcher\u003e matchers \u003d new ArrayList\u003cLocalizedMatcher\u003e(matcherStack);\n        matcherStack.clear();\n        return (List) matchers;\n    }",
    "begin_line": 39,
    "end_line": 47,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.reportAnd#52",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reportAnd()",
    "snippet": "public HandyReturnValues reportAnd() {\n        assertStateFor(\"And(?)\", TWO_SUB_MATCHERS);\n        And and \u003d new And(popLastArgumentMatchers(TWO_SUB_MATCHERS));\n        matcherStack.push(new LocalizedMatcher(and));\n        return new HandyReturnValues();\n    }",
    "begin_line": 52,
    "end_line": 57,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.reportOr#62",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reportOr()",
    "snippet": "public HandyReturnValues reportOr() {\n        assertStateFor(\"Or(?)\", TWO_SUB_MATCHERS);\n        Or or \u003d new Or(popLastArgumentMatchers(TWO_SUB_MATCHERS));\n        matcherStack.push(new LocalizedMatcher(or));\n        return new HandyReturnValues();\n    }",
    "begin_line": 62,
    "end_line": 67,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.reportNot#72",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reportNot()",
    "snippet": "public HandyReturnValues reportNot() {\n        assertStateFor(\"Not(?)\", ONE_SUB_MATCHER);\n        Not not \u003d new Not(popLastArgumentMatchers(ONE_SUB_MATCHER).get(0));\n        matcherStack.push(new LocalizedMatcher(not));\n        return new HandyReturnValues();\n    }",
    "begin_line": 72,
    "end_line": 77,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.assertStateFor#79",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.assertStateFor(java.lang.String, int)",
    "snippet": "private void assertStateFor(String additionalMatcherName, int subMatchersCount) {\n        assertMatchersFoundFor(additionalMatcherName);\n        assertIncorrectUseOfAdditionalMatchers(additionalMatcherName, subMatchersCount);\n    }",
    "begin_line": 79,
    "end_line": 82,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.popLastArgumentMatchers#84",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.popLastArgumentMatchers(int)",
    "snippet": "private List\u003cMatcher\u003e popLastArgumentMatchers(int count) {\n        List\u003cMatcher\u003e result \u003d new LinkedList\u003cMatcher\u003e();\n        result.addAll(matcherStack.subList(matcherStack.size() - count, matcherStack.size()));\n        for (int i \u003d 0; i \u003c count; i++) {\n            matcherStack.pop();\n        }\n        return result;\n    }",
    "begin_line": 84,
    "end_line": 91,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.assertMatchersFoundFor#93",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.assertMatchersFoundFor(java.lang.String)",
    "snippet": "private void assertMatchersFoundFor(String additionalMatcherName) {\n        if (matcherStack.isEmpty()) {\n            matcherStack.clear();\n            new Reporter().reportNoSubMatchersFound(additionalMatcherName);\n        }\n    }",
    "begin_line": 93,
    "end_line": 98,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.assertIncorrectUseOfAdditionalMatchers#100",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.assertIncorrectUseOfAdditionalMatchers(java.lang.String, int)",
    "snippet": "private void assertIncorrectUseOfAdditionalMatchers(String additionalMatcherName, int count) {\n        if(matcherStack.size() \u003c count) {\n            ArrayList\u003cLocalizedMatcher\u003e lastMatchers \u003d new ArrayList\u003cLocalizedMatcher\u003e(matcherStack);\n            matcherStack.clear();\n            new Reporter().incorrectUseOfAdditionalMatchers(additionalMatcherName, count, lastMatchers);\n        }\n    }",
    "begin_line": 100,
    "end_line": 106,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.validateState#111",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.validateState()",
    "snippet": "public void validateState() {\n        if (!matcherStack.isEmpty()) {\n            ArrayList lastMatchers \u003d new ArrayList\u003cLocalizedMatcher\u003e(matcherStack);\n            matcherStack.clear();\n            new Reporter().misplacedArgumentMatcher(lastMatchers);\n        }\n    }",
    "begin_line": 111,
    "end_line": 117,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.reset#122",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reset()",
    "snippet": "public void reset() {\n        matcherStack.clear();\n    }",
    "begin_line": 122,
    "end_line": 124,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.reportOngoingStubbing#29",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.reportOngoingStubbing(org.mockito.internal.progress.IOngoingStubbing)",
    "snippet": "public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n        this.iOngoingStubbing \u003d iOngoingStubbing;\n    }",
    "begin_line": 29,
    "end_line": 31,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.pullOngoingStubbing#33",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.pullOngoingStubbing()",
    "snippet": "public IOngoingStubbing pullOngoingStubbing() {\n        IOngoingStubbing temp \u003d iOngoingStubbing;\n        iOngoingStubbing \u003d null;\n        return temp;\n    }",
    "begin_line": 33,
    "end_line": 37,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.verificationStarted#39",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.verificationStarted(org.mockito.verification.VerificationMode)",
    "snippet": "public void verificationStarted(VerificationMode verify) {\n        validateState();\n        resetOngoingStubbing();\n        verificationMode \u003d new Localized(verify);\n    }",
    "begin_line": 39,
    "end_line": 43,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.resetOngoingStubbing#48",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.resetOngoingStubbing()",
    "snippet": "public void resetOngoingStubbing() {\n        iOngoingStubbing \u003d null;\n    }",
    "begin_line": 48,
    "end_line": 50,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.pullVerificationMode#52",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.pullVerificationMode()",
    "snippet": "public VerificationMode pullVerificationMode() {\n        if (verificationMode \u003d\u003d null) {\n            return null;\n        }\n        \n        VerificationMode temp \u003d verificationMode.getObject();\n        verificationMode \u003d null;\n        return temp;\n    }",
    "begin_line": 52,
    "end_line": 60,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.stubbingStarted#62",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.stubbingStarted()",
    "snippet": "public void stubbingStarted() {\n        validateState();\n        stubbingInProgress \u003d new LocationImpl();\n    }",
    "begin_line": 62,
    "end_line": 65,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.validateState#67",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateState()",
    "snippet": "public void validateState() {\n        validateMostStuff();\n        \n        //validate stubbing:\n        if (stubbingInProgress !\u003d null) {\n            Location temp \u003d stubbingInProgress;\n            stubbingInProgress \u003d null;\n            reporter.unfinishedStubbing(temp);\n        }\n    }",
    "begin_line": 67,
    "end_line": 76,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.validateMostStuff#78",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateMostStuff()",
    "snippet": "private void validateMostStuff() {\n        //State is cool when GlobalConfiguration is already loaded\n        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.configuration.MockitoConfiguration class\n        GlobalConfiguration.validate();\n\n        if (verificationMode !\u003d null) {\n            Location location \u003d verificationMode.getLocation();\n            verificationMode \u003d null;\n            reporter.unfinishedVerificationException(location);\n        }\n\n        getArgumentMatcherStorage().validateState();\n    }",
    "begin_line": 78,
    "end_line": 90,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.stubbingCompleted#92",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.stubbingCompleted(org.mockito.invocation.Invocation)",
    "snippet": "public void stubbingCompleted(Invocation invocation) {\n        stubbingInProgress \u003d null;\n    }",
    "begin_line": 92,
    "end_line": 94,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.toString#96",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.toString()",
    "snippet": "public String toString() {\n        return  \"iOngoingStubbing: \" + iOngoingStubbing + \n        \", verificationMode: \" + verificationMode +\n        \", stubbingInProgress: \" + stubbingInProgress;\n    }",
    "begin_line": 96,
    "end_line": 100,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.reset#102",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.reset()",
    "snippet": "public void reset() {\n        stubbingInProgress \u003d null;\n        verificationMode \u003d null;\n        getArgumentMatcherStorage().reset();\n    }",
    "begin_line": 102,
    "end_line": 106,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.getArgumentMatcherStorage#108",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.getArgumentMatcherStorage()",
    "snippet": "public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return argumentMatcherStorage;\n    }",
    "begin_line": 108,
    "end_line": 110,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.mockingStarted#112",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.mockingStarted(java.lang.Object, java.lang.Class)",
    "snippet": "public void mockingStarted(Object mock, Class classToMock) {\n        if (listener instanceof MockingStartedListener) {\n            ((MockingStartedListener) listener).mockingStarted(mock, classToMock);\n        }\n        validateMostStuff();\n    }",
    "begin_line": 112,
    "end_line": 117,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockingProgressImpl.setListener#119",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/MockingProgressImpl.java",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.setListener(org.mockito.internal.listeners.MockingProgressListener)",
    "snippet": "public void setListener(MockingProgressListener listener) {\n        this.listener \u003d listener;\n    }",
    "begin_line": 119,
    "end_line": 121,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.threadSafely#20",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.threadSafely()",
    "snippet": "static MockingProgress threadSafely() {\n        if (mockingProgress.get() \u003d\u003d null) {\n            mockingProgress.set(new MockingProgressImpl());\n        }\n        return mockingProgress.get();\n    }",
    "begin_line": 20,
    "end_line": 25,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.reportOngoingStubbing#27",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.reportOngoingStubbing(org.mockito.internal.progress.IOngoingStubbing)",
    "snippet": "public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n        threadSafely().reportOngoingStubbing(iOngoingStubbing);\n    }",
    "begin_line": 27,
    "end_line": 29,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.pullOngoingStubbing#31",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.pullOngoingStubbing()",
    "snippet": "public IOngoingStubbing pullOngoingStubbing() {\n        return threadSafely().pullOngoingStubbing();\n    }",
    "begin_line": 31,
    "end_line": 33,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.verificationStarted#35",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.verificationStarted(org.mockito.verification.VerificationMode)",
    "snippet": "public void verificationStarted(VerificationMode verify) {\n        threadSafely().verificationStarted(verify);\n    }",
    "begin_line": 35,
    "end_line": 37,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.pullVerificationMode#39",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.pullVerificationMode()",
    "snippet": "public VerificationMode pullVerificationMode() {\n        return threadSafely().pullVerificationMode();\n    }",
    "begin_line": 39,
    "end_line": 41,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.stubbingStarted#43",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.stubbingStarted()",
    "snippet": "public void stubbingStarted() {\n        threadSafely().stubbingStarted();\n    }",
    "begin_line": 43,
    "end_line": 45,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.validateState#47",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.validateState()",
    "snippet": "public void validateState() {\n        threadSafely().validateState();\n    }",
    "begin_line": 47,
    "end_line": 49,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.stubbingCompleted#51",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.stubbingCompleted(org.mockito.invocation.Invocation)",
    "snippet": "public void stubbingCompleted(Invocation invocation) {\n        threadSafely().stubbingCompleted(invocation);\n    }",
    "begin_line": 51,
    "end_line": 53,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.toString#55",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.toString()",
    "snippet": "public String toString() {\n        return threadSafely().toString();\n    }",
    "begin_line": 55,
    "end_line": 57,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.reset#59",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.reset()",
    "snippet": "public void reset() {\n        threadSafely().reset();\n    }",
    "begin_line": 59,
    "end_line": 61,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.resetOngoingStubbing#63",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.resetOngoingStubbing()",
    "snippet": "public void resetOngoingStubbing() {\n        threadSafely().resetOngoingStubbing();\n    }",
    "begin_line": 63,
    "end_line": 65,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.getArgumentMatcherStorage#67",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.getArgumentMatcherStorage()",
    "snippet": "public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return threadSafely().getArgumentMatcherStorage();\n    }",
    "begin_line": 67,
    "end_line": 69,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.mockingStarted#71",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.mockingStarted(java.lang.Object, java.lang.Class)",
    "snippet": "public void mockingStarted(Object mock, Class classToMock) {\n        threadSafely().mockingStarted(mock, classToMock);\n    }",
    "begin_line": 71,
    "end_line": 73,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ThreadSafeMockingProgress.setListener#75",
    "is_bug": true,
    "src_path": "org/mockito/internal/progress/ThreadSafeMockingProgress.java",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.setListener(org.mockito.internal.listeners.MockingProgressListener)",
    "snippet": "public void setListener(MockingProgressListener listener) {\n        threadSafely().setListener(listener);\n    }",
    "begin_line": 75,
    "end_line": 77,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReturnsEmptyValues.answer#62",
    "is_bug": true,
    "src_path": "org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
    "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues.answer(org.mockito.invocation.InvocationOnMock)",
    "snippet": "public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock \u003d invocation.getMock();\n            MockName name \u003d mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return invocation.getMock() \u003d\u003d invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class\u003c?\u003e returnType \u003d invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }",
    "begin_line": 62,
    "end_line": 80,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReturnsEmptyValues.returnValueFor#82",
    "is_bug": true,
    "src_path": "org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
    "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues.returnValueFor(java.lang.Class\u003c?\u003e)",
    "snippet": "Object returnValueFor(Class\u003c?\u003e type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n            //new instances are used instead of Collections.emptyList(), etc.\n            //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type \u003d\u003d Collection.class) {\n            return new LinkedList\u003cObject\u003e();\n        } else if (type \u003d\u003d Set.class) {\n            return new HashSet\u003cObject\u003e();\n        } else if (type \u003d\u003d HashSet.class) {\n            return new HashSet\u003cObject\u003e();\n        } else if (type \u003d\u003d SortedSet.class) {\n            return new TreeSet\u003cObject\u003e();\n        } else if (type \u003d\u003d TreeSet.class) {\n            return new TreeSet\u003cObject\u003e();\n        } else if (type \u003d\u003d LinkedHashSet.class) {\n            return new LinkedHashSet\u003cObject\u003e();\n        } else if (type \u003d\u003d List.class) {\n            return new LinkedList\u003cObject\u003e();\n        } else if (type \u003d\u003d LinkedList.class) {\n            return new LinkedList\u003cObject\u003e();\n        } else if (type \u003d\u003d ArrayList.class) {\n            return new ArrayList\u003cObject\u003e();\n        } else if (type \u003d\u003d Map.class) {\n            return new HashMap\u003cObject, Object\u003e();\n        } else if (type \u003d\u003d HashMap.class) {\n            return new HashMap\u003cObject, Object\u003e();\n        } else if (type \u003d\u003d SortedMap.class) {\n            return new TreeMap\u003cObject, Object\u003e();\n        } else if (type \u003d\u003d TreeMap.class) {\n            return new TreeMap\u003cObject, Object\u003e();\n        } else if (type \u003d\u003d LinkedHashMap.class) {\n            return new LinkedHashMap\u003cObject, Object\u003e();\n        }\n        //Let\u0027s not care about the rest of collections.\n        return null;\n    }",
    "begin_line": 82,
    "end_line": 118,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Checks.checkNotNull#13",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/Checks.java",
    "class_name": "org.mockito.internal.util.Checks",
    "signature": "org.mockito.internal.util.Checks.checkNotNull(T, java.lang.String)",
    "snippet": "public static \u003cT\u003e T checkNotNull(T value, String checkedValue) {\n        if(value \u003d\u003d null) {\n            throw new NullPointerException(checkedValue + \" should not be null\");\n        }\n        return value;\n    }",
    "begin_line": 13,
    "end_line": 18,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Checks.checkItemsNotNull#20",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/Checks.java",
    "class_name": "org.mockito.internal.util.Checks",
    "signature": "org.mockito.internal.util.Checks.checkItemsNotNull(T, java.lang.String)",
    "snippet": "public static \u003cT extends Iterable\u003e T checkItemsNotNull(T iterable, String checkedIterable) {\n        checkNotNull(iterable, checkedIterable);\n        for (Object item : iterable) {\n            checkNotNull(item, \"item in \" + checkedIterable);\n        }\n        return iterable;\n    }",
    "begin_line": 20,
    "end_line": 26,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.isTypeMockable#26",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isTypeMockable(java.lang.Class\u003c?\u003e)",
    "snippet": "public boolean isTypeMockable(Class\u003c?\u003e type) {\n      return !type.isPrimitive() \u0026\u0026 !Modifier.isFinal(type.getModifiers());\n    }",
    "begin_line": 26,
    "end_line": 28,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.createMock#30",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.createMock(org.mockito.mock.MockCreationSettings\u003cT\u003e)",
    "snippet": "public \u003cT\u003e T createMock(MockCreationSettings\u003cT\u003e settings) {\n        MockHandler mockHandler \u003d new MockHandlerFactory().create(settings);\n\n        T mock \u003d mockMaker.createMock(settings, mockHandler);\n\n        Object spiedInstance \u003d settings.getSpiedInstance();\n        if (spiedInstance !\u003d null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n\n        return mock;\n    }",
    "begin_line": 30,
    "end_line": 41,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.resetMock#43",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.resetMock(T)",
    "snippet": "public \u003cT\u003e void resetMock(T mock) {\n        InternalMockHandler oldHandler \u003d (InternalMockHandler) getMockHandler(mock);\n        MockCreationSettings settings \u003d oldHandler.getMockSettings();\n        MockHandler newHandler \u003d new MockHandlerFactory().create(settings);\n\n        mockMaker.resetMock(mock, newHandler, settings);\n    }",
    "begin_line": 43,
    "end_line": 49,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.getMockHandler#51",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.getMockHandler(T)",
    "snippet": "public \u003cT\u003e InternalMockHandler\u003cT\u003e getMockHandler(T mock) {\n        if (mock \u003d\u003d null) {\n            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n        }\n\n        if (isMockitoMock(mock)) {\n            MockHandler handler \u003d mockMaker.getHandler(mock);\n            return (InternalMockHandler) handler;\n        } else {\n            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n        }\n    }",
    "begin_line": 51,
    "end_line": 62,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.isMock#64",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMock(java.lang.Object)",
    "snippet": "public boolean isMock(Object mock) {\n        // double check to avoid classes that have the same interfaces, could be great to have a custom mockito field in the proxy instead of relying on instance fields\n        return isMockitoMock(mock);\n    }",
    "begin_line": 64,
    "end_line": 67,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.isSpy#69",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isSpy(java.lang.Object)",
    "snippet": "public boolean isSpy(Object mock) {\n        return isMockitoMock(mock) \u0026\u0026 getMockSettings(mock).getDefaultAnswer() \u003d\u003d Mockito.CALLS_REAL_METHODS;\n    }",
    "begin_line": 69,
    "end_line": 71,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.isMockitoMock#73",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMockitoMock(T)",
    "snippet": "private \u003cT\u003e boolean isMockitoMock(T mock) {\n        return mockMaker.getHandler(mock) !\u003d null;\n    }",
    "begin_line": 73,
    "end_line": 75,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.getMockName#77",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.getMockName(java.lang.Object)",
    "snippet": "public MockName getMockName(Object mock) {\n        return getMockHandler(mock).getMockSettings().getMockName();\n    }",
    "begin_line": 77,
    "end_line": 79,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.maybeRedefineMockName#81",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.maybeRedefineMockName(java.lang.Object, java.lang.String)",
    "snippet": "public void maybeRedefineMockName(Object mock, String newName) {\n        MockName mockName \u003d getMockName(mock);\n        //TODO SF hacky...\n        if (mockName.isDefault() \u0026\u0026 getMockHandler(mock).getMockSettings() instanceof CreationSettings) {\n            ((CreationSettings) getMockHandler(mock).getMockSettings()).setMockName(new MockNameImpl(newName));\n        }\n    }",
    "begin_line": 81,
    "end_line": 87,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MockUtil.getMockSettings#89",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/MockUtil.java",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.getMockSettings(java.lang.Object)",
    "snippet": "public MockCreationSettings getMockSettings(Object mock) {\n        return getMockHandler(mock).getMockSettings();\n    }",
    "begin_line": 89,
    "end_line": 91,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectMethodsGuru.isToString#17",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/ObjectMethodsGuru.java",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isToString(java.lang.reflect.Method)",
    "snippet": "public boolean isToString(Method method) {\n        return isToString(new DelegatingMethod(method));\n    }",
    "begin_line": 17,
    "end_line": 19,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectMethodsGuru.isToString#21",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/ObjectMethodsGuru.java",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isToString(org.mockito.internal.invocation.MockitoMethod)",
    "snippet": "public boolean isToString(MockitoMethod method) {\n        return method.getReturnType() \u003d\u003d String.class\n                \u0026\u0026 method.getParameterTypes().length \u003d\u003d 0\n                \u0026\u0026 method.getName().equals(\"toString\");\n    }",
    "begin_line": 21,
    "end_line": 25,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectMethodsGuru.isEqualsMethod#27",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/ObjectMethodsGuru.java",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isEqualsMethod(java.lang.reflect.Method)",
    "snippet": "public boolean isEqualsMethod(Method method) {\n        return method.getName().equals(\"equals\")\n                \u0026\u0026 method.getParameterTypes().length \u003d\u003d 1\n                \u0026\u0026 method.getParameterTypes()[0] \u003d\u003d Object.class;\n    }",
    "begin_line": 27,
    "end_line": 31,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectMethodsGuru.isHashCodeMethod#33",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/ObjectMethodsGuru.java",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isHashCodeMethod(java.lang.reflect.Method)",
    "snippet": "public boolean isHashCodeMethod(Method method) {\n        return method.getName().equals(\"hashCode\")\n                \u0026\u0026 method.getParameterTypes().length \u003d\u003d 0;\n    }",
    "begin_line": 33,
    "end_line": 36,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectMethodsGuru.isCompareToMethod#38",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/ObjectMethodsGuru.java",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isCompareToMethod(java.lang.reflect.Method)",
    "snippet": "public boolean isCompareToMethod(Method method) {\n        return Comparable.class.isAssignableFrom(method.getDeclaringClass())\n                \u0026\u0026 method.getName().equals(\"compareTo\")\n                \u0026\u0026 method.getParameterTypes().length \u003d\u003d 1\n                \u0026\u0026 method.getParameterTypes()[0] \u003d\u003d method.getDeclaringClass();\n    }",
    "begin_line": 38,
    "end_line": 43,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Primitives.primitiveTypeOf#28",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/Primitives.java",
    "class_name": "org.mockito.internal.util.Primitives",
    "signature": "org.mockito.internal.util.Primitives.primitiveTypeOf(java.lang.Class\u003cT\u003e)",
    "snippet": "public static \u003cT\u003e Class\u003cT\u003e primitiveTypeOf(Class\u003cT\u003e clazz) {\n        if (clazz.isPrimitive()) {\n            return clazz;\n        }\n        return (Class\u003cT\u003e) PRIMITIVE_TYPES.get(clazz);\n    }",
    "begin_line": 28,
    "end_line": 33,
    "comment": "/** \n * Returns the primitive type of the given class. \u003cp/\u003e The passed class can be any class : \u003ccode\u003eboolean.class\u003c/code\u003e, \u003ccode\u003eInteger.class\u003c/code\u003e in witch case this method will return \u003ccode\u003eboolean.class\u003c/code\u003e, even \u003ccode\u003eSomeObject.class\u003c/code\u003e in which case \u003ccode\u003enull\u003c/code\u003e will be returned.\n * @param clazz The class from which primitive type has to be retrieved\n * @param \u003c T \u003e   The type\n * @return The primitive type if relevant, otherwise \u003ccode\u003enull\u003c/code\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Primitives.isPrimitiveOrWrapper#41",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/Primitives.java",
    "class_name": "org.mockito.internal.util.Primitives",
    "signature": "org.mockito.internal.util.Primitives.isPrimitiveOrWrapper(java.lang.Class\u003c?\u003e)",
    "snippet": "public static boolean isPrimitiveOrWrapper(Class\u003c?\u003e type) {\n        return PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.containsKey(type);\n    }",
    "begin_line": 41,
    "end_line": 43,
    "comment": "/** \n * Indicates if the given class is primitive type or a primitive wrapper.\n * @param type The type to check\n * @return \u003ccode\u003etrue\u003c/code\u003e if primitive or wrapper, \u003ccode\u003efalse\u003c/code\u003e otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Primitives.defaultValueForPrimitiveOrWrapper#52",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/Primitives.java",
    "class_name": "org.mockito.internal.util.Primitives",
    "signature": "org.mockito.internal.util.Primitives.defaultValueForPrimitiveOrWrapper(java.lang.Class\u003cT\u003e)",
    "snippet": "public static \u003cT\u003e T defaultValueForPrimitiveOrWrapper(Class\u003cT\u003e primitiveOrWrapperType) {\n        return (T) PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.get(primitiveOrWrapperType);\n    }",
    "begin_line": 52,
    "end_line": 54,
    "comment": "/** \n * Returns the boxed default value for a primitive or a primitive wrapper.\n * @param primitiveOrWrapperType The type to lookup the default value\n * @return The boxed default values as defined in Java Language Specification,\u003ccode\u003enull\u003c/code\u003e if the type is neither a primitive nor a wrapper\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.iterator#36",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.iterator()",
    "snippet": "public Iterator\u003cObject\u003e iterator() {\n        return new Iterator\u003cObject\u003e() {\n            private final Iterator\u003cHashCodeAndEqualsMockWrapper\u003e iterator \u003d backingHashSet.iterator();\n\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            public Object next() {\n                return iterator.next().get();\n            }\n\n            public void remove() {\n                iterator.remove();\n            }\n        };\n    }",
    "begin_line": 36,
    "end_line": 52,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.hasNext#40",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.hasNext()",
    "snippet": "public boolean hasNext() {\n                return iterator.hasNext();\n            }",
    "begin_line": 40,
    "end_line": 42,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.next#44",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.next()",
    "snippet": "public Object next() {\n                return iterator.next().get();\n            }",
    "begin_line": 44,
    "end_line": 46,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.remove#48",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.remove()",
    "snippet": "public void remove() {\n                iterator.remove();\n            }",
    "begin_line": 48,
    "end_line": 50,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.size#54",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.size()",
    "snippet": "public int size() {\n        return backingHashSet.size();\n    }",
    "begin_line": 54,
    "end_line": 56,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.isEmpty#58",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.isEmpty()",
    "snippet": "public boolean isEmpty() {\n        return backingHashSet.isEmpty();\n    }",
    "begin_line": 58,
    "end_line": 60,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.contains#62",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.contains(java.lang.Object)",
    "snippet": "public boolean contains(Object mock) {\n        return backingHashSet.contains(HashCodeAndEqualsMockWrapper.of(mock));\n    }",
    "begin_line": 62,
    "end_line": 64,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.add#66",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.add(java.lang.Object)",
    "snippet": "public boolean add(Object mock) {\n        return backingHashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n    }",
    "begin_line": 66,
    "end_line": 68,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.remove#70",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.remove(java.lang.Object)",
    "snippet": "public boolean remove(Object mock) {\n        return backingHashSet.remove(HashCodeAndEqualsMockWrapper.of(mock));\n    }",
    "begin_line": 70,
    "end_line": 72,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.clear#74",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.clear()",
    "snippet": "public void clear() {\n        backingHashSet.clear();\n    }",
    "begin_line": 74,
    "end_line": 76,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.clone#78",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.clone()",
    "snippet": "@Override public Object clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException();\n    }",
    "begin_line": 78,
    "end_line": 80,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.equals#82",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.equals(java.lang.Object)",
    "snippet": "@Override public boolean equals(Object o) {\n        if (!(o instanceof HashCodeAndEqualsSafeSet)) {\n            return false;\n        }\n        HashCodeAndEqualsSafeSet that \u003d (HashCodeAndEqualsSafeSet) o;\n        return backingHashSet.equals(that.backingHashSet);\n    }",
    "begin_line": 82,
    "end_line": 88,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.hashCode#90",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.hashCode()",
    "snippet": "@Override public int hashCode() {\n        return backingHashSet.hashCode();\n    }",
    "begin_line": 90,
    "end_line": 92,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.toArray#94",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.toArray()",
    "snippet": "public Object[] toArray() {\n        return unwrapTo(new Object[size()]);\n    }",
    "begin_line": 94,
    "end_line": 96,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.unwrapTo#98",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.unwrapTo(T[])",
    "snippet": "private \u003cT\u003e T[] unwrapTo(T[] array) {\n        Iterator\u003cObject\u003e iterator \u003d iterator();\n        for (int i \u003d 0, objectsLength \u003d array.length; i \u003c objectsLength; i++) {\n            if (iterator.hasNext()) {\n                array[i] \u003d (T) iterator.next();\n            }\n        }\n        return array;\n    }",
    "begin_line": 98,
    "end_line": 106,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.toArray#109",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.toArray(T[])",
    "snippet": "public \u003cT\u003e T[] toArray(T[] typedArray) {\n        T[] array \u003d typedArray.length \u003e\u003d size() ? typedArray :\n                (T[]) newInstance(typedArray.getClass().getComponentType(), size());\n        return unwrapTo(array);\n    }",
    "begin_line": 109,
    "end_line": 113,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.removeAll#115",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.removeAll(java.util.Collection\u003c?\u003e)",
    "snippet": "public boolean removeAll(Collection\u003c?\u003e mocks) {\n        return backingHashSet.removeAll(asWrappedMocks(mocks));\n    }",
    "begin_line": 115,
    "end_line": 117,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.containsAll#119",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.containsAll(java.util.Collection\u003c?\u003e)",
    "snippet": "public boolean containsAll(Collection\u003c?\u003e mocks) {\n        return backingHashSet.containsAll(asWrappedMocks(mocks));\n    }",
    "begin_line": 119,
    "end_line": 121,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.addAll#123",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.addAll(java.util.Collection\u003c?\u003e)",
    "snippet": "public boolean addAll(Collection\u003c?\u003e mocks) {\n        return backingHashSet.addAll(asWrappedMocks(mocks));\n    }",
    "begin_line": 123,
    "end_line": 125,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.retainAll#127",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.retainAll(java.util.Collection\u003c?\u003e)",
    "snippet": "public boolean retainAll(Collection\u003c?\u003e mocks) {\n        return backingHashSet.retainAll(asWrappedMocks(mocks));\n    }",
    "begin_line": 127,
    "end_line": 129,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.asWrappedMocks#131",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.asWrappedMocks(java.util.Collection\u003c?\u003e)",
    "snippet": "private HashSet\u003cHashCodeAndEqualsMockWrapper\u003e asWrappedMocks(Collection\u003c?\u003e mocks) {\n        Checks.checkNotNull(mocks, \"Passed collection should notify() be null\");\n        HashSet\u003cHashCodeAndEqualsMockWrapper\u003e hashSet \u003d new HashSet\u003cHashCodeAndEqualsMockWrapper\u003e();\n        for (Object mock : mocks) {\n            assert ! (mock instanceof HashCodeAndEqualsMockWrapper) : \"WRONG\";\n            hashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n        }\n        return hashSet;\n    }",
    "begin_line": 131,
    "end_line": 139,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.toString#141",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.toString()",
    "snippet": "@Override public String toString() {\n        return backingHashSet.toString();\n    }",
    "begin_line": 141,
    "end_line": 143,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.of#145",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.of(java.lang.Object)",
    "snippet": "public static HashCodeAndEqualsSafeSet of(Object... mocks) {\n        return of(Arrays.asList(mocks));\n    }",
    "begin_line": 145,
    "end_line": 147,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.of#149",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.of(java.lang.Iterable\u003cjava.lang.Object\u003e)",
    "snippet": "public static HashCodeAndEqualsSafeSet of(Iterable\u003cObject\u003e objects) {\n        HashCodeAndEqualsSafeSet hashCodeAndEqualsSafeSet \u003d new HashCodeAndEqualsSafeSet();\n        if (objects !\u003d null) {\n            for (Object mock : objects) {\n                hashCodeAndEqualsSafeSet.add(mock);\n            }\n        }\n        return hashCodeAndEqualsSafeSet;\n    }",
    "begin_line": 149,
    "end_line": 157,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Iterables.toIterable#15",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/Iterables.java",
    "class_name": "org.mockito.internal.util.collections.Iterables",
    "signature": "org.mockito.internal.util.collections.Iterables.toIterable(java.util.Enumeration\u003cT\u003e)",
    "snippet": "public static \u003cT\u003e Iterable\u003cT\u003e toIterable(Enumeration\u003cT\u003e in) {\n        List\u003cT\u003e out \u003d new LinkedList\u003cT\u003e();\n        while(in.hasMoreElements()) {\n            out.add(in.nextElement());\n        }\n        return out;\n    }",
    "begin_line": 15,
    "end_line": 21,
    "comment": "/** \n * Converts enumeration into iterable\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sets.newMockSafeHashSet#15",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/Sets.java",
    "class_name": "org.mockito.internal.util.collections.Sets",
    "signature": "org.mockito.internal.util.collections.Sets.newMockSafeHashSet(java.lang.Iterable\u003cjava.lang.Object\u003e)",
    "snippet": "public static Set\u003cObject\u003e newMockSafeHashSet(Iterable\u003cObject\u003e mocks) {\n        return HashCodeAndEqualsSafeSet.of(mocks);\n    }",
    "begin_line": 15,
    "end_line": 17,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sets.newMockSafeHashSet#19",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/Sets.java",
    "class_name": "org.mockito.internal.util.collections.Sets",
    "signature": "org.mockito.internal.util.collections.Sets.newMockSafeHashSet(java.lang.Object)",
    "snippet": "public static Set\u003cObject\u003e newMockSafeHashSet(Object... mocks) {\n        return HashCodeAndEqualsSafeSet.of(mocks);\n    }",
    "begin_line": 19,
    "end_line": 21,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sets.newIdentitySet#23",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/Sets.java",
    "class_name": "org.mockito.internal.util.collections.Sets",
    "signature": "org.mockito.internal.util.collections.Sets.newIdentitySet()",
    "snippet": "public static IdentitySet newIdentitySet() {\n        return new IdentitySet();\n    }",
    "begin_line": 23,
    "end_line": 25,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sets.newSet#27",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/collections/Sets.java",
    "class_name": "org.mockito.internal.util.collections.Sets",
    "signature": "org.mockito.internal.util.collections.Sets.newSet(T)",
    "snippet": "public static \u003cT\u003e Set\u003cT\u003e newSet(T ... elements) {\n        if (elements \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Expected an array of elements (or empty array) but received a null.\");\n        }\n        return new LinkedHashSet\u003cT\u003e(asList(elements));\n    }",
    "begin_line": 27,
    "end_line": 32,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AccessibilityChanger.safelyDisableAccess#16",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/reflection/AccessibilityChanger.java",
    "class_name": "org.mockito.internal.util.reflection.AccessibilityChanger",
    "signature": "org.mockito.internal.util.reflection.AccessibilityChanger.safelyDisableAccess(java.lang.reflect.AccessibleObject)",
    "snippet": "public void safelyDisableAccess(AccessibleObject accessibleObject) {\n        assert wasAccessible !\u003d null : \"accessibility info shall not be null\";\n        try {\n            accessibleObject.setAccessible(wasAccessible);\n        } catch (Throwable t) {\n            //ignore\n        }\n    }",
    "begin_line": 16,
    "end_line": 23,
    "comment": "/** \n * safely disables access\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AccessibilityChanger.enableAccess#28",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/reflection/AccessibilityChanger.java",
    "class_name": "org.mockito.internal.util.reflection.AccessibilityChanger",
    "signature": "org.mockito.internal.util.reflection.AccessibilityChanger.enableAccess(java.lang.reflect.AccessibleObject)",
    "snippet": "public void enableAccess(AccessibleObject accessibleObject) {\n        wasAccessible \u003d accessibleObject.isAccessible();\n        accessibleObject.setAccessible(true);\n    }",
    "begin_line": 28,
    "end_line": 31,
    "comment": "/** \n * changes the accessibleObject accessibility and returns true if accessibility was changed\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FieldReader.FieldReader#17",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/reflection/FieldReader.java",
    "class_name": "org.mockito.internal.util.reflection.FieldReader",
    "signature": "org.mockito.internal.util.reflection.FieldReader.FieldReader(java.lang.Object, java.lang.reflect.Field)",
    "snippet": "public FieldReader(Object target, Field field) {\n        this.target \u003d target;\n        this.field \u003d field;\n        changer.enableAccess(field);\n    }",
    "begin_line": 17,
    "end_line": 21,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FieldReader.isNull#23",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/reflection/FieldReader.java",
    "class_name": "org.mockito.internal.util.reflection.FieldReader",
    "signature": "org.mockito.internal.util.reflection.FieldReader.isNull()",
    "snippet": "public boolean isNull() {\n            return read() \u003d\u003d null;\n    }",
    "begin_line": 23,
    "end_line": 25,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FieldReader.read#27",
    "is_bug": true,
    "src_path": "org/mockito/internal/util/reflection/FieldReader.java",
    "class_name": "org.mockito.internal.util.reflection.FieldReader",
    "signature": "org.mockito.internal.util.reflection.FieldReader.read()",
    "snippet": "public Object read() {\n        try {\n            return field.get(target);\n        } catch (Exception e) {\n            throw new MockitoException(\"Cannot read state from field: \" + field + \", on instance: \" + target);\n        }\n    }",
    "begin_line": 27,
    "end_line": 33,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]