[
  {
    "name": "IOUtils.buffer#229",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.InputStream)",
    "snippet": "@SuppressWarnings(\"resource\") buffer(final InputStream inputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);\n    }",
    "begin_line": 229,
    "end_line": 235,
    "comment": "/** \n * Returns the given InputStream if it is already a  {@link BufferedInputStream}, otherwise creates a BufferedInputStream from the given InputStream.\n * @param inputStream the InputStream to wrap or return (not null)\n * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#248",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.InputStream, int)",
    "snippet": "@SuppressWarnings(\"resource\") buffer(final InputStream inputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream, size);\n    }",
    "begin_line": 248,
    "end_line": 254,
    "comment": "/** \n * Returns the given InputStream if it is already a  {@link BufferedInputStream}, otherwise creates a BufferedInputStream from the given InputStream.\n * @param inputStream the InputStream to wrap or return (not null)\n * @param size the buffer size, if a new BufferedInputStream is created.\n * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#266",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.OutputStream)",
    "snippet": "@SuppressWarnings(\"resource\") buffer(final OutputStream outputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream);\n    }",
    "begin_line": 266,
    "end_line": 272,
    "comment": "/** \n * Returns the given OutputStream if it is already a  {@link BufferedOutputStream}, otherwise creates a BufferedOutputStream from the given OutputStream.\n * @param outputStream the OutputStream to wrap or return (not null)\n * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#285",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.OutputStream, int)",
    "snippet": "@SuppressWarnings(\"resource\") buffer(final OutputStream outputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream, size);\n    }",
    "begin_line": 285,
    "end_line": 291,
    "comment": "/** \n * Returns the given OutputStream if it is already a  {@link BufferedOutputStream}, otherwise creates a BufferedOutputStream from the given OutputStream.\n * @param outputStream the OutputStream to wrap or return (not null)\n * @param size the buffer size, if a new BufferedOutputStream is created.\n * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#302",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Reader)",
    "snippet": "public static BufferedReader buffer(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }",
    "begin_line": 302,
    "end_line": 304,
    "comment": "/** \n * Returns the given reader if it is already a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#316",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Reader, int)",
    "snippet": "public static BufferedReader buffer(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }",
    "begin_line": 316,
    "end_line": 318,
    "comment": "/** \n * Returns the given reader if it is already a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @param size the buffer size, if a new BufferedReader is created.\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#329",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Writer)",
    "snippet": "public static BufferedWriter buffer(final Writer writer) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer);\n    }",
    "begin_line": 329,
    "end_line": 331,
    "comment": "/** \n * Returns the given Writer if it is already a  {@link BufferedWriter}, otherwise creates a BufferedWriter from the given Writer.\n * @param writer the Writer to wrap or return (not null)\n * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#343",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Writer, int)",
    "snippet": "public static BufferedWriter buffer(final Writer writer, final int size) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer, size);\n    }",
    "begin_line": 343,
    "end_line": 345,
    "comment": "/** \n * Returns the given Writer if it is already a  {@link BufferedWriter}, otherwise creates a BufferedWriter from the given Writer.\n * @param writer the Writer to wrap or return (not null)\n * @param size the buffer size, if a new BufferedWriter is created.\n * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.byteArray#353",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.byteArray()",
    "snippet": "public static byte[] byteArray() {\n        return byteArray(DEFAULT_BUFFER_SIZE);\n    }",
    "begin_line": 353,
    "end_line": 355,
    "comment": "/** \n * Returns a new byte array of size  {@link #DEFAULT_BUFFER_SIZE}.\n * @return a new byte array of size {@link #DEFAULT_BUFFER_SIZE}.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.byteArray#367",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.byteArray(int)",
    "snippet": "public static byte[] byteArray(final int size) {\n        return new byte[size];\n    }",
    "begin_line": 367,
    "end_line": 369,
    "comment": "/** \n * Returns a new byte array of the given size. TODO Consider guarding or warning against large allocations...\n * @param size array size.\n * @return a new byte array of the given size.\n * @throws NegativeArraySizeException if the size is negative.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.charArray#377",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.charArray()",
    "snippet": "private static char[] charArray() {\n        return charArray(DEFAULT_BUFFER_SIZE);\n    }",
    "begin_line": 377,
    "end_line": 379,
    "comment": "/** \n * Returns a new char array of size  {@link #DEFAULT_BUFFER_SIZE}.\n * @return a new char array of size {@link #DEFAULT_BUFFER_SIZE}.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.charArray#390",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.charArray(int)",
    "snippet": "private static char[] charArray(final int size) {\n        return new char[size];\n    }",
    "begin_line": 390,
    "end_line": 392,
    "comment": "/** \n * Returns a new char array of the given size. TODO Consider guarding or warning against large allocations...\n * @param size array size.\n * @return a new char array of the given size.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.clear#402",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.clear()",
    "snippet": "static void clear() {\n        SCRATCH_BYTE_BUFFER_RW.remove();\n        SCRATCH_CHAR_BUFFER_RW.remove();\n        Arrays.fill(SCRATCH_BYTE_BUFFER_WO, (byte) 0);\n        Arrays.fill(SCRATCH_CHAR_BUFFER_WO, (char) 0);\n    }",
    "begin_line": 402,
    "end_line": 407,
    "comment": "/** \n * Clears any state. \u003cul\u003e \u003cli\u003eRemoves the current thread\u0027s value for thread-local variables.\u003c/li\u003e \u003cli\u003eSets static scratch arrays to 0s.\u003c/li\u003e \u003c/ul\u003e\n * @see IO#clear()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#416",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.io.Closeable)",
    "snippet": "public static void close(final Closeable closeable) throws IOException {\n        if (closeable !\u003d null) {\n            closeable.close();\n        }\n    }",
    "begin_line": 416,
    "end_line": 420,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation.\n * @param closeable The resource to close, may be null.\n * @throws IOException if an I/O error occurs.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#429",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.io.Closeable)",
    "snippet": "public static void close(final Closeable... closeables) throws IOExceptionList {\n        IOConsumer.forAll(IOUtils::close, closeables);\n    }",
    "begin_line": 429,
    "end_line": 431,
    "comment": "/** \n * Closes the given  {@link Closeable}s as null-safe operations.\n * @param closeables The resource(s) to close, may be null.\n * @throws IOExceptionList if an I/O error occurs.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#441",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.io.Closeable, org.apache.commons.io.function.IOConsumer\u003cjava.io.IOException\u003e)",
    "snippet": "public static void close(final Closeable closeable, final IOConsumer\u003cIOException\u003e consumer) throws IOException {\n        if (closeable !\u003d null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer !\u003d null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }",
    "begin_line": 441,
    "end_line": 451,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation.\n * @param closeable The resource to close, may be null.\n * @param consumer Consume the IOException thrown by {@link Closeable#close()}.\n * @throws IOException if an I/O error occurs.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#459",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.net.URLConnection)",
    "snippet": "public static void close(final URLConnection conn) {\n        if (conn instanceof HttpURLConnection) {\n            ((HttpURLConnection) conn).disconnect();\n        }\n    }",
    "begin_line": 459,
    "end_line": 463,
    "comment": "/** \n * Closes a URLConnection.\n * @param conn the connection to close.\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQ#470",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQ(java.io.Closeable)",
    "snippet": "private static void closeQ(final Closeable closeable) {\n        closeQuietly(closeable, null);\n    }",
    "begin_line": 470,
    "end_line": 472,
    "comment": "/** \n * Avoids the need to type cast.\n * @param closeable the object to close, may be null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#515",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Closeable)",
    "snippet": "public static void closeQuietly(final Closeable closeable) {\n        closeQuietly(closeable, null);\n    }",
    "begin_line": 515,
    "end_line": 517,
    "comment": "/** \n * Closes a  {@link Closeable} unconditionally.\u003cp\u003e Equivalent to  {@link Closeable#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Closeable closeable \u003d null; try { closeable \u003d new FileReader(\u0026quot;foo.txt\u0026quot;); // process closeable closeable.close(); } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(closeable); } \u003c/pre\u003e \u003cp\u003e Closing all streams: \u003c/p\u003e \u003cpre\u003e try { return IOUtils.copy(inputStream, outputStream); } finally { IOUtils.closeQuietly(inputStream); IOUtils.closeQuietly(outputStream); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param closeable the objects to close, may be null or already closed\n * @since 2.0\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#565",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Closeable)",
    "snippet": "public static void closeQuietly(final Closeable... closeables) {\n        if (closeables !\u003d null) {\n            closeQuietly(Arrays.stream(closeables));\n        }\n    }",
    "begin_line": 565,
    "end_line": 569,
    "comment": "/** \n * Closes a  {@link Closeable} unconditionally.\u003cp\u003e Equivalent to  {@link Closeable#close()}, except any exceptions will be ignored. \u003cp\u003e This is typically used in finally blocks to ensure that the closeable is closed even if an Exception was thrown before the normal close statement was reached. \u003cbr\u003e \u003cb\u003eIt should not be used to replace the close statement(s) which should be present for the non-exceptional case.\u003c/b\u003e \u003cbr\u003e It is only intended to simplify tidying up where normal processing has already failed and reporting close failure as well is not necessary or useful. \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Closeable closeable \u003d null; try { closeable \u003d new FileReader(\u0026quot;foo.txt\u0026quot;); // processing using the closeable; may throw an Exception closeable.close(); // Normal close - exceptions not ignored } catch (Exception e) { // error handling } finally { \u003cb\u003eIOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception\u003c/b\u003e } \u003c/pre\u003e \u003cp\u003e Closing all streams: \u003cbr\u003e \u003cpre\u003e try { return IOUtils.copy(inputStream, outputStream); } finally { IOUtils.closeQuietly(inputStream, outputStream); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param closeables the objects to close, may be null or already closed\n * @see #closeQuietly(Closeable)\n * @since 2.5\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#578",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Closeable, java.util.function.Consumer\u003cjava.io.IOException\u003e)",
    "snippet": "public static void closeQuietly(final Closeable closeable, final Consumer\u003cIOException\u003e consumer) {\n        if (closeable !\u003d null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer !\u003d null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }",
    "begin_line": 578,
    "end_line": 588,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation while consuming IOException by the given {@code consumer}.\n * @param closeable The resource to close, may be null.\n * @param consumer Consumes the IOException thrown by {@link Closeable#close()}.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#619",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.InputStream)",
    "snippet": "public static void closeQuietly(final InputStream input) {\n        closeQ(input);\n    }",
    "begin_line": 619,
    "end_line": 621,
    "comment": "/** \n * Closes an  {@link InputStream} unconditionally.\u003cp\u003e Equivalent to  {@link InputStream#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e byte[] data \u003d new byte[1024]; InputStream in \u003d null; try { in \u003d new FileInputStream(\"foo.txt\"); in.read(data); in.close(); //close errors are handled } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(in); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param input the InputStream to close, may be null or already closed\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#633",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.lang.Iterable\u003cjava.io.Closeable\u003e)",
    "snippet": "public static void closeQuietly(final Iterable\u003cCloseable\u003e closeables) {\n        if (closeables !\u003d null) {\n            closeables.forEach(IOUtils::closeQuietly);\n        }\n    }",
    "begin_line": 633,
    "end_line": 637,
    "comment": "/** \n * Closes an iterable of  {@link Closeable} unconditionally.\u003cp\u003e Equivalent calling  {@link Closeable#close()} on each element, except any exceptions will be ignored.\u003c/p\u003e\n * @param closeables the objects to close, may be null or already closed\n * @see #closeQuietly(Closeable)\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#669",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)",
    "snippet": "public static void closeQuietly(final OutputStream output) {\n        closeQ(output);\n    }",
    "begin_line": 669,
    "end_line": 671,
    "comment": "/** \n * Closes an  {@link OutputStream} unconditionally.\u003cp\u003e Equivalent to  {@link OutputStream#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e byte[] data \u003d \"Hello, World\".getBytes(); OutputStream out \u003d null; try { out \u003d new FileOutputStream(\"foo.txt\"); out.write(data); out.close(); //close errors are handled } catch (IOException e) { // error handling } finally { IOUtils.closeQuietly(out); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param output the OutputStream to close, may be null or already closed\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#702",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Reader)",
    "snippet": "public static void closeQuietly(final Reader reader) {\n        closeQ(reader);\n    }",
    "begin_line": 702,
    "end_line": 704,
    "comment": "/** \n * Closes an  {@link Reader} unconditionally.\u003cp\u003e Equivalent to  {@link Reader#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e char[] data \u003d new char[1024]; Reader in \u003d null; try { in \u003d new FileReader(\"foo.txt\"); in.read(data); in.close(); //close errors are handled } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(in); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param reader the Reader to close, may be null or already closed\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#735",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.nio.channels.Selector)",
    "snippet": "public static void closeQuietly(final Selector selector) {\n        closeQ(selector);\n    }",
    "begin_line": 735,
    "end_line": 737,
    "comment": "/** \n * Closes a  {@link Selector} unconditionally.\u003cp\u003e Equivalent to  {@link Selector#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Selector selector \u003d null; try { selector \u003d Selector.open(); // process socket } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(selector); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param selector the Selector to close, may be null or already closed\n * @since 2.2\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#768",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.net.ServerSocket)",
    "snippet": "public static void closeQuietly(final ServerSocket serverSocket) {\n        closeQ(serverSocket);\n    }",
    "begin_line": 768,
    "end_line": 770,
    "comment": "/** \n * Closes a  {@link ServerSocket} unconditionally.\u003cp\u003e Equivalent to  {@link ServerSocket#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e ServerSocket socket \u003d null; try { socket \u003d new ServerSocket(); // process socket socket.close(); } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(socket); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param serverSocket the ServerSocket to close, may be null or already closed\n * @since 2.2\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#801",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.net.Socket)",
    "snippet": "public static void closeQuietly(final Socket socket) {\n        closeQ(socket);\n    }",
    "begin_line": 801,
    "end_line": 803,
    "comment": "/** \n * Closes a  {@link Socket} unconditionally.\u003cp\u003e Equivalent to  {@link Socket#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Socket socket \u003d null; try { socket \u003d new Socket(\"http://www.foo.com/\", 80); // process socket socket.close(); } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(socket); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param socket the Socket to close, may be null or already closed\n * @since 2.0\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#815",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.util.stream.Stream\u003cjava.io.Closeable\u003e)",
    "snippet": "public static void closeQuietly(final Stream\u003cCloseable\u003e closeables) {\n        if (closeables !\u003d null) {\n            closeables.forEach(IOUtils::closeQuietly);\n        }\n    }",
    "begin_line": 815,
    "end_line": 819,
    "comment": "/** \n * Closes a stream of  {@link Closeable} unconditionally.\u003cp\u003e Equivalent calling  {@link Closeable#close()} on each element, except any exceptions will be ignored.\u003c/p\u003e\n * @param closeables the objects to close, may be null or already closed\n * @see #closeQuietly(Closeable)\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#849",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Writer)",
    "snippet": "public static void closeQuietly(final Writer writer) {\n        closeQ(writer);\n    }",
    "begin_line": 849,
    "end_line": 851,
    "comment": "/** \n * Closes an  {@link Writer} unconditionally.\u003cp\u003e Equivalent to  {@link Writer#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Writer out \u003d null; try { out \u003d new StringWriter(); out.write(\"Hello World\"); out.close(); //close errors are handled } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(out); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param writer the Writer to close, may be null or already closed\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.consume#865",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.consume(java.io.InputStream)",
    "snippet": "public static long consume(final InputStream input) throws IOException {\n        return copyLarge(input, NullOutputStream.INSTANCE);\n    }",
    "begin_line": 865,
    "end_line": 867,
    "comment": "/** \n * Consumes bytes from a  {@link InputStream} and ignores them.\u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param input the {@link InputStream} to read.\n * @return the number of bytes copied. or {@code 0} if {@code input is null}.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.consume#881",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.consume(java.io.Reader)",
    "snippet": "public static long consume(final Reader input) throws IOException {\n        return copyLarge(input, NullWriter.INSTANCE);\n    }",
    "begin_line": 881,
    "end_line": 883,
    "comment": "/** \n * Consumes characters from a  {@link Reader} and ignores them.\u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param input the {@link Reader} to read.\n * @return the number of bytes copied. or {@code 0} if {@code input is null}.\n * @throws NullPointerException if the Reader is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#899",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.io.InputStream, java.io.InputStream)",
    "snippet": "public static boolean contentEquals(final InputStream input1, final InputStream input2) throws IOException {\n        // Before making any changes, please test with\n        // org.apache.commons.io.jmh.IOUtilsContentEqualsInputStreamsBenchmark\n        if (input1 \u003d\u003d input2) {\n            return true;\n        }\n        if (input1 \u003d\u003d null || input2 \u003d\u003d null) {\n            return false;\n        }\n\n        // reuse one\n        final byte[] array1 \u003d getScratchByteArray();\n        // allocate another\n        final byte[] array2 \u003d byteArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 \u003d 0;\n            pos2 \u003d 0;\n            for (int index \u003d 0; index \u003c DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 \u003d\u003d index) {\n                    do {\n                        count1 \u003d input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 \u003d\u003d 0);\n                    if (count1 \u003d\u003d EOF) {\n                        return pos2 \u003d\u003d index \u0026\u0026 input2.read() \u003d\u003d EOF;\n                    }\n                    pos1 +\u003d count1;\n                }\n                if (pos2 \u003d\u003d index) {\n                    do {\n                        count2 \u003d input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 \u003d\u003d 0);\n                    if (count2 \u003d\u003d EOF) {\n                        return pos1 \u003d\u003d index \u0026\u0026 input1.read() \u003d\u003d EOF;\n                    }\n                    pos2 +\u003d count2;\n                }\n                if (array1[index] !\u003d array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }",
    "begin_line": 899,
    "end_line": 944,
    "comment": "/** \n * Compares the contents of two Streams to determine if they are equal or not. \u003cp\u003e This method buffers the input internally using {@link BufferedInputStream} if they are not already buffered.\u003c/p\u003e\n * @param input1 the first stream\n * @param input2 the second stream\n * @return true if the content of the streams are equal or they both don\u0027texist, false otherwise\n * @throws IOException          if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#947",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.util.Iterator\u003c?\u003e, java.util.Iterator\u003c?\u003e)",
    "snippet": "private static boolean contentEquals(final Iterator\u003c?\u003e iterator1, final Iterator\u003c?\u003e iterator2) {\n        while (iterator1.hasNext()) {\n            if (!iterator2.hasNext()) {\n                return false;\n            }\n            if (!Objects.equals(iterator1.next(), iterator2.next())) {\n                return false;\n            }\n        }\n        return !iterator2.hasNext();\n    }",
    "begin_line": 947,
    "end_line": 957,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#972",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.io.Reader, java.io.Reader)",
    "snippet": "public static boolean contentEquals(final Reader input1, final Reader input2) throws IOException {\n        if (input1 \u003d\u003d input2) {\n            return true;\n        }\n        if (input1 \u003d\u003d null || input2 \u003d\u003d null) {\n            return false;\n        }\n\n        // reuse one\n        final char[] array1 \u003d getScratchCharArray();\n        // but allocate another\n        final char[] array2 \u003d charArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 \u003d 0;\n            pos2 \u003d 0;\n            for (int index \u003d 0; index \u003c DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 \u003d\u003d index) {\n                    do {\n                        count1 \u003d input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 \u003d\u003d 0);\n                    if (count1 \u003d\u003d EOF) {\n                        return pos2 \u003d\u003d index \u0026\u0026 input2.read() \u003d\u003d EOF;\n                    }\n                    pos1 +\u003d count1;\n                }\n                if (pos2 \u003d\u003d index) {\n                    do {\n                        count2 \u003d input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 \u003d\u003d 0);\n                    if (count2 \u003d\u003d EOF) {\n                        return pos1 \u003d\u003d index \u0026\u0026 input1.read() \u003d\u003d EOF;\n                    }\n                    pos2 +\u003d count2;\n                }\n                if (array1[index] !\u003d array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }",
    "begin_line": 972,
    "end_line": 1015,
    "comment": "/** \n * Compares the contents of two Readers to determine if they are equal or not. \u003cp\u003e This method buffers the input internally using  {@link BufferedReader} if they are not already buffered.\u003c/p\u003e\n * @param input1 the first reader\n * @param input2 the second reader\n * @return true if the content of the readers are equal or they both don\u0027t exist, false otherwise\n * @throws NullPointerException if either input is null\n * @throws IOException if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#1018",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.util.stream.Stream\u003c?\u003e, java.util.stream.Stream\u003c?\u003e)",
    "snippet": "private static boolean contentEquals(final Stream\u003c?\u003e stream1, final Stream\u003c?\u003e stream2) {\n        if (stream1 \u003d\u003d stream2) {\n            return true;\n        }\n        if (stream1 \u003d\u003d null || stream2 \u003d\u003d null) {\n            return false;\n        }\n        return contentEquals(stream1.iterator(), stream2.iterator());\n    }",
    "begin_line": 1018,
    "end_line": 1026,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEqualsIgnoreEOL#1029",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEqualsIgnoreEOL(java.io.BufferedReader, java.io.BufferedReader)",
    "snippet": "private static boolean contentEqualsIgnoreEOL(final BufferedReader reader1, final BufferedReader reader2) {\n        if (reader1 \u003d\u003d reader2) {\n            return true;\n        }\n        if (reader1 \u003d\u003d null || reader2 \u003d\u003d null) {\n            return false;\n        }\n        return contentEquals(reader1.lines(), reader2.lines());\n    }",
    "begin_line": 1029,
    "end_line": 1037,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEqualsIgnoreEOL#1055",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEqualsIgnoreEOL(java.io.Reader, java.io.Reader)",
    "snippet": "@SuppressWarnings(\"resource\")\n    public static boolean contentEqualsIgnoreEOL(final Reader reader1, final Reader reader2) throws UncheckedIOException {\n        if (reader1 \u003d\u003d reader2) {\n            return true;\n        }\n        if (reader1 \u003d\u003d null || reader2 \u003d\u003d null) {\n            return false;\n        }\n        return contentEqualsIgnoreEOL(toBufferedReader(reader1), toBufferedReader(reader2));\n    }",
    "begin_line": 1055,
    "end_line": 1063,
    "comment": "/** \n * Compares the contents of two Readers to determine if they are equal or not, ignoring EOL characters. \u003cp\u003e This method buffers the input internally using {@link BufferedReader} if they are not already buffered.\u003c/p\u003e\n * @param reader1 the first reader\n * @param reader2 the second reader\n * @return true if the content of the readers are equal (ignoring EOL differences),  false otherwise\n * @throws NullPointerException if either input is null\n * @throws UncheckedIOException if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1084",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)",
    "snippet": "public static int copy(final InputStream inputStream, final OutputStream outputStream) throws IOException {\n        final long count \u003d copyLarge(inputStream, outputStream);\n        return count \u003e Integer.MAX_VALUE ? EOF : (int) count;\n    }",
    "begin_line": 1084,
    "end_line": 1087,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to an {@link OutputStream}. \u003cp\u003e This method buffers the input internally, so there is no need to use a  {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e Large streams (over 2GB) will return a bytes copied value of  {@code -1} after the copy has completed sincethe correct number of bytes cannot be returned as an int. For large streams use the {@link #copyLarge(InputStream,OutputStream)} method.\u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @param outputStream the {@link OutputStream} to write.\n * @return the number of bytes copied, or -1 if greater than {@link Integer#MAX_VALUE}.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1105",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream, int)",
    "snippet": "public static long copy(final InputStream inputStream, final OutputStream outputStream, final int bufferSize)\n            throws IOException {\n        return copyLarge(inputStream, outputStream, IOUtils.byteArray(bufferSize));\n    }",
    "begin_line": 1105,
    "end_line": 1108,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to an {@link OutputStream} using an internal buffer of thegiven size. \u003cp\u003e This method buffers the input internally, so there is no need to use a  {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @param outputStream the {@link OutputStream} to write to\n * @param bufferSize the bufferSize used to copy from the input to the output\n * @return the number of bytes copied.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1129",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.Writer)",
    "snippet": "@Deprecated\n    public static void copy(final InputStream input, final Writer writer)\n            throws IOException {\n        copy(input, writer, Charset.defaultCharset());\n    }",
    "begin_line": 1129,
    "end_line": 1132,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to chars on a{@link Writer} using the default character encoding of the platform.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e This method uses  {@link InputStreamReader}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #copy(InputStream,Writer,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1152",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.Writer, java.nio.charset.Charset)",
    "snippet": "public static void copy(final InputStream input, final Writer writer, final Charset inputCharset)\n            throws IOException {\n        final InputStreamReader reader \u003d new InputStreamReader(input, Charsets.toCharset(inputCharset));\n        copy(reader, writer);\n    }",
    "begin_line": 1152,
    "end_line": 1156,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to chars on a{@link Writer} using the specified character encoding.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e This method uses  {@link InputStreamReader}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param writer the {@link Writer} to write to\n * @param inputCharset the charset to use for the input stream, null means platform default\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1183",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.Writer, java.lang.String)",
    "snippet": "public static void copy(final InputStream input, final Writer writer, final String inputCharsetName)\n            throws IOException {\n        copy(input, writer, Charsets.toCharset(inputCharsetName));\n    }",
    "begin_line": 1183,
    "end_line": 1186,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to chars on a{@link Writer} using the specified character encoding.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link InputStreamReader}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param writer the {@link Writer} to write to\n * @param inputCharsetName the name of the requested charset for the InputStream, null means platform default\n * @throws NullPointerException                         if the input or output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1212",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.ByteArrayOutputStream)",
    "snippet": "@SuppressWarnings(\"resource\") copy(final java.io.ByteArrayOutputStream outputStream) throws IOException {\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        final QueueInputStream in \u003d new QueueInputStream();\n        outputStream.writeTo(in.newQueueOutputStream());\n        return in;\n    }",
    "begin_line": 1212,
    "end_line": 1217,
    "comment": "/** \n * Copies bytes from a  {@link java.io.ByteArrayOutputStream} to a {@link QueueInputStream}. \u003cp\u003e Unlike using JDK  {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, thissolution works safely in a single thread environment. \u003c/p\u003e \u003cp\u003e Example usage: \u003c/p\u003e \u003cpre\u003e ByteArrayOutputStream outputStream \u003d new ByteArrayOutputStream(); outputStream.writeBytes(\"hello world\".getBytes(StandardCharsets.UTF_8)); InputStream inputStream \u003d IOUtils.copy(outputStream); \u003c/pre\u003e\n * @param outputStream the {@link java.io.ByteArrayOutputStream} to read.\n * @return the {@link QueueInputStream} filled with the content of the outputStream.\n * @throws NullPointerException if the {@link java.io.ByteArrayOutputStream} is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.12\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1239",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.lang.Appendable)",
    "snippet": "public static long copy(final Reader reader, final Appendable output) throws IOException {\n        return copy(reader, output, CharBuffer.allocate(DEFAULT_BUFFER_SIZE));\n    }",
    "begin_line": 1239,
    "end_line": 1241,
    "comment": "/** \n * Copies chars from a  {@link Reader} to a {@link Appendable}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Large streams (over 2GB) will return a chars copied value of {@code -1} after the copy has completed since the correctnumber of chars cannot be returned as an int. For large streams use the  {@link #copyLarge(Reader,Writer)} method.\u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link Appendable} to write to\n * @return the number of characters copied, or -1 if \u0026gt; Integer.MAX_VALUE\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1258",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.lang.Appendable, java.nio.CharBuffer)",
    "snippet": "public static long copy(final Reader reader, final Appendable output, final CharBuffer buffer) throws IOException {\n        long count \u003d 0;\n        int n;\n        while (EOF !\u003d (n \u003d reader.read(buffer))) {\n            buffer.flip();\n            output.append(buffer, 0, n);\n            count +\u003d n;\n        }\n        return count;\n    }",
    "begin_line": 1258,
    "end_line": 1267,
    "comment": "/** \n * Copies chars from a  {@link Reader} to an {@link Appendable}. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link Appendable} to write to\n * @param buffer the buffer to be used for the copy\n * @return the number of characters copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1293",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void copy(final Reader reader, final OutputStream output)\n            throws IOException {\n        copy(reader, output, Charset.defaultCharset());\n    }",
    "begin_line": 1293,
    "end_line": 1296,
    "comment": "/** \n * Copies chars from a  {@link Reader} to bytes on an{@link OutputStream} using the default character encoding of theplatform, and calling flush. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Due to the implementation of OutputStreamWriter, this method performs a flush. \u003c/p\u003e \u003cp\u003e This method uses  {@link OutputStreamWriter}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #copy(Reader,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1321",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void copy(final Reader reader, final OutputStream output, final Charset outputCharset)\n            throws IOException {\n        final OutputStreamWriter writer \u003d new OutputStreamWriter(output, Charsets.toCharset(outputCharset));\n        copy(reader, writer);\n        // XXX Unless anyone is planning on rewriting OutputStreamWriter,\n        // we have to flush here.\n        writer.flush();\n    }",
    "begin_line": 1321,
    "end_line": 1328,
    "comment": "/** \n * Copies chars from a  {@link Reader} to bytes on an{@link OutputStream} using the specified character encoding, andcalling flush. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Due to the implementation of OutputStreamWriter, this method performs a flush. \u003c/p\u003e \u003cp\u003e This method uses  {@link OutputStreamWriter}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link OutputStream} to write to\n * @param outputCharset the charset to use for the OutputStream, null means platform default\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1360",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void copy(final Reader reader, final OutputStream output, final String outputCharsetName)\n            throws IOException {\n        copy(reader, output, Charsets.toCharset(outputCharsetName));\n    }",
    "begin_line": 1360,
    "end_line": 1363,
    "comment": "/** \n * Copies chars from a  {@link Reader} to bytes on an{@link OutputStream} using the specified character encoding, andcalling flush. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e Due to the implementation of OutputStreamWriter, this method performs a flush. \u003c/p\u003e \u003cp\u003e This method uses  {@link OutputStreamWriter}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link OutputStream} to write to\n * @param outputCharsetName the name of the requested charset for the OutputStream, null means platform default\n * @throws NullPointerException                         if the input or output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1385",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.Writer)",
    "snippet": "public static int copy(final Reader reader, final Writer writer) throws IOException {\n        final long count \u003d copyLarge(reader, writer);\n        if (count \u003e Integer.MAX_VALUE) {\n            return EOF;\n        }\n        return (int) count;\n    }",
    "begin_line": 1385,
    "end_line": 1391,
    "comment": "/** \n * Copies chars from a  {@link Reader} to a {@link Writer}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Large streams (over 2GB) will return a chars copied value of {@code -1} after the copy has completed since the correctnumber of chars cannot be returned as an int. For large streams use the  {@link #copyLarge(Reader,Writer)} method.\u003c/p\u003e\n * @param reader the {@link Reader} to read.\n * @param writer the {@link Writer} to write.\n * @return the number of characters copied, or -1 if \u0026gt; Integer.MAX_VALUE\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1410",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.net.URL, java.io.File)",
    "snippet": "public static long copy(final URL url, final File file) throws IOException {\n        try (OutputStream outputStream \u003d Files.newOutputStream(Objects.requireNonNull(file, \"file\").toPath())) {\n            return copy(url, outputStream);\n        }\n    }",
    "begin_line": 1410,
    "end_line": 1414,
    "comment": "/** \n * Copies bytes from a  {@link URL} to an {@link OutputStream}. \u003cp\u003e This method buffers the input internally, so there is no need to use a  {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param url the {@link URL} to read.\n * @param file the {@link OutputStream} to write.\n * @return the number of bytes copied.\n * @throws NullPointerException if the URL is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1433",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.net.URL, java.io.OutputStream)",
    "snippet": "public static long copy(final URL url, final OutputStream outputStream) throws IOException {\n        try (InputStream inputStream \u003d Objects.requireNonNull(url, \"url\").openStream()) {\n            return copyLarge(inputStream, outputStream);\n        }\n    }",
    "begin_line": 1433,
    "end_line": 1437,
    "comment": "/** \n * Copies bytes from a  {@link URL} to an {@link OutputStream}. \u003cp\u003e This method buffers the input internally, so there is no need to use a  {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param url the {@link URL} to read.\n * @param outputStream the {@link OutputStream} to write.\n * @return the number of bytes copied.\n * @throws NullPointerException if the URL is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1458",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream)",
    "snippet": "public static long copyLarge(final InputStream inputStream, final OutputStream outputStream)\n            throws IOException {\n        return copy(inputStream, outputStream, DEFAULT_BUFFER_SIZE);\n    }",
    "begin_line": 1458,
    "end_line": 1461,
    "comment": "/** \n * Copies bytes from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @param outputStream the {@link OutputStream} to write.\n * @return the number of bytes copied.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1481",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, byte[])",
    "snippet": "@SuppressWarnings(\"resource\") copyLarge(final InputStream inputStream, final OutputStream outputStream, final byte[] buffer)\n        throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        long count \u003d 0;\n        int n;\n        while (EOF !\u003d (n \u003d inputStream.read(buffer))) {\n            outputStream.write(buffer, 0, n);\n            count +\u003d n;\n        }\n        return count;\n    }",
    "begin_line": 1481,
    "end_line": 1492,
    "comment": "/** \n * Copies bytes from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @param outputStream the {@link OutputStream} to write.\n * @param buffer the buffer to use for the copy\n * @return the number of bytes copied.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1518",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long)",
    "snippet": "public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset,\n                                 final long length) throws IOException {\n        return copyLarge(input, output, inputOffset, length, getScratchByteArray());\n    }",
    "begin_line": 1518,
    "end_line": 1521,
    "comment": "/** \n * Copies some or all bytes from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}, optionally skipping input bytes. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}.\n * @param input the {@link InputStream} to read\n * @param output the {@link OutputStream} to write to\n * @param inputOffset : number of bytes to skip from input before copying-ve values are ignored\n * @param length : number of bytes to copy. -ve means all\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1547",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long, byte[])",
    "snippet": "public static long copyLarge(final InputStream input, final OutputStream output,\n                                 final long inputOffset, final long length, final byte[] buffer) throws IOException {\n        if (inputOffset \u003e 0) {\n            skipFully(input, inputOffset);\n        }\n        if (length \u003d\u003d 0) {\n            return 0;\n        }\n        final int bufferLength \u003d buffer.length;\n        int bytesToRead \u003d bufferLength;\n        if (length \u003e 0 \u0026\u0026 length \u003c bufferLength) {\n            bytesToRead \u003d (int) length;\n        }\n        int read;\n        long totalRead \u003d 0;\n        while (bytesToRead \u003e 0 \u0026\u0026 EOF !\u003d (read \u003d input.read(buffer, 0, bytesToRead))) {\n            output.write(buffer, 0, read);\n            totalRead +\u003d read;\n            if (length \u003e 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead \u003d (int) Math.min(length - totalRead, bufferLength);\n            }\n        }\n        return totalRead;\n    }",
    "begin_line": 1547,
    "end_line": 1571,
    "comment": "/** \n * Copies some or all bytes from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}, optionally skipping input bytes. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param output the {@link OutputStream} to write to\n * @param inputOffset : number of bytes to skip from input before copying-ve values are ignored\n * @param length : number of bytes to copy. -ve means all\n * @param buffer the buffer to use for the copy\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1590",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer)",
    "snippet": "public static long copyLarge(final Reader reader, final Writer writer) throws IOException {\n        return copyLarge(reader, writer, getScratchCharArray());\n    }",
    "begin_line": 1590,
    "end_line": 1592,
    "comment": "/** \n * Copies chars from a large (over 2GB)  {@link Reader} to a {@link Writer}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param reader the {@link Reader} to source.\n * @param writer the {@link Writer} to target.\n * @return the number of characters copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1609",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, char[])",
    "snippet": "public static long copyLarge(final Reader reader, final Writer writer, final char[] buffer) throws IOException {\n        long count \u003d 0;\n        int n;\n        while (EOF !\u003d (n \u003d reader.read(buffer))) {\n            writer.write(buffer, 0, n);\n            count +\u003d n;\n        }\n        return count;\n    }",
    "begin_line": 1609,
    "end_line": 1617,
    "comment": "/** \n * Copies chars from a large (over 2GB)  {@link Reader} to a {@link Writer}. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to source.\n * @param writer the {@link Writer} to target.\n * @param buffer the buffer to be used for the copy\n * @return the number of characters copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1640",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long)",
    "snippet": "public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length)\n            throws IOException {\n        return copyLarge(reader, writer, inputOffset, length, getScratchCharArray());\n    }",
    "begin_line": 1640,
    "end_line": 1643,
    "comment": "/** \n * Copies some or all chars from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}, optionally skipping input chars. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param writer the {@link Writer} to write to\n * @param inputOffset : number of chars to skip from input before copying-ve values are ignored\n * @param length : number of chars to copy. -ve means all\n * @return the number of chars copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1664",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long, char[])",
    "snippet": "public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length,\n                                 final char[] buffer)\n            throws IOException {\n        if (inputOffset \u003e 0) {\n            skipFully(reader, inputOffset);\n        }\n        if (length \u003d\u003d 0) {\n            return 0;\n        }\n        int bytesToRead \u003d buffer.length;\n        if (length \u003e 0 \u0026\u0026 length \u003c buffer.length) {\n            bytesToRead \u003d (int) length;\n        }\n        int read;\n        long totalRead \u003d 0;\n        while (bytesToRead \u003e 0 \u0026\u0026 EOF !\u003d (read \u003d reader.read(buffer, 0, bytesToRead))) {\n            writer.write(buffer, 0, read);\n            totalRead +\u003d read;\n            if (length \u003e 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead \u003d (int) Math.min(length - totalRead, buffer.length);\n            }\n        }\n        return totalRead;\n    }",
    "begin_line": 1664,
    "end_line": 1688,
    "comment": "/** \n * Copies some or all chars from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}, optionally skipping input chars. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param writer the {@link Writer} to write to\n * @param inputOffset : number of chars to skip from input before copying-ve values are ignored\n * @param length : number of chars to copy. -ve means all\n * @param buffer the buffer to be used for the copy\n * @return the number of chars copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.fill0#1696",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.fill0(byte[])",
    "snippet": "private static byte[] fill0(final byte[] arr) {\n        Arrays.fill(arr, (byte) 0);\n        return arr;\n    }",
    "begin_line": 1696,
    "end_line": 1699,
    "comment": "/** \n * Fills the given array with 0s.\n * @param arr The array to fill.\n * @return The given array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.fill0#1707",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.fill0(char[])",
    "snippet": "private static char[] fill0(final char[] arr) {\n        Arrays.fill(arr, (char) 0);\n        return arr;\n    }",
    "begin_line": 1707,
    "end_line": 1710,
    "comment": "/** \n * Fills the given array with 0s.\n * @param arr The array to fill.\n * @return The given array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.getScratchByteArray#1717",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.getScratchByteArray()",
    "snippet": "static byte[] getScratchByteArray() {\n        return fill0(SCRATCH_BYTE_BUFFER_RW.get());\n    }",
    "begin_line": 1717,
    "end_line": 1719,
    "comment": "/** \n * Gets the internal byte array buffer, intended for both reading and writing.\n * @return the internal byte array buffer, intended for both reading and writing.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.getScratchByteArrayWriteOnly#1726",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.getScratchByteArrayWriteOnly()",
    "snippet": "static byte[] getScratchByteArrayWriteOnly() {\n        return fill0(SCRATCH_BYTE_BUFFER_WO);\n    }",
    "begin_line": 1726,
    "end_line": 1728,
    "comment": "/** \n * Gets the internal byte array intended for write only operations.\n * @return the internal byte array intended for write only operations.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.getScratchCharArray#1735",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.getScratchCharArray()",
    "snippet": "static char[] getScratchCharArray() {\n        return fill0(SCRATCH_CHAR_BUFFER_RW.get());\n    }",
    "begin_line": 1735,
    "end_line": 1737,
    "comment": "/** \n * Gets the char byte array buffer, intended for both reading and writing.\n * @return the char byte array buffer, intended for both reading and writing.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.getScratchCharArrayWriteOnly#1744",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.getScratchCharArrayWriteOnly()",
    "snippet": "static char[] getScratchCharArrayWriteOnly() {\n        return fill0(SCRATCH_CHAR_BUFFER_WO);\n    }",
    "begin_line": 1744,
    "end_line": 1746,
    "comment": "/** \n * Gets the internal char array intended for write only operations.\n * @return the internal char array intended for write only operations.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1755",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(byte[])",
    "snippet": "public static int length(final byte[] array) {\n        return array \u003d\u003d null ? 0 : array.length;\n    }",
    "begin_line": 1755,
    "end_line": 1757,
    "comment": "/** \n * Returns the length of the given array in a null-safe manner.\n * @param array an array or null\n * @return the array length -- or 0 if the given array is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1766",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(char[])",
    "snippet": "public static int length(final char[] array) {\n        return array \u003d\u003d null ? 0 : array.length;\n    }",
    "begin_line": 1766,
    "end_line": 1768,
    "comment": "/** \n * Returns the length of the given array in a null-safe manner.\n * @param array an array or null\n * @return the array length -- or 0 if the given array is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1777",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(java.lang.CharSequence)",
    "snippet": "public static int length(final CharSequence csq) {\n        return csq \u003d\u003d null ? 0 : csq.length();\n    }",
    "begin_line": 1777,
    "end_line": 1779,
    "comment": "/** \n * Returns the length of the given CharSequence in a null-safe manner.\n * @param csq a CharSequence or null\n * @return the CharSequence length -- or 0 if the given CharSequence is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1788",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(java.lang.Object[])",
    "snippet": "public static int length(final Object[] array) {\n        return array \u003d\u003d null ? 0 : array.length;\n    }",
    "begin_line": 1788,
    "end_line": 1790,
    "comment": "/** \n * Returns the length of the given array in a null-safe manner.\n * @param array an array or null\n * @return the array length -- or 0 if the given array is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.lineIterator#1823",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.lineIterator(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static LineIterator lineIterator(final InputStream input, final Charset charset) {\n        return new LineIterator(new InputStreamReader(input, Charsets.toCharset(charset)));\n    }",
    "begin_line": 1823,
    "end_line": 1825,
    "comment": "/** \n * Returns an Iterator for the lines in an  {@link InputStream}, using the character encoding specified (or default encoding if null). \u003cp\u003e {@link LineIterator} holds a reference to the open{@link InputStream} specified here. When you have finished withthe iterator you should close the stream to free internal resources. This can be done by using a try-with-resources block, closing the stream directly, or by calling {@link LineIterator#close()}. \u003c/p\u003e \u003cp\u003e The recommended usage pattern is: \u003c/p\u003e \u003cpre\u003e try { LineIterator it \u003d IOUtils.lineIterator(stream, charset); while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { IOUtils.closeQuietly(stream); } \u003c/pre\u003e\n * @param input the {@link InputStream} to read, not null\n * @param charset the charset to use, null means platform default\n * @return an Iterator of the lines in the reader, never null\n * @throws IllegalArgumentException if the input is null\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.lineIterator#1861",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.lineIterator(java.io.InputStream, java.lang.String)",
    "snippet": "public static LineIterator lineIterator(final InputStream input, final String charsetName) {\n        return lineIterator(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 1861,
    "end_line": 1863,
    "comment": "/** \n * Returns an Iterator for the lines in an  {@link InputStream}, using the character encoding specified (or default encoding if null). \u003cp\u003e {@link LineIterator} holds a reference to the open{@link InputStream} specified here. When you have finished withthe iterator you should close the stream to free internal resources. This can be done by using a try-with-resources block, closing the stream directly, or by calling {@link LineIterator#close()}. \u003c/p\u003e \u003cp\u003e The recommended usage pattern is: \u003c/p\u003e \u003cpre\u003e try { LineIterator it \u003d IOUtils.lineIterator(stream, StandardCharsets.UTF_8.name()); while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { IOUtils.closeQuietly(stream); } \u003c/pre\u003e\n * @param input the {@link InputStream} to read, not null\n * @param charsetName the encoding to use, null means platform default\n * @return an Iterator of the lines in the reader, never null\n * @throws IllegalArgumentException                     if the input is null\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.lineIterator#1894",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.lineIterator(java.io.Reader)",
    "snippet": "public static LineIterator lineIterator(final Reader reader) {\n        return new LineIterator(reader);\n    }",
    "begin_line": 1894,
    "end_line": 1896,
    "comment": "/** \n * Returns an Iterator for the lines in a  {@link Reader}. \u003cp\u003e {@link LineIterator} holds a reference to the open{@link Reader} specified here. When you have finished with theiterator you should close the reader to free internal resources. This can be done by using a try-with-resources block, closing the reader directly, or by calling {@link LineIterator#close()}. \u003c/p\u003e \u003cp\u003e The recommended usage pattern is: \u003c/p\u003e \u003cpre\u003e try { LineIterator it \u003d IOUtils.lineIterator(reader); while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { IOUtils.closeQuietly(reader); } \u003c/pre\u003e\n * @param reader the {@link Reader} to read, not null\n * @return an Iterator of the lines in the reader, never null\n * @throws NullPointerException if the reader is null\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1910",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.InputStream, byte[])",
    "snippet": "public static int read(final InputStream input, final byte[] buffer) throws IOException {\n        return read(input, buffer, 0, buffer.length);\n    }",
    "begin_line": 1910,
    "end_line": 1912,
    "comment": "/** \n * Reads bytes from an input stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link InputStream}.\n * @param input where to read input from\n * @param buffer destination\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1929",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.InputStream, byte[], int, int)",
    "snippet": "public static int read(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length \u003d\u003d 0) {\n            return 0;\n        }\n        return read(input::read, buffer, offset, length);\n    }",
    "begin_line": 1929,
    "end_line": 1935,
    "comment": "/** \n * Reads bytes from an input stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link InputStream}.\n * @param input where to read input\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IllegalArgumentException if length is negative\n * @throws IOException              if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1950",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(org.apache.commons.io.function.IOTriFunction\u003cbyte[],java.lang.Integer,java.lang.Integer,java.lang.Integer\u003e, byte[], int, int)",
    "snippet": "static int read(final IOTriFunction\u003cbyte[], Integer, Integer, Integer\u003e input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length \u003c 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining \u003d length;\n        while (remaining \u003e 0) {\n            final int location \u003d length - remaining;\n            final int count \u003d input.apply(buffer, offset + location, remaining);\n            if (EOF \u003d\u003d count) {\n                break;\n            }\n            remaining -\u003d count;\n        }\n        return length - remaining;\n    }",
    "begin_line": 1950,
    "end_line": 1965,
    "comment": "/** \n * Reads bytes from an input. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link InputStream}.\n * @param input  How to read input\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IllegalArgumentException if length is negative\n * @throws IOException              if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1981",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)",
    "snippet": "public static int read(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int length \u003d buffer.remaining();\n        while (buffer.remaining() \u003e 0) {\n            final int count \u003d input.read(buffer);\n            if (EOF \u003d\u003d count) { // EOF\n                break;\n            }\n        }\n        return length - buffer.remaining();\n    }",
    "begin_line": 1981,
    "end_line": 1990,
    "comment": "/** \n * Reads bytes from a ReadableByteChannel. \u003cp\u003e This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link ReadableByteChannel}. \u003c/p\u003e\n * @param input the byte channel to read\n * @param buffer byte buffer destination\n * @return the actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#2004",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.Reader, char[])",
    "snippet": "public static int read(final Reader reader, final char[] buffer) throws IOException {\n        return read(reader, buffer, 0, buffer.length);\n    }",
    "begin_line": 2004,
    "end_line": 2006,
    "comment": "/** \n * Reads characters from an input character stream. This implementation guarantees that it will read as many characters as possible before giving up; this may not always be the case for subclasses of  {@link Reader}.\n * @param reader where to read input from\n * @param buffer destination\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#2023",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.Reader, char[], int, int)",
    "snippet": "public static int read(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length \u003c 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining \u003d length;\n        while (remaining \u003e 0) {\n            final int location \u003d length - remaining;\n            final int count \u003d reader.read(buffer, offset + location, remaining);\n            if (EOF \u003d\u003d count) { // EOF\n                break;\n            }\n            remaining -\u003d count;\n        }\n        return length - remaining;\n    }",
    "begin_line": 2023,
    "end_line": 2038,
    "comment": "/** \n * Reads characters from an input character stream. This implementation guarantees that it will read as many characters as possible before giving up; this may not always be the case for subclasses of  {@link Reader}.\n * @param reader where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IllegalArgumentException if length is negative\n * @throws IOException              if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2055",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[])",
    "snippet": "public static void readFully(final InputStream input, final byte[] buffer) throws IOException {\n        readFully(input, buffer, 0, buffer.length);\n    }",
    "begin_line": 2055,
    "end_line": 2057,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#read(byte[],int,int)} maynot read as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param input where to read input from\n * @param buffer destination\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of bytes read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2076",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[], int, int)",
    "snippet": "public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual \u003d read(input, buffer, offset, length);\n        if (actual !\u003d length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }",
    "begin_line": 2076,
    "end_line": 2082,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#read(byte[],int,int)} maynot read as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param input where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of bytes read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2099",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, int)",
    "snippet": "public static byte[] readFully(final InputStream input, final int length) throws IOException {\n        final byte[] buffer \u003d byteArray(length);\n        readFully(input, buffer, 0, buffer.length);\n        return buffer;\n    }",
    "begin_line": 2099,
    "end_line": 2103,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#read(byte[],int,int)} maynot read as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param input where to read input from\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return the bytes read from input\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of bytes read was incorrect\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2118",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)",
    "snippet": "public static void readFully(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int expected \u003d buffer.remaining();\n        final int actual \u003d read(input, buffer);\n        if (actual !\u003d expected) {\n            throw new EOFException(\"Length to read: \" + expected + \" actual: \" + actual);\n        }\n    }",
    "begin_line": 2118,
    "end_line": 2124,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link ReadableByteChannel#read(ByteBuffer)} maynot read as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param input the byte channel to read\n * @param buffer byte buffer destination\n * @throws IOException  if there is a problem reading the file\n * @throws EOFException if the number of bytes read was incorrect\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2140",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[])",
    "snippet": "public static void readFully(final Reader reader, final char[] buffer) throws IOException {\n        readFully(reader, buffer, 0, buffer.length);\n    }",
    "begin_line": 2140,
    "end_line": 2142,
    "comment": "/** \n * Reads the requested number of characters or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link Reader#read(char[],int,int)} maynot read as many characters as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param reader where to read input from\n * @param buffer destination\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of characters read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2160",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[], int, int)",
    "snippet": "public static void readFully(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual \u003d read(reader, buffer, offset, length);\n        if (actual !\u003d length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }",
    "begin_line": 2160,
    "end_line": 2166,
    "comment": "/** \n * Reads the requested number of characters or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link Reader#read(char[],int,int)} maynot read as many characters as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param reader where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of characters read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#2184",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static List\u003cString\u003e readLines(final InputStream input) throws UncheckedIOException {\n        return readLines(input, Charset.defaultCharset());\n    }",
    "begin_line": 2184,
    "end_line": 2186,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a list of Strings,one entry per line, using the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read, not null\n * @return the list of Strings, never null\n * @throws NullPointerException if the input is null\n * @throws UncheckedIOException if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #readLines(InputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#2203",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static List\u003cString\u003e readLines(final InputStream input, final Charset charset) throws UncheckedIOException {\n        return readLines(new InputStreamReader(input, Charsets.toCharset(charset)));\n    }",
    "begin_line": 2203,
    "end_line": 2205,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a list of Strings,one entry per line, using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read, not null\n * @param charset the charset to use, null means platform default\n * @return the list of Strings, never null\n * @throws NullPointerException if the input is null\n * @throws UncheckedIOException if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#2229",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.InputStream, java.lang.String)",
    "snippet": "public static List\u003cString\u003e readLines(final InputStream input, final String charsetName) throws UncheckedIOException {\n        return readLines(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2229,
    "end_line": 2231,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a list of Strings,one entry per line, using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read, not null\n * @param charsetName the name of the requested charset, null means platform default\n * @return the list of Strings, never null\n * @throws NullPointerException                         if the input is null\n * @throws UncheckedIOException                         if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#2248",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.Reader)",
    "snippet": "@SuppressWarnings(\"resource\") readLines(final Reader reader) throws UncheckedIOException {\n        return toBufferedReader(reader).lines().collect(Collectors.toList());\n    }",
    "begin_line": 2248,
    "end_line": 2250,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a list of Strings,one entry per line. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read, not null\n * @return the list of Strings, never null\n * @throws NullPointerException if the input is null\n * @throws UncheckedIOException if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToByteArray#2264",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToByteArray(java.lang.String)",
    "snippet": "public static byte[] resourceToByteArray(final String name) throws IOException {\n        return resourceToByteArray(name, null);\n    }",
    "begin_line": 2264,
    "end_line": 2266,
    "comment": "/** \n * Gets the contents of a resource as a byte array. \u003cp\u003e Delegates to  {@link #resourceToByteArray(String,ClassLoader) resourceToByteArray(String, null)}. \u003c/p\u003e\n * @param name The resource name.\n * @return the requested byte array\n * @throws IOException if an I/O error occurs or the resource is not found.\n * @see #resourceToByteArray(String,ClassLoader)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToByteArray#2281",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToByteArray(java.lang.String, java.lang.ClassLoader)",
    "snippet": "public static byte[] resourceToByteArray(final String name, final ClassLoader classLoader) throws IOException {\n        return toByteArray(resourceToURL(name, classLoader));\n    }",
    "begin_line": 2281,
    "end_line": 2283,
    "comment": "/** \n * Gets the contents of a resource as a byte array. \u003cp\u003e Delegates to  {@link #resourceToURL(String,ClassLoader)}. \u003c/p\u003e\n * @param name The resource name.\n * @param classLoader the class loader that the resolution of the resource is delegated to\n * @return the requested byte array\n * @throws IOException if an I/O error occurs or the resource is not found.\n * @see #resourceToURL(String,ClassLoader)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToString#2298",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToString(java.lang.String, java.nio.charset.Charset)",
    "snippet": "public static String resourceToString(final String name, final Charset charset) throws IOException {\n        return resourceToString(name, charset, null);\n    }",
    "begin_line": 2298,
    "end_line": 2300,
    "comment": "/** \n * Gets the contents of a resource as a String using the specified character encoding. \u003cp\u003e Delegates to  {@link #resourceToString(String,Charset,ClassLoader) resourceToString(String, Charset, null)}. \u003c/p\u003e\n * @param name The resource name.\n * @param charset the charset to use, null means platform default\n * @return the requested String\n * @throws IOException if an I/O error occurs or the resource is not found.\n * @see #resourceToString(String,Charset,ClassLoader)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToString#2316",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToString(java.lang.String, java.nio.charset.Charset, java.lang.ClassLoader)",
    "snippet": "public static String resourceToString(final String name, final Charset charset, final ClassLoader classLoader) throws IOException {\n        return toString(resourceToURL(name, classLoader), charset);\n    }",
    "begin_line": 2316,
    "end_line": 2318,
    "comment": "/** \n * Gets the contents of a resource as a String using the specified character encoding. \u003cp\u003e Delegates to  {@link #resourceToURL(String,ClassLoader)}. \u003c/p\u003e\n * @param name The resource name.\n * @param charset the Charset to use, null means platform default\n * @param classLoader the class loader that the resolution of the resource is delegated to\n * @return the requested String\n * @throws IOException if an I/O error occurs.\n * @see #resourceToURL(String,ClassLoader)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToURL#2331",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToURL(java.lang.String)",
    "snippet": "public static URL resourceToURL(final String name) throws IOException {\n        return resourceToURL(name, null);\n    }",
    "begin_line": 2331,
    "end_line": 2333,
    "comment": "/** \n * Gets a URL pointing to the given resource. \u003cp\u003e Delegates to  {@link #resourceToURL(String,ClassLoader) resourceToURL(String, null)}. \u003c/p\u003e\n * @param name The resource name.\n * @return A URL object for reading the resource.\n * @throws IOException if the resource is not found.\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToURL#2348",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToURL(java.lang.String, java.lang.ClassLoader)",
    "snippet": "public static URL resourceToURL(final String name, final ClassLoader classLoader) throws IOException {\n        // What about the thread context class loader?\n        // What about the system class loader?\n        final URL resource \u003d classLoader \u003d\u003d null ? IOUtils.class.getResource(name) : classLoader.getResource(name);\n        if (resource \u003d\u003d null) {\n            throw new IOException(\"Resource not found: \" + name);\n        }\n        return resource;\n    }",
    "begin_line": 2348,
    "end_line": 2356,
    "comment": "/** \n * Gets a URL pointing to the given resource. \u003cp\u003e If the  {@code classLoader} is not null, call {@link ClassLoader#getResource(String)}, otherwise call {@link Class#getResource(String) IOUtils.class.getResource(name)}. \u003c/p\u003e\n * @param name The resource name.\n * @param classLoader Delegate to this class loader if not null\n * @return A URL object for reading the resource.\n * @throws IOException if the resource is not found.\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2379",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)",
    "snippet": "public static long skip(final InputStream input, final long toSkip) throws IOException {\n        return skip(input, toSkip, IOUtils::getScratchByteArrayWriteOnly);\n    }",
    "begin_line": 2379,
    "end_line": 2381,
    "comment": "/** \n * Skips bytes from an input byte stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for skip() implementations in subclasses of  {@link InputStream}. \u003cp\u003e Note that the implementation uses  {@link InputStream#read(byte[],int,int)} ratherthan delegating to  {@link InputStream#skip(long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of bytes are skipped. \u003c/p\u003e\n * @param input byte stream to skip\n * @param toSkip number of bytes to skip.\n * @return number of bytes actually skipped.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @see InputStream#skip(long)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-203\"\u003eIO-203 - Add skipFully() method for InputStreams\u003c/a\u003e\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2409",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.io.InputStream, long, java.util.function.Supplier\u003cbyte[]\u003e)",
    "snippet": "public static long skip(final InputStream input, final long toSkip, final Supplier\u003cbyte[]\u003e skipBufferSupplier) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        //\n        // No need to synchronize access to SCRATCH_BYTE_BUFFER_WO: We don\u0027t care if the buffer is written multiple\n        // times or in parallel since the data is ignored. We reuse the same buffer, if the buffer size were variable or read-write,\n        // we would need to synch or use a thread local to ensure some other thread safety.\n        //\n        long remain \u003d toSkip;\n        while (remain \u003e 0) {\n            final byte[] skipBuffer \u003d skipBufferSupplier.get();\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final long n \u003d input.read(skipBuffer, 0, (int) Math.min(remain, skipBuffer.length));\n            if (n \u003c 0) { // EOF\n                break;\n            }\n            remain -\u003d n;\n        }\n        return toSkip - remain;\n    }",
    "begin_line": 2409,
    "end_line": 2429,
    "comment": "/** \n * Skips bytes from an input byte stream. \u003cp\u003e Intended for special cases when customization of the temporary buffer is needed because, for example, a nested input stream has requirements for the bytes read. For example, when using  {@link InflaterInputStream}s from multiple threads. \u003c/p\u003e \u003cp\u003e This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for skip() implementations in subclasses of  {@link InputStream}. \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link InputStream#read(byte[],int,int)} rather than delegating to {@link InputStream#skip(long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of bytes are skipped. \u003c/p\u003e\n * @param input              byte stream to skip\n * @param toSkip             number of bytes to skip.\n * @param skipBufferSupplier Supplies the buffer to use for reading.\n * @return number of bytes actually skipped.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @see InputStream#skip(long)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-203\"\u003eIO-203 - Add skipFully() method for InputStreams\u003c/a\u003e\n * @since 2.14.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2443",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.nio.channels.ReadableByteChannel, long)",
    "snippet": "public static long skip(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        final ByteBuffer skipByteBuffer \u003d ByteBuffer.allocate((int) Math.min(toSkip, DEFAULT_BUFFER_SIZE));\n        long remain \u003d toSkip;\n        while (remain \u003e 0) {\n            skipByteBuffer.position(0);\n            skipByteBuffer.limit((int) Math.min(remain, DEFAULT_BUFFER_SIZE));\n            final int n \u003d input.read(skipByteBuffer);\n            if (n \u003d\u003d EOF) {\n                break;\n            }\n            remain -\u003d n;\n        }\n        return toSkip - remain;\n    }",
    "begin_line": 2443,
    "end_line": 2459,
    "comment": "/** \n * Skips bytes from a ReadableByteChannel. This implementation guarantees that it will read as many bytes as possible before giving up.\n * @param input ReadableByteChannel to skip\n * @param toSkip number of bytes to skip.\n * @return number of bytes actually skipped.\n * @throws IOException              if there is a problem reading the ReadableByteChannel\n * @throws IllegalArgumentException if toSkip is negative\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2482",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.io.Reader, long)",
    "snippet": "public static long skip(final Reader reader, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        long remain \u003d toSkip;\n        while (remain \u003e 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final char[] charArray \u003d getScratchCharArrayWriteOnly();\n            final long n \u003d reader.read(charArray, 0, (int) Math.min(remain, charArray.length));\n            if (n \u003c 0) { // EOF\n                break;\n            }\n            remain -\u003d n;\n        }\n        return toSkip - remain;\n    }",
    "begin_line": 2482,
    "end_line": 2497,
    "comment": "/** \n * Skips characters from an input character stream. This implementation guarantees that it will read as many characters as possible before giving up; this may not always be the case for skip() implementations in subclasses of  {@link Reader}. \u003cp\u003e Note that the implementation uses  {@link Reader#read(char[],int,int)} ratherthan delegating to  {@link Reader#skip(long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param reader character stream to skip\n * @param toSkip number of characters to skip.\n * @return number of characters actually skipped.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @see Reader#skip(long)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-203\"\u003eIO-203 - Add skipFully() method for InputStreams\u003c/a\u003e\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2519",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long)",
    "snippet": "public static void skipFully(final InputStream input, final long toSkip) throws IOException {\n        final long skipped \u003d skip(input, toSkip, IOUtils::getScratchByteArrayWriteOnly);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2519,
    "end_line": 2524,
    "comment": "/** \n * Skips the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#skip(long)} maynot skip as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input stream to skip\n * @param toSkip the number of bytes to skip\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of bytes skipped was incorrect\n * @see InputStream#skip(long)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2549",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long, java.util.function.Supplier\u003cbyte[]\u003e)",
    "snippet": "public static void skipFully(final InputStream input, final long toSkip, final Supplier\u003cbyte[]\u003e skipBufferSupplier) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped \u003d skip(input, toSkip, skipBufferSupplier);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2549,
    "end_line": 2557,
    "comment": "/** \n * Skips the requested number of bytes or fail if there are not enough left. \u003cp\u003e Intended for special cases when customization of the temporary buffer is needed because, for example, a nested input stream has requirements for the bytes read. For example, when using  {@link InflaterInputStream}s from multiple threads. \u003c/p\u003e \u003cp\u003e This allows for the possibility that  {@link InputStream#skip(long)} may not skip as many bytes as requested (most likely because of reaching EOF).\u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input              stream to skip\n * @param toSkip             the number of bytes to skip\n * @param skipBufferSupplier Supplies the buffer to use for reading.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of bytes skipped was incorrect\n * @see InputStream#skip(long)\n * @since 2.14.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2569",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.nio.channels.ReadableByteChannel, long)",
    "snippet": "public static void skipFully(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped \u003d skip(input, toSkip);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2569,
    "end_line": 2577,
    "comment": "/** \n * Skips the requested number of bytes or fail if there are not enough left.\n * @param input ReadableByteChannel to skip\n * @param toSkip the number of bytes to skip\n * @throws IOException              if there is a problem reading the ReadableByteChannel\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of bytes skipped was incorrect\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2599",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.io.Reader, long)",
    "snippet": "public static void skipFully(final Reader reader, final long toSkip) throws IOException {\n        final long skipped \u003d skip(reader, toSkip);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Chars to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2599,
    "end_line": 2604,
    "comment": "/** \n * Skips the requested number of characters or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link Reader#skip(long)} maynot skip as many characters as requested (most likely because of reaching EOF). \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(Reader,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param reader stream to skip\n * @param toSkip the number of characters to skip\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of characters skipped was incorrect\n * @see Reader#skip(long)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedInputStream#2630",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedInputStream(java.io.InputStream)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input);\n    }",
    "begin_line": 2630,
    "end_line": 2632,
    "comment": "/** \n * Fetches entire contents of an  {@link InputStream} and representsame data as result InputStream. \u003cp\u003e This method is useful where, \u003c/p\u003e \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e \u003cp\u003e It can be used in favor of  {@link #toByteArray(InputStream)}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input Stream to be fully buffered.\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedInputStream#2659",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedInputStream(java.io.InputStream, int)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input, final int size) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input, size);\n    }",
    "begin_line": 2659,
    "end_line": 2661,
    "comment": "/** \n * Fetches entire contents of an  {@link InputStream} and representsame data as result InputStream. \u003cp\u003e This method is useful where, \u003c/p\u003e \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e \u003cp\u003e It can be used in favor of  {@link #toByteArray(InputStream)}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input Stream to be fully buffered.\n * @param size the initial buffer size\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs.\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedReader#2673",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedReader(java.io.Reader)",
    "snippet": "public static BufferedReader toBufferedReader(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }",
    "begin_line": 2673,
    "end_line": 2675,
    "comment": "/** \n * Returns the given reader if it is a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @see #buffer(Reader)\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedReader#2688",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedReader(java.io.Reader, int)",
    "snippet": "public static BufferedReader toBufferedReader(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }",
    "begin_line": 2688,
    "end_line": 2690,
    "comment": "/** \n * Returns the given reader if it is a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @param size the buffer size, if a new BufferedReader is created.\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @see #buffer(Reader)\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2704",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream)",
    "snippet": "public static byte[] toByteArray(final InputStream inputStream) throws IOException {\n        // We use a ThresholdingOutputStream to avoid reading AND writing more than Integer.MAX_VALUE.\n        try (UnsynchronizedByteArrayOutputStream ubaOutput \u003d UnsynchronizedByteArrayOutputStream.builder().get();\n            ThresholdingOutputStream thresholdOutput \u003d new ThresholdingOutputStream(Integer.MAX_VALUE, os -\u003e {\n                throw new IllegalArgumentException(String.format(\"Cannot read more than %,d into a byte array\", Integer.MAX_VALUE));\n            }, os -\u003e ubaOutput)) {\n            copy(inputStream, thresholdOutput);\n            return ubaOutput.toByteArray();\n        }\n    }",
    "begin_line": 2704,
    "end_line": 2713,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a {@code byte[]}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @return the requested byte array.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws IOException if an I/O error occurs or reading more than {@link Integer#MAX_VALUE} occurs.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2726",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream, int)",
    "snippet": "public static byte[] toByteArray(final InputStream input, final int size) throws IOException {\n        if (size \u003d\u003d 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        return toByteArray(Objects.requireNonNull(input, \"input\")::read, size);\n    }",
    "begin_line": 2726,
    "end_line": 2731,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a {@code byte[]}. Use this method instead of {@link #toByteArray(InputStream)} when {@link InputStream} size is known.\n * @param input the {@link InputStream} to read.\n * @param size the size of {@link InputStream} to read, where 0 \u0026lt; {@code size} \u0026lt;\u003d length of input stream.\n * @return byte [] of length {@code size}.\n * @throws IOException if an I/O error occurs or {@link InputStream} length is smaller than parameter {@code size}.\n * @throws IllegalArgumentException if {@code size} is less than zero.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2749",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream, long)",
    "snippet": "public static byte[] toByteArray(final InputStream input, final long size) throws IOException {\n        if (size \u003e Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Size cannot be greater than Integer max value: \" + size);\n        }\n        return toByteArray(input, (int) size);\n    }",
    "begin_line": 2749,
    "end_line": 2754,
    "comment": "/** \n * Gets contents of an  {@link InputStream} as a {@code byte[]}. Use this method instead of  {@link #toByteArray(InputStream)}when  {@link InputStream} size is known.\u003cb\u003eNOTE:\u003c/b\u003e the method checks that the length can safely be cast to an int without truncation before using  {@link IOUtils#toByteArray(InputStream,int)} to read into the byte array.(Arrays can have no more than Integer.MAX_VALUE entries anyway)\n * @param input the {@link InputStream} to read\n * @param size the size of {@link InputStream} to read, where 0 \u0026lt; {@code size} \u0026lt;\u003d min(Integer.MAX_VALUE, length of input stream).\n * @return byte [] the requested byte array, of length {@code size}\n * @throws IOException              if an I/O error occurs or {@link InputStream} length is less than {@code size}\n * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE\n * @see IOUtils#toByteArray(InputStream,int)\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2765",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(org.apache.commons.io.function.IOTriFunction\u003cbyte[],java.lang.Integer,java.lang.Integer,java.lang.Integer\u003e, int)",
    "snippet": "static byte[] toByteArray(final IOTriFunction\u003cbyte[], Integer, Integer, Integer\u003e input, final int size) throws IOException {\n\n        if (size \u003c 0) {\n            throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + size);\n        }\n\n        if (size \u003d\u003d 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n\n        final byte[] data \u003d byteArray(size);\n        int offset \u003d 0;\n        int read;\n\n        while (offset \u003c size \u0026\u0026 (read \u003d input.apply(data, offset, size - offset)) !\u003d EOF) {\n            offset +\u003d read;\n        }\n\n        if (offset !\u003d size) {\n            throw new IOException(\"Unexpected read size, current: \" + offset + \", expected: \" + size);\n        }\n\n        return data;\n    }",
    "begin_line": 2765,
    "end_line": 2788,
    "comment": "/** \n * Gets the contents of an input as a  {@code byte[]}.\n * @param input the input to read.\n * @param size the size of the input to read, where 0 \u0026lt; {@code size} \u0026lt;\u003d length of input.\n * @return byte [] of length {@code size}.\n * @throws IOException if an I/O error occurs or input length is smaller than parameter {@code size}.\n * @throws IllegalArgumentException if {@code size} is less than zero.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2805",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.Reader)",
    "snippet": "@Deprecated\n    public static byte[] toByteArray(final Reader reader) throws IOException {\n        return toByteArray(reader, Charset.defaultCharset());\n    }",
    "begin_line": 2805,
    "end_line": 2807,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a {@code byte[]}using the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @deprecated 2.5 use {@link #toByteArray(Reader,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2824",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.Reader, java.nio.charset.Charset)",
    "snippet": "public static byte[] toByteArray(final Reader reader, final Charset charset) throws IOException {\n        try (ByteArrayOutputStream output \u003d new ByteArrayOutputStream()) {\n            copy(reader, output, charset);\n            return output.toByteArray();\n        }\n    }",
    "begin_line": 2824,
    "end_line": 2829,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a {@code byte[]}using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param charset the charset to use, null means platform default\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2853",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.Reader, java.lang.String)",
    "snippet": "public static byte[] toByteArray(final Reader reader, final String charsetName) throws IOException {\n        return toByteArray(reader, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2853,
    "end_line": 2855,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a {@code byte[]}using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested byte array\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2870",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.lang.String)",
    "snippet": "@Deprecated\n    public static byte[] toByteArray(final String input) {\n        // make explicit the use of the default charset\n        return input.getBytes(Charset.defaultCharset());\n    }",
    "begin_line": 2870,
    "end_line": 2873,
    "comment": "/** \n * Gets the contents of a  {@link String} as a {@code byte[]}using the default character encoding of the platform. \u003cp\u003e This is the same as  {@link String#getBytes()}. \u003c/p\u003e\n * @param input the {@link String} to convert\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @deprecated 2.5 Use {@link String#getBytes()} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2884",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.net.URI)",
    "snippet": "public static byte[] toByteArray(final URI uri) throws IOException {\n        return toByteArray(uri.toURL());\n    }",
    "begin_line": 2884,
    "end_line": 2886,
    "comment": "/** \n * Gets the contents of a  {@link URI} as a {@code byte[]}.\n * @param uri the {@link URI} to read\n * @return the requested byte array\n * @throws NullPointerException if the uri is null\n * @throws IOException          if an I/O exception occurs\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2897",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.net.URL)",
    "snippet": "public static byte[] toByteArray(final URL url) throws IOException {\n        try (CloseableURLConnection urlConnection \u003d CloseableURLConnection.open(url)) {\n            return toByteArray(urlConnection);\n        }\n    }",
    "begin_line": 2897,
    "end_line": 2901,
    "comment": "/** \n * Gets the contents of a  {@link URL} as a {@code byte[]}.\n * @param url the {@link URL} to read\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O exception occurs\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2912",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.net.URLConnection)",
    "snippet": "public static byte[] toByteArray(final URLConnection urlConnection) throws IOException {\n        try (InputStream inputStream \u003d urlConnection.getInputStream()) {\n            return toByteArray(inputStream);\n        }\n    }",
    "begin_line": 2912,
    "end_line": 2916,
    "comment": "/** \n * Gets the contents of a  {@link URLConnection} as a {@code byte[]}.\n * @param urlConnection the {@link URLConnection} to read.\n * @return the requested byte array.\n * @throws NullPointerException if the urlConn is null.\n * @throws IOException if an I/O exception occurs.\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2934",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static char[] toCharArray(final InputStream inputStream) throws IOException {\n        return toCharArray(inputStream, Charset.defaultCharset());\n    }",
    "begin_line": 2934,
    "end_line": 2936,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a character arrayusing the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read\n * @return the requested character array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #toCharArray(InputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2953",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static char[] toCharArray(final InputStream inputStream, final Charset charset)\n            throws IOException {\n        final CharArrayWriter writer \u003d new CharArrayWriter();\n        copy(inputStream, writer, charset);\n        return writer.toCharArray();\n    }",
    "begin_line": 2953,
    "end_line": 2958,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a character arrayusing the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read\n * @param charset the charset to use, null means platform default\n * @return the requested character array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2982",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.InputStream, java.lang.String)",
    "snippet": "public static char[] toCharArray(final InputStream inputStream, final String charsetName) throws IOException {\n        return toCharArray(inputStream, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2982,
    "end_line": 2984,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a character arrayusing the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested character array\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2999",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.Reader)",
    "snippet": "public static char[] toCharArray(final Reader reader) throws IOException {\n        final CharArrayWriter sw \u003d new CharArrayWriter();\n        copy(reader, sw);\n        return sw.toCharArray();\n    }",
    "begin_line": 2999,
    "end_line": 3003,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a character array.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @return the requested character array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3015",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.CharSequence)",
    "snippet": "@Deprecated\n    public static InputStream toInputStream(final CharSequence input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }",
    "begin_line": 3015,
    "end_line": 3017,
    "comment": "/** \n * Converts the specified CharSequence to an input stream, encoded as bytes using the default character encoding of the platform.\n * @param input the CharSequence to convert\n * @return an input stream\n * @since 2.0\n * @deprecated 2.5 use {@link #toInputStream(CharSequence,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3028",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.CharSequence, java.nio.charset.Charset)",
    "snippet": "public static InputStream toInputStream(final CharSequence input, final Charset charset) {\n        return toInputStream(input.toString(), charset);\n    }",
    "begin_line": 3028,
    "end_line": 3030,
    "comment": "/** \n * Converts the specified CharSequence to an input stream, encoded as bytes using the specified character encoding.\n * @param input the CharSequence to convert\n * @param charset the charset to use, null means platform default\n * @return an input stream\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3048",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.CharSequence, java.lang.String)",
    "snippet": "public static InputStream toInputStream(final CharSequence input, final String charsetName) {\n        return toInputStream(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3048,
    "end_line": 3050,
    "comment": "/** \n * Converts the specified CharSequence to an input stream, encoded as bytes using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e\n * @param input the CharSequence to convert\n * @param charsetName the name of the requested charset, null means platform default\n * @return an input stream\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3062",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.String)",
    "snippet": "@Deprecated\n    public static InputStream toInputStream(final String input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }",
    "begin_line": 3062,
    "end_line": 3064,
    "comment": "/** \n * Converts the specified string to an input stream, encoded as bytes using the default character encoding of the platform.\n * @param input the string to convert\n * @return an input stream\n * @since 1.1\n * @deprecated 2.5 use {@link #toInputStream(String,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3075",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.String, java.nio.charset.Charset)",
    "snippet": "public static InputStream toInputStream(final String input, final Charset charset) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charset)));\n    }",
    "begin_line": 3075,
    "end_line": 3077,
    "comment": "/** \n * Converts the specified string to an input stream, encoded as bytes using the specified character encoding.\n * @param input the string to convert\n * @param charset the charset to use, null means platform default\n * @return an input stream\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3095",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.String, java.lang.String)",
    "snippet": "public static InputStream toInputStream(final String input, final String charsetName) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charsetName)));\n    }",
    "begin_line": 3095,
    "end_line": 3097,
    "comment": "/** \n * Converts the specified string to an input stream, encoded as bytes using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e\n * @param input the string to convert\n * @param charsetName the name of the requested charset, null means platform default\n * @return an input stream\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3109",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(byte[])",
    "snippet": "@Deprecated\n    public static String toString(final byte[] input) {\n        // make explicit the use of the default charset\n        return new String(input, Charset.defaultCharset());\n    }",
    "begin_line": 3109,
    "end_line": 3112,
    "comment": "/** \n * Gets the contents of a  {@code byte[]} as a Stringusing the default character encoding of the platform.\n * @param input the byte array to read\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @deprecated 2.5 Use {@link String#String(byte[])} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3127",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(byte[], java.lang.String)",
    "snippet": "public static String toString(final byte[] input, final String charsetName) {\n        return new String(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3127,
    "end_line": 3129,
    "comment": "/** \n * Gets the contents of a  {@code byte[]} as a Stringusing the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e\n * @param input the byte array to read\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested String\n * @throws NullPointerException if the input is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3146",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static String toString(final InputStream input) throws IOException {\n        return toString(input, Charset.defaultCharset());\n    }",
    "begin_line": 3146,
    "end_line": 3148,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a Stringusing the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @deprecated 2.5 use {@link #toString(InputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3165",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static String toString(final InputStream input, final Charset charset) throws IOException {\n        try (StringBuilderWriter sw \u003d new StringBuilderWriter()) {\n            copy(input, sw, charset);\n            return sw.toString();\n        }\n    }",
    "begin_line": 3165,
    "end_line": 3170,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a Stringusing the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param charset the charset to use, null means platform default\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3193",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.InputStream, java.lang.String)",
    "snippet": "public static String toString(final InputStream input, final String charsetName)\n            throws IOException {\n        return toString(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3193,
    "end_line": 3196,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a Stringusing the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested String\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3213",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(org.apache.commons.io.function.IOSupplier\u003cjava.io.InputStream\u003e, java.nio.charset.Charset)",
    "snippet": "public static String toString(final IOSupplier\u003cInputStream\u003e input, final Charset charset) throws IOException {\n        return toString(input, charset, () -\u003e {\n            throw new NullPointerException(\"input\");\n        });\n    }",
    "begin_line": 3213,
    "end_line": 3217,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} from a supplier as a Stringusing the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input supplies the {@link InputStream} to read\n * @param charset the charset to use, null means platform default\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3235",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(org.apache.commons.io.function.IOSupplier\u003cjava.io.InputStream\u003e, java.nio.charset.Charset, org.apache.commons.io.function.IOSupplier\u003cjava.lang.String\u003e)",
    "snippet": "public static String toString(final IOSupplier\u003cInputStream\u003e input, final Charset charset, final IOSupplier\u003cString\u003e defaultString) throws IOException {\n        if (input \u003d\u003d null) {\n            return defaultString.get();\n        }\n        try (InputStream inputStream \u003d input.get()) {\n            return inputStream !\u003d null ? toString(inputStream, charset) : defaultString.get();\n        }\n    }",
    "begin_line": 3235,
    "end_line": 3242,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} from a supplier as a Stringusing the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input supplies the {@link InputStream} to read\n * @param charset the charset to use, null means platform default\n * @param defaultString the default return value if the supplier or its value is null.\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3256",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.Reader)",
    "snippet": "public static String toString(final Reader reader) throws IOException {\n        try (StringBuilderWriter sw \u003d new StringBuilderWriter()) {\n            copy(reader, sw);\n            return sw.toString();\n        }\n    }",
    "begin_line": 3256,
    "end_line": 3261,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a String.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3273",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URI)",
    "snippet": "@Deprecated\n    public static String toString(final URI uri) throws IOException {\n        return toString(uri, Charset.defaultCharset());\n    }",
    "begin_line": 3273,
    "end_line": 3275,
    "comment": "/** \n * Gets the contents at the given URI.\n * @param uri The URI source.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.1\n * @deprecated 2.5 use {@link #toString(URI,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3286",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URI, java.nio.charset.Charset)",
    "snippet": "public static String toString(final URI uri, final Charset encoding) throws IOException {\n        return toString(uri.toURL(), Charsets.toCharset(encoding));\n    }",
    "begin_line": 3286,
    "end_line": 3288,
    "comment": "/** \n * Gets the contents at the given URI.\n * @param uri The URI source.\n * @param encoding The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.3.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3302",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URI, java.lang.String)",
    "snippet": "public static String toString(final URI uri, final String charsetName) throws IOException {\n        return toString(uri, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3302,
    "end_line": 3304,
    "comment": "/** \n * Gets the contents at the given URI.\n * @param uri The URI source.\n * @param charsetName The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException                                  if an I/O exception occurs.\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3316",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URL)",
    "snippet": "@Deprecated\n    public static String toString(final URL url) throws IOException {\n        return toString(url, Charset.defaultCharset());\n    }",
    "begin_line": 3316,
    "end_line": 3318,
    "comment": "/** \n * Gets the contents at the given URL.\n * @param url The URL source.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.1\n * @deprecated 2.5 use {@link #toString(URL,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3329",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URL, java.nio.charset.Charset)",
    "snippet": "public static String toString(final URL url, final Charset encoding) throws IOException {\n        return toString(url::openStream, encoding);\n    }",
    "begin_line": 3329,
    "end_line": 3331,
    "comment": "/** \n * Gets the contents at the given URL.\n * @param url The URL source.\n * @param encoding The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3345",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URL, java.lang.String)",
    "snippet": "public static String toString(final URL url, final String charsetName) throws IOException {\n        return toString(url, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3345,
    "end_line": 3347,
    "comment": "/** \n * Gets the contents at the given URL.\n * @param url The URL source.\n * @param charsetName The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException                                  if an I/O exception occurs.\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3359",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.OutputStream)",
    "snippet": "public static void write(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data !\u003d null) {\n            output.write(data);\n        }\n    }",
    "begin_line": 3359,
    "end_line": 3364,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to an {@link OutputStream}.\n * @param data the byte array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3382",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.Writer)",
    "snippet": "@Deprecated\n    public static void write(final byte[] data, final Writer writer) throws IOException {\n        write(data, writer, Charset.defaultCharset());\n    }",
    "begin_line": 3382,
    "end_line": 3384,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to chars on a {@link Writer}using the default character encoding of the platform. \u003cp\u003e This method uses  {@link String#String(byte[])}. \u003c/p\u003e\n * @param data the byte array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #write(byte[],Writer,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3401",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.Writer, java.nio.charset.Charset)",
    "snippet": "public static void write(final byte[] data, final Writer writer, final Charset charset) throws IOException {\n        if (data !\u003d null) {\n            writer.write(new String(data, Charsets.toCharset(charset)));\n        }\n    }",
    "begin_line": 3401,
    "end_line": 3405,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to chars on a {@link Writer}using the specified character encoding. \u003cp\u003e This method uses  {@link String#String(byte[],String)}. \u003c/p\u003e\n * @param data the byte array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3429",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.Writer, java.lang.String)",
    "snippet": "public static void write(final byte[] data, final Writer writer, final String charsetName) throws IOException {\n        write(data, writer, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3429,
    "end_line": 3431,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to chars on a {@link Writer}using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#String(byte[],String)}. \u003c/p\u003e\n * @param data the byte array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException                         if output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3450",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final char[] data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 3450,
    "end_line": 3453,
    "comment": "/** \n * Writes chars from a  {@code char[]} to bytes on an{@link OutputStream}. \u003cp\u003e This method uses  {@link String#String(char[])} and{@link String#getBytes()}. \u003c/p\u003e\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #write(char[],OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3471",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void write(final char[] data, final OutputStream output, final Charset charset) throws IOException {\n        if (data !\u003d null) {\n            write(new String(data), output, charset);\n        }\n    }",
    "begin_line": 3471,
    "end_line": 3475,
    "comment": "/** \n * Writes chars from a  {@code char[]} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e This method uses  {@link String#String(char[])} and{@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3499",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.OutputStream, java.lang.String)",
    "snippet": "public static void write(final char[] data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3499,
    "end_line": 3502,
    "comment": "/** \n * Writes chars from a  {@code char[]} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#String(char[])} and{@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException                         if output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3514",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.Writer)",
    "snippet": "public static void write(final char[] data, final Writer writer) throws IOException {\n        if (data !\u003d null) {\n            writer.write(data);\n        }\n    }",
    "begin_line": 3514,
    "end_line": 3518,
    "comment": "/** \n * Writes chars from a  {@code char[]} to a {@link Writer}\n * @param data the char array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3536",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final CharSequence data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 3536,
    "end_line": 3539,
    "comment": "/** \n * Writes chars from a  {@link CharSequence} to bytes on an{@link OutputStream} using the default character encoding of theplatform. \u003cp\u003e This method uses  {@link String#getBytes()}. \u003c/p\u003e\n * @param data the {@link CharSequence} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.0\n * @deprecated 2.5 use {@link #write(CharSequence,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3555",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void write(final CharSequence data, final OutputStream output, final Charset charset)\n            throws IOException {\n        if (data !\u003d null) {\n            write(data.toString(), output, charset);\n        }\n    }",
    "begin_line": 3555,
    "end_line": 3560,
    "comment": "/** \n * Writes chars from a  {@link CharSequence} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link CharSequence} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3582",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void write(final CharSequence data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3582,
    "end_line": 3585,
    "comment": "/** \n * Writes chars from a  {@link CharSequence} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link CharSequence} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException        if output is null\n * @throws IOException                 if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3597",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.Writer)",
    "snippet": "public static void write(final CharSequence data, final Writer writer) throws IOException {\n        if (data !\u003d null) {\n            write(data.toString(), writer);\n        }\n    }",
    "begin_line": 3597,
    "end_line": 3601,
    "comment": "/** \n * Writes chars from a  {@link CharSequence} to a {@link Writer}.\n * @param data the {@link CharSequence} to write, null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3619",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final String data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 3619,
    "end_line": 3622,
    "comment": "/** \n * Writes chars from a  {@link String} to bytes on an{@link OutputStream} using the default character encoding of theplatform. \u003cp\u003e This method uses  {@link String#getBytes()}. \u003c/p\u003e\n * @param data the {@link String} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #write(String,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3639",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "@SuppressWarnings(\"resource\")\n    public static void write(final String data, final OutputStream output, final Charset charset) throws IOException {\n        if (data !\u003d null) {\n            // Use Charset#encode(String), since calling String#getBytes(Charset) might result in\n            // NegativeArraySizeException or OutOfMemoryError.\n            // The underlying OutputStream should not be closed, so the channel is not closed.\n            Channels.newChannel(output).write(Charsets.toCharset(charset).encode(data));\n        }\n    }",
    "begin_line": 3639,
    "end_line": 3646,
    "comment": "/** \n * Writes chars from a  {@link String} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link String} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3668",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void write(final String data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3668,
    "end_line": 3671,
    "comment": "/** \n * Writes chars from a  {@link String} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link String} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException        if output is null\n * @throws IOException                 if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3682",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.Writer)",
    "snippet": "public static void write(final String data, final Writer writer) throws IOException {\n        if (data !\u003d null) {\n            writer.write(data);\n        }\n    }",
    "begin_line": 3682,
    "end_line": 3686,
    "comment": "/** \n * Writes chars from a  {@link String} to a {@link Writer}.\n * @param data the {@link String} to write, null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3704",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.StringBuffer, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final StringBuffer data, final OutputStream output) //NOSONAR\n            throws IOException {\n        write(data, output, (String) null);\n    }",
    "begin_line": 3704,
    "end_line": 3707,
    "comment": "/** \n * Writes chars from a  {@link StringBuffer} to bytes on an{@link OutputStream} using the default character encoding of theplatform. \u003cp\u003e This method uses  {@link String#getBytes()}. \u003c/p\u003e\n * @param data the {@link StringBuffer} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated Use {@link #write(CharSequence,OutputStream)}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3731",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.StringBuffer, java.io.OutputStream, java.lang.String)",
    "snippet": "@Deprecated\n    public static void write(final StringBuffer data, final OutputStream output, final String charsetName) //NOSONAR\n        throws IOException {\n        if (data !\u003d null) {\n            write(data.toString(), output, Charsets.toCharset(charsetName));\n        }\n    }",
    "begin_line": 3731,
    "end_line": 3736,
    "comment": "/** \n * Writes chars from a  {@link StringBuffer} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link StringBuffer} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException        if output is null\n * @throws IOException                 if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n * @deprecated Use {@link #write(CharSequence,OutputStream,String)}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3749",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.StringBuffer, java.io.Writer)",
    "snippet": "@Deprecated\n    public static void write(final StringBuffer data, final Writer writer) //NOSONAR\n            throws IOException {\n        if (data !\u003d null) {\n            writer.write(data.toString());\n        }\n    }",
    "begin_line": 3749,
    "end_line": 3754,
    "comment": "/** \n * Writes chars from a  {@link StringBuffer} to a {@link Writer}.\n * @param data the {@link StringBuffer} to write, null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated Use {@link #write(CharSequence,Writer)}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeChunked#3768",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeChunked(byte[], java.io.OutputStream)",
    "snippet": "public static void writeChunked(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data !\u003d null) {\n            int bytes \u003d data.length;\n            int offset \u003d 0;\n            while (bytes \u003e 0) {\n                final int chunk \u003d Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                output.write(data, offset, chunk);\n                bytes -\u003d chunk;\n                offset +\u003d chunk;\n            }\n        }\n    }",
    "begin_line": 3768,
    "end_line": 3780,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to an {@link OutputStream} using chunked writes.This is intended for writing very large byte arrays which might otherwise cause excessive memory usage if the native code has to allocate a copy.\n * @param data the byte array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeChunked#3794",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeChunked(char[], java.io.Writer)",
    "snippet": "public static void writeChunked(final char[] data, final Writer writer) throws IOException {\n        if (data !\u003d null) {\n            int bytes \u003d data.length;\n            int offset \u003d 0;\n            while (bytes \u003e 0) {\n                final int chunk \u003d Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                writer.write(data, offset, chunk);\n                bytes -\u003d chunk;\n                offset +\u003d chunk;\n            }\n        }\n    }",
    "begin_line": 3794,
    "end_line": 3805,
    "comment": "/** \n * Writes chars from a  {@code char[]} to a {@link Writer} using chunked writes.This is intended for writing very large byte arrays which might otherwise cause excessive memory usage if the native code has to allocate a copy.\n * @param data the char array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3821",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void writeLines(final Collection\u003c?\u003e lines, final String lineEnding,\n                                  final OutputStream output) throws IOException {\n        writeLines(lines, lineEnding, output, Charset.defaultCharset());\n    }",
    "begin_line": 3821,
    "end_line": 3824,
    "comment": "/** \n * Writes the  {@link #toString()} value of each item in a collection toan  {@link OutputStream} line by line, using the default characterencoding of the platform and the specified line ending.\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param output the {@link OutputStream} to write to, not null, not closed\n * @throws NullPointerException if the output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #writeLines(Collection,String,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3844",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void writeLines(final Collection\u003c?\u003e lines, String lineEnding, final OutputStream output,\n            Charset charset) throws IOException {\n        if (lines \u003d\u003d null) {\n            return;\n        }\n        if (lineEnding \u003d\u003d null) {\n            lineEnding \u003d System.lineSeparator();\n        }\n        if (StandardCharsets.UTF_16.equals(charset)) {\n            // don\u0027t write a BOM\n            charset \u003d StandardCharsets.UTF_16BE;\n        }\n        final byte[] eolBytes \u003d lineEnding.getBytes(charset);\n        for (final Object line : lines) {\n            if (line !\u003d null) {\n                write(line.toString(), output, charset);\n            }\n            output.write(eolBytes);\n        }\n    }",
    "begin_line": 3844,
    "end_line": 3863,
    "comment": "/** \n * Writes the  {@link #toString()} value of each item in a collection toan  {@link OutputStream} line by line, using the specified characterencoding and the specified line ending. \u003cp\u003e UTF-16 is written big-endian with no byte order mark. For little endian, use UTF-16LE. For a BOM, write it to the stream before calling this method. \u003c/p\u003e\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param output the {@link OutputStream} to write to, not null, not closed\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3885",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void writeLines(final Collection\u003c?\u003e lines, final String lineEnding,\n                                  final OutputStream output, final String charsetName) throws IOException {\n        writeLines(lines, lineEnding, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3885,
    "end_line": 3888,
    "comment": "/** \n * Writes the  {@link #toString()} value of each item in a collection toan  {@link OutputStream} line by line, using the specified characterencoding and the specified line ending. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param output the {@link OutputStream} to write to, not null, not closed\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException                         if the output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3901",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.Writer)",
    "snippet": "public static void writeLines(final Collection\u003c?\u003e lines, String lineEnding,\n                                  final Writer writer) throws IOException {\n        if (lines \u003d\u003d null) {\n            return;\n        }\n        if (lineEnding \u003d\u003d null) {\n            lineEnding \u003d System.lineSeparator();\n        }\n        for (final Object line : lines) {\n            if (line !\u003d null) {\n                writer.write(line.toString());\n            }\n            writer.write(lineEnding);\n        }\n    }",
    "begin_line": 3901,
    "end_line": 3915,
    "comment": "/** \n * Writes the  {@link #toString()} value of each item in a collection toa  {@link Writer} line by line, using the specified line ending.\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param writer the {@link Writer} to write to, not null, not closed\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writer#3926",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writer(java.lang.Appendable)",
    "snippet": "public static Writer writer(final Appendable appendable) {\n        Objects.requireNonNull(appendable, \"appendable\");\n        if (appendable instanceof Writer) {\n            return (Writer) appendable;\n        }\n        if (appendable instanceof StringBuilder) {\n            return new StringBuilderWriter((StringBuilder) appendable);\n        }\n        return new AppendableWriter\u003c\u003e(appendable);\n    }",
    "begin_line": 3926,
    "end_line": 3935,
    "comment": "/** \n * Returns the given Appendable if it is already a  {@link Writer}, otherwise creates a Writer wrapper around the given Appendable.\n * @param appendable the Appendable to wrap or return (not null)\n * @return  the given Appendable or a Writer wrapper around the given Appendable\n * @throws NullPointerException if the input parameter is null\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.IOUtils#3942",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.IOUtils()",
    "snippet": "@Deprecated\n    public IOUtils() { //NOSONAR\n    }",
    "begin_line": 3942,
    "end_line": 3943,
    "comment": "/** \n * Instances should NOT be constructed in standard programming.\n * @deprecated Will be private in 3.0.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.StandardLineSeparator#52",
    "is_bug": true,
    "src_path": "org/apache/commons/io/StandardLineSeparator.java",
    "class_name": "org.apache.commons.io.StandardLineSeparator",
    "signature": "org.apache.commons.io.StandardLineSeparator.StandardLineSeparator(java.lang.String)",
    "snippet": " StandardLineSeparator(final String lineSeparator) {\n        this.lineSeparator \u003d Objects.requireNonNull(lineSeparator, \"lineSeparator\");\n    }",
    "begin_line": 52,
    "end_line": 54,
    "comment": "/** \n * Constructs a new instance for a non-null line separator.\n * @param lineSeparator a non-null line separator.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getBytes#62",
    "is_bug": true,
    "src_path": "org/apache/commons/io/StandardLineSeparator.java",
    "class_name": "org.apache.commons.io.StandardLineSeparator",
    "signature": "org.apache.commons.io.StandardLineSeparator.getBytes(java.nio.charset.Charset)",
    "snippet": "public byte[] getBytes(final Charset charset) {\n        return lineSeparator.getBytes(charset);\n    }",
    "begin_line": 62,
    "end_line": 64,
    "comment": "/** \n * Gets the bytes for this instance encoded using the given Charset.\n * @param charset the encoding Charset.\n * @return the bytes for this instance encoded using the given Charset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getString#71",
    "is_bug": true,
    "src_path": "org/apache/commons/io/StandardLineSeparator.java",
    "class_name": "org.apache.commons.io.StandardLineSeparator",
    "signature": "org.apache.commons.io.StandardLineSeparator.getString()",
    "snippet": "public String getString() {\n        return lineSeparator;\n    }",
    "begin_line": 71,
    "end_line": 73,
    "comment": "/** \n * Gets the String value of this instance.\n * @return the String value of this instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.toDefaultFileVisitResult#44",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.toDefaultFileVisitResult(boolean)",
    "snippet": "static FileVisitResult toDefaultFileVisitResult(final boolean accept) {\n        return accept ? FileVisitResult.CONTINUE : FileVisitResult.TERMINATE;\n    }",
    "begin_line": 44,
    "end_line": 46,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.AbstractFileFilter#61",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.AbstractFileFilter()",
    "snippet": "public AbstractFileFilter() {\n        this(FileVisitResult.CONTINUE, FileVisitResult.TERMINATE);\n    }",
    "begin_line": 61,
    "end_line": 63,
    "comment": "/** \n * Constructs a new instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.AbstractFileFilter#72",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.AbstractFileFilter(java.nio.file.FileVisitResult, java.nio.file.FileVisitResult)",
    "snippet": "protected AbstractFileFilter(final FileVisitResult onAccept, final FileVisitResult onReject) {\n        this.onAccept \u003d onAccept;\n        this.onReject \u003d onReject;\n    }",
    "begin_line": 72,
    "end_line": 75,
    "comment": "/** \n * Constructs a new instance.\n * @param onAccept What to do on acceptance.\n * @param onReject What to do on rejection.\n * @since 2.12.0.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.accept#84",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        Objects.requireNonNull(file, \"file\");\n        return accept(file.getParentFile(), file.getName());\n    }",
    "begin_line": 84,
    "end_line": 87,
    "comment": "/** \n * Checks to see if the File should be accepted by this filter.\n * @param file the File to check\n * @return true if this file matches the test\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.accept#97",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.accept(java.io.File, java.lang.String)",
    "snippet": "@Override\n    public boolean accept(final File dir, final String name) {\n        Objects.requireNonNull(name, \"name\");\n        return accept(new File(dir, name));\n    }",
    "begin_line": 97,
    "end_line": 100,
    "comment": "/** \n * Checks to see if the File should be accepted by this filter.\n * @param dir the directory File to check\n * @param name the file name within the directory to check\n * @return true if this file matches the test\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.append#102",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.append(java.util.List\u003c?\u003e, java.lang.StringBuilder)",
    "snippet": "void append(final List\u003c?\u003e list, final StringBuilder buffer) {\n        for (int i \u003d 0; i \u003c list.size(); i++) {\n            if (i \u003e 0) {\n                buffer.append(\",\");\n            }\n            buffer.append(list.get(i));\n        }\n    }",
    "begin_line": 102,
    "end_line": 109,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.append#111",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.append(java.lang.Object[], java.lang.StringBuilder)",
    "snippet": "void append(final Object[] array, final StringBuilder buffer) {\n        for (int i \u003d 0; i \u003c array.length; i++) {\n            if (i \u003e 0) {\n                buffer.append(\",\");\n            }\n            buffer.append(array[i]);\n        }\n    }",
    "begin_line": 111,
    "end_line": 118,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.get#120",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.get(org.apache.commons.io.function.IOSupplier\u003cjava.nio.file.FileVisitResult\u003e)",
    "snippet": "FileVisitResult get(final IOSupplier\u003cFileVisitResult\u003e supplier) {\n        try {\n            return supplier.get();\n        } catch (IOException e) {\n            return handle(e);\n        }\n    }",
    "begin_line": 120,
    "end_line": 126,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.handle#135",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.handle(java.lang.Throwable)",
    "snippet": "protected FileVisitResult handle(final Throwable t) {\n        return FileVisitResult.TERMINATE;\n    }",
    "begin_line": 135,
    "end_line": 137,
    "comment": "/** \n * Handles exceptions caught while accepting.\n * @param t the caught Throwable.\n * @return the given Throwable.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.postVisitDirectory#140",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.postVisitDirectory(java.nio.file.Path, java.io.IOException)",
    "snippet": "@Override\n    public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n        return FileVisitResult.CONTINUE;\n    }",
    "begin_line": 140,
    "end_line": 142,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.preVisitDirectory#145",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.preVisitDirectory(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attributes) throws IOException {\n        return accept(dir, attributes);\n    }",
    "begin_line": 145,
    "end_line": 147,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.toFileVisitResult#155",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.toFileVisitResult(boolean)",
    "snippet": "FileVisitResult toFileVisitResult(final boolean accept) {\n        return accept ? onAccept : onReject;\n    }",
    "begin_line": 155,
    "end_line": 157,
    "comment": "/** \n * Converts a boolean into a FileVisitResult.\n * @param accept accepted or rejected.\n * @return a FileVisitResult.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.toString#165",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.toString()",
    "snippet": "@Override\n    public String toString() {\n        return getClass().getSimpleName();\n    }",
    "begin_line": 165,
    "end_line": 167,
    "comment": "/** \n * Provides a String representation of this file filter.\n * @return a String representation\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.visitFile#170",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.visitFile(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult visitFile(final Path file, final BasicFileAttributes attributes) throws IOException {\n        return accept(file, attributes);\n    }",
    "begin_line": 170,
    "end_line": 172,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.visitFileFailed#175",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.visitFileFailed(java.nio.file.Path, java.io.IOException)",
    "snippet": "@Override\n    public FileVisitResult visitFileFailed(final Path file, final IOException exc) throws IOException {\n        return FileVisitResult.CONTINUE;\n    }",
    "begin_line": 175,
    "end_line": 177,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.accept#51",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    boolean accept(File file);",
    "begin_line": 51,
    "end_line": 51,
    "comment": "/** \n * Tests if a File should be accepted by this filter. \u003cp\u003e Defined in  {@link java.io.FileFilter}. \u003c/p\u003e\n * @param file the File to check.\n * @return true if this file matches the test.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.accept#64",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.accept(java.io.File, java.lang.String)",
    "snippet": "@Override\n    boolean accept(File dir, String name);",
    "begin_line": 64,
    "end_line": 64,
    "comment": "/** \n * Tests if a File should be accepted by this filter. \u003cp\u003e Defined in  {@link java.io.FilenameFilter}. \u003c/p\u003e\n * @param dir the directory File to check.\n * @param name the file name within the directory to check.\n * @return true if this file matches the test.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.accept#74",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    default FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {\n        return AbstractFileFilter.toDefaultFileVisitResult(path !\u003d null \u0026\u0026 accept(path.toFile()));\n    }",
    "begin_line": 74,
    "end_line": 76,
    "comment": "/** \n * Checks to see if a Path should be accepted by this filter.\n * @param path the Path to check.\n * @return true if this path matches the test.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.and#85",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.and(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "default IOFileFilter and(final IOFileFilter fileFilter) {\n        return new AndFileFilter(this, fileFilter);\n    }",
    "begin_line": 85,
    "end_line": 87,
    "comment": "/** \n * Constructs a new \"and\" filter with this filter.\n * @param fileFilter the filter to \"and\".\n * @return a new filter.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.matches#97",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.matches(java.nio.file.Path)",
    "snippet": "@Override\n    default boolean matches(final Path path) {\n        return accept(path, null) !\u003d FileVisitResult.TERMINATE;\n    }",
    "begin_line": 97,
    "end_line": 99,
    "comment": "/** \n * Tests if a Path should be accepted by this filter.\n * @param path the Path to check.\n * @return true if this path matches the test.\n * @since 2.14.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.negate#107",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.negate()",
    "snippet": "default IOFileFilter negate() {\n        return new NotFileFilter(this);\n    }",
    "begin_line": 107,
    "end_line": 109,
    "comment": "/** \n * Constructs a new \"not\" filter with this filter.\n * @return a new filter.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.or#118",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.or(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "default IOFileFilter or(final IOFileFilter fileFilter) {\n        return new OrFileFilter(this, fileFilter);\n    }",
    "begin_line": 118,
    "end_line": 120,
    "comment": "/** \n * Constructs a new \"or\" filter with this filter.\n * @param fileFilter the filter to \"or\".\n * @return a new filter.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.compile#85",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.compile(java.lang.String, int)",
    "snippet": "private static Pattern compile(final String pattern, final int flags) {\n        Objects.requireNonNull(pattern, \"pattern\");\n        return Pattern.compile(pattern, flags);\n    }",
    "begin_line": 85,
    "end_line": 88,
    "comment": "/** \n * Compiles the given pattern source.\n * @param pattern the source pattern.\n * @param flags the compilation flags.\n * @return a new Pattern.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.toFlags#96",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.toFlags(org.apache.commons.io.IOCase)",
    "snippet": "private static int toFlags(final IOCase ioCase) {\n        return IOCase.isCaseSensitive(ioCase) ? 0 : Pattern.CASE_INSENSITIVE;\n    }",
    "begin_line": 96,
    "end_line": 98,
    "comment": "/** \n * Converts IOCase to Pattern compilation flags.\n * @param ioCase case-sensitivity.\n * @return Pattern compilation flags.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.RegexFileFilter#113",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.RegexFileFilter(java.util.regex.Pattern)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n    public RegexFileFilter(final Pattern pattern) {\n        this(pattern, (Function\u003cPath, String\u003e \u0026 Serializable) p -\u003e p.getFileName().toString());\n    }",
    "begin_line": 113,
    "end_line": 115,
    "comment": "/** \n * Constructs a new regular expression filter for a compiled regular expression\n * @param pattern regular expression to match.\n * @throws NullPointerException if the pattern is null.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.RegexFileFilter#125",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.RegexFileFilter(java.util.regex.Pattern, java.util.function.Function\u003cjava.nio.file.Path,java.lang.String\u003e)",
    "snippet": "public RegexFileFilter(final Pattern pattern, final Function\u003cPath, String\u003e pathToString) {\n        Objects.requireNonNull(pattern, \"pattern\");\n        this.pattern \u003d pattern;\n        this.pathToString \u003d pathToString;\n    }",
    "begin_line": 125,
    "end_line": 129,
    "comment": "/** \n * Constructs a new regular expression filter for a compiled regular expression\n * @param pattern regular expression to match.\n * @param pathToString How convert a path to a string.\n * @throws NullPointerException if the pattern is null.\n * @since 2.10.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.RegexFileFilter#137",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.RegexFileFilter(java.lang.String)",
    "snippet": "public RegexFileFilter(final String pattern) {\n        this(pattern, 0);\n    }",
    "begin_line": 137,
    "end_line": 139,
    "comment": "/** \n * Constructs a new regular expression filter.\n * @param pattern regular string expression to match\n * @throws NullPointerException if the pattern is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.RegexFileFilter#148",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.RegexFileFilter(java.lang.String, int)",
    "snippet": "public RegexFileFilter(final String pattern, final int flags) {\n        this(compile(pattern, flags));\n    }",
    "begin_line": 148,
    "end_line": 150,
    "comment": "/** \n * Constructs a new regular expression filter with the specified flags.\n * @param pattern regular string expression to match\n * @param flags pattern flags - e.g. {@link Pattern#CASE_INSENSITIVE}\n * @throws IllegalArgumentException if the pattern is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.RegexFileFilter#159",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.RegexFileFilter(java.lang.String, org.apache.commons.io.IOCase)",
    "snippet": "public RegexFileFilter(final String pattern, final IOCase ioCase) {\n        this(compile(pattern, toFlags(ioCase)));\n    }",
    "begin_line": 159,
    "end_line": 161,
    "comment": "/** \n * Constructs a new regular expression filter with the specified flags case sensitivity.\n * @param pattern regular string expression to match\n * @param ioCase how to handle case sensitivity, null means case-sensitive\n * @throws IllegalArgumentException if the pattern is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.accept#171",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.accept(java.io.File, java.lang.String)",
    "snippet": "@Override\n    public boolean accept(final File dir, final String name) {\n        return pattern.matcher(name).matches();\n    }",
    "begin_line": 171,
    "end_line": 173,
    "comment": "/** \n * Checks to see if the file name matches one of the regular expressions.\n * @param dir the file directory (ignored)\n * @param name the file name\n * @return true if the file name matches one of the regular expressions\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.accept#183",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {\n        return toFileVisitResult(pattern.matcher(pathToString.apply(path)).matches());\n    }",
    "begin_line": 183,
    "end_line": 185,
    "comment": "/** \n * Checks to see if the file name matches one of the regular expressions.\n * @param path the path\n * @param attributes the path attributes\n * @return true if the file name matches one of the regular expressions\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RegexFileFilter.toString#193",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/RegexFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.RegexFileFilter",
    "signature": "org.apache.commons.io.filefilter.RegexFileFilter.toString()",
    "snippet": "@Override\n    public String toString() {\n        return \"RegexFileFilter [pattern\u003d\" + pattern + \"]\";\n    }",
    "begin_line": 193,
    "end_line": 195,
    "comment": "/** \n * Returns a debug string.\n * @since 2.10.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.construct#79",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.construct(byte[], int, int)",
    "snippet": "T construct(final byte[] buffer, final int offset, final int length);",
    "begin_line": 79,
    "end_line": 79,
    "comment": "/** \n * Constructs an InputStream subclass.\n * @param buffer the buffer\n * @param offset the offset into the buffer\n * @param length the length of the buffer\n * @return the InputStream subclass.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.close#111",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.close()",
    "snippet": "@Override\n    public void close() throws IOException {\n        //nop\n    }",
    "begin_line": 111,
    "end_line": 113,
    "comment": "/** \n * Does nothing. The methods in this class can be called after the stream has been closed without generating an  {@link IOException}.\n * @throws IOException never (this method should not declare this exception but it has to now due to backwardscompatibility)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.needNewBuffer#121",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.needNewBuffer(int)",
    "snippet": "protected void needNewBuffer(final int newCount) {\n        if (currentBufferIndex \u003c buffers.size() - 1) {\n            // Recycling old buffer\n            filledBufferSum +\u003d currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer \u003d buffers.get(currentBufferIndex);\n        } else {\n            // Creating new buffer\n            final int newBufferSize;\n            if (currentBuffer \u003d\u003d null) {\n                newBufferSize \u003d newCount;\n                filledBufferSum \u003d 0;\n            } else {\n                newBufferSize \u003d Math.max(currentBuffer.length \u003c\u003c 1, newCount - filledBufferSum);\n                filledBufferSum +\u003d currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer \u003d IOUtils.byteArray(newBufferSize);\n            buffers.add(currentBuffer);\n        }\n    }",
    "begin_line": 121,
    "end_line": 143,
    "comment": "/** \n * Makes a new buffer available either by allocating a new one or re-cycling an existing one.\n * @param newCount  the size of the buffer if one is created\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.reset#148",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.reset()",
    "snippet": "public abstract void reset();",
    "begin_line": 148,
    "end_line": 148,
    "comment": "/** \n * @see java.io.ByteArrayOutputStream#reset()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.resetImpl#153",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.resetImpl()",
    "snippet": "protected void resetImpl() {\n        count \u003d 0;\n        filledBufferSum \u003d 0;\n        currentBufferIndex \u003d 0;\n        if (reuseBuffers) {\n            currentBuffer \u003d buffers.get(currentBufferIndex);\n        } else {\n            //Throw away old buffers\n            currentBuffer \u003d null;\n            final int size \u003d buffers.get(0).length;\n            buffers.clear();\n            needNewBuffer(size);\n            reuseBuffers \u003d true;\n        }\n    }",
    "begin_line": 153,
    "end_line": 167,
    "comment": "/** \n * @see java.io.ByteArrayOutputStream#reset()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.size#174",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.size()",
    "snippet": "public abstract int size();",
    "begin_line": 174,
    "end_line": 174,
    "comment": "/** \n * Returns the current size of the byte array.\n * @return the current size of the byte array\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toByteArray#183",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toByteArray()",
    "snippet": "public abstract byte[] toByteArray();",
    "begin_line": 183,
    "end_line": 183,
    "comment": "/** \n * Gets the current contents of this byte stream as a byte array. The result is independent of this stream.\n * @return the current contents of this output stream, as a byte array\n * @see java.io.ByteArrayOutputStream#toByteArray()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toByteArrayImpl#192",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toByteArrayImpl()",
    "snippet": "protected byte[] toByteArrayImpl() {\n        int remaining \u003d count;\n        if (remaining \u003d\u003d 0) {\n            return IOUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] newBuf \u003d IOUtils.byteArray(remaining);\n        int pos \u003d 0;\n        for (final byte[] buf : buffers) {\n            final int c \u003d Math.min(buf.length, remaining);\n            System.arraycopy(buf, 0, newBuf, pos, c);\n            pos +\u003d c;\n            remaining -\u003d c;\n            if (remaining \u003d\u003d 0) {\n                break;\n            }\n        }\n        return newBuf;\n    }",
    "begin_line": 192,
    "end_line": 209,
    "comment": "/** \n * Gets the current contents of this byte stream as a byte array. The result is independent of this stream.\n * @return the current contents of this output stream, as a byte array\n * @see java.io.ByteArrayOutputStream#toByteArray()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toInputStream#221",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toInputStream()",
    "snippet": "public abstract InputStream toInputStream();",
    "begin_line": 221,
    "end_line": 221,
    "comment": "/** \n * Gets the current contents of this byte stream as an Input Stream. The returned stream is backed by buffers of  {@code this} stream,avoiding memory allocation and copy, thus saving space and time.\u003cbr\u003e\n * @return the current contents of this output stream.\n * @see java.io.ByteArrayOutputStream#toByteArray()\n * @see #reset()\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toInputStream#239",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toInputStream(org.apache.commons.io.output.AbstractByteArrayOutputStream.InputStreamConstructor\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"resource\") toInputStream(final InputStreamConstructor\u003cT\u003e isConstructor) {\n        int remaining \u003d count;\n        if (remaining \u003d\u003d 0) {\n            return ClosedInputStream.INSTANCE;\n        }\n        final List\u003cT\u003e list \u003d new ArrayList\u003c\u003e(buffers.size());\n        for (final byte[] buf : buffers) {\n            final int c \u003d Math.min(buf.length, remaining);\n            list.add(isConstructor.construct(buf, 0, c));\n            remaining -\u003d c;\n            if (remaining \u003d\u003d 0) {\n                break;\n            }\n        }\n        reuseBuffers \u003d false;\n        return new SequenceInputStream(Collections.enumeration(list));\n    }",
    "begin_line": 239,
    "end_line": 255,
    "comment": "/** \n * Gets the current contents of this byte stream as an Input Stream. The returned stream is backed by buffers of  {@code this} stream,avoiding memory allocation and copy, thus saving space and time.\u003cbr\u003e\n * @param \u003c T \u003e the type of the InputStream which makes upthe  {@link SequenceInputStream}.\n * @param isConstructor A constructor for an InputStream which makesup the  {@link SequenceInputStream}.\n * @return the current contents of this output stream.\n * @see java.io.ByteArrayOutputStream#toByteArray()\n * @see #reset()\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toString#266",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toString()",
    "snippet": "@Override\n    @Deprecated\n    public String toString() {\n        // make explicit the use of the default charset\n        return new String(toByteArray(), Charset.defaultCharset());\n    }",
    "begin_line": 266,
    "end_line": 269,
    "comment": "/** \n * Gets the current contents of this byte stream as a string using the platform default charset.\n * @return the contents of the byte array as a String\n * @see java.io.ByteArrayOutputStream#toString()\n * @deprecated 2.5 use {@link #toString(String)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toString#280",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toString(java.nio.charset.Charset)",
    "snippet": "public String toString(final Charset charset) {\n        return new String(toByteArray(), charset);\n    }",
    "begin_line": 280,
    "end_line": 282,
    "comment": "/** \n * Gets the current contents of this byte stream as a string using the specified encoding.\n * @param charset  the character encoding\n * @return the string converted from the byte array\n * @see java.io.ByteArrayOutputStream#toString(String)\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toString#293",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toString(java.lang.String)",
    "snippet": "public String toString(final String enc) throws UnsupportedEncodingException {\n        return new String(toByteArray(), enc);\n    }",
    "begin_line": 293,
    "end_line": 295,
    "comment": "/** \n * Gets the current contents of this byte stream as a string using the specified encoding.\n * @param enc  the name of the character encoding\n * @return the string converted from the byte array\n * @throws UnsupportedEncodingException if the encoding is not supported\n * @see java.io.ByteArrayOutputStream#toString(String)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.write#298",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.write(byte[], int, int)",
    "snippet": "@Override\n    public abstract void write(final byte[] b, final int off, final int len);",
    "begin_line": 298,
    "end_line": 298,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.write#311",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.write(java.io.InputStream)",
    "snippet": "public abstract int write(final InputStream in) throws IOException;",
    "begin_line": 311,
    "end_line": 311,
    "comment": "/** \n * Writes the entire contents of the specified input stream to this byte stream. Bytes from the input stream are read directly into the internal buffer of this stream.\n * @param in the input stream to read from\n * @return total number of bytes read from the input stream(and written to this stream)\n * @throws IOException if an I/O error occurs while reading the input stream\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.write#314",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.write(int)",
    "snippet": "@Override\n    public abstract void write(final int b);",
    "begin_line": 314,
    "end_line": 314,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.writeImpl#322",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeImpl(byte[], int, int)",
    "snippet": "protected void writeImpl(final byte[] b, final int off, final int len) {\n        final int newCount \u003d count + len;\n        int remaining \u003d len;\n        int inBufferPos \u003d count - filledBufferSum;\n        while (remaining \u003e 0) {\n            final int part \u003d Math.min(remaining, currentBuffer.length - inBufferPos);\n            System.arraycopy(b, off + len - remaining, currentBuffer, inBufferPos, part);\n            remaining -\u003d part;\n            if (remaining \u003e 0) {\n                needNewBuffer(newCount);\n                inBufferPos \u003d 0;\n            }\n        }\n        count \u003d newCount;\n    }",
    "begin_line": 322,
    "end_line": 336,
    "comment": "/** \n * Writes the bytes to the byte array.\n * @param b the bytes to write\n * @param off The start offset\n * @param len The number of bytes to write\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.writeImpl#349",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeImpl(java.io.InputStream)",
    "snippet": "protected int writeImpl(final InputStream in) throws IOException {\n        int readCount \u003d 0;\n        int inBufferPos \u003d count - filledBufferSum;\n        int n \u003d in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);\n        while (n !\u003d EOF) {\n            readCount +\u003d n;\n            inBufferPos +\u003d n;\n            count +\u003d n;\n            if (inBufferPos \u003d\u003d currentBuffer.length) {\n                needNewBuffer(currentBuffer.length);\n                inBufferPos \u003d 0;\n            }\n            n \u003d in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);\n        }\n        return readCount;\n    }",
    "begin_line": 349,
    "end_line": 364,
    "comment": "/** \n * Writes the entire contents of the specified input stream to this byte stream. Bytes from the input stream are read directly into the internal buffer of this stream.\n * @param in the input stream to read from\n * @return total number of bytes read from the input stream(and written to this stream)\n * @throws IOException if an I/O error occurs while reading the input stream\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.writeImpl#370",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeImpl(int)",
    "snippet": "protected void writeImpl(final int b) {\n        int inBufferPos \u003d count - filledBufferSum;\n        if (inBufferPos \u003d\u003d currentBuffer.length) {\n            needNewBuffer(count + 1);\n            inBufferPos \u003d 0;\n        }\n        currentBuffer[inBufferPos] \u003d (byte) b;\n        count++;\n    }",
    "begin_line": 370,
    "end_line": 378,
    "comment": "/** \n * Write a byte to byte array.\n * @param b the byte to write\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.writeTo#388",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeTo(java.io.OutputStream)",
    "snippet": "public abstract void writeTo(final OutputStream out) throws IOException;",
    "begin_line": 388,
    "end_line": 388,
    "comment": "/** \n * Writes the entire contents of this byte stream to the specified output stream.\n * @param out  the output stream to write to\n * @throws IOException if an I/O error occurs, such as if the stream is closed\n * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.writeToImpl#398",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeToImpl(java.io.OutputStream)",
    "snippet": "protected void writeToImpl(final OutputStream out) throws IOException {\n        int remaining \u003d count;\n        for (final byte[] buf : buffers) {\n            final int c \u003d Math.min(buf.length, remaining);\n            out.write(buf, 0, c);\n            remaining -\u003d c;\n            if (remaining \u003d\u003d 0) {\n                break;\n            }\n        }\n    }",
    "begin_line": 398,
    "end_line": 408,
    "comment": "/** \n * Writes the entire contents of this byte stream to the specified output stream.\n * @param out  the output stream to write to\n * @throws IOException if an I/O error occurs, such as if the stream is closed\n * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.toBufferedInputStream#52",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.toBufferedInputStream(java.io.InputStream)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input)\n            throws IOException {\n        return toBufferedInputStream(input, DEFAULT_SIZE);\n    }",
    "begin_line": 52,
    "end_line": 55,
    "comment": "/** \n * Fetches entire contents of an  {@link InputStream} and representsame data as result InputStream. \u003cp\u003e This method is useful where, \u003c/p\u003e \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e It can be used in favor of  {@link #toByteArray()}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n * @param input Stream to be fully buffered.\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.toBufferedInputStream#80",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.toBufferedInputStream(java.io.InputStream, int)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input, final int size)\n        throws IOException {\n        try (ByteArrayOutputStream output \u003d new ByteArrayOutputStream(size)) {\n            output.write(input);\n            return output.toInputStream();\n        }\n    }",
    "begin_line": 80,
    "end_line": 86,
    "comment": "/** \n * Fetches entire contents of an  {@link InputStream} and representsame data as result InputStream. \u003cp\u003e This method is useful where, \u003c/p\u003e \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e It can be used in favor of  {@link #toByteArray()}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n * @param input Stream to be fully buffered.\n * @param size the initial buffer size\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs.\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.ByteArrayOutputStream#92",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.ByteArrayOutputStream()",
    "snippet": "public ByteArrayOutputStream() {\n        this(DEFAULT_SIZE);\n    }",
    "begin_line": 92,
    "end_line": 94,
    "comment": "/** \n * Constructs a new byte array output stream. The buffer capacity is initially  {@value AbstractByteArrayOutputStream#DEFAULT_SIZE} bytes, though its size increases if necessary.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.ByteArrayOutputStream#103",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.ByteArrayOutputStream(int)",
    "snippet": "public ByteArrayOutputStream(final int size) {\n        if (size \u003c 0) {\n            throw new IllegalArgumentException(\"Negative initial size: \" + size);\n        }\n        synchronized (this) {\n            needNewBuffer(size);\n        }\n    }",
    "begin_line": 103,
    "end_line": 110,
    "comment": "/** \n * Constructs a new byte array output stream, with a buffer capacity of the specified size, in bytes.\n * @param size  the initial size\n * @throws IllegalArgumentException if size is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.reset#116",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.reset()",
    "snippet": "@Override\n    public synchronized void reset() {\n        resetImpl();\n    }",
    "begin_line": 116,
    "end_line": 118,
    "comment": "/** \n * @see java.io.ByteArrayOutputStream#reset()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.size#121",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.size()",
    "snippet": "@Override\n    public synchronized int size() {\n        return count;\n    }",
    "begin_line": 121,
    "end_line": 123,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.toByteArray#126",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.toByteArray()",
    "snippet": "@Override\n    public synchronized byte[] toByteArray() {\n        return toByteArrayImpl();\n    }",
    "begin_line": 126,
    "end_line": 128,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.toInputStream#131",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.toInputStream()",
    "snippet": "@Override\n    public synchronized InputStream toInputStream() {\n        return toInputStream(java.io.ByteArrayInputStream::new);\n    }",
    "begin_line": 131,
    "end_line": 133,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.write#136",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.write(byte[], int, int)",
    "snippet": "@Override\n    public void write(final byte[] b, final int off, final int len) {\n        if (off \u003c 0\n                || off \u003e b.length\n                || len \u003c 0\n                || off + len \u003e b.length\n                || off + len \u003c 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (len \u003d\u003d 0) {\n            return;\n        }\n        synchronized (this) {\n            writeImpl(b, off, len);\n        }\n    }",
    "begin_line": 136,
    "end_line": 150,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.write#153",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.write(java.io.InputStream)",
    "snippet": "@Override\n    public synchronized int write(final InputStream in) throws IOException {\n        return writeImpl(in);\n    }",
    "begin_line": 153,
    "end_line": 155,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.write#158",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.write(int)",
    "snippet": "@Override\n    public synchronized void write(final int b) {\n        writeImpl(b);\n    }",
    "begin_line": 158,
    "end_line": 160,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.writeTo#163",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.writeTo(java.io.OutputStream)",
    "snippet": "@Override\n    public synchronized void writeTo(final OutputStream out) throws IOException {\n        writeToImpl(out);\n    }",
    "begin_line": 163,
    "end_line": 165,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]