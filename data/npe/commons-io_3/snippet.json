[
  {
    "name": "null.current#139",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.current()",
    "snippet": "private static FileSystem current() {\n        if (IS_OS_LINUX) {\n            return LINUX;\n        }\n        if (IS_OS_MAC) {\n            return MAC_OSX;\n        }\n        if (IS_OS_WINDOWS) {\n            return WINDOWS;\n        }\n        return GENERIC;\n    }",
    "begin_line": 139,
    "end_line": 150,
    "comment": "/** \n * Gets the current file system.\n * @return the current file system\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getCurrent#157",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getCurrent()",
    "snippet": "public static FileSystem getCurrent() {\n        return CURRENT;\n    }",
    "begin_line": 157,
    "end_line": 159,
    "comment": "/** \n * Gets the current file system.\n * @return the current file system\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getOsMatchesName#168",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getOsMatchesName(java.lang.String)",
    "snippet": "private static boolean getOsMatchesName(final String osNamePrefix) {\n        return isOsNameMatch(getSystemProperty(\"os.name\"), osNamePrefix);\n    }",
    "begin_line": 168,
    "end_line": 170,
    "comment": "/** \n * Decides if the operating system matches.\n * @param osNamePrefix the prefix for the os name\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getSystemProperty#185",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getSystemProperty(java.lang.String)",
    "snippet": "private static String getSystemProperty(final String property) {\n        try {\n            return System.getProperty(property);\n        } catch (final SecurityException ex) {\n            // we are not allowed to look at this property\n            System.err.println(\"Caught a SecurityException reading the system property \u0027\" + property\n                    + \"\u0027; the SystemUtils property value will default to null.\");\n            return null;\n        }\n    }",
    "begin_line": 185,
    "end_line": 194,
    "comment": "/** \n * \u003cp\u003e Gets a System property, defaulting to  {@code null} if the property cannot be read.\u003c/p\u003e \u003cp\u003e If a  {@link SecurityException} is caught, the return value is {@code null} and a message is written to{@code System.err}. \u003c/p\u003e\n * @param property the system property name\n * @return the system property value or {@code null} if a security problem occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.indexOf#239",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.indexOf(java.lang.CharSequence, int, int)",
    "snippet": "private static int indexOf(final CharSequence cs, final int searchChar, int start) {\n        if (cs instanceof String) {\n            return ((String) cs).indexOf(searchChar, start);\n        }\n        final int sz \u003d cs.length();\n        if (start \u003c 0) {\n            start \u003d 0;\n        }\n        if (searchChar \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            for (int i \u003d start; i \u003c sz; i++) {\n                if (cs.charAt(i) \u003d\u003d searchChar) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        //supplementary characters (LANG1300)\n        if (searchChar \u003c\u003d Character.MAX_CODE_POINT) {\n            final char[] chars \u003d Character.toChars(searchChar);\n            for (int i \u003d start; i \u003c sz - 1; i++) {\n                final char high \u003d cs.charAt(i);\n                final char low \u003d cs.charAt(i + 1);\n                if (high \u003d\u003d chars[0] \u0026\u0026 low \u003d\u003d chars[1]) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }",
    "begin_line": 239,
    "end_line": 267,
    "comment": "/** \n * Copied from Apache Commons Lang CharSequenceUtils. Returns the index within  {@code cs} of the first occurrence of thespecified character, starting the search at the specified index. \u003cp\u003e If a character with value  {@code searchChar} occurs in thecharacter sequence represented by the  {@code cs}object at an index no smaller than  {@code start}, then the index of the first such occurrence is returned. For values of  {@code searchChar} in the range from 0 to 0xFFFF (inclusive),this is the smallest value \u003ci\u003ek\u003c/i\u003e such that: \u003c/p\u003e \u003cblockquote\u003e\u003cpre\u003e (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d searchChar) \u0026amp;\u0026amp; (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d start) \u003c/pre\u003e\u003c/blockquote\u003e is true. For other values of  {@code searchChar}, it is the smallest value \u003ci\u003ek\u003c/i\u003e such that: \u003cblockquote\u003e\u003cpre\u003e (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d searchChar) \u0026amp;\u0026amp; (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d start) \u003c/pre\u003e\u003c/blockquote\u003e \u003cp\u003e is true. In either case, if no such character occurs in  {@code cs}at or after position  {@code start}, then {@code -1} is returned.\u003c/p\u003e \u003cp\u003e There is no restriction on the value of  {@code start}. If it is negative, it has the same effect as if it were zero: the entire {@link CharSequence} may be searched. If it is greater thanthe length of  {@code cs}, it has the same effect as if it were equal to the length of  {@code cs}:  {@code -1} is returned.\u003c/p\u003e \u003cp\u003eAll indices are specified in  {@code char} values(Unicode code units). \u003c/p\u003e\n * @param cs  the {@link CharSequence} to be processed, not null\n * @param searchChar  the char to be searched for\n * @param start  the start index, negative starts at the string start\n * @return the index where the search char was found, -1 if not found\n * @since 3.6 updated to behave more like {@link String}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isOsNameMatch#281",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isOsNameMatch(java.lang.String, java.lang.String)",
    "snippet": "private static boolean isOsNameMatch(final String osName, final String osNamePrefix) {\n        if (osName \u003d\u003d null) {\n            return false;\n        }\n        return osName.toUpperCase(Locale.ROOT).startsWith(osNamePrefix.toUpperCase(Locale.ROOT));\n    }",
    "begin_line": 281,
    "end_line": 286,
    "comment": "/** \n * Decides if the operating system matches. \u003cp\u003e This method is package private instead of private to support unit test invocation. \u003c/p\u003e\n * @param osName the actual OS name\n * @param osNamePrefix the prefix for the expected OS name\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.replace#296",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.replace(java.lang.String, char, char)",
    "snippet": "private static String replace(final String path, final char oldChar, final char newChar) {\n        return path \u003d\u003d null ? null : path.replace(oldChar, newChar);\n    }",
    "begin_line": 296,
    "end_line": 298,
    "comment": "/** \n * Null-safe replace.\n * @param path the path to be changed, null ignored.\n * @param oldChar the old character.\n * @param newChar the new character.\n * @return the new path.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.FileSystem#326",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.FileSystem(int, boolean, boolean, int, int, int[], java.lang.String[], boolean, boolean, char)",
    "snippet": " FileSystem(final int blockSize, final boolean caseSensitive, final boolean casePreserving,\n        final int maxFileLength, final int maxPathLength, final int[] illegalFileNameChars,\n        final String[] reservedFileNames, final boolean reservedFileNamesExtensions, final boolean supportsDriveLetter, final char nameSeparator) {\n        this.blockSize \u003d blockSize;\n        this.maxFileNameLength \u003d maxFileLength;\n        this.maxPathLength \u003d maxPathLength;\n        this.illegalFileNameChars \u003d Objects.requireNonNull(illegalFileNameChars, \"illegalFileNameChars\");\n        this.reservedFileNames \u003d Objects.requireNonNull(reservedFileNames, \"reservedFileNames\");\n        this.reservedFileNamesExtensions \u003d reservedFileNamesExtensions;\n        this.caseSensitive \u003d caseSensitive;\n        this.casePreserving \u003d casePreserving;\n        this.supportsDriveLetter \u003d supportsDriveLetter;\n        this.nameSeparator \u003d nameSeparator;\n        this.nameSeparatorOther \u003d FilenameUtils.flipSeparator(nameSeparator);\n    }",
    "begin_line": 326,
    "end_line": 340,
    "comment": "/** \n * Constructs a new instance.\n * @param blockSize file allocation block size in bytes.\n * @param caseSensitive Whether this file system is case-sensitive.\n * @param casePreserving Whether this file system is case-preserving.\n * @param maxFileLength The maximum length for file names. The file name does not include folders.\n * @param maxPathLength The maximum length of the path to a file. This can include folders.\n * @param illegalFileNameChars Illegal characters for this file system.\n * @param reservedFileNames The reserved file names.\n * @param reservedFileNamesExtensions TODO\n * @param supportsDriveLetter Whether this file system support driver letters.\n * @param nameSeparator The name separator, \u0027\\\\\u0027 on Windows, \u0027/\u0027 on Linux.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getBlockSize#348",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getBlockSize()",
    "snippet": "public int getBlockSize() {\n        return blockSize;\n    }",
    "begin_line": 348,
    "end_line": 350,
    "comment": "/** \n * Gets the file allocation block size in bytes.\n * @return the file allocation block size in bytes.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getIllegalFileNameChars#357",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getIllegalFileNameChars()",
    "snippet": "public char[] getIllegalFileNameChars() {\n        final char[] chars \u003d new char[illegalFileNameChars.length];\n        for (int i \u003d 0; i \u003c illegalFileNameChars.length; i++) {\n            chars[i] \u003d (char) illegalFileNameChars[i];\n        }\n        return chars;\n    }",
    "begin_line": 357,
    "end_line": 363,
    "comment": "/** \n * Gets a cloned copy of the illegal characters for this file system.\n * @return the illegal characters for this file system.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getIllegalFileNameCodePoints#371",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getIllegalFileNameCodePoints()",
    "snippet": "public int[] getIllegalFileNameCodePoints() {\n        return this.illegalFileNameChars.clone();\n    }",
    "begin_line": 371,
    "end_line": 373,
    "comment": "/** \n * Gets a cloned copy of the illegal code points for this file system.\n * @return the illegal code points for this file system.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getMaxFileNameLength#380",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getMaxFileNameLength()",
    "snippet": "public int getMaxFileNameLength() {\n        return maxFileNameLength;\n    }",
    "begin_line": 380,
    "end_line": 382,
    "comment": "/** \n * Gets the maximum length for file names. The file name does not include folders.\n * @return the maximum length for file names.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getMaxPathLength#389",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getMaxPathLength()",
    "snippet": "public int getMaxPathLength() {\n        return maxPathLength;\n    }",
    "begin_line": 389,
    "end_line": 391,
    "comment": "/** \n * Gets the maximum length of the path to a file. This can include folders.\n * @return the maximum length of the path to a file.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getNameSeparator#400",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getNameSeparator()",
    "snippet": "public char getNameSeparator() {\n        return nameSeparator;\n    }",
    "begin_line": 400,
    "end_line": 402,
    "comment": "/** \n * Gets the name separator, \u0027\\\\\u0027 on Windows, \u0027/\u0027 on Linux.\n * @return \u0027\\\\\u0027 on Windows, \u0027/\u0027 on Linux.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getReservedFileNames#409",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getReservedFileNames()",
    "snippet": "public String[] getReservedFileNames() {\n        return reservedFileNames.clone();\n    }",
    "begin_line": 409,
    "end_line": 411,
    "comment": "/** \n * Gets a cloned copy of the reserved file names.\n * @return the reserved file names.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isCasePreserving#418",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isCasePreserving()",
    "snippet": "public boolean isCasePreserving() {\n        return casePreserving;\n    }",
    "begin_line": 418,
    "end_line": 420,
    "comment": "/** \n * Tests whether this file system preserves case.\n * @return Whether this file system preserves case.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isCaseSensitive#427",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isCaseSensitive()",
    "snippet": "public boolean isCaseSensitive() {\n        return caseSensitive;\n    }",
    "begin_line": 427,
    "end_line": 429,
    "comment": "/** \n * Tests whether this file system is case-sensitive.\n * @return Whether this file system is case-sensitive.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isIllegalFileNameChar#438",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isIllegalFileNameChar(int)",
    "snippet": "private boolean isIllegalFileNameChar(final int c) {\n        return Arrays.binarySearch(illegalFileNameChars, c) \u003e\u003d 0;\n    }",
    "begin_line": 438,
    "end_line": 440,
    "comment": "/** \n * Tests if the given character is illegal in a file name,  {@code false} otherwise.\n * @param c the character to test\n * @return {@code true} if the given character is illegal in a file name, {@code false} otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isLegalFileName#451",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isLegalFileName(java.lang.CharSequence)",
    "snippet": "public boolean isLegalFileName(final CharSequence candidate) {\n        if (candidate \u003d\u003d null || candidate.length() \u003d\u003d 0 || candidate.length() \u003e maxFileNameLength) {\n            return false;\n        }\n        if (isReservedFileName(candidate)) {\n            return false;\n        }\n        return candidate.chars().noneMatch(this::isIllegalFileNameChar);\n    }",
    "begin_line": 451,
    "end_line": 459,
    "comment": "/** \n * Tests if a candidate file name (without a path) such as  {@code \"filename.ext\"} or {@code \"filename\"} is apotentially legal file name. If the file name length exceeds  {@link #getMaxFileNameLength()}, or if it contains an illegal character then the check fails.\n * @param candidate a candidate file name (without a path) like  {@code \"filename.ext\"} or {@code \"filename\"}\n * @return {@code true} if the candidate name is legal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isReservedFileName#468",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isReservedFileName(java.lang.CharSequence)",
    "snippet": "public boolean isReservedFileName(final CharSequence candidate) {\n        final CharSequence test \u003d reservedFileNamesExtensions ? trimExtension(candidate) : candidate;\n        return Arrays.binarySearch(reservedFileNames, test) \u003e\u003d 0;\n    }",
    "begin_line": 468,
    "end_line": 471,
    "comment": "/** \n * Tests whether the given string is a reserved file name.\n * @param candidate the string to test\n * @return {@code true} if the given string is a reserved file name.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.normalizeSeparators#480",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.normalizeSeparators(java.lang.String)",
    "snippet": "public String normalizeSeparators(final String path) {\n        return replace(path, nameSeparatorOther, nameSeparator);\n    }",
    "begin_line": 480,
    "end_line": 482,
    "comment": "/** \n * Converts all separators to the Windows separator of backslash.\n * @param path the path to be changed, null ignored\n * @return the updated path\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.supportsDriveLetter#496",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.supportsDriveLetter()",
    "snippet": "public boolean supportsDriveLetter() {\n        return supportsDriveLetter;\n    }",
    "begin_line": 496,
    "end_line": 498,
    "comment": "/** \n * Tests whether this file system support driver letters. \u003cp\u003e Windows supports driver letters as do other operating systems. Whether these other OS\u0027s still support Java like OS/2, is a different matter. \u003c/p\u003e\n * @return whether this file system support driver letters.\n * @since 2.9.0\n * @see \u003ca href\u003d\"https://en.wikipedia.org/wiki/Drive_letter_assignment\"\u003eOperating systems that use drive letter\n     *      assignment\u003c/a\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.toLegalFileName#512",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.toLegalFileName(java.lang.String, char)",
    "snippet": "public String toLegalFileName(final String candidate, final char replacement) {\n        if (isIllegalFileNameChar(replacement)) {\n            // %s does not work properly with NUL\n            throw new IllegalArgumentException(String.format(\"The replacement character \u0027%s\u0027 cannot be one of the %s illegal characters: %s\",\n                replacement \u003d\u003d \u0027\\0\u0027 ? \"\\\\0\" : replacement, name(), Arrays.toString(illegalFileNameChars)));\n        }\n        final String truncated \u003d candidate.length() \u003e maxFileNameLength ? candidate.substring(0, maxFileNameLength) : candidate;\n        final int[] array \u003d truncated.chars().map(i -\u003e isIllegalFileNameChar(i) ? replacement : i).toArray();\n        return new String(array, 0, array.length);\n    }",
    "begin_line": 512,
    "end_line": 521,
    "comment": "/** \n * Converts a candidate file name (without a path) like  {@code \"filename.ext\"} or {@code \"filename\"} to a legal filename. Illegal characters in the candidate name are replaced by the  {@code replacement} character. If the filename length exceeds  {@link #getMaxFileNameLength()}, then the name is truncated to {@link #getMaxFileNameLength()}.\n * @param candidate a candidate file name (without a path) like  {@code \"filename.ext\"} or {@code \"filename\"}\n * @param replacement Illegal characters in the candidate name are replaced by this character\n * @return a String without illegal characters\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.trimExtension#523",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.trimExtension(java.lang.CharSequence)",
    "snippet": "CharSequence trimExtension(final CharSequence cs) {\n        final int index \u003d indexOf(cs, \u0027.\u0027, 0);\n        return index \u003c 0 ? cs : cs.subSequence(0, index);\n    }",
    "begin_line": 523,
    "end_line": 526,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.concat#201",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.concat(java.lang.String, java.lang.String)",
    "snippet": "public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix \u003d getPrefixLength(fullFileNameToAdd);\n        if (prefix \u003c 0) {\n            return null;\n        }\n        if (prefix \u003e 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath \u003d\u003d null) {\n            return null;\n        }\n        final int len \u003d basePath.length();\n        if (len \u003d\u003d 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch \u003d basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + \u0027/\u0027 + fullFileNameToAdd);\n    }",
    "begin_line": 201,
    "end_line": 221,
    "comment": "/** \n * Concatenates a fileName to a base path using normal command line style rules. \u003cp\u003e The effect is equivalent to resultant directory after changing directory to the first argument, followed by changing directory to the second argument. \u003c/p\u003e \u003cp\u003e The first argument is the base path, the second is the path to concatenate. The returned path is always normalized via  {@link #normalize(String)}, thus  {@code ..} is handled.\u003c/p\u003e \u003cp\u003e If  {@code pathToAdd} is absolute (has an absolute prefix), thenit will be normalized and returned. Otherwise, the paths will be joined, normalized and returned. \u003c/p\u003e \u003cp\u003e The output will be the same on both Unix and Windows except for the separator character. \u003c/p\u003e \u003cpre\u003e /foo/      + bar        --\u0026gt;  /foo/bar /foo       + bar        --\u0026gt;  /foo/bar /foo       + /bar       --\u0026gt;  /bar /foo       + C:/bar     --\u0026gt;  C:/bar /foo       + C:bar      --\u0026gt;  C:bar [1] /foo/a/    + ../bar     --\u0026gt;  /foo/bar /foo/      + ../../bar  --\u0026gt;  null /foo/      + /bar       --\u0026gt;  /bar /foo/..    + /bar       --\u0026gt;  /bar /foo       + bar/c.txt  --\u0026gt;  /foo/bar/c.txt /foo/c.txt + bar        --\u0026gt;  /foo/c.txt/bar [2] \u003c/pre\u003e \u003cp\u003e [1] Note that the Windows relative drive prefix is unreliable when used with this method. \u003c/p\u003e \u003cp\u003e [2] Note that the first parameter must be a path. If it ends with a name, then the name will be built into the concatenated path. If this might be a problem, use  {@link #getFullPath(String)} on the base path argument.\u003c/p\u003e\n * @param basePath  the base path to attach to, always treated as a path\n * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n * @return the concatenated path, or null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.directoryContains#244",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.directoryContains(java.lang.String, java.lang.String)",
    "snippet": "public static boolean directoryContains(final String canonicalParent, final String canonicalChild) {\n        if (isEmpty(canonicalParent) || isEmpty(canonicalChild)) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        final char separator \u003d toSeparator(canonicalParent.charAt(0) \u003d\u003d UNIX_NAME_SEPARATOR);\n        final String parentWithEndSeparator \u003d canonicalParent.charAt(canonicalParent.length() - 1) \u003d\u003d separator ? canonicalParent : canonicalParent + separator;\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, parentWithEndSeparator);\n    }",
    "begin_line": 244,
    "end_line": 257,
    "comment": "/** \n * Determines whether the  {@code parent} directory contains the {@code child} element (a file or directory).\u003cp\u003e The files names are expected to be normalized. \u003c/p\u003e Edge cases: \u003cul\u003e \u003cli\u003eA  {@code directory} must not be null: if null, throw IllegalArgumentException\u003c/li\u003e\u003cli\u003eA directory does not contain itself: return false\u003c/li\u003e \u003cli\u003eA null child file is not contained in any parent: return false\u003c/li\u003e \u003c/ul\u003e\n * @param canonicalParent the file to consider as the parent.\n * @param canonicalChild the file to consider as the child.\n * @return true is the candidate leaf is under by the specified composite. False otherwise.\n * @since 2.2\n * @see FileUtils#directoryContains(File,File)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.doGetFullPath#267",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.doGetFullPath(java.lang.String, boolean)",
    "snippet": "private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        final int prefix \u003d getPrefixLength(fileName);\n        if (prefix \u003c 0) {\n            return null;\n        }\n        if (prefix \u003e\u003d fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index \u003d indexOfLastSeparator(fileName);\n        if (index \u003c 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end \u003d index + (includeSeparator ?  1 : 0);\n        if (end \u003d\u003d 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }",
    "begin_line": 267,
    "end_line": 290,
    "comment": "/** \n * Does the work of getting the path.\n * @param fileName  the fileName\n * @param includeSeparator  true to include the end separator\n * @return the path\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.doGetPath#300",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.doGetPath(java.lang.String, int)",
    "snippet": "private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        final int prefix \u003d getPrefixLength(fileName);\n        if (prefix \u003c 0) {\n            return null;\n        }\n        final int index \u003d indexOfLastSeparator(fileName);\n        final int endIndex \u003d index + separatorAdd;\n        if (prefix \u003e\u003d fileName.length() || index \u003c 0 || prefix \u003e\u003d endIndex) {\n            return EMPTY_STRING;\n        }\n        return requireNonNullChars(fileName.substring(prefix, endIndex));\n    }",
    "begin_line": 300,
    "end_line": 314,
    "comment": "/** \n * Does the work of getting the path.\n * @param fileName  the fileName\n * @param separatorAdd  0 to omit the end separator, 1 to return it\n * @return the path\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.doNormalize#325",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.doNormalize(java.lang.String, char, boolean)",
    "snippet": "private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n\n        requireNonNullChars(fileName);\n\n        int size \u003d fileName.length();\n        if (size \u003d\u003d 0) {\n            return fileName;\n        }\n        final int prefix \u003d getPrefixLength(fileName);\n        if (prefix \u003c 0) {\n            return null;\n        }\n\n        final char[] array \u003d new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator \u003d flipSeparator(separator);\n        for (int i \u003d 0; i \u003c array.length; i++) {\n            if (array[i] \u003d\u003d otherSeparator) {\n                array[i] \u003d separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory \u003d true;\n        if (array[size - 1] !\u003d separator) {\n            array[size++] \u003d separator;\n            lastIsDirectory \u003d false;\n        }\n\n        // adjoining slashes\n        // If we get here, prefix can only be 0 or greater, size 1 or greater\n        // If prefix is 0, set loop start to 1 to prevent index errors\n        for (int i \u003d prefix !\u003d 0 ? prefix : 1; i \u003c size; i++) {\n            if (array[i] \u003d\u003d separator \u0026\u0026 array[i - 1] \u003d\u003d separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i \u003d prefix + 1; i \u003c size; i++) {\n            if (array[i] \u003d\u003d separator \u0026\u0026 array[i - 1] \u003d\u003d \u0027.\u0027 \u0026\u0026\n                    (i \u003d\u003d prefix + 1 || array[i - 2] \u003d\u003d separator)) {\n                if (i \u003d\u003d size - 1) {\n                    lastIsDirectory \u003d true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -\u003d2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i \u003d prefix + 2; i \u003c size; i++) {\n            if (array[i] \u003d\u003d separator \u0026\u0026 array[i - 1] \u003d\u003d \u0027.\u0027 \u0026\u0026 array[i - 2] \u003d\u003d \u0027.\u0027 \u0026\u0026\n                    (i \u003d\u003d prefix + 2 || array[i - 3] \u003d\u003d separator)) {\n                if (i \u003d\u003d prefix + 2) {\n                    return null;\n                }\n                if (i \u003d\u003d size - 1) {\n                    lastIsDirectory \u003d true;\n                }\n                int j;\n                for (j \u003d i - 4 ; j \u003e\u003d prefix; j--) {\n                    if (array[j] \u003d\u003d separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -\u003d i - j;\n                        i \u003d j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -\u003d i + 1 - prefix;\n                i \u003d prefix + 1;\n            }\n        }\n\n        if (size \u003c\u003d 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size \u003c\u003d prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory \u0026\u0026 keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }",
    "begin_line": 325,
    "end_line": 421,
    "comment": "/** \n * Internal method to perform the normalization.\n * @param fileName  the fileName\n * @param separator The separator character to use\n * @param keepSeparator  true to keep the final separator\n * @return the normalized fileName\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equals#435",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equals(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }",
    "begin_line": 435,
    "end_line": 437,
    "comment": "/** \n * Checks whether two fileNames are equal exactly. \u003cp\u003e No processing is performed on the fileNames other than comparison, thus this is merely a null-safe case-sensitive equals. \u003c/p\u003e\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @return true if the fileNames are equal, null equals null\n * @see IOCase#SENSITIVE\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equals#450",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equals(java.lang.String, java.lang.String, boolean, org.apache.commons.io.IOCase)",
    "snippet": "public static boolean equals(String fileName1, String fileName2, final boolean normalize, final IOCase ioCase) {\n\n        if (fileName1 \u003d\u003d null || fileName2 \u003d\u003d null) {\n            return fileName1 \u003d\u003d null \u0026\u0026 fileName2 \u003d\u003d null;\n        }\n        if (normalize) {\n            fileName1 \u003d normalize(fileName1);\n            if (fileName1 \u003d\u003d null) {\n                return false;\n            }\n            fileName2 \u003d normalize(fileName2);\n            if (fileName2 \u003d\u003d null) {\n                return false;\n            }\n        }\n        return IOCase.value(ioCase, IOCase.SENSITIVE).checkEquals(fileName1, fileName2);\n    }",
    "begin_line": 450,
    "end_line": 466,
    "comment": "/** \n * Checks whether two fileNames are equal, optionally normalizing and providing control over the case-sensitivity.\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @param normalize  whether to normalize the fileNames\n * @param ioCase  what case sensitivity rule to use, null means case-sensitive\n * @return true if the fileNames are equal, null equals null\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equalsNormalized#480",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equalsNormalized(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }",
    "begin_line": 480,
    "end_line": 482,
    "comment": "/** \n * Checks whether two fileNames are equal after both have been normalized. \u003cp\u003e Both fileNames are first passed to  {@link #normalize(String)}. The check is then performed in a case-sensitive manner. \u003c/p\u003e\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @return true if the fileNames are equal, null equals null\n * @see IOCase#SENSITIVE\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equalsNormalizedOnSystem#498",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equalsNormalizedOnSystem(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }",
    "begin_line": 498,
    "end_line": 500,
    "comment": "/** \n * Checks whether two fileNames are equal after both have been normalized and using the case rules of the system. \u003cp\u003e Both fileNames are first passed to  {@link #normalize(String)}. The check is then performed case-sensitive on Unix and case-insensitive on Windows. \u003c/p\u003e\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @return true if the fileNames are equal, null equals null\n * @see IOCase#SYSTEM\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equalsOnSystem#514",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equalsOnSystem(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }",
    "begin_line": 514,
    "end_line": 516,
    "comment": "/** \n * Checks whether two fileNames are equal using the case rules of the system. \u003cp\u003e No processing is performed on the fileNames other than comparison. The check is case-sensitive on Unix and case-insensitive on Windows. \u003c/p\u003e\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @return true if the fileNames are equal, null equals null\n * @see IOCase#SYSTEM\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.flipSeparator#524",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.flipSeparator(char)",
    "snippet": "static char flipSeparator(final char ch) {\n        if (ch \u003d\u003d UNIX_NAME_SEPARATOR) {\n            return WINDOWS_NAME_SEPARATOR;\n        }\n        if (ch \u003d\u003d WINDOWS_NAME_SEPARATOR) {\n            return UNIX_NAME_SEPARATOR;\n        }\n        throw new IllegalArgumentException(String.valueOf(ch));\n    }",
    "begin_line": 524,
    "end_line": 532,
    "comment": "/** \n * Flips the Windows name separator to Linux and vice-versa.\n * @param ch The Windows or Linux name separator.\n * @return The Windows or Linux name separator.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getAdsCriticalOffset#540",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getAdsCriticalOffset(java.lang.String)",
    "snippet": "private static int getAdsCriticalOffset(final String fileName) {\n        // Step 1: Remove leading path segments.\n        final int offset1 \u003d fileName.lastIndexOf(SYSTEM_NAME_SEPARATOR);\n        final int offset2 \u003d fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 \u003d\u003d -1) {\n            if (offset2 \u003d\u003d -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 \u003d\u003d -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }",
    "begin_line": 540,
    "end_line": 554,
    "comment": "/** \n * Special handling for NTFS ADS: Don\u0027t accept colon in the fileName.\n * @param fileName a file name\n * @return ADS offsets.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getBaseName#576",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getBaseName(java.lang.String)",
    "snippet": "public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }",
    "begin_line": 576,
    "end_line": 578,
    "comment": "/** \n * Gets the base name, minus the full path and extension, from a full fileName. \u003cp\u003e This method will handle a file in either Unix or Windows format. The text after the last forward or backslash and before the last dot is returned. \u003c/p\u003e \u003cpre\u003e a/b/c.txt --\u0026gt; c a.txt     --\u0026gt; a a/b/c     --\u0026gt; c a/b/c/    --\u0026gt; \"\" \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the name of the file without the path, or an empty string if none exists\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getExtension#610",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getExtension(java.lang.String)",
    "snippet": "public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        final int index \u003d indexOfExtension(fileName);\n        if (index \u003d\u003d NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }",
    "begin_line": 610,
    "end_line": 619,
    "comment": "/** \n * Gets the extension of a fileName. \u003cp\u003e This method returns the textual part of the fileName after the last dot. There must be no directory separator after the dot. \u003c/p\u003e \u003cpre\u003e foo.txt      --\u0026gt; \"txt\" a/b/c.jpg    --\u0026gt; \"jpg\" a/b.txt/c    --\u0026gt; \"\" a/b/c        --\u0026gt; \"\" \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on, with the exception of a possible  {@link IllegalArgumentException} on Windows (see below).\u003c/p\u003e \u003cp\u003e \u003cb\u003eNote:\u003c/b\u003e This method used to have a hidden problem for names like \"foo.exe:bar.txt\". In this case, the name wouldn\u0027t be the name of a file, but the identifier of an alternate data stream (bar.txt) on the file foo.exe. The method used to return \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing an  {@link IllegalArgumentException} for names like this.\u003c/p\u003e\n * @param fileName the fileName to retrieve the extension of.\n * @return the extension of the file or an empty string if none exists or {@code null}if the fileName is  {@code null}.\n * @throws IllegalArgumentException \u003cb\u003eWindows only:\u003c/b\u003e The fileName parameter is, in fact,the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getFullPath#649",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getFullPath(java.lang.String)",
    "snippet": "public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }",
    "begin_line": 649,
    "end_line": 651,
    "comment": "/** \n * Gets the full path from a full fileName, which is the prefix + path. \u003cp\u003e This method will handle a file in either Unix or Windows format. The method is entirely text based, and returns the text before and including the last forward or backslash. \u003c/p\u003e \u003cpre\u003e C:\\a\\b\\c.txt --\u0026gt; C:\\a\\b\\ ~/a/b/c.txt  --\u0026gt; ~/a/b/ a.txt        --\u0026gt; \"\" a/b/c        --\u0026gt; a/b/ a/b/c/       --\u0026gt; a/b/c/ C:           --\u0026gt; C: C:\\          --\u0026gt; C:\\ ~            --\u0026gt; ~/ ~/           --\u0026gt; ~/ ~user        --\u0026gt; ~user/ ~user/       --\u0026gt; ~user/ \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the path of the file, an empty string if none exists, null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getFullPathNoEndSeparator#682",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getFullPathNoEndSeparator(java.lang.String)",
    "snippet": "public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }",
    "begin_line": 682,
    "end_line": 684,
    "comment": "/** \n * Gets the full path from a full fileName, which is the prefix + path, and also excluding the final directory separator. \u003cp\u003e This method will handle a file in either Unix or Windows format. The method is entirely text based, and returns the text before the last forward or backslash. \u003c/p\u003e \u003cpre\u003e C:\\a\\b\\c.txt --\u0026gt; C:\\a\\b ~/a/b/c.txt  --\u0026gt; ~/a/b a.txt        --\u0026gt; \"\" a/b/c        --\u0026gt; a/b a/b/c/       --\u0026gt; a/b/c C:           --\u0026gt; C: C:\\          --\u0026gt; C:\\ ~            --\u0026gt; ~ ~/           --\u0026gt; ~ ~user        --\u0026gt; ~user ~user/       --\u0026gt; ~user \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the path of the file, an empty string if none exists, null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getName#706",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getName(java.lang.String)",
    "snippet": "public static String getName(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        return requireNonNullChars(fileName).substring(indexOfLastSeparator(fileName) + 1);\n    }",
    "begin_line": 706,
    "end_line": 711,
    "comment": "/** \n * Gets the name minus the path from a full fileName. \u003cp\u003e This method will handle a file in either Unix or Windows format. The text after the last forward or backslash is returned. \u003c/p\u003e \u003cpre\u003e a/b/c.txt --\u0026gt; c.txt a.txt     --\u0026gt; a.txt a/b/c     --\u0026gt; c a/b/c/    --\u0026gt; \"\" \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the name of the file without the path, or an empty string if none exists\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getPath#739",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getPath(java.lang.String)",
    "snippet": "public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }",
    "begin_line": 739,
    "end_line": 741,
    "comment": "/** \n * Gets the path from a full fileName, which excludes the prefix. \u003cp\u003e This method will handle a file in either Unix or Windows format. The method is entirely text based, and returns the text before and including the last forward or backslash. \u003c/p\u003e \u003cpre\u003e C:\\a\\b\\c.txt --\u0026gt; a\\b\\ ~/a/b/c.txt  --\u0026gt; a/b/ a.txt        --\u0026gt; \"\" a/b/c        --\u0026gt; a/b/ a/b/c/       --\u0026gt; a/b/c/ \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e \u003cp\u003e This method drops the prefix from the result. See  {@link #getFullPath(String)} for the method that retains the prefix.\u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the path of the file, an empty string if none exists, null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getPathNoEndSeparator#770",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getPathNoEndSeparator(java.lang.String)",
    "snippet": "public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }",
    "begin_line": 770,
    "end_line": 772,
    "comment": "/** \n * Gets the path from a full fileName, which excludes the prefix, and also excluding the final directory separator. \u003cp\u003e This method will handle a file in either Unix or Windows format. The method is entirely text based, and returns the text before the last forward or backslash. \u003c/p\u003e \u003cpre\u003e C:\\a\\b\\c.txt --\u0026gt; a\\b ~/a/b/c.txt  --\u0026gt; a/b a.txt        --\u0026gt; \"\" a/b/c        --\u0026gt; a/b a/b/c/       --\u0026gt; a/b/c \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e \u003cp\u003e This method drops the prefix from the result. See  {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the path of the file, an empty string if none exists, null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getPrefix#806",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
    "snippet": "public static String getPrefix(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        final int len \u003d getPrefixLength(fileName);\n        if (len \u003c 0) {\n            return null;\n        }\n        if (len \u003e fileName.length()) {\n            requireNonNullChars(fileName);\n            return fileName + UNIX_NAME_SEPARATOR;\n        }\n        return requireNonNullChars(fileName.substring(0, len));\n    }",
    "begin_line": 806,
    "end_line": 819,
    "comment": "/** \n * Gets the prefix from a full fileName, such as  {@code C:/}or  {@code ~/}. \u003cp\u003e This method will handle a file in either Unix or Windows format. The prefix includes the first slash in the full fileName where applicable. \u003c/p\u003e \u003cpre\u003e Windows: a\\b\\c.txt           --\u0026gt; \"\"          --\u0026gt; relative \\a\\b\\c.txt          --\u0026gt; \"\\\"         --\u0026gt; current drive absolute C:a\\b\\c.txt         --\u0026gt; \"C:\"        --\u0026gt; drive relative C:\\a\\b\\c.txt        --\u0026gt; \"C:\\\"       --\u0026gt; absolute \\\\server\\a\\b\\c.txt  --\u0026gt; \"\\\\server\\\" --\u0026gt; UNC Unix: a/b/c.txt           --\u0026gt; \"\"          --\u0026gt; relative /a/b/c.txt          --\u0026gt; \"/\"         --\u0026gt; absolute ~/a/b/c.txt         --\u0026gt; \"~/\"        --\u0026gt; current user ~                   --\u0026gt; \"~/\"        --\u0026gt; current user (slash added) ~user/a/b/c.txt     --\u0026gt; \"~user/\"    --\u0026gt; named user ~user               --\u0026gt; \"~user/\"    --\u0026gt; named user (slash added) \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. ie. both Unix and Windows prefixes are matched regardless. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the prefix of the file, null if invalid\n * @throws IllegalArgumentException if the result contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getPrefixLength#864",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)",
    "snippet": "public static int getPrefixLength(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return NOT_FOUND;\n        }\n        final int len \u003d fileName.length();\n        if (len \u003d\u003d 0) {\n            return 0;\n        }\n        char ch0 \u003d fileName.charAt(0);\n        if (ch0 \u003d\u003d \u0027:\u0027) {\n            return NOT_FOUND;\n        }\n        if (len \u003d\u003d 1) {\n            if (ch0 \u003d\u003d \u0027~\u0027) {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 \u003d\u003d \u0027~\u0027) {\n            int posUnix \u003d fileName.indexOf(UNIX_NAME_SEPARATOR, 1);\n            int posWin \u003d fileName.indexOf(WINDOWS_NAME_SEPARATOR, 1);\n            if (posUnix \u003d\u003d NOT_FOUND \u0026\u0026 posWin \u003d\u003d NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix \u003d posUnix \u003d\u003d NOT_FOUND ? posWin : posUnix;\n            posWin \u003d posWin \u003d\u003d NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 \u003d fileName.charAt(1);\n        if (ch1 \u003d\u003d \u0027:\u0027) {\n            ch0 \u003d Character.toUpperCase(ch0);\n            if (ch0 \u003e\u003d \u0027A\u0027 \u0026\u0026 ch0 \u003c\u003d \u0027Z\u0027) {\n                if (len \u003d\u003d 2 \u0026\u0026 !FileSystem.getCurrent().supportsDriveLetter()) {\n                    return 0;\n                }\n                if (len \u003d\u003d 2 || !isSeparator(fileName.charAt(2))) {\n                    return 2;\n                }\n                return 3;\n            }\n            if (ch0 \u003d\u003d UNIX_NAME_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        }\n        if (!isSeparator(ch0) || !isSeparator(ch1)) {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        int posUnix \u003d fileName.indexOf(UNIX_NAME_SEPARATOR, 2);\n        int posWin \u003d fileName.indexOf(WINDOWS_NAME_SEPARATOR, 2);\n        if (posUnix \u003d\u003d NOT_FOUND \u0026\u0026 posWin \u003d\u003d NOT_FOUND || posUnix \u003d\u003d 2 || posWin \u003d\u003d 2) {\n            return NOT_FOUND;\n        }\n        posUnix \u003d posUnix \u003d\u003d NOT_FOUND ? posWin : posUnix;\n        posWin \u003d posWin \u003d\u003d NOT_FOUND ? posUnix : posWin;\n        final int pos \u003d Math.min(posUnix, posWin) + 1;\n        final String hostnamePart \u003d fileName.substring(2, pos - 1);\n        return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n    }",
    "begin_line": 864,
    "end_line": 923,
    "comment": "/** \n * Returns the length of the fileName prefix, such as  {@code C:/} or {@code ~/}. \u003cp\u003e This method will handle a file in either Unix or Windows format. \u003c/p\u003e \u003cp\u003e The prefix length includes the first slash in the full fileName if applicable. Thus, it is possible that the length returned is greater than the length of the input string. \u003c/p\u003e \u003cpre\u003e Windows: a\\b\\c.txt           --\u0026gt; 0           --\u0026gt; relative \\a\\b\\c.txt          --\u0026gt; 1           --\u0026gt; current drive absolute C:a\\b\\c.txt         --\u0026gt; 2           --\u0026gt; drive relative C:\\a\\b\\c.txt        --\u0026gt; 3           --\u0026gt; absolute \\\\server\\a\\b\\c.txt  --\u0026gt; 9           --\u0026gt; UNC \\\\\\a\\b\\c.txt        --\u0026gt; -1          --\u0026gt; error Unix: a/b/c.txt           --\u0026gt; 0           --\u0026gt; relative /a/b/c.txt          --\u0026gt; 1           --\u0026gt; absolute ~/a/b/c.txt         --\u0026gt; 2           --\u0026gt; current user ~                   --\u0026gt; 2           --\u0026gt; current user (slash added) ~user/a/b/c.txt     --\u0026gt; 6           --\u0026gt; named user ~user               --\u0026gt; 6           --\u0026gt; named user (slash added) //server/a/b/c.txt  --\u0026gt; 9 ///a/b/c.txt        --\u0026gt; -1          --\u0026gt; error C:                  --\u0026gt; 0           --\u0026gt; valid file name as only null character and / are reserved characters \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. ie. both Unix and Windows prefixes are matched regardless. \u003c/p\u003e \u003cp\u003e Note that a leading // (or \\\\) is used to indicate a UNC name on Windows. These must be followed by a server name, so double-slashes are not collapsed to a single slash at the start of the fileName. \u003c/p\u003e\n * @param fileName  the fileName to find the prefix in, null returns -1\n * @return the length of the prefix, -1 if invalid or null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.indexOfExtension#947",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.indexOfExtension(java.lang.String)",
    "snippet": "public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName \u003d\u003d null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don\u0027t accept colon in the fileName.\n            final int offset \u003d fileName.indexOf(\u0027:\u0027, getAdsCriticalOffset(fileName));\n            if (offset !\u003d -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (\u0027:\u0027) in file name is forbidden.\");\n            }\n        }\n        final int extensionPos \u003d fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator \u003d indexOfLastSeparator(fileName);\n        return lastSeparator \u003e extensionPos ? NOT_FOUND : extensionPos;\n    }",
    "begin_line": 947,
    "end_line": 961,
    "comment": "/** \n * Returns the index of the last extension separator character, which is a dot. \u003cp\u003e This method also checks that there is no directory separator after the last dot. To do this it uses {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\u003c/p\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on, with the exception of a possible  {@link IllegalArgumentException} on Windows (see below).\u003c/p\u003e \u003cb\u003eNote:\u003c/b\u003e This method used to have a hidden problem for names like \"foo.exe:bar.txt\". In this case, the name wouldn\u0027t be the name of a file, but the identifier of an alternate data stream (bar.txt) on the file foo.exe. The method used to return \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing an  {@link IllegalArgumentException} for names like this.\n * @param fileName the fileName to find the last extension separator in, null returns -1\n * @return the index of the last extension separator character, or -1 if there is no such character\n * @throws IllegalArgumentException \u003cb\u003eWindows only:\u003c/b\u003e The fileName parameter is, in fact,the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.indexOfLastSeparator#975",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.indexOfLastSeparator(java.lang.String)",
    "snippet": "public static int indexOfLastSeparator(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos \u003d fileName.lastIndexOf(UNIX_NAME_SEPARATOR);\n        final int lastWindowsPos \u003d fileName.lastIndexOf(WINDOWS_NAME_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }",
    "begin_line": 975,
    "end_line": 982,
    "comment": "/** \n * Returns the index of the last directory separator character. \u003cp\u003e This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. \u003cp\u003e The output will be the same irrespective of the machine that the code is running on.\n * @param fileName  the fileName to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isEmpty#984",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isEmpty(java.lang.String)",
    "snippet": "private static boolean isEmpty(final String string) {\n        return string \u003d\u003d null || string.isEmpty();\n    }",
    "begin_line": 984,
    "end_line": 986,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isExtension#1000",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isExtension(java.lang.String, java.util.Collection\u003cjava.lang.String\u003e)",
    "snippet": "public static boolean isExtension(final String fileName, final Collection\u003cString\u003e extensions) {\n        if (fileName \u003d\u003d null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions \u003d\u003d null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) \u003d\u003d NOT_FOUND;\n        }\n        return extensions.contains(getExtension(fileName));\n    }",
    "begin_line": 1000,
    "end_line": 1010,
    "comment": "/** \n * Checks whether the extension of the fileName is one of those specified. \u003cp\u003e This method obtains the extension as the textual part of the fileName after the last dot. There must be no directory separator after the dot. The extension check is case-sensitive on all platforms.\n * @param fileName  the fileName to query, null returns false\n * @param extensions  the extensions to check for, null checks for no extension\n * @return true if the fileName is one of the extensions\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isExtension#1024",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isExtension(java.lang.String, java.lang.String)",
    "snippet": "public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName \u003d\u003d null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (isEmpty(extension)) {\n            return indexOfExtension(fileName) \u003d\u003d NOT_FOUND;\n        }\n        return getExtension(fileName).equals(extension);\n    }",
    "begin_line": 1024,
    "end_line": 1034,
    "comment": "/** \n * Checks whether the extension of the fileName is that specified. \u003cp\u003e This method obtains the extension as the textual part of the fileName after the last dot. There must be no directory separator after the dot. The extension check is case-sensitive on all platforms.\n * @param fileName  the fileName to query, null returns false\n * @param extension  the extension to check for, null or empty checks for no extension\n * @return true if the fileName has the specified extension\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isExtension#1048",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isExtension(java.lang.String, java.lang.String)",
    "snippet": "public static boolean isExtension(final String fileName, final String... extensions) {\n        if (fileName \u003d\u003d null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions \u003d\u003d null || extensions.length \u003d\u003d 0) {\n            return indexOfExtension(fileName) \u003d\u003d NOT_FOUND;\n        }\n        final String fileExt \u003d getExtension(fileName);\n        return Stream.of(extensions).anyMatch(fileExt::equals);\n    }",
    "begin_line": 1048,
    "end_line": 1059,
    "comment": "/** \n * Checks whether the extension of the fileName is one of those specified. \u003cp\u003e This method obtains the extension as the textual part of the fileName after the last dot. There must be no directory separator after the dot. The extension check is case-sensitive on all platforms.\n * @param fileName  the fileName to query, null returns false\n * @param extensions  the extensions to check for, null checks for no extension\n * @return true if the fileName is one of the extensions\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isIPv4Address#1068",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isIPv4Address(java.lang.String)",
    "snippet": " isIPv4Address(final String name) {\n        final Matcher m \u003d IPV4_PATTERN.matcher(name);\n        if (!m.matches() || m.groupCount() !\u003d 4) {\n            return false;\n        }\n\n        // verify that address subgroups are legal\n        for (int i \u003d 1; i \u003c\u003d 4; i++) {\n            final String ipSegment \u003d m.group(i);\n            final int iIpSegment \u003d Integer.parseInt(ipSegment);\n            if (iIpSegment \u003e IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n\n            if (ipSegment.length() \u003e 1 \u0026\u0026 ipSegment.startsWith(\"0\")) {\n                return false;\n            }\n\n        }\n\n        return true;\n    }",
    "begin_line": 1068,
    "end_line": 1089,
    "comment": "/** \n * Checks whether a given string represents a valid IPv4 address.\n * @param name the name to validate\n * @return true if the given name is a valid IPv4 address\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isIPv6Address#1098",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isIPv6Address(java.lang.String)",
    "snippet": "private static boolean isIPv6Address(final String inet6Address) {\n        final boolean containsCompressedZeroes \u003d inet6Address.contains(\"::\");\n        if (containsCompressedZeroes \u0026\u0026 inet6Address.indexOf(\"::\") !\u003d inet6Address.lastIndexOf(\"::\")) {\n            return false;\n        }\n        if (inet6Address.startsWith(\":\") \u0026\u0026 !inet6Address.startsWith(\"::\")\n                || inet6Address.endsWith(\":\") \u0026\u0026 !inet6Address.endsWith(\"::\")) {\n            return false;\n        }\n        String[] octets \u003d inet6Address.split(\":\");\n        if (containsCompressedZeroes) {\n            final List\u003cString\u003e octetList \u003d new ArrayList\u003c\u003e(Arrays.asList(octets));\n            if (inet6Address.endsWith(\"::\")) {\n                // String.split() drops ending empty segments\n                octetList.add(\"\");\n            } else if (inet6Address.startsWith(\"::\") \u0026\u0026 !octetList.isEmpty()) {\n                octetList.remove(0);\n            }\n            octets \u003d octetList.toArray(EMPTY_STRING_ARRAY);\n        }\n        if (octets.length \u003e IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n        int validOctets \u003d 0;\n        int emptyOctets \u003d 0; // consecutive empty chunks\n        for (int index \u003d 0; index \u003c octets.length; index++) {\n            final String octet \u003d octets[index];\n            if (octet.isEmpty()) {\n                emptyOctets++;\n                if (emptyOctets \u003e 1) {\n                    return false;\n                }\n            } else {\n                emptyOctets \u003d 0;\n                // Is last chunk an IPv4 address?\n                if (index \u003d\u003d octets.length - 1 \u0026\u0026 octet.contains(\".\")) {\n                    if (!isIPv4Address(octet)) {\n                        return false;\n                    }\n                    validOctets +\u003d 2;\n                    continue;\n                }\n                if (octet.length() \u003e IPV6_MAX_HEX_DIGITS_PER_GROUP) {\n                    return false;\n                }\n                final int octetInt;\n                try {\n                    octetInt \u003d Integer.parseInt(octet, BASE_16);\n                } catch (final NumberFormatException e) {\n                    return false;\n                }\n                if (octetInt \u003c 0 || octetInt \u003e MAX_UNSIGNED_SHORT) {\n                    return false;\n                }\n            }\n            validOctets++;\n        }\n        return validOctets \u003c\u003d IPV6_MAX_HEX_GROUPS \u0026\u0026 (validOctets \u003e\u003d IPV6_MAX_HEX_GROUPS || containsCompressedZeroes);\n    }",
    "begin_line": 1098,
    "end_line": 1156,
    "comment": "/** \n * Checks whether a given string represents a valid IPv6 address.\n * @param inet6Address the name to validate\n * @return true if the given name is a valid IPv6 address\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isRFC3986HostName#1166",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isRFC3986HostName(java.lang.String)",
    "snippet": "private static boolean isRFC3986HostName(final String name) {\n        final String[] parts \u003d name.split(\"\\\\.\", -1);\n        for (int i \u003d 0; i \u003c parts.length; i++) {\n            if (parts[i].isEmpty()) {\n                // trailing dot is legal, otherwise we\u0027ve hit a .. sequence\n                return i \u003d\u003d parts.length - 1;\n            }\n            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 1166,
    "end_line": 1178,
    "comment": "/** \n * Checks whether a given string is a valid host name according to RFC 3986 - not accepting IP addresses.\n * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n * @param name the hostname to validate\n * @return true if the given name is a valid host name\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isSeparator#1186",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isSeparator(char)",
    "snippet": "private static boolean isSeparator(final char ch) {\n        return ch \u003d\u003d UNIX_NAME_SEPARATOR || ch \u003d\u003d WINDOWS_NAME_SEPARATOR;\n    }",
    "begin_line": 1186,
    "end_line": 1188,
    "comment": "/** \n * Checks if the character is a separator.\n * @param ch  the character to check\n * @return true if it is a separator character\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isSystemWindows#1195",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isSystemWindows()",
    "snippet": "static boolean isSystemWindows() {\n        return SYSTEM_NAME_SEPARATOR \u003d\u003d WINDOWS_NAME_SEPARATOR;\n    }",
    "begin_line": 1195,
    "end_line": 1197,
    "comment": "/** \n * Determines if Windows file system is in use.\n * @return true if the system is Windows\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isValidHostName#1211",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isValidHostName(java.lang.String)",
    "snippet": "private static boolean isValidHostName(final String name) {\n        return isIPv6Address(name) || isRFC3986HostName(name);\n    }",
    "begin_line": 1211,
    "end_line": 1213,
    "comment": "/** \n * Checks whether a given string is a valid host name according to RFC 3986. \u003cp\u003eAccepted are IP addresses (v4 and v6) as well as what the RFC calls a \"reg-name\". Percent encoded names don\u0027t seem to be valid names in UNC paths.\u003c/p\u003e\n * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n * @param name the hostname to validate\n * @return true if the given name is a valid host name\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.normalize#1256",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.normalize(java.lang.String)",
    "snippet": "public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, true);\n    }",
    "begin_line": 1256,
    "end_line": 1258,
    "comment": "/** \n * Normalizes a path, removing double and single dot path steps. \u003cp\u003e This method normalizes a path to a standard format. The input may contain separators in either Unix or Windows format. The output will contain separators in the format of the system. \u003cp\u003e A trailing slash will be retained. A double slash will be merged to a single slash (but UNC names are handled). A single dot path segment will be removed. A double dot will cause that path segment and the one before to be removed. If the double dot has no parent path segment to work with,  {@code null}is returned. \u003cp\u003e The output will be the same on both Unix and Windows except for the separator character. \u003cpre\u003e /foo//               --\u0026gt;   /foo/ /foo/./              --\u0026gt;   /foo/ /foo/../bar          --\u0026gt;   /bar /foo/../bar/         --\u0026gt;   /bar/ /foo/../bar/../baz   --\u0026gt;   /baz //foo//./bar         --\u0026gt;   //foo/bar /../                 --\u0026gt;   null ../foo               --\u0026gt;   null foo/bar/..           --\u0026gt;   foo/ foo/../../bar        --\u0026gt;   null foo/../bar           --\u0026gt;   bar //server/foo/../bar  --\u0026gt;   //server/bar //server/../bar      --\u0026gt;   null C:\\foo\\..\\bar        --\u0026gt;   C:\\bar C:\\..\\bar            --\u0026gt;   null ~/foo/../bar/        --\u0026gt;   ~/bar/ ~/../bar             --\u0026gt;   null \u003c/pre\u003e (Note the file separator returned will be correct for Windows/Unix)\n * @param fileName  the fileName to normalize, null returns null\n * @return the normalized fileName, or null if invalid\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.normalize#1305",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.normalize(java.lang.String, boolean)",
    "snippet": "public static String normalize(final String fileName, final boolean unixSeparator) {\n        return doNormalize(fileName, toSeparator(unixSeparator), true);\n    }",
    "begin_line": 1305,
    "end_line": 1307,
    "comment": "/** \n * Normalizes a path, removing double and single dot path steps. \u003cp\u003e This method normalizes a path to a standard format. The input may contain separators in either Unix or Windows format. The output will contain separators in the format specified. \u003cp\u003e A trailing slash will be retained. A double slash will be merged to a single slash (but UNC names are handled). A single dot path segment will be removed. A double dot will cause that path segment and the one before to be removed. If the double dot has no parent path segment to work with,  {@code null}is returned. \u003cp\u003e The output will be the same on both Unix and Windows except for the separator character. \u003cpre\u003e /foo//               --\u0026gt;   /foo/ /foo/./              --\u0026gt;   /foo/ /foo/../bar          --\u0026gt;   /bar /foo/../bar/         --\u0026gt;   /bar/ /foo/../bar/../baz   --\u0026gt;   /baz //foo//./bar         --\u0026gt;   /foo/bar /../                 --\u0026gt;   null ../foo               --\u0026gt;   null foo/bar/..           --\u0026gt;   foo/ foo/../../bar        --\u0026gt;   null foo/../bar           --\u0026gt;   bar //server/foo/../bar  --\u0026gt;   //server/bar //server/../bar      --\u0026gt;   null C:\\foo\\..\\bar        --\u0026gt;   C:\\bar C:\\..\\bar            --\u0026gt;   null ~/foo/../bar/        --\u0026gt;   ~/bar/ ~/../bar             --\u0026gt;   null \u003c/pre\u003e The output will be the same on both Unix and Windows including the separator character.\n * @param fileName  the fileName to normalize, null returns null\n * @param unixSeparator {@code true} if a Unix separator shouldbe used or  {@code false} if a Windows separator should be used.\n * @return the normalized fileName, or null if invalid\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.normalizeNoEndSeparator#1351",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.normalizeNoEndSeparator(java.lang.String)",
    "snippet": "public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, false);\n    }",
    "begin_line": 1351,
    "end_line": 1353,
    "comment": "/** \n * Normalizes a path, removing double and single dot path steps, and removing any final directory separator. \u003cp\u003e This method normalizes a path to a standard format. The input may contain separators in either Unix or Windows format. The output will contain separators in the format of the system. \u003cp\u003e A trailing slash will be removed. A double slash will be merged to a single slash (but UNC names are handled). A single dot path segment will be removed. A double dot will cause that path segment and the one before to be removed. If the double dot has no parent path segment to work with,  {@code null}is returned. \u003cp\u003e The output will be the same on both Unix and Windows except for the separator character. \u003cpre\u003e /foo//               --\u0026gt;   /foo /foo/./              --\u0026gt;   /foo /foo/../bar          --\u0026gt;   /bar /foo/../bar/         --\u0026gt;   /bar /foo/../bar/../baz   --\u0026gt;   /baz //foo//./bar         --\u0026gt;   /foo/bar /../                 --\u0026gt;   null ../foo               --\u0026gt;   null foo/bar/..           --\u0026gt;   foo foo/../../bar        --\u0026gt;   null foo/../bar           --\u0026gt;   bar //server/foo/../bar  --\u0026gt;   //server/bar //server/../bar      --\u0026gt;   null C:\\foo\\..\\bar        --\u0026gt;   C:\\bar C:\\..\\bar            --\u0026gt;   null ~/foo/../bar/        --\u0026gt;   ~/bar ~/../bar             --\u0026gt;   null \u003c/pre\u003e (Note the file separator returned will be correct for Windows/Unix)\n * @param fileName  the fileName to normalize, null returns null\n * @return the normalized fileName, or null if invalid\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.normalizeNoEndSeparator#1399",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.normalizeNoEndSeparator(java.lang.String, boolean)",
    "snippet": "public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         return doNormalize(fileName, toSeparator(unixSeparator), false);\n    }",
    "begin_line": 1399,
    "end_line": 1401,
    "comment": "/** \n * Normalizes a path, removing double and single dot path steps, and removing any final directory separator. \u003cp\u003e This method normalizes a path to a standard format. The input may contain separators in either Unix or Windows format. The output will contain separators in the format specified. \u003cp\u003e A trailing slash will be removed. A double slash will be merged to a single slash (but UNC names are handled). A single dot path segment will be removed. A double dot will cause that path segment and the one before to be removed. If the double dot has no parent path segment to work with,  {@code null}is returned. \u003cp\u003e The output will be the same on both Unix and Windows including the separator character. \u003cpre\u003e /foo//               --\u0026gt;   /foo /foo/./              --\u0026gt;   /foo /foo/../bar          --\u0026gt;   /bar /foo/../bar/         --\u0026gt;   /bar /foo/../bar/../baz   --\u0026gt;   /baz //foo//./bar         --\u0026gt;   /foo/bar /../                 --\u0026gt;   null ../foo               --\u0026gt;   null foo/bar/..           --\u0026gt;   foo foo/../../bar        --\u0026gt;   null foo/../bar           --\u0026gt;   bar //server/foo/../bar  --\u0026gt;   //server/bar //server/../bar      --\u0026gt;   null C:\\foo\\..\\bar        --\u0026gt;   C:\\bar C:\\..\\bar            --\u0026gt;   null ~/foo/../bar/        --\u0026gt;   ~/bar ~/../bar             --\u0026gt;   null \u003c/pre\u003e\n * @param fileName  the fileName to normalize, null returns null\n * @param unixSeparator {@code true} if a Unix separator shouldbe used or  {@code false} if a Windows separator should be used.\n * @return the normalized fileName, or null if invalid\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.removeExtension#1421",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.removeExtension(java.lang.String)",
    "snippet": "public static String removeExtension(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n\n        final int index \u003d indexOfExtension(fileName);\n        if (index \u003d\u003d NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }",
    "begin_line": 1421,
    "end_line": 1432,
    "comment": "/** \n * Removes the extension from a fileName. \u003cp\u003e This method returns the textual part of the fileName before the last dot. There must be no directory separator after the dot. \u003cpre\u003e foo.txt    --\u0026gt; foo a\\b\\c.jpg  --\u0026gt; a\\b\\c a\\b\\c      --\u0026gt; a\\b\\c a.b\\c      --\u0026gt; a.b\\c \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on.\n * @param fileName  the fileName to query, null returns null\n * @return the fileName minus the extension\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.requireNonNullChars#1443",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.requireNonNullChars(java.lang.String)",
    "snippet": "private static String requireNonNullChars(final String path) {\n        if (path.indexOf(0) \u003e\u003d 0) {\n            throw new IllegalArgumentException(\n                \"Null character present in file/path name. There are no known legitimate use cases for such data, but several injection attacks may use it\");\n        }\n        return path;\n    }",
    "begin_line": 1443,
    "end_line": 1449,
    "comment": "/** \n * Checks the input for null characters ( {@code U+0000}), a sign of unsanitized data being passed to file level functions. This may be used for poison byte attacks.\n * @param path the path to check\n * @return The input\n * @throws IllegalArgumentException if path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.separatorsToSystem#1457",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.separatorsToSystem(java.lang.String)",
    "snippet": "public static String separatorsToSystem(final String path) {\n        return FileSystem.getCurrent().normalizeSeparators(path);\n    }",
    "begin_line": 1457,
    "end_line": 1459,
    "comment": "/** \n * Converts all separators to the system separator.\n * @param path the path to be changed, null ignored.\n * @return the updated path.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.separatorsToUnix#1467",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.separatorsToUnix(java.lang.String)",
    "snippet": "public static String separatorsToUnix(final String path) {\n        return FileSystem.LINUX.normalizeSeparators(path);\n    }",
    "begin_line": 1467,
    "end_line": 1469,
    "comment": "/** \n * Converts all separators to the Unix separator of forward slash.\n * @param path the path to be changed, null ignored.\n * @return the new path.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.separatorsToWindows#1477",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.separatorsToWindows(java.lang.String)",
    "snippet": "public static String separatorsToWindows(final String path) {\n        return FileSystem.WINDOWS.normalizeSeparators(path);\n    }",
    "begin_line": 1477,
    "end_line": 1479,
    "comment": "/** \n * Converts all separators to the Windows separator of backslash.\n * @param path the path to be changed, null ignored.\n * @return the updated path.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.splitOnTokens#1489",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.splitOnTokens(java.lang.String)",
    "snippet": "static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf(\u0027?\u0027) \u003d\u003d NOT_FOUND \u0026\u0026 text.indexOf(\u0027*\u0027) \u003d\u003d NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array \u003d text.toCharArray();\n        final ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        final StringBuilder buffer \u003d new StringBuilder();\n        char prevChar \u003d 0;\n        for (final char ch : array) {\n            if (ch \u003d\u003d \u0027?\u0027 || ch \u003d\u003d \u0027*\u0027) {\n                if (buffer.length() !\u003d 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch \u003d\u003d \u0027?\u0027) {\n                    list.add(\"?\");\n                } else if (prevChar !\u003d \u0027*\u0027) {// ch \u003d\u003d \u0027*\u0027 here; check if previous char was \u0027*\u0027\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar \u003d ch;\n        }\n        if (buffer.length() !\u003d 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray(EMPTY_STRING_ARRAY);\n    }",
    "begin_line": 1489,
    "end_line": 1522,
    "comment": "/** \n * Splits a string into a number of tokens. The text is split by \u0027?\u0027 and \u0027*\u0027. Where multiple \u0027*\u0027 occur consecutively they are collapsed into a single \u0027*\u0027.\n * @param text  the text to split\n * @return the array of tokens, never null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.toSeparator#1530",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.toSeparator(boolean)",
    "snippet": "private static char toSeparator(final boolean unixSeparator) {\n        return unixSeparator ? UNIX_NAME_SEPARATOR : WINDOWS_NAME_SEPARATOR;\n    }",
    "begin_line": 1530,
    "end_line": 1532,
    "comment": "/** \n * Returns \u0027/\u0027 if given true, \u0027\\\\\u0027 otherwise.\n * @param unixSeparator which separator to return.\n * @return \u0027/\u0027 if given true, \u0027\\\\\u0027 otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.wildcardMatch#1556",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.wildcardMatch(java.lang.String, java.lang.String)",
    "snippet": "public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }",
    "begin_line": 1556,
    "end_line": 1558,
    "comment": "/** \n * Checks a fileName to see if it matches the specified wildcard matcher, always testing case-sensitive. \u003cp\u003e The wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a single or multiple (zero or more) wildcard characters. This is the same as often found on DOS/Unix command lines. The check is case-sensitive always. \u003cpre\u003e wildcardMatch(\"c.txt\", \"*.txt\")      --\u0026gt; true wildcardMatch(\"c.txt\", \"*.jpg\")      --\u0026gt; false wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u0026gt; true wildcardMatch(\"c.txt\", \"*.???\")      --\u0026gt; true wildcardMatch(\"c.txt\", \"*.????\")     --\u0026gt; false \u003c/pre\u003e N.B. the sequence \"*?\" does not work properly at present in match strings.\n * @param fileName  the fileName to match on\n * @param wildcardMatcher  the wildcard string to match against\n * @return true if the fileName matches the wildcard string\n * @see IOCase#SENSITIVE\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.wildcardMatch#1574",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.wildcardMatch(java.lang.String, java.lang.String, org.apache.commons.io.IOCase)",
    "snippet": "public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase ioCase) {\n        if (fileName \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n            return true;\n        }\n        if (fileName \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n            return false;\n        }\n        ioCase \u003d IOCase.value(ioCase, IOCase.SENSITIVE);\n        final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n        boolean anyChars \u003d false;\n        int textIdx \u003d 0;\n        int wcsIdx \u003d 0;\n        final Deque\u003cint[]\u003e backtrack \u003d new ArrayDeque\u003c\u003e(wcs.length);\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (!backtrack.isEmpty()) {\n                final int[] array \u003d backtrack.pop();\n                wcsIdx \u003d array[0];\n                textIdx \u003d array[1];\n                anyChars \u003d true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx \u003c wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx \u003e fileName.length()) {\n                        break;\n                    }\n                    anyChars \u003d false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars \u003d true;\n                    if (wcsIdx \u003d\u003d wcs.length - 1) {\n                        textIdx \u003d fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx \u003d ioCase.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx \u003d\u003d NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat \u003d ioCase.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat \u003e\u003d 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else if (!ioCase.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        // matching from current position\n                        // couldn\u0027t match token\n                        break;\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx +\u003d wcs[wcsIdx].length();\n                    anyChars \u003d false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d fileName.length()) {\n                return true;\n            }\n\n        } while (!backtrack.isEmpty());\n\n        return false;\n    }",
    "begin_line": 1574,
    "end_line": 1650,
    "comment": "/** \n * Checks a fileName to see if it matches the specified wildcard matcher allowing control over case-sensitivity. \u003cp\u003e The wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a single or multiple (zero or more) wildcard characters. N.B. the sequence \"*?\" does not work properly at present in match strings.\n * @param fileName  the fileName to match on\n * @param wildcardMatcher  the wildcard string to match against\n * @param ioCase  what case sensitivity rule to use, null means case-sensitive\n * @return true if the fileName matches the wildcard string\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.wildcardMatchOnSystem#1674",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.wildcardMatchOnSystem(java.lang.String, java.lang.String)",
    "snippet": "public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }",
    "begin_line": 1674,
    "end_line": 1676,
    "comment": "/** \n * Checks a fileName to see if it matches the specified wildcard matcher using the case rules of the system. \u003cp\u003e The wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a single or multiple (zero or more) wildcard characters. This is the same as often found on DOS/Unix command lines. The check is case-sensitive on Unix and case-insensitive on Windows. \u003cpre\u003e wildcardMatch(\"c.txt\", \"*.txt\")      --\u0026gt; true wildcardMatch(\"c.txt\", \"*.jpg\")      --\u0026gt; false wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u0026gt; true wildcardMatch(\"c.txt\", \"*.???\")      --\u0026gt; true wildcardMatch(\"c.txt\", \"*.????\")     --\u0026gt; false \u003c/pre\u003e N.B. the sequence \"*?\" does not work properly at present in match strings.\n * @param fileName  the fileName to match on\n * @param wildcardMatcher  the wildcard string to match against\n * @return true if the fileName matches the wildcard string\n * @see IOCase#SYSTEM\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.FilenameUtils#1681",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.FilenameUtils()",
    "snippet": "public FilenameUtils() {\n    }",
    "begin_line": 1681,
    "end_line": 1682,
    "comment": "/** \n * Instances should NOT be constructed in standard programming.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.forName#78",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.forName(java.lang.String)",
    "snippet": "public static IOCase forName(final String name) {\n        return Stream.of(IOCase.values()).filter(ioCase -\u003e ioCase.getName().equals(name)).findFirst()\n                .orElseThrow(() -\u003e new IllegalArgumentException(\"Illegal IOCase name: \" + name));\n    }",
    "begin_line": 78,
    "end_line": 81,
    "comment": "/** \n * Factory method to create an IOCase from a name.\n * @param name  the name to find\n * @return the IOCase object\n * @throws IllegalArgumentException if the name is invalid\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isCaseSensitive#90",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.isCaseSensitive(org.apache.commons.io.IOCase)",
    "snippet": "public static boolean isCaseSensitive(final IOCase ioCase) {\n        return ioCase !\u003d null \u0026\u0026 ioCase.isCaseSensitive();\n    }",
    "begin_line": 90,
    "end_line": 92,
    "comment": "/** \n * Tests for cases sensitivity in a null-safe manner.\n * @param ioCase an IOCase.\n * @return true if the input is non-null and {@link #isCaseSensitive()}.\n * @since 2.10.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.value#102",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.value(org.apache.commons.io.IOCase, org.apache.commons.io.IOCase)",
    "snippet": "public static IOCase value(final IOCase value, final IOCase defaultValue) {\n        return value !\u003d null ? value : defaultValue;\n    }",
    "begin_line": 102,
    "end_line": 104,
    "comment": "/** \n * Returns the given value if not-null, the defaultValue if null.\n * @param value the value to test.\n * @param defaultValue the default value.\n * @return the given value if not-null, the defaultValue if null.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.IOCase#118",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.IOCase(java.lang.String, boolean)",
    "snippet": " IOCase(final String name, final boolean sensitive) {\n        this.name \u003d name;\n        this.sensitive \u003d sensitive;\n    }",
    "begin_line": 118,
    "end_line": 121,
    "comment": "/** \n * Constructs a new instance.\n * @param name  the name\n * @param sensitive  the sensitivity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkCompareTo#135",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkCompareTo(java.lang.String, java.lang.String)",
    "snippet": "public int checkCompareTo(final String str1, final String str2) {\n        Objects.requireNonNull(str1, \"str1\");\n        Objects.requireNonNull(str2, \"str2\");\n        return sensitive ? str1.compareTo(str2) : str1.compareToIgnoreCase(str2);\n    }",
    "begin_line": 135,
    "end_line": 139,
    "comment": "/** \n * Compares two strings using the case-sensitivity rule. \u003cp\u003e This method mimics  {@link String#compareTo} but takes case-sensitivityinto account. \u003c/p\u003e\n * @param str1  the first string to compare, not null\n * @param str2  the second string to compare, not null\n * @return true if equal using the case rules\n * @throws NullPointerException if either string is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkEndsWith#152",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkEndsWith(java.lang.String, java.lang.String)",
    "snippet": "public boolean checkEndsWith(final String str, final String end) {\n        if (str \u003d\u003d null || end \u003d\u003d null) {\n            return false;\n        }\n        final int endLen \u003d end.length();\n        return str.regionMatches(!sensitive, str.length() - endLen, end, 0, endLen);\n    }",
    "begin_line": 152,
    "end_line": 158,
    "comment": "/** \n * Checks if one string ends with another using the case-sensitivity rule. \u003cp\u003e This method mimics  {@link String#endsWith} but takes case-sensitivityinto account. \u003c/p\u003e\n * @param str  the string to check\n * @param end  the end to compare against\n * @return true if equal using the case rules, false if either input is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkEquals#172",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkEquals(java.lang.String, java.lang.String)",
    "snippet": "public boolean checkEquals(final String str1, final String str2) {\n        Objects.requireNonNull(str1, \"str1\");\n        Objects.requireNonNull(str2, \"str2\");\n        return sensitive ? str1.equals(str2) : str1.equalsIgnoreCase(str2);\n    }",
    "begin_line": 172,
    "end_line": 176,
    "comment": "/** \n * Compares two strings using the case-sensitivity rule. \u003cp\u003e This method mimics  {@link String#equals} but takes case-sensitivityinto account. \u003c/p\u003e\n * @param str1  the first string to compare, not null\n * @param str2  the second string to compare, not null\n * @return true if equal using the case rules\n * @throws NullPointerException if either string is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkIndexOf#194",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkIndexOf(java.lang.String, int, java.lang.String)",
    "snippet": "public int checkIndexOf(final String str, final int strStartIndex, final String search) {\n        final int endIndex \u003d str.length() - search.length();\n        if (endIndex \u003e\u003d strStartIndex) {\n            for (int i \u003d strStartIndex; i \u003c\u003d endIndex; i++) {\n                if (checkRegionMatches(str, i, search)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }",
    "begin_line": 194,
    "end_line": 204,
    "comment": "/** \n * Checks if one string contains another starting at a specific index using the case-sensitivity rule. \u003cp\u003e This method mimics parts of  {@link String#indexOf(String,int)}but takes case-sensitivity into account. \u003c/p\u003e\n * @param str  the string to check, not null\n * @param strStartIndex  the index to start at in str\n * @param search  the start to search for, not null\n * @return the first index of the search String,-1 if no match or  {@code null} string input\n * @throws NullPointerException if either string is null\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkRegionMatches#219",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkRegionMatches(java.lang.String, int, java.lang.String)",
    "snippet": "public boolean checkRegionMatches(final String str, final int strStartIndex, final String search) {\n        return str.regionMatches(!sensitive, strStartIndex, search, 0, search.length());\n    }",
    "begin_line": 219,
    "end_line": 221,
    "comment": "/** \n * Checks if one string contains another at a specific index using the case-sensitivity rule. \u003cp\u003e This method mimics parts of  {@link String#regionMatches(boolean,int,String,int,int)}but takes case-sensitivity into account. \u003c/p\u003e\n * @param str  the string to check, not null\n * @param strStartIndex  the index to start at in str\n * @param search  the start to search for, not null\n * @return true if equal using the case rules\n * @throws NullPointerException if either string is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkStartsWith#234",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkStartsWith(java.lang.String, java.lang.String)",
    "snippet": "public boolean checkStartsWith(final String str, final String start) {\n        return str !\u003d null \u0026\u0026 start !\u003d null \u0026\u0026 str.regionMatches(!sensitive, 0, start, 0, start.length());\n    }",
    "begin_line": 234,
    "end_line": 236,
    "comment": "/** \n * Checks if one string starts with another using the case-sensitivity rule. \u003cp\u003e This method mimics  {@link String#startsWith(String)} but takes case-sensitivityinto account. \u003c/p\u003e\n * @param str  the string to check\n * @param start  the start to compare against\n * @return true if equal using the case rules, false if either input is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getName#243",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.getName()",
    "snippet": "public String getName() {\n        return name;\n    }",
    "begin_line": 243,
    "end_line": 245,
    "comment": "/** \n * Gets the name of the constant.\n * @return the name of the constant\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isCaseSensitive#252",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.isCaseSensitive()",
    "snippet": "public boolean isCaseSensitive() {\n        return sensitive;\n    }",
    "begin_line": 252,
    "end_line": 254,
    "comment": "/** \n * Does the object represent case-sensitive comparison.\n * @return true if case-sensitive\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.readResolve#262",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.readResolve()",
    "snippet": "private Object readResolve() {\n        return forName(name);\n    }",
    "begin_line": 262,
    "end_line": 264,
    "comment": "/** \n * Replaces the enumeration from the stream with a real one. This ensures that the correct flag is set for SYSTEM.\n * @return the resolved object\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.toString#272",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.toString()",
    "snippet": "@Override\n    public String toString() {\n        return name;\n    }",
    "begin_line": 272,
    "end_line": 274,
    "comment": "/** \n * Gets a string describing the sensitivity.\n * @return a string describing the sensitivity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#229",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.InputStream)",
    "snippet": "@SuppressWarnings(\"resource\") buffer(final InputStream inputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);\n    }",
    "begin_line": 229,
    "end_line": 235,
    "comment": "/** \n * Returns the given InputStream if it is already a  {@link BufferedInputStream}, otherwise creates a BufferedInputStream from the given InputStream.\n * @param inputStream the InputStream to wrap or return (not null)\n * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#248",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.InputStream, int)",
    "snippet": "@SuppressWarnings(\"resource\") buffer(final InputStream inputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream, size);\n    }",
    "begin_line": 248,
    "end_line": 254,
    "comment": "/** \n * Returns the given InputStream if it is already a  {@link BufferedInputStream}, otherwise creates a BufferedInputStream from the given InputStream.\n * @param inputStream the InputStream to wrap or return (not null)\n * @param size the buffer size, if a new BufferedInputStream is created.\n * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#266",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.OutputStream)",
    "snippet": "@SuppressWarnings(\"resource\") buffer(final OutputStream outputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream);\n    }",
    "begin_line": 266,
    "end_line": 272,
    "comment": "/** \n * Returns the given OutputStream if it is already a  {@link BufferedOutputStream}, otherwise creates a BufferedOutputStream from the given OutputStream.\n * @param outputStream the OutputStream to wrap or return (not null)\n * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#285",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.OutputStream, int)",
    "snippet": "@SuppressWarnings(\"resource\") buffer(final OutputStream outputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream, size);\n    }",
    "begin_line": 285,
    "end_line": 291,
    "comment": "/** \n * Returns the given OutputStream if it is already a  {@link BufferedOutputStream}, otherwise creates a BufferedOutputStream from the given OutputStream.\n * @param outputStream the OutputStream to wrap or return (not null)\n * @param size the buffer size, if a new BufferedOutputStream is created.\n * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#302",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Reader)",
    "snippet": "public static BufferedReader buffer(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }",
    "begin_line": 302,
    "end_line": 304,
    "comment": "/** \n * Returns the given reader if it is already a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#316",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Reader, int)",
    "snippet": "public static BufferedReader buffer(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }",
    "begin_line": 316,
    "end_line": 318,
    "comment": "/** \n * Returns the given reader if it is already a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @param size the buffer size, if a new BufferedReader is created.\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#329",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Writer)",
    "snippet": "public static BufferedWriter buffer(final Writer writer) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer);\n    }",
    "begin_line": 329,
    "end_line": 331,
    "comment": "/** \n * Returns the given Writer if it is already a  {@link BufferedWriter}, otherwise creates a BufferedWriter from the given Writer.\n * @param writer the Writer to wrap or return (not null)\n * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#343",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Writer, int)",
    "snippet": "public static BufferedWriter buffer(final Writer writer, final int size) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer, size);\n    }",
    "begin_line": 343,
    "end_line": 345,
    "comment": "/** \n * Returns the given Writer if it is already a  {@link BufferedWriter}, otherwise creates a BufferedWriter from the given Writer.\n * @param writer the Writer to wrap or return (not null)\n * @param size the buffer size, if a new BufferedWriter is created.\n * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.byteArray#353",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.byteArray()",
    "snippet": "public static byte[] byteArray() {\n        return byteArray(DEFAULT_BUFFER_SIZE);\n    }",
    "begin_line": 353,
    "end_line": 355,
    "comment": "/** \n * Returns a new byte array of size  {@link #DEFAULT_BUFFER_SIZE}.\n * @return a new byte array of size {@link #DEFAULT_BUFFER_SIZE}.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.byteArray#367",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.byteArray(int)",
    "snippet": "public static byte[] byteArray(final int size) {\n        return new byte[size];\n    }",
    "begin_line": 367,
    "end_line": 369,
    "comment": "/** \n * Returns a new byte array of the given size. TODO Consider guarding or warning against large allocations...\n * @param size array size.\n * @return a new byte array of the given size.\n * @throws NegativeArraySizeException if the size is negative.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.charArray#377",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.charArray()",
    "snippet": "private static char[] charArray() {\n        return charArray(DEFAULT_BUFFER_SIZE);\n    }",
    "begin_line": 377,
    "end_line": 379,
    "comment": "/** \n * Returns a new char array of size  {@link #DEFAULT_BUFFER_SIZE}.\n * @return a new char array of size {@link #DEFAULT_BUFFER_SIZE}.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.charArray#390",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.charArray(int)",
    "snippet": "private static char[] charArray(final int size) {\n        return new char[size];\n    }",
    "begin_line": 390,
    "end_line": 392,
    "comment": "/** \n * Returns a new char array of the given size. TODO Consider guarding or warning against large allocations...\n * @param size array size.\n * @return a new char array of the given size.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.clear#402",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.clear()",
    "snippet": "static void clear() {\n        SCRATCH_BYTE_BUFFER_RW.remove();\n        SCRATCH_CHAR_BUFFER_RW.remove();\n        Arrays.fill(SCRATCH_BYTE_BUFFER_WO, (byte) 0);\n        Arrays.fill(SCRATCH_CHAR_BUFFER_WO, (char) 0);\n    }",
    "begin_line": 402,
    "end_line": 407,
    "comment": "/** \n * Clears any state. \u003cul\u003e \u003cli\u003eRemoves the current thread\u0027s value for thread-local variables.\u003c/li\u003e \u003cli\u003eSets static scratch arrays to 0s.\u003c/li\u003e \u003c/ul\u003e\n * @see IO#clear()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#416",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.io.Closeable)",
    "snippet": "public static void close(final Closeable closeable) throws IOException {\n        if (closeable !\u003d null) {\n            closeable.close();\n        }\n    }",
    "begin_line": 416,
    "end_line": 420,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation.\n * @param closeable The resource to close, may be null.\n * @throws IOException if an I/O error occurs.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#429",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.io.Closeable)",
    "snippet": "public static void close(final Closeable... closeables) throws IOExceptionList {\n        IOConsumer.forAll(IOUtils::close, closeables);\n    }",
    "begin_line": 429,
    "end_line": 431,
    "comment": "/** \n * Closes the given  {@link Closeable}s as null-safe operations.\n * @param closeables The resource(s) to close, may be null.\n * @throws IOExceptionList if an I/O error occurs.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#441",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.io.Closeable, org.apache.commons.io.function.IOConsumer\u003cjava.io.IOException\u003e)",
    "snippet": "public static void close(final Closeable closeable, final IOConsumer\u003cIOException\u003e consumer) throws IOException {\n        if (closeable !\u003d null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer !\u003d null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }",
    "begin_line": 441,
    "end_line": 451,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation.\n * @param closeable The resource to close, may be null.\n * @param consumer Consume the IOException thrown by {@link Closeable#close()}.\n * @throws IOException if an I/O error occurs.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#459",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.net.URLConnection)",
    "snippet": "public static void close(final URLConnection conn) {\n        if (conn instanceof HttpURLConnection) {\n            ((HttpURLConnection) conn).disconnect();\n        }\n    }",
    "begin_line": 459,
    "end_line": 463,
    "comment": "/** \n * Closes a URLConnection.\n * @param conn the connection to close.\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQ#470",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQ(java.io.Closeable)",
    "snippet": "private static void closeQ(final Closeable closeable) {\n        closeQuietly(closeable, null);\n    }",
    "begin_line": 470,
    "end_line": 472,
    "comment": "/** \n * Avoids the need to type cast.\n * @param closeable the object to close, may be null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#515",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Closeable)",
    "snippet": "public static void closeQuietly(final Closeable closeable) {\n        closeQuietly(closeable, null);\n    }",
    "begin_line": 515,
    "end_line": 517,
    "comment": "/** \n * Closes a  {@link Closeable} unconditionally.\u003cp\u003e Equivalent to  {@link Closeable#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Closeable closeable \u003d null; try { closeable \u003d new FileReader(\u0026quot;foo.txt\u0026quot;); // process closeable closeable.close(); } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(closeable); } \u003c/pre\u003e \u003cp\u003e Closing all streams: \u003c/p\u003e \u003cpre\u003e try { return IOUtils.copy(inputStream, outputStream); } finally { IOUtils.closeQuietly(inputStream); IOUtils.closeQuietly(outputStream); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param closeable the objects to close, may be null or already closed\n * @since 2.0\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#565",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Closeable)",
    "snippet": "public static void closeQuietly(final Closeable... closeables) {\n        if (closeables !\u003d null) {\n            closeQuietly(Arrays.stream(closeables));\n        }\n    }",
    "begin_line": 565,
    "end_line": 569,
    "comment": "/** \n * Closes a  {@link Closeable} unconditionally.\u003cp\u003e Equivalent to  {@link Closeable#close()}, except any exceptions will be ignored. \u003cp\u003e This is typically used in finally blocks to ensure that the closeable is closed even if an Exception was thrown before the normal close statement was reached. \u003cbr\u003e \u003cb\u003eIt should not be used to replace the close statement(s) which should be present for the non-exceptional case.\u003c/b\u003e \u003cbr\u003e It is only intended to simplify tidying up where normal processing has already failed and reporting close failure as well is not necessary or useful. \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Closeable closeable \u003d null; try { closeable \u003d new FileReader(\u0026quot;foo.txt\u0026quot;); // processing using the closeable; may throw an Exception closeable.close(); // Normal close - exceptions not ignored } catch (Exception e) { // error handling } finally { \u003cb\u003eIOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception\u003c/b\u003e } \u003c/pre\u003e \u003cp\u003e Closing all streams: \u003cbr\u003e \u003cpre\u003e try { return IOUtils.copy(inputStream, outputStream); } finally { IOUtils.closeQuietly(inputStream, outputStream); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param closeables the objects to close, may be null or already closed\n * @see #closeQuietly(Closeable)\n * @since 2.5\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#578",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Closeable, java.util.function.Consumer\u003cjava.io.IOException\u003e)",
    "snippet": "public static void closeQuietly(final Closeable closeable, final Consumer\u003cIOException\u003e consumer) {\n        if (closeable !\u003d null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer !\u003d null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }",
    "begin_line": 578,
    "end_line": 588,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation while consuming IOException by the given {@code consumer}.\n * @param closeable The resource to close, may be null.\n * @param consumer Consumes the IOException thrown by {@link Closeable#close()}.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#619",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.InputStream)",
    "snippet": "public static void closeQuietly(final InputStream input) {\n        closeQ(input);\n    }",
    "begin_line": 619,
    "end_line": 621,
    "comment": "/** \n * Closes an  {@link InputStream} unconditionally.\u003cp\u003e Equivalent to  {@link InputStream#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e byte[] data \u003d new byte[1024]; InputStream in \u003d null; try { in \u003d new FileInputStream(\"foo.txt\"); in.read(data); in.close(); //close errors are handled } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(in); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param input the InputStream to close, may be null or already closed\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#633",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.lang.Iterable\u003cjava.io.Closeable\u003e)",
    "snippet": "public static void closeQuietly(final Iterable\u003cCloseable\u003e closeables) {\n        if (closeables !\u003d null) {\n            closeables.forEach(IOUtils::closeQuietly);\n        }\n    }",
    "begin_line": 633,
    "end_line": 637,
    "comment": "/** \n * Closes an iterable of  {@link Closeable} unconditionally.\u003cp\u003e Equivalent calling  {@link Closeable#close()} on each element, except any exceptions will be ignored.\u003c/p\u003e\n * @param closeables the objects to close, may be null or already closed\n * @see #closeQuietly(Closeable)\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#669",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)",
    "snippet": "public static void closeQuietly(final OutputStream output) {\n        closeQ(output);\n    }",
    "begin_line": 669,
    "end_line": 671,
    "comment": "/** \n * Closes an  {@link OutputStream} unconditionally.\u003cp\u003e Equivalent to  {@link OutputStream#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e byte[] data \u003d \"Hello, World\".getBytes(); OutputStream out \u003d null; try { out \u003d new FileOutputStream(\"foo.txt\"); out.write(data); out.close(); //close errors are handled } catch (IOException e) { // error handling } finally { IOUtils.closeQuietly(out); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param output the OutputStream to close, may be null or already closed\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#702",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Reader)",
    "snippet": "public static void closeQuietly(final Reader reader) {\n        closeQ(reader);\n    }",
    "begin_line": 702,
    "end_line": 704,
    "comment": "/** \n * Closes an  {@link Reader} unconditionally.\u003cp\u003e Equivalent to  {@link Reader#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e char[] data \u003d new char[1024]; Reader in \u003d null; try { in \u003d new FileReader(\"foo.txt\"); in.read(data); in.close(); //close errors are handled } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(in); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param reader the Reader to close, may be null or already closed\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#735",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.nio.channels.Selector)",
    "snippet": "public static void closeQuietly(final Selector selector) {\n        closeQ(selector);\n    }",
    "begin_line": 735,
    "end_line": 737,
    "comment": "/** \n * Closes a  {@link Selector} unconditionally.\u003cp\u003e Equivalent to  {@link Selector#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Selector selector \u003d null; try { selector \u003d Selector.open(); // process socket } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(selector); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param selector the Selector to close, may be null or already closed\n * @since 2.2\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#768",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.net.ServerSocket)",
    "snippet": "public static void closeQuietly(final ServerSocket serverSocket) {\n        closeQ(serverSocket);\n    }",
    "begin_line": 768,
    "end_line": 770,
    "comment": "/** \n * Closes a  {@link ServerSocket} unconditionally.\u003cp\u003e Equivalent to  {@link ServerSocket#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e ServerSocket socket \u003d null; try { socket \u003d new ServerSocket(); // process socket socket.close(); } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(socket); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param serverSocket the ServerSocket to close, may be null or already closed\n * @since 2.2\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#801",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.net.Socket)",
    "snippet": "public static void closeQuietly(final Socket socket) {\n        closeQ(socket);\n    }",
    "begin_line": 801,
    "end_line": 803,
    "comment": "/** \n * Closes a  {@link Socket} unconditionally.\u003cp\u003e Equivalent to  {@link Socket#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Socket socket \u003d null; try { socket \u003d new Socket(\"http://www.foo.com/\", 80); // process socket socket.close(); } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(socket); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param socket the Socket to close, may be null or already closed\n * @since 2.0\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#815",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.util.stream.Stream\u003cjava.io.Closeable\u003e)",
    "snippet": "public static void closeQuietly(final Stream\u003cCloseable\u003e closeables) {\n        if (closeables !\u003d null) {\n            closeables.forEach(IOUtils::closeQuietly);\n        }\n    }",
    "begin_line": 815,
    "end_line": 819,
    "comment": "/** \n * Closes a stream of  {@link Closeable} unconditionally.\u003cp\u003e Equivalent calling  {@link Closeable#close()} on each element, except any exceptions will be ignored.\u003c/p\u003e\n * @param closeables the objects to close, may be null or already closed\n * @see #closeQuietly(Closeable)\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#849",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Writer)",
    "snippet": "public static void closeQuietly(final Writer writer) {\n        closeQ(writer);\n    }",
    "begin_line": 849,
    "end_line": 851,
    "comment": "/** \n * Closes an  {@link Writer} unconditionally.\u003cp\u003e Equivalent to  {@link Writer#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003c/p\u003e \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Writer out \u003d null; try { out \u003d new StringWriter(); out.write(\"Hello World\"); out.close(); //close errors are handled } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(out); } \u003c/pre\u003e \u003cp\u003e Also consider using a try-with-resources statement where appropriate. \u003c/p\u003e\n * @param writer the Writer to close, may be null or already closed\n * @see Throwable#addSuppressed(Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.consume#865",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.consume(java.io.InputStream)",
    "snippet": "public static long consume(final InputStream input) throws IOException {\n        return copyLarge(input, NullOutputStream.INSTANCE);\n    }",
    "begin_line": 865,
    "end_line": 867,
    "comment": "/** \n * Consumes bytes from a  {@link InputStream} and ignores them.\u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param input the {@link InputStream} to read.\n * @return the number of bytes copied. or {@code 0} if {@code input is null}.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.consume#881",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.consume(java.io.Reader)",
    "snippet": "public static long consume(final Reader input) throws IOException {\n        return copyLarge(input, NullWriter.INSTANCE);\n    }",
    "begin_line": 881,
    "end_line": 883,
    "comment": "/** \n * Consumes characters from a  {@link Reader} and ignores them.\u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param input the {@link Reader} to read.\n * @return the number of bytes copied. or {@code 0} if {@code input is null}.\n * @throws NullPointerException if the Reader is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#899",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.io.InputStream, java.io.InputStream)",
    "snippet": "public static boolean contentEquals(final InputStream input1, final InputStream input2) throws IOException {\n        // Before making any changes, please test with\n        // org.apache.commons.io.jmh.IOUtilsContentEqualsInputStreamsBenchmark\n        if (input1 \u003d\u003d input2) {\n            return true;\n        }\n        if (input1 \u003d\u003d null || input2 \u003d\u003d null) {\n            return false;\n        }\n\n        // reuse one\n        final byte[] array1 \u003d getScratchByteArray();\n        // allocate another\n        final byte[] array2 \u003d byteArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 \u003d 0;\n            pos2 \u003d 0;\n            for (int index \u003d 0; index \u003c DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 \u003d\u003d index) {\n                    do {\n                        count1 \u003d input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 \u003d\u003d 0);\n                    if (count1 \u003d\u003d EOF) {\n                        return pos2 \u003d\u003d index \u0026\u0026 input2.read() \u003d\u003d EOF;\n                    }\n                    pos1 +\u003d count1;\n                }\n                if (pos2 \u003d\u003d index) {\n                    do {\n                        count2 \u003d input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 \u003d\u003d 0);\n                    if (count2 \u003d\u003d EOF) {\n                        return pos1 \u003d\u003d index \u0026\u0026 input1.read() \u003d\u003d EOF;\n                    }\n                    pos2 +\u003d count2;\n                }\n                if (array1[index] !\u003d array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }",
    "begin_line": 899,
    "end_line": 944,
    "comment": "/** \n * Compares the contents of two Streams to determine if they are equal or not. \u003cp\u003e This method buffers the input internally using {@link BufferedInputStream} if they are not already buffered.\u003c/p\u003e\n * @param input1 the first stream\n * @param input2 the second stream\n * @return true if the content of the streams are equal or they both don\u0027texist, false otherwise\n * @throws IOException          if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#947",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.util.Iterator\u003c?\u003e, java.util.Iterator\u003c?\u003e)",
    "snippet": "private static boolean contentEquals(final Iterator\u003c?\u003e iterator1, final Iterator\u003c?\u003e iterator2) {\n        while (iterator1.hasNext()) {\n            if (!iterator2.hasNext()) {\n                return false;\n            }\n            if (!Objects.equals(iterator1.next(), iterator2.next())) {\n                return false;\n            }\n        }\n        return !iterator2.hasNext();\n    }",
    "begin_line": 947,
    "end_line": 957,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#972",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.io.Reader, java.io.Reader)",
    "snippet": "public static boolean contentEquals(final Reader input1, final Reader input2) throws IOException {\n        if (input1 \u003d\u003d input2) {\n            return true;\n        }\n        if (input1 \u003d\u003d null || input2 \u003d\u003d null) {\n            return false;\n        }\n\n        // reuse one\n        final char[] array1 \u003d getScratchCharArray();\n        // but allocate another\n        final char[] array2 \u003d charArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 \u003d 0;\n            pos2 \u003d 0;\n            for (int index \u003d 0; index \u003c DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 \u003d\u003d index) {\n                    do {\n                        count1 \u003d input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 \u003d\u003d 0);\n                    if (count1 \u003d\u003d EOF) {\n                        return pos2 \u003d\u003d index \u0026\u0026 input2.read() \u003d\u003d EOF;\n                    }\n                    pos1 +\u003d count1;\n                }\n                if (pos2 \u003d\u003d index) {\n                    do {\n                        count2 \u003d input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 \u003d\u003d 0);\n                    if (count2 \u003d\u003d EOF) {\n                        return pos1 \u003d\u003d index \u0026\u0026 input1.read() \u003d\u003d EOF;\n                    }\n                    pos2 +\u003d count2;\n                }\n                if (array1[index] !\u003d array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }",
    "begin_line": 972,
    "end_line": 1015,
    "comment": "/** \n * Compares the contents of two Readers to determine if they are equal or not. \u003cp\u003e This method buffers the input internally using  {@link BufferedReader} if they are not already buffered.\u003c/p\u003e\n * @param input1 the first reader\n * @param input2 the second reader\n * @return true if the content of the readers are equal or they both don\u0027t exist, false otherwise\n * @throws NullPointerException if either input is null\n * @throws IOException if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#1018",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.util.stream.Stream\u003c?\u003e, java.util.stream.Stream\u003c?\u003e)",
    "snippet": "private static boolean contentEquals(final Stream\u003c?\u003e stream1, final Stream\u003c?\u003e stream2) {\n        if (stream1 \u003d\u003d stream2) {\n            return true;\n        }\n        if (stream1 \u003d\u003d null || stream2 \u003d\u003d null) {\n            return false;\n        }\n        return contentEquals(stream1.iterator(), stream2.iterator());\n    }",
    "begin_line": 1018,
    "end_line": 1026,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEqualsIgnoreEOL#1029",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEqualsIgnoreEOL(java.io.BufferedReader, java.io.BufferedReader)",
    "snippet": "private static boolean contentEqualsIgnoreEOL(final BufferedReader reader1, final BufferedReader reader2) {\n        if (reader1 \u003d\u003d reader2) {\n            return true;\n        }\n        if (reader1 \u003d\u003d null || reader2 \u003d\u003d null) {\n            return false;\n        }\n        return contentEquals(reader1.lines(), reader2.lines());\n    }",
    "begin_line": 1029,
    "end_line": 1037,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEqualsIgnoreEOL#1055",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEqualsIgnoreEOL(java.io.Reader, java.io.Reader)",
    "snippet": "@SuppressWarnings(\"resource\")\n    public static boolean contentEqualsIgnoreEOL(final Reader reader1, final Reader reader2) throws UncheckedIOException {\n        if (reader1 \u003d\u003d reader2) {\n            return true;\n        }\n        if (reader1 \u003d\u003d null || reader2 \u003d\u003d null) {\n            return false;\n        }\n        return contentEqualsIgnoreEOL(toBufferedReader(reader1), toBufferedReader(reader2));\n    }",
    "begin_line": 1055,
    "end_line": 1063,
    "comment": "/** \n * Compares the contents of two Readers to determine if they are equal or not, ignoring EOL characters. \u003cp\u003e This method buffers the input internally using {@link BufferedReader} if they are not already buffered.\u003c/p\u003e\n * @param reader1 the first reader\n * @param reader2 the second reader\n * @return true if the content of the readers are equal (ignoring EOL differences),  false otherwise\n * @throws NullPointerException if either input is null\n * @throws UncheckedIOException if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1084",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)",
    "snippet": "public static int copy(final InputStream inputStream, final OutputStream outputStream) throws IOException {\n        final long count \u003d copyLarge(inputStream, outputStream);\n        return count \u003e Integer.MAX_VALUE ? EOF : (int) count;\n    }",
    "begin_line": 1084,
    "end_line": 1087,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to an {@link OutputStream}. \u003cp\u003e This method buffers the input internally, so there is no need to use a  {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e Large streams (over 2GB) will return a bytes copied value of  {@code -1} after the copy has completed sincethe correct number of bytes cannot be returned as an int. For large streams use the {@link #copyLarge(InputStream,OutputStream)} method.\u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @param outputStream the {@link OutputStream} to write.\n * @return the number of bytes copied, or -1 if greater than {@link Integer#MAX_VALUE}.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1105",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream, int)",
    "snippet": "public static long copy(final InputStream inputStream, final OutputStream outputStream, final int bufferSize)\n            throws IOException {\n        return copyLarge(inputStream, outputStream, IOUtils.byteArray(bufferSize));\n    }",
    "begin_line": 1105,
    "end_line": 1108,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to an {@link OutputStream} using an internal buffer of thegiven size. \u003cp\u003e This method buffers the input internally, so there is no need to use a  {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @param outputStream the {@link OutputStream} to write to\n * @param bufferSize the bufferSize used to copy from the input to the output\n * @return the number of bytes copied.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1129",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.Writer)",
    "snippet": "@Deprecated\n    public static void copy(final InputStream input, final Writer writer)\n            throws IOException {\n        copy(input, writer, Charset.defaultCharset());\n    }",
    "begin_line": 1129,
    "end_line": 1132,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to chars on a{@link Writer} using the default character encoding of the platform.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e This method uses  {@link InputStreamReader}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #copy(InputStream,Writer,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1152",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.Writer, java.nio.charset.Charset)",
    "snippet": "public static void copy(final InputStream input, final Writer writer, final Charset inputCharset)\n            throws IOException {\n        final InputStreamReader reader \u003d new InputStreamReader(input, Charsets.toCharset(inputCharset));\n        copy(reader, writer);\n    }",
    "begin_line": 1152,
    "end_line": 1156,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to chars on a{@link Writer} using the specified character encoding.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e This method uses  {@link InputStreamReader}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param writer the {@link Writer} to write to\n * @param inputCharset the charset to use for the input stream, null means platform default\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1183",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.Writer, java.lang.String)",
    "snippet": "public static void copy(final InputStream input, final Writer writer, final String inputCharsetName)\n            throws IOException {\n        copy(input, writer, Charsets.toCharset(inputCharsetName));\n    }",
    "begin_line": 1183,
    "end_line": 1186,
    "comment": "/** \n * Copies bytes from an  {@link InputStream} to chars on a{@link Writer} using the specified character encoding.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link InputStreamReader}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param writer the {@link Writer} to write to\n * @param inputCharsetName the name of the requested charset for the InputStream, null means platform default\n * @throws NullPointerException                         if the input or output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1212",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.ByteArrayOutputStream)",
    "snippet": "@SuppressWarnings(\"resource\") copy(final java.io.ByteArrayOutputStream outputStream) throws IOException {\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        final QueueInputStream in \u003d new QueueInputStream();\n        outputStream.writeTo(in.newQueueOutputStream());\n        return in;\n    }",
    "begin_line": 1212,
    "end_line": 1217,
    "comment": "/** \n * Copies bytes from a  {@link java.io.ByteArrayOutputStream} to a {@link QueueInputStream}. \u003cp\u003e Unlike using JDK  {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, thissolution works safely in a single thread environment. \u003c/p\u003e \u003cp\u003e Example usage: \u003c/p\u003e \u003cpre\u003e ByteArrayOutputStream outputStream \u003d new ByteArrayOutputStream(); outputStream.writeBytes(\"hello world\".getBytes(StandardCharsets.UTF_8)); InputStream inputStream \u003d IOUtils.copy(outputStream); \u003c/pre\u003e\n * @param outputStream the {@link java.io.ByteArrayOutputStream} to read.\n * @return the {@link QueueInputStream} filled with the content of the outputStream.\n * @throws NullPointerException if the {@link java.io.ByteArrayOutputStream} is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.12\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1239",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.lang.Appendable)",
    "snippet": "public static long copy(final Reader reader, final Appendable output) throws IOException {\n        return copy(reader, output, CharBuffer.allocate(DEFAULT_BUFFER_SIZE));\n    }",
    "begin_line": 1239,
    "end_line": 1241,
    "comment": "/** \n * Copies chars from a  {@link Reader} to a {@link Appendable}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Large streams (over 2GB) will return a chars copied value of {@code -1} after the copy has completed since the correctnumber of chars cannot be returned as an int. For large streams use the  {@link #copyLarge(Reader,Writer)} method.\u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link Appendable} to write to\n * @return the number of characters copied, or -1 if \u0026gt; Integer.MAX_VALUE\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1258",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.lang.Appendable, java.nio.CharBuffer)",
    "snippet": "public static long copy(final Reader reader, final Appendable output, final CharBuffer buffer) throws IOException {\n        long count \u003d 0;\n        int n;\n        while (EOF !\u003d (n \u003d reader.read(buffer))) {\n            buffer.flip();\n            output.append(buffer, 0, n);\n            count +\u003d n;\n        }\n        return count;\n    }",
    "begin_line": 1258,
    "end_line": 1267,
    "comment": "/** \n * Copies chars from a  {@link Reader} to an {@link Appendable}. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link Appendable} to write to\n * @param buffer the buffer to be used for the copy\n * @return the number of characters copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1293",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void copy(final Reader reader, final OutputStream output)\n            throws IOException {\n        copy(reader, output, Charset.defaultCharset());\n    }",
    "begin_line": 1293,
    "end_line": 1296,
    "comment": "/** \n * Copies chars from a  {@link Reader} to bytes on an{@link OutputStream} using the default character encoding of theplatform, and calling flush. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Due to the implementation of OutputStreamWriter, this method performs a flush. \u003c/p\u003e \u003cp\u003e This method uses  {@link OutputStreamWriter}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #copy(Reader,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1321",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void copy(final Reader reader, final OutputStream output, final Charset outputCharset)\n            throws IOException {\n        final OutputStreamWriter writer \u003d new OutputStreamWriter(output, Charsets.toCharset(outputCharset));\n        copy(reader, writer);\n        // XXX Unless anyone is planning on rewriting OutputStreamWriter,\n        // we have to flush here.\n        writer.flush();\n    }",
    "begin_line": 1321,
    "end_line": 1328,
    "comment": "/** \n * Copies chars from a  {@link Reader} to bytes on an{@link OutputStream} using the specified character encoding, andcalling flush. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Due to the implementation of OutputStreamWriter, this method performs a flush. \u003c/p\u003e \u003cp\u003e This method uses  {@link OutputStreamWriter}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link OutputStream} to write to\n * @param outputCharset the charset to use for the OutputStream, null means platform default\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1360",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void copy(final Reader reader, final OutputStream output, final String outputCharsetName)\n            throws IOException {\n        copy(reader, output, Charsets.toCharset(outputCharsetName));\n    }",
    "begin_line": 1360,
    "end_line": 1363,
    "comment": "/** \n * Copies chars from a  {@link Reader} to bytes on an{@link OutputStream} using the specified character encoding, andcalling flush. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e Due to the implementation of OutputStreamWriter, this method performs a flush. \u003c/p\u003e \u003cp\u003e This method uses  {@link OutputStreamWriter}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param output the {@link OutputStream} to write to\n * @param outputCharsetName the name of the requested charset for the OutputStream, null means platform default\n * @throws NullPointerException                         if the input or output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1385",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.Writer)",
    "snippet": "public static int copy(final Reader reader, final Writer writer) throws IOException {\n        final long count \u003d copyLarge(reader, writer);\n        if (count \u003e Integer.MAX_VALUE) {\n            return EOF;\n        }\n        return (int) count;\n    }",
    "begin_line": 1385,
    "end_line": 1391,
    "comment": "/** \n * Copies chars from a  {@link Reader} to a {@link Writer}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e Large streams (over 2GB) will return a chars copied value of {@code -1} after the copy has completed since the correctnumber of chars cannot be returned as an int. For large streams use the  {@link #copyLarge(Reader,Writer)} method.\u003c/p\u003e\n * @param reader the {@link Reader} to read.\n * @param writer the {@link Writer} to write.\n * @return the number of characters copied, or -1 if \u0026gt; Integer.MAX_VALUE\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1410",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.net.URL, java.io.File)",
    "snippet": "public static long copy(final URL url, final File file) throws IOException {\n        try (OutputStream outputStream \u003d Files.newOutputStream(Objects.requireNonNull(file, \"file\").toPath())) {\n            return copy(url, outputStream);\n        }\n    }",
    "begin_line": 1410,
    "end_line": 1414,
    "comment": "/** \n * Copies bytes from a  {@link URL} to an {@link OutputStream}. \u003cp\u003e This method buffers the input internally, so there is no need to use a  {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param url the {@link URL} to read.\n * @param file the {@link OutputStream} to write.\n * @return the number of bytes copied.\n * @throws NullPointerException if the URL is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1433",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.net.URL, java.io.OutputStream)",
    "snippet": "public static long copy(final URL url, final OutputStream outputStream) throws IOException {\n        try (InputStream inputStream \u003d Objects.requireNonNull(url, \"url\").openStream()) {\n            return copyLarge(inputStream, outputStream);\n        }\n    }",
    "begin_line": 1433,
    "end_line": 1437,
    "comment": "/** \n * Copies bytes from a  {@link URL} to an {@link OutputStream}. \u003cp\u003e This method buffers the input internally, so there is no need to use a  {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param url the {@link URL} to read.\n * @param outputStream the {@link OutputStream} to write.\n * @return the number of bytes copied.\n * @throws NullPointerException if the URL is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1458",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream)",
    "snippet": "public static long copyLarge(final InputStream inputStream, final OutputStream outputStream)\n            throws IOException {\n        return copy(inputStream, outputStream, DEFAULT_BUFFER_SIZE);\n    }",
    "begin_line": 1458,
    "end_line": 1461,
    "comment": "/** \n * Copies bytes from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @param outputStream the {@link OutputStream} to write.\n * @return the number of bytes copied.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1481",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, byte[])",
    "snippet": "@SuppressWarnings(\"resource\") copyLarge(final InputStream inputStream, final OutputStream outputStream, final byte[] buffer)\n        throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        long count \u003d 0;\n        int n;\n        while (EOF !\u003d (n \u003d inputStream.read(buffer))) {\n            outputStream.write(buffer, 0, n);\n            count +\u003d n;\n        }\n        return count;\n    }",
    "begin_line": 1481,
    "end_line": 1492,
    "comment": "/** \n * Copies bytes from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @param outputStream the {@link OutputStream} to write.\n * @param buffer the buffer to use for the copy\n * @return the number of bytes copied.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws NullPointerException if the OutputStream is {@code null}.\n * @throws IOException if an I/O error occurs.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1518",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long)",
    "snippet": "public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset,\n                                 final long length) throws IOException {\n        return copyLarge(input, output, inputOffset, length, getScratchByteArray());\n    }",
    "begin_line": 1518,
    "end_line": 1521,
    "comment": "/** \n * Copies some or all bytes from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}, optionally skipping input bytes. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}.\n * @param input the {@link InputStream} to read\n * @param output the {@link OutputStream} to write to\n * @param inputOffset : number of bytes to skip from input before copying-ve values are ignored\n * @param length : number of bytes to copy. -ve means all\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1547",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long, byte[])",
    "snippet": "public static long copyLarge(final InputStream input, final OutputStream output,\n                                 final long inputOffset, final long length, final byte[] buffer) throws IOException {\n        if (inputOffset \u003e 0) {\n            skipFully(input, inputOffset);\n        }\n        if (length \u003d\u003d 0) {\n            return 0;\n        }\n        final int bufferLength \u003d buffer.length;\n        int bytesToRead \u003d bufferLength;\n        if (length \u003e 0 \u0026\u0026 length \u003c bufferLength) {\n            bytesToRead \u003d (int) length;\n        }\n        int read;\n        long totalRead \u003d 0;\n        while (bytesToRead \u003e 0 \u0026\u0026 EOF !\u003d (read \u003d input.read(buffer, 0, bytesToRead))) {\n            output.write(buffer, 0, read);\n            totalRead +\u003d read;\n            if (length \u003e 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead \u003d (int) Math.min(length - totalRead, bufferLength);\n            }\n        }\n        return totalRead;\n    }",
    "begin_line": 1547,
    "end_line": 1571,
    "comment": "/** \n * Copies some or all bytes from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}, optionally skipping input bytes. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param output the {@link OutputStream} to write to\n * @param inputOffset : number of bytes to skip from input before copying-ve values are ignored\n * @param length : number of bytes to copy. -ve means all\n * @param buffer the buffer to use for the copy\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1590",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer)",
    "snippet": "public static long copyLarge(final Reader reader, final Writer writer) throws IOException {\n        return copyLarge(reader, writer, getScratchCharArray());\n    }",
    "begin_line": 1590,
    "end_line": 1592,
    "comment": "/** \n * Copies chars from a large (over 2GB)  {@link Reader} to a {@link Writer}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param reader the {@link Reader} to source.\n * @param writer the {@link Writer} to target.\n * @return the number of characters copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1609",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, char[])",
    "snippet": "public static long copyLarge(final Reader reader, final Writer writer, final char[] buffer) throws IOException {\n        long count \u003d 0;\n        int n;\n        while (EOF !\u003d (n \u003d reader.read(buffer))) {\n            writer.write(buffer, 0, n);\n            count +\u003d n;\n        }\n        return count;\n    }",
    "begin_line": 1609,
    "end_line": 1617,
    "comment": "/** \n * Copies chars from a large (over 2GB)  {@link Reader} to a {@link Writer}. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to source.\n * @param writer the {@link Writer} to target.\n * @param buffer the buffer to be used for the copy\n * @return the number of characters copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1640",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long)",
    "snippet": "public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length)\n            throws IOException {\n        return copyLarge(reader, writer, inputOffset, length, getScratchCharArray());\n    }",
    "begin_line": 1640,
    "end_line": 1643,
    "comment": "/** \n * Copies some or all chars from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}, optionally skipping input chars. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param writer the {@link Writer} to write to\n * @param inputOffset : number of chars to skip from input before copying-ve values are ignored\n * @param length : number of chars to copy. -ve means all\n * @return the number of chars copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1664",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long, char[])",
    "snippet": "public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length,\n                                 final char[] buffer)\n            throws IOException {\n        if (inputOffset \u003e 0) {\n            skipFully(reader, inputOffset);\n        }\n        if (length \u003d\u003d 0) {\n            return 0;\n        }\n        int bytesToRead \u003d buffer.length;\n        if (length \u003e 0 \u0026\u0026 length \u003c buffer.length) {\n            bytesToRead \u003d (int) length;\n        }\n        int read;\n        long totalRead \u003d 0;\n        while (bytesToRead \u003e 0 \u0026\u0026 EOF !\u003d (read \u003d reader.read(buffer, 0, bytesToRead))) {\n            writer.write(buffer, 0, read);\n            totalRead +\u003d read;\n            if (length \u003e 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead \u003d (int) Math.min(length - totalRead, buffer.length);\n            }\n        }\n        return totalRead;\n    }",
    "begin_line": 1664,
    "end_line": 1688,
    "comment": "/** \n * Copies some or all chars from a large (over 2GB)  {@link InputStream} to an{@link OutputStream}, optionally skipping input chars. \u003cp\u003e This method uses the provided buffer, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param writer the {@link Writer} to write to\n * @param inputOffset : number of chars to skip from input before copying-ve values are ignored\n * @param length : number of chars to copy. -ve means all\n * @param buffer the buffer to be used for the copy\n * @return the number of chars copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.fill0#1696",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.fill0(byte[])",
    "snippet": "private static byte[] fill0(final byte[] arr) {\n        Arrays.fill(arr, (byte) 0);\n        return arr;\n    }",
    "begin_line": 1696,
    "end_line": 1699,
    "comment": "/** \n * Fills the given array with 0s.\n * @param arr The array to fill.\n * @return The given array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.fill0#1707",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.fill0(char[])",
    "snippet": "private static char[] fill0(final char[] arr) {\n        Arrays.fill(arr, (char) 0);\n        return arr;\n    }",
    "begin_line": 1707,
    "end_line": 1710,
    "comment": "/** \n * Fills the given array with 0s.\n * @param arr The array to fill.\n * @return The given array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.getScratchByteArray#1717",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.getScratchByteArray()",
    "snippet": "static byte[] getScratchByteArray() {\n        return fill0(SCRATCH_BYTE_BUFFER_RW.get());\n    }",
    "begin_line": 1717,
    "end_line": 1719,
    "comment": "/** \n * Gets the internal byte array buffer, intended for both reading and writing.\n * @return the internal byte array buffer, intended for both reading and writing.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.getScratchByteArrayWriteOnly#1726",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.getScratchByteArrayWriteOnly()",
    "snippet": "static byte[] getScratchByteArrayWriteOnly() {\n        return fill0(SCRATCH_BYTE_BUFFER_WO);\n    }",
    "begin_line": 1726,
    "end_line": 1728,
    "comment": "/** \n * Gets the internal byte array intended for write only operations.\n * @return the internal byte array intended for write only operations.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.getScratchCharArray#1735",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.getScratchCharArray()",
    "snippet": "static char[] getScratchCharArray() {\n        return fill0(SCRATCH_CHAR_BUFFER_RW.get());\n    }",
    "begin_line": 1735,
    "end_line": 1737,
    "comment": "/** \n * Gets the char byte array buffer, intended for both reading and writing.\n * @return the char byte array buffer, intended for both reading and writing.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.getScratchCharArrayWriteOnly#1744",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.getScratchCharArrayWriteOnly()",
    "snippet": "static char[] getScratchCharArrayWriteOnly() {\n        return fill0(SCRATCH_CHAR_BUFFER_WO);\n    }",
    "begin_line": 1744,
    "end_line": 1746,
    "comment": "/** \n * Gets the internal char array intended for write only operations.\n * @return the internal char array intended for write only operations.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1755",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(byte[])",
    "snippet": "public static int length(final byte[] array) {\n        return array \u003d\u003d null ? 0 : array.length;\n    }",
    "begin_line": 1755,
    "end_line": 1757,
    "comment": "/** \n * Returns the length of the given array in a null-safe manner.\n * @param array an array or null\n * @return the array length -- or 0 if the given array is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1766",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(char[])",
    "snippet": "public static int length(final char[] array) {\n        return array \u003d\u003d null ? 0 : array.length;\n    }",
    "begin_line": 1766,
    "end_line": 1768,
    "comment": "/** \n * Returns the length of the given array in a null-safe manner.\n * @param array an array or null\n * @return the array length -- or 0 if the given array is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1777",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(java.lang.CharSequence)",
    "snippet": "public static int length(final CharSequence csq) {\n        return csq \u003d\u003d null ? 0 : csq.length();\n    }",
    "begin_line": 1777,
    "end_line": 1779,
    "comment": "/** \n * Returns the length of the given CharSequence in a null-safe manner.\n * @param csq a CharSequence or null\n * @return the CharSequence length -- or 0 if the given CharSequence is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1788",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(java.lang.Object[])",
    "snippet": "public static int length(final Object[] array) {\n        return array \u003d\u003d null ? 0 : array.length;\n    }",
    "begin_line": 1788,
    "end_line": 1790,
    "comment": "/** \n * Returns the length of the given array in a null-safe manner.\n * @param array an array or null\n * @return the array length -- or 0 if the given array is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.lineIterator#1823",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.lineIterator(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static LineIterator lineIterator(final InputStream input, final Charset charset) {\n        return new LineIterator(new InputStreamReader(input, Charsets.toCharset(charset)));\n    }",
    "begin_line": 1823,
    "end_line": 1825,
    "comment": "/** \n * Returns an Iterator for the lines in an  {@link InputStream}, using the character encoding specified (or default encoding if null). \u003cp\u003e {@link LineIterator} holds a reference to the open{@link InputStream} specified here. When you have finished withthe iterator you should close the stream to free internal resources. This can be done by using a try-with-resources block, closing the stream directly, or by calling {@link LineIterator#close()}. \u003c/p\u003e \u003cp\u003e The recommended usage pattern is: \u003c/p\u003e \u003cpre\u003e try { LineIterator it \u003d IOUtils.lineIterator(stream, charset); while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { IOUtils.closeQuietly(stream); } \u003c/pre\u003e\n * @param input the {@link InputStream} to read, not null\n * @param charset the charset to use, null means platform default\n * @return an Iterator of the lines in the reader, never null\n * @throws IllegalArgumentException if the input is null\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.lineIterator#1861",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.lineIterator(java.io.InputStream, java.lang.String)",
    "snippet": "public static LineIterator lineIterator(final InputStream input, final String charsetName) {\n        return lineIterator(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 1861,
    "end_line": 1863,
    "comment": "/** \n * Returns an Iterator for the lines in an  {@link InputStream}, using the character encoding specified (or default encoding if null). \u003cp\u003e {@link LineIterator} holds a reference to the open{@link InputStream} specified here. When you have finished withthe iterator you should close the stream to free internal resources. This can be done by using a try-with-resources block, closing the stream directly, or by calling {@link LineIterator#close()}. \u003c/p\u003e \u003cp\u003e The recommended usage pattern is: \u003c/p\u003e \u003cpre\u003e try { LineIterator it \u003d IOUtils.lineIterator(stream, StandardCharsets.UTF_8.name()); while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { IOUtils.closeQuietly(stream); } \u003c/pre\u003e\n * @param input the {@link InputStream} to read, not null\n * @param charsetName the encoding to use, null means platform default\n * @return an Iterator of the lines in the reader, never null\n * @throws IllegalArgumentException                     if the input is null\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.lineIterator#1894",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.lineIterator(java.io.Reader)",
    "snippet": "public static LineIterator lineIterator(final Reader reader) {\n        return new LineIterator(reader);\n    }",
    "begin_line": 1894,
    "end_line": 1896,
    "comment": "/** \n * Returns an Iterator for the lines in a  {@link Reader}. \u003cp\u003e {@link LineIterator} holds a reference to the open{@link Reader} specified here. When you have finished with theiterator you should close the reader to free internal resources. This can be done by using a try-with-resources block, closing the reader directly, or by calling {@link LineIterator#close()}. \u003c/p\u003e \u003cp\u003e The recommended usage pattern is: \u003c/p\u003e \u003cpre\u003e try { LineIterator it \u003d IOUtils.lineIterator(reader); while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { IOUtils.closeQuietly(reader); } \u003c/pre\u003e\n * @param reader the {@link Reader} to read, not null\n * @return an Iterator of the lines in the reader, never null\n * @throws NullPointerException if the reader is null\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1910",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.InputStream, byte[])",
    "snippet": "public static int read(final InputStream input, final byte[] buffer) throws IOException {\n        return read(input, buffer, 0, buffer.length);\n    }",
    "begin_line": 1910,
    "end_line": 1912,
    "comment": "/** \n * Reads bytes from an input stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link InputStream}.\n * @param input where to read input from\n * @param buffer destination\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1929",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.InputStream, byte[], int, int)",
    "snippet": "public static int read(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length \u003d\u003d 0) {\n            return 0;\n        }\n        return read(input::read, buffer, offset, length);\n    }",
    "begin_line": 1929,
    "end_line": 1935,
    "comment": "/** \n * Reads bytes from an input stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link InputStream}.\n * @param input where to read input\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IllegalArgumentException if length is negative\n * @throws IOException              if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1950",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(org.apache.commons.io.function.IOTriFunction\u003cbyte[],java.lang.Integer,java.lang.Integer,java.lang.Integer\u003e, byte[], int, int)",
    "snippet": "static int read(final IOTriFunction\u003cbyte[], Integer, Integer, Integer\u003e input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length \u003c 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining \u003d length;\n        while (remaining \u003e 0) {\n            final int location \u003d length - remaining;\n            final int count \u003d input.apply(buffer, offset + location, remaining);\n            if (EOF \u003d\u003d count) {\n                break;\n            }\n            remaining -\u003d count;\n        }\n        return length - remaining;\n    }",
    "begin_line": 1950,
    "end_line": 1965,
    "comment": "/** \n * Reads bytes from an input. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link InputStream}.\n * @param input  How to read input\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IllegalArgumentException if length is negative\n * @throws IOException              if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1981",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)",
    "snippet": "public static int read(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int length \u003d buffer.remaining();\n        while (buffer.remaining() \u003e 0) {\n            final int count \u003d input.read(buffer);\n            if (EOF \u003d\u003d count) { // EOF\n                break;\n            }\n        }\n        return length - buffer.remaining();\n    }",
    "begin_line": 1981,
    "end_line": 1990,
    "comment": "/** \n * Reads bytes from a ReadableByteChannel. \u003cp\u003e This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link ReadableByteChannel}. \u003c/p\u003e\n * @param input the byte channel to read\n * @param buffer byte buffer destination\n * @return the actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#2004",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.Reader, char[])",
    "snippet": "public static int read(final Reader reader, final char[] buffer) throws IOException {\n        return read(reader, buffer, 0, buffer.length);\n    }",
    "begin_line": 2004,
    "end_line": 2006,
    "comment": "/** \n * Reads characters from an input character stream. This implementation guarantees that it will read as many characters as possible before giving up; this may not always be the case for subclasses of  {@link Reader}.\n * @param reader where to read input from\n * @param buffer destination\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#2023",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.Reader, char[], int, int)",
    "snippet": "public static int read(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length \u003c 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining \u003d length;\n        while (remaining \u003e 0) {\n            final int location \u003d length - remaining;\n            final int count \u003d reader.read(buffer, offset + location, remaining);\n            if (EOF \u003d\u003d count) { // EOF\n                break;\n            }\n            remaining -\u003d count;\n        }\n        return length - remaining;\n    }",
    "begin_line": 2023,
    "end_line": 2038,
    "comment": "/** \n * Reads characters from an input character stream. This implementation guarantees that it will read as many characters as possible before giving up; this may not always be the case for subclasses of  {@link Reader}.\n * @param reader where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IllegalArgumentException if length is negative\n * @throws IOException              if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2055",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[])",
    "snippet": "public static void readFully(final InputStream input, final byte[] buffer) throws IOException {\n        readFully(input, buffer, 0, buffer.length);\n    }",
    "begin_line": 2055,
    "end_line": 2057,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#read(byte[],int,int)} maynot read as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param input where to read input from\n * @param buffer destination\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of bytes read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2076",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[], int, int)",
    "snippet": "public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual \u003d read(input, buffer, offset, length);\n        if (actual !\u003d length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }",
    "begin_line": 2076,
    "end_line": 2082,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#read(byte[],int,int)} maynot read as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param input where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of bytes read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2099",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, int)",
    "snippet": "public static byte[] readFully(final InputStream input, final int length) throws IOException {\n        final byte[] buffer \u003d byteArray(length);\n        readFully(input, buffer, 0, buffer.length);\n        return buffer;\n    }",
    "begin_line": 2099,
    "end_line": 2103,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#read(byte[],int,int)} maynot read as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param input where to read input from\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return the bytes read from input\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of bytes read was incorrect\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2118",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)",
    "snippet": "public static void readFully(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int expected \u003d buffer.remaining();\n        final int actual \u003d read(input, buffer);\n        if (actual !\u003d expected) {\n            throw new EOFException(\"Length to read: \" + expected + \" actual: \" + actual);\n        }\n    }",
    "begin_line": 2118,
    "end_line": 2124,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link ReadableByteChannel#read(ByteBuffer)} maynot read as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param input the byte channel to read\n * @param buffer byte buffer destination\n * @throws IOException  if there is a problem reading the file\n * @throws EOFException if the number of bytes read was incorrect\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2140",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[])",
    "snippet": "public static void readFully(final Reader reader, final char[] buffer) throws IOException {\n        readFully(reader, buffer, 0, buffer.length);\n    }",
    "begin_line": 2140,
    "end_line": 2142,
    "comment": "/** \n * Reads the requested number of characters or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link Reader#read(char[],int,int)} maynot read as many characters as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param reader where to read input from\n * @param buffer destination\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of characters read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#2160",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[], int, int)",
    "snippet": "public static void readFully(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual \u003d read(reader, buffer, offset, length);\n        if (actual !\u003d length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }",
    "begin_line": 2160,
    "end_line": 2166,
    "comment": "/** \n * Reads the requested number of characters or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link Reader#read(char[],int,int)} maynot read as many characters as requested (most likely because of reaching EOF). \u003c/p\u003e\n * @param reader where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of characters read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#2184",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static List\u003cString\u003e readLines(final InputStream input) throws UncheckedIOException {\n        return readLines(input, Charset.defaultCharset());\n    }",
    "begin_line": 2184,
    "end_line": 2186,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a list of Strings,one entry per line, using the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read, not null\n * @return the list of Strings, never null\n * @throws NullPointerException if the input is null\n * @throws UncheckedIOException if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #readLines(InputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#2203",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static List\u003cString\u003e readLines(final InputStream input, final Charset charset) throws UncheckedIOException {\n        return readLines(new InputStreamReader(input, Charsets.toCharset(charset)));\n    }",
    "begin_line": 2203,
    "end_line": 2205,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a list of Strings,one entry per line, using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read, not null\n * @param charset the charset to use, null means platform default\n * @return the list of Strings, never null\n * @throws NullPointerException if the input is null\n * @throws UncheckedIOException if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#2229",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.InputStream, java.lang.String)",
    "snippet": "public static List\u003cString\u003e readLines(final InputStream input, final String charsetName) throws UncheckedIOException {\n        return readLines(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2229,
    "end_line": 2231,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a list of Strings,one entry per line, using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read, not null\n * @param charsetName the name of the requested charset, null means platform default\n * @return the list of Strings, never null\n * @throws NullPointerException                         if the input is null\n * @throws UncheckedIOException                         if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#2248",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.Reader)",
    "snippet": "@SuppressWarnings(\"resource\") readLines(final Reader reader) throws UncheckedIOException {\n        return toBufferedReader(reader).lines().collect(Collectors.toList());\n    }",
    "begin_line": 2248,
    "end_line": 2250,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a list of Strings,one entry per line. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read, not null\n * @return the list of Strings, never null\n * @throws NullPointerException if the input is null\n * @throws UncheckedIOException if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToByteArray#2264",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToByteArray(java.lang.String)",
    "snippet": "public static byte[] resourceToByteArray(final String name) throws IOException {\n        return resourceToByteArray(name, null);\n    }",
    "begin_line": 2264,
    "end_line": 2266,
    "comment": "/** \n * Gets the contents of a resource as a byte array. \u003cp\u003e Delegates to  {@link #resourceToByteArray(String,ClassLoader) resourceToByteArray(String, null)}. \u003c/p\u003e\n * @param name The resource name.\n * @return the requested byte array\n * @throws IOException if an I/O error occurs or the resource is not found.\n * @see #resourceToByteArray(String,ClassLoader)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToByteArray#2281",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToByteArray(java.lang.String, java.lang.ClassLoader)",
    "snippet": "public static byte[] resourceToByteArray(final String name, final ClassLoader classLoader) throws IOException {\n        return toByteArray(resourceToURL(name, classLoader));\n    }",
    "begin_line": 2281,
    "end_line": 2283,
    "comment": "/** \n * Gets the contents of a resource as a byte array. \u003cp\u003e Delegates to  {@link #resourceToURL(String,ClassLoader)}. \u003c/p\u003e\n * @param name The resource name.\n * @param classLoader the class loader that the resolution of the resource is delegated to\n * @return the requested byte array\n * @throws IOException if an I/O error occurs or the resource is not found.\n * @see #resourceToURL(String,ClassLoader)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToString#2298",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToString(java.lang.String, java.nio.charset.Charset)",
    "snippet": "public static String resourceToString(final String name, final Charset charset) throws IOException {\n        return resourceToString(name, charset, null);\n    }",
    "begin_line": 2298,
    "end_line": 2300,
    "comment": "/** \n * Gets the contents of a resource as a String using the specified character encoding. \u003cp\u003e Delegates to  {@link #resourceToString(String,Charset,ClassLoader) resourceToString(String, Charset, null)}. \u003c/p\u003e\n * @param name The resource name.\n * @param charset the charset to use, null means platform default\n * @return the requested String\n * @throws IOException if an I/O error occurs or the resource is not found.\n * @see #resourceToString(String,Charset,ClassLoader)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToString#2316",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToString(java.lang.String, java.nio.charset.Charset, java.lang.ClassLoader)",
    "snippet": "public static String resourceToString(final String name, final Charset charset, final ClassLoader classLoader) throws IOException {\n        return toString(resourceToURL(name, classLoader), charset);\n    }",
    "begin_line": 2316,
    "end_line": 2318,
    "comment": "/** \n * Gets the contents of a resource as a String using the specified character encoding. \u003cp\u003e Delegates to  {@link #resourceToURL(String,ClassLoader)}. \u003c/p\u003e\n * @param name The resource name.\n * @param charset the Charset to use, null means platform default\n * @param classLoader the class loader that the resolution of the resource is delegated to\n * @return the requested String\n * @throws IOException if an I/O error occurs.\n * @see #resourceToURL(String,ClassLoader)\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToURL#2331",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToURL(java.lang.String)",
    "snippet": "public static URL resourceToURL(final String name) throws IOException {\n        return resourceToURL(name, null);\n    }",
    "begin_line": 2331,
    "end_line": 2333,
    "comment": "/** \n * Gets a URL pointing to the given resource. \u003cp\u003e Delegates to  {@link #resourceToURL(String,ClassLoader) resourceToURL(String, null)}. \u003c/p\u003e\n * @param name The resource name.\n * @return A URL object for reading the resource.\n * @throws IOException if the resource is not found.\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToURL#2348",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToURL(java.lang.String, java.lang.ClassLoader)",
    "snippet": "public static URL resourceToURL(final String name, final ClassLoader classLoader) throws IOException {\n        // What about the thread context class loader?\n        // What about the system class loader?\n        final URL resource \u003d classLoader \u003d\u003d null ? IOUtils.class.getResource(name) : classLoader.getResource(name);\n        if (resource \u003d\u003d null) {\n            throw new IOException(\"Resource not found: \" + name);\n        }\n        return resource;\n    }",
    "begin_line": 2348,
    "end_line": 2356,
    "comment": "/** \n * Gets a URL pointing to the given resource. \u003cp\u003e If the  {@code classLoader} is not null, call {@link ClassLoader#getResource(String)}, otherwise call {@link Class#getResource(String) IOUtils.class.getResource(name)}. \u003c/p\u003e\n * @param name The resource name.\n * @param classLoader Delegate to this class loader if not null\n * @return A URL object for reading the resource.\n * @throws IOException if the resource is not found.\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2379",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)",
    "snippet": "public static long skip(final InputStream input, final long toSkip) throws IOException {\n        return skip(input, toSkip, IOUtils::getScratchByteArrayWriteOnly);\n    }",
    "begin_line": 2379,
    "end_line": 2381,
    "comment": "/** \n * Skips bytes from an input byte stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for skip() implementations in subclasses of  {@link InputStream}. \u003cp\u003e Note that the implementation uses  {@link InputStream#read(byte[],int,int)} ratherthan delegating to  {@link InputStream#skip(long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of bytes are skipped. \u003c/p\u003e\n * @param input byte stream to skip\n * @param toSkip number of bytes to skip.\n * @return number of bytes actually skipped.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @see InputStream#skip(long)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-203\"\u003eIO-203 - Add skipFully() method for InputStreams\u003c/a\u003e\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2409",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.io.InputStream, long, java.util.function.Supplier\u003cbyte[]\u003e)",
    "snippet": "public static long skip(final InputStream input, final long toSkip, final Supplier\u003cbyte[]\u003e skipBufferSupplier) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        //\n        // No need to synchronize access to SCRATCH_BYTE_BUFFER_WO: We don\u0027t care if the buffer is written multiple\n        // times or in parallel since the data is ignored. We reuse the same buffer, if the buffer size were variable or read-write,\n        // we would need to synch or use a thread local to ensure some other thread safety.\n        //\n        long remain \u003d toSkip;\n        while (remain \u003e 0) {\n            final byte[] skipBuffer \u003d skipBufferSupplier.get();\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final long n \u003d input.read(skipBuffer, 0, (int) Math.min(remain, skipBuffer.length));\n            if (n \u003c 0) { // EOF\n                break;\n            }\n            remain -\u003d n;\n        }\n        return toSkip - remain;\n    }",
    "begin_line": 2409,
    "end_line": 2429,
    "comment": "/** \n * Skips bytes from an input byte stream. \u003cp\u003e Intended for special cases when customization of the temporary buffer is needed because, for example, a nested input stream has requirements for the bytes read. For example, when using  {@link InflaterInputStream}s from multiple threads. \u003c/p\u003e \u003cp\u003e This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for skip() implementations in subclasses of  {@link InputStream}. \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link InputStream#read(byte[],int,int)} rather than delegating to {@link InputStream#skip(long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of bytes are skipped. \u003c/p\u003e\n * @param input              byte stream to skip\n * @param toSkip             number of bytes to skip.\n * @param skipBufferSupplier Supplies the buffer to use for reading.\n * @return number of bytes actually skipped.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @see InputStream#skip(long)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-203\"\u003eIO-203 - Add skipFully() method for InputStreams\u003c/a\u003e\n * @since 2.14.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2443",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.nio.channels.ReadableByteChannel, long)",
    "snippet": "public static long skip(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        final ByteBuffer skipByteBuffer \u003d ByteBuffer.allocate((int) Math.min(toSkip, DEFAULT_BUFFER_SIZE));\n        long remain \u003d toSkip;\n        while (remain \u003e 0) {\n            skipByteBuffer.position(0);\n            skipByteBuffer.limit((int) Math.min(remain, DEFAULT_BUFFER_SIZE));\n            final int n \u003d input.read(skipByteBuffer);\n            if (n \u003d\u003d EOF) {\n                break;\n            }\n            remain -\u003d n;\n        }\n        return toSkip - remain;\n    }",
    "begin_line": 2443,
    "end_line": 2459,
    "comment": "/** \n * Skips bytes from a ReadableByteChannel. This implementation guarantees that it will read as many bytes as possible before giving up.\n * @param input ReadableByteChannel to skip\n * @param toSkip number of bytes to skip.\n * @return number of bytes actually skipped.\n * @throws IOException              if there is a problem reading the ReadableByteChannel\n * @throws IllegalArgumentException if toSkip is negative\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2482",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.io.Reader, long)",
    "snippet": "public static long skip(final Reader reader, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        long remain \u003d toSkip;\n        while (remain \u003e 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final char[] charArray \u003d getScratchCharArrayWriteOnly();\n            final long n \u003d reader.read(charArray, 0, (int) Math.min(remain, charArray.length));\n            if (n \u003c 0) { // EOF\n                break;\n            }\n            remain -\u003d n;\n        }\n        return toSkip - remain;\n    }",
    "begin_line": 2482,
    "end_line": 2497,
    "comment": "/** \n * Skips characters from an input character stream. This implementation guarantees that it will read as many characters as possible before giving up; this may not always be the case for skip() implementations in subclasses of  {@link Reader}. \u003cp\u003e Note that the implementation uses  {@link Reader#read(char[],int,int)} ratherthan delegating to  {@link Reader#skip(long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param reader character stream to skip\n * @param toSkip number of characters to skip.\n * @return number of characters actually skipped.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @see Reader#skip(long)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-203\"\u003eIO-203 - Add skipFully() method for InputStreams\u003c/a\u003e\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2519",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long)",
    "snippet": "public static void skipFully(final InputStream input, final long toSkip) throws IOException {\n        final long skipped \u003d skip(input, toSkip, IOUtils::getScratchByteArrayWriteOnly);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2519,
    "end_line": 2524,
    "comment": "/** \n * Skips the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#skip(long)} maynot skip as many bytes as requested (most likely because of reaching EOF). \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input stream to skip\n * @param toSkip the number of bytes to skip\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of bytes skipped was incorrect\n * @see InputStream#skip(long)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2549",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long, java.util.function.Supplier\u003cbyte[]\u003e)",
    "snippet": "public static void skipFully(final InputStream input, final long toSkip, final Supplier\u003cbyte[]\u003e skipBufferSupplier) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped \u003d skip(input, toSkip, skipBufferSupplier);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2549,
    "end_line": 2557,
    "comment": "/** \n * Skips the requested number of bytes or fail if there are not enough left. \u003cp\u003e Intended for special cases when customization of the temporary buffer is needed because, for example, a nested input stream has requirements for the bytes read. For example, when using  {@link InflaterInputStream}s from multiple threads. \u003c/p\u003e \u003cp\u003e This allows for the possibility that  {@link InputStream#skip(long)} may not skip as many bytes as requested (most likely because of reaching EOF).\u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input              stream to skip\n * @param toSkip             the number of bytes to skip\n * @param skipBufferSupplier Supplies the buffer to use for reading.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of bytes skipped was incorrect\n * @see InputStream#skip(long)\n * @since 2.14.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2569",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.nio.channels.ReadableByteChannel, long)",
    "snippet": "public static void skipFully(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped \u003d skip(input, toSkip);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2569,
    "end_line": 2577,
    "comment": "/** \n * Skips the requested number of bytes or fail if there are not enough left.\n * @param input ReadableByteChannel to skip\n * @param toSkip the number of bytes to skip\n * @throws IOException              if there is a problem reading the ReadableByteChannel\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of bytes skipped was incorrect\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2599",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.io.Reader, long)",
    "snippet": "public static void skipFully(final Reader reader, final long toSkip) throws IOException {\n        final long skipped \u003d skip(reader, toSkip);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Chars to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2599,
    "end_line": 2604,
    "comment": "/** \n * Skips the requested number of characters or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link Reader#skip(long)} maynot skip as many characters as requested (most likely because of reaching EOF). \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(Reader,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param reader stream to skip\n * @param toSkip the number of characters to skip\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of characters skipped was incorrect\n * @see Reader#skip(long)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedInputStream#2630",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedInputStream(java.io.InputStream)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input);\n    }",
    "begin_line": 2630,
    "end_line": 2632,
    "comment": "/** \n * Fetches entire contents of an  {@link InputStream} and representsame data as result InputStream. \u003cp\u003e This method is useful where, \u003c/p\u003e \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e \u003cp\u003e It can be used in favor of  {@link #toByteArray(InputStream)}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input Stream to be fully buffered.\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedInputStream#2659",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedInputStream(java.io.InputStream, int)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input, final int size) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input, size);\n    }",
    "begin_line": 2659,
    "end_line": 2661,
    "comment": "/** \n * Fetches entire contents of an  {@link InputStream} and representsame data as result InputStream. \u003cp\u003e This method is useful where, \u003c/p\u003e \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e \u003cp\u003e It can be used in favor of  {@link #toByteArray(InputStream)}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input Stream to be fully buffered.\n * @param size the initial buffer size\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs.\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedReader#2673",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedReader(java.io.Reader)",
    "snippet": "public static BufferedReader toBufferedReader(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }",
    "begin_line": 2673,
    "end_line": 2675,
    "comment": "/** \n * Returns the given reader if it is a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @see #buffer(Reader)\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedReader#2688",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedReader(java.io.Reader, int)",
    "snippet": "public static BufferedReader toBufferedReader(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }",
    "begin_line": 2688,
    "end_line": 2690,
    "comment": "/** \n * Returns the given reader if it is a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @param size the buffer size, if a new BufferedReader is created.\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @see #buffer(Reader)\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2704",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream)",
    "snippet": "public static byte[] toByteArray(final InputStream inputStream) throws IOException {\n        // We use a ThresholdingOutputStream to avoid reading AND writing more than Integer.MAX_VALUE.\n        try (UnsynchronizedByteArrayOutputStream ubaOutput \u003d UnsynchronizedByteArrayOutputStream.builder().get();\n            ThresholdingOutputStream thresholdOutput \u003d new ThresholdingOutputStream(Integer.MAX_VALUE, os -\u003e {\n                throw new IllegalArgumentException(String.format(\"Cannot read more than %,d into a byte array\", Integer.MAX_VALUE));\n            }, os -\u003e ubaOutput)) {\n            copy(inputStream, thresholdOutput);\n            return ubaOutput.toByteArray();\n        }\n    }",
    "begin_line": 2704,
    "end_line": 2713,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a {@code byte[]}. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read.\n * @return the requested byte array.\n * @throws NullPointerException if the InputStream is {@code null}.\n * @throws IOException if an I/O error occurs or reading more than {@link Integer#MAX_VALUE} occurs.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2726",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream, int)",
    "snippet": "public static byte[] toByteArray(final InputStream input, final int size) throws IOException {\n        if (size \u003d\u003d 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        return toByteArray(Objects.requireNonNull(input, \"input\")::read, size);\n    }",
    "begin_line": 2726,
    "end_line": 2731,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a {@code byte[]}. Use this method instead of {@link #toByteArray(InputStream)} when {@link InputStream} size is known.\n * @param input the {@link InputStream} to read.\n * @param size the size of {@link InputStream} to read, where 0 \u0026lt; {@code size} \u0026lt;\u003d length of input stream.\n * @return byte [] of length {@code size}.\n * @throws IOException if an I/O error occurs or {@link InputStream} length is smaller than parameter {@code size}.\n * @throws IllegalArgumentException if {@code size} is less than zero.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2749",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream, long)",
    "snippet": "public static byte[] toByteArray(final InputStream input, final long size) throws IOException {\n        if (size \u003e Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Size cannot be greater than Integer max value: \" + size);\n        }\n        return toByteArray(input, (int) size);\n    }",
    "begin_line": 2749,
    "end_line": 2754,
    "comment": "/** \n * Gets contents of an  {@link InputStream} as a {@code byte[]}. Use this method instead of  {@link #toByteArray(InputStream)}when  {@link InputStream} size is known.\u003cb\u003eNOTE:\u003c/b\u003e the method checks that the length can safely be cast to an int without truncation before using  {@link IOUtils#toByteArray(InputStream,int)} to read into the byte array.(Arrays can have no more than Integer.MAX_VALUE entries anyway)\n * @param input the {@link InputStream} to read\n * @param size the size of {@link InputStream} to read, where 0 \u0026lt; {@code size} \u0026lt;\u003d min(Integer.MAX_VALUE, length of input stream).\n * @return byte [] the requested byte array, of length {@code size}\n * @throws IOException              if an I/O error occurs or {@link InputStream} length is less than {@code size}\n * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE\n * @see IOUtils#toByteArray(InputStream,int)\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2765",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(org.apache.commons.io.function.IOTriFunction\u003cbyte[],java.lang.Integer,java.lang.Integer,java.lang.Integer\u003e, int)",
    "snippet": "static byte[] toByteArray(final IOTriFunction\u003cbyte[], Integer, Integer, Integer\u003e input, final int size) throws IOException {\n\n        if (size \u003c 0) {\n            throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + size);\n        }\n\n        if (size \u003d\u003d 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n\n        final byte[] data \u003d byteArray(size);\n        int offset \u003d 0;\n        int read;\n\n        while (offset \u003c size \u0026\u0026 (read \u003d input.apply(data, offset, size - offset)) !\u003d EOF) {\n            offset +\u003d read;\n        }\n\n        if (offset !\u003d size) {\n            throw new IOException(\"Unexpected read size, current: \" + offset + \", expected: \" + size);\n        }\n\n        return data;\n    }",
    "begin_line": 2765,
    "end_line": 2788,
    "comment": "/** \n * Gets the contents of an input as a  {@code byte[]}.\n * @param input the input to read.\n * @param size the size of the input to read, where 0 \u0026lt; {@code size} \u0026lt;\u003d length of input.\n * @return byte [] of length {@code size}.\n * @throws IOException if an I/O error occurs or input length is smaller than parameter {@code size}.\n * @throws IllegalArgumentException if {@code size} is less than zero.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2805",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.Reader)",
    "snippet": "@Deprecated\n    public static byte[] toByteArray(final Reader reader) throws IOException {\n        return toByteArray(reader, Charset.defaultCharset());\n    }",
    "begin_line": 2805,
    "end_line": 2807,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a {@code byte[]}using the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @deprecated 2.5 use {@link #toByteArray(Reader,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2824",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.Reader, java.nio.charset.Charset)",
    "snippet": "public static byte[] toByteArray(final Reader reader, final Charset charset) throws IOException {\n        try (ByteArrayOutputStream output \u003d new ByteArrayOutputStream()) {\n            copy(reader, output, charset);\n            return output.toByteArray();\n        }\n    }",
    "begin_line": 2824,
    "end_line": 2829,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a {@code byte[]}using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param charset the charset to use, null means platform default\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2853",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.Reader, java.lang.String)",
    "snippet": "public static byte[] toByteArray(final Reader reader, final String charsetName) throws IOException {\n        return toByteArray(reader, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2853,
    "end_line": 2855,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a {@code byte[]}using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested byte array\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2870",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.lang.String)",
    "snippet": "@Deprecated\n    public static byte[] toByteArray(final String input) {\n        // make explicit the use of the default charset\n        return input.getBytes(Charset.defaultCharset());\n    }",
    "begin_line": 2870,
    "end_line": 2873,
    "comment": "/** \n * Gets the contents of a  {@link String} as a {@code byte[]}using the default character encoding of the platform. \u003cp\u003e This is the same as  {@link String#getBytes()}. \u003c/p\u003e\n * @param input the {@link String} to convert\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @deprecated 2.5 Use {@link String#getBytes()} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2884",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.net.URI)",
    "snippet": "public static byte[] toByteArray(final URI uri) throws IOException {\n        return toByteArray(uri.toURL());\n    }",
    "begin_line": 2884,
    "end_line": 2886,
    "comment": "/** \n * Gets the contents of a  {@link URI} as a {@code byte[]}.\n * @param uri the {@link URI} to read\n * @return the requested byte array\n * @throws NullPointerException if the uri is null\n * @throws IOException          if an I/O exception occurs\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2897",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.net.URL)",
    "snippet": "public static byte[] toByteArray(final URL url) throws IOException {\n        try (CloseableURLConnection urlConnection \u003d CloseableURLConnection.open(url)) {\n            return toByteArray(urlConnection);\n        }\n    }",
    "begin_line": 2897,
    "end_line": 2901,
    "comment": "/** \n * Gets the contents of a  {@link URL} as a {@code byte[]}.\n * @param url the {@link URL} to read\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O exception occurs\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2912",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.net.URLConnection)",
    "snippet": "public static byte[] toByteArray(final URLConnection urlConnection) throws IOException {\n        try (InputStream inputStream \u003d urlConnection.getInputStream()) {\n            return toByteArray(inputStream);\n        }\n    }",
    "begin_line": 2912,
    "end_line": 2916,
    "comment": "/** \n * Gets the contents of a  {@link URLConnection} as a {@code byte[]}.\n * @param urlConnection the {@link URLConnection} to read.\n * @return the requested byte array.\n * @throws NullPointerException if the urlConn is null.\n * @throws IOException if an I/O exception occurs.\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2934",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static char[] toCharArray(final InputStream inputStream) throws IOException {\n        return toCharArray(inputStream, Charset.defaultCharset());\n    }",
    "begin_line": 2934,
    "end_line": 2936,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a character arrayusing the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read\n * @return the requested character array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #toCharArray(InputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2953",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static char[] toCharArray(final InputStream inputStream, final Charset charset)\n            throws IOException {\n        final CharArrayWriter writer \u003d new CharArrayWriter();\n        copy(inputStream, writer, charset);\n        return writer.toCharArray();\n    }",
    "begin_line": 2953,
    "end_line": 2958,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a character arrayusing the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read\n * @param charset the charset to use, null means platform default\n * @return the requested character array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2982",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.InputStream, java.lang.String)",
    "snippet": "public static char[] toCharArray(final InputStream inputStream, final String charsetName) throws IOException {\n        return toCharArray(inputStream, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2982,
    "end_line": 2984,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a character arrayusing the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param inputStream the {@link InputStream} to read\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested character array\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2999",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.Reader)",
    "snippet": "public static char[] toCharArray(final Reader reader) throws IOException {\n        final CharArrayWriter sw \u003d new CharArrayWriter();\n        copy(reader, sw);\n        return sw.toCharArray();\n    }",
    "begin_line": 2999,
    "end_line": 3003,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a character array.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @return the requested character array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3015",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.CharSequence)",
    "snippet": "@Deprecated\n    public static InputStream toInputStream(final CharSequence input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }",
    "begin_line": 3015,
    "end_line": 3017,
    "comment": "/** \n * Converts the specified CharSequence to an input stream, encoded as bytes using the default character encoding of the platform.\n * @param input the CharSequence to convert\n * @return an input stream\n * @since 2.0\n * @deprecated 2.5 use {@link #toInputStream(CharSequence,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3028",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.CharSequence, java.nio.charset.Charset)",
    "snippet": "public static InputStream toInputStream(final CharSequence input, final Charset charset) {\n        return toInputStream(input.toString(), charset);\n    }",
    "begin_line": 3028,
    "end_line": 3030,
    "comment": "/** \n * Converts the specified CharSequence to an input stream, encoded as bytes using the specified character encoding.\n * @param input the CharSequence to convert\n * @param charset the charset to use, null means platform default\n * @return an input stream\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3048",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.CharSequence, java.lang.String)",
    "snippet": "public static InputStream toInputStream(final CharSequence input, final String charsetName) {\n        return toInputStream(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3048,
    "end_line": 3050,
    "comment": "/** \n * Converts the specified CharSequence to an input stream, encoded as bytes using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e\n * @param input the CharSequence to convert\n * @param charsetName the name of the requested charset, null means platform default\n * @return an input stream\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3062",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.String)",
    "snippet": "@Deprecated\n    public static InputStream toInputStream(final String input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }",
    "begin_line": 3062,
    "end_line": 3064,
    "comment": "/** \n * Converts the specified string to an input stream, encoded as bytes using the default character encoding of the platform.\n * @param input the string to convert\n * @return an input stream\n * @since 1.1\n * @deprecated 2.5 use {@link #toInputStream(String,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3075",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.String, java.nio.charset.Charset)",
    "snippet": "public static InputStream toInputStream(final String input, final Charset charset) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charset)));\n    }",
    "begin_line": 3075,
    "end_line": 3077,
    "comment": "/** \n * Converts the specified string to an input stream, encoded as bytes using the specified character encoding.\n * @param input the string to convert\n * @param charset the charset to use, null means platform default\n * @return an input stream\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#3095",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.String, java.lang.String)",
    "snippet": "public static InputStream toInputStream(final String input, final String charsetName) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charsetName)));\n    }",
    "begin_line": 3095,
    "end_line": 3097,
    "comment": "/** \n * Converts the specified string to an input stream, encoded as bytes using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e\n * @param input the string to convert\n * @param charsetName the name of the requested charset, null means platform default\n * @return an input stream\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3109",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(byte[])",
    "snippet": "@Deprecated\n    public static String toString(final byte[] input) {\n        // make explicit the use of the default charset\n        return new String(input, Charset.defaultCharset());\n    }",
    "begin_line": 3109,
    "end_line": 3112,
    "comment": "/** \n * Gets the contents of a  {@code byte[]} as a Stringusing the default character encoding of the platform.\n * @param input the byte array to read\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @deprecated 2.5 Use {@link String#String(byte[])} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3127",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(byte[], java.lang.String)",
    "snippet": "public static String toString(final byte[] input, final String charsetName) {\n        return new String(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3127,
    "end_line": 3129,
    "comment": "/** \n * Gets the contents of a  {@code byte[]} as a Stringusing the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e\n * @param input the byte array to read\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested String\n * @throws NullPointerException if the input is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3146",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static String toString(final InputStream input) throws IOException {\n        return toString(input, Charset.defaultCharset());\n    }",
    "begin_line": 3146,
    "end_line": 3148,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a Stringusing the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @deprecated 2.5 use {@link #toString(InputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3165",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static String toString(final InputStream input, final Charset charset) throws IOException {\n        try (StringBuilderWriter sw \u003d new StringBuilderWriter()) {\n            copy(input, sw, charset);\n            return sw.toString();\n        }\n    }",
    "begin_line": 3165,
    "end_line": 3170,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a Stringusing the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param charset the charset to use, null means platform default\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3193",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.InputStream, java.lang.String)",
    "snippet": "public static String toString(final InputStream input, final String charsetName)\n            throws IOException {\n        return toString(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3193,
    "end_line": 3196,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} as a Stringusing the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input the {@link InputStream} to read\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested String\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3213",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(org.apache.commons.io.function.IOSupplier\u003cjava.io.InputStream\u003e, java.nio.charset.Charset)",
    "snippet": "public static String toString(final IOSupplier\u003cInputStream\u003e input, final Charset charset) throws IOException {\n        return toString(input, charset, () -\u003e {\n            throw new NullPointerException(\"input\");\n        });\n    }",
    "begin_line": 3213,
    "end_line": 3217,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} from a supplier as a Stringusing the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input supplies the {@link InputStream} to read\n * @param charset the charset to use, null means platform default\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3235",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(org.apache.commons.io.function.IOSupplier\u003cjava.io.InputStream\u003e, java.nio.charset.Charset, org.apache.commons.io.function.IOSupplier\u003cjava.lang.String\u003e)",
    "snippet": "public static String toString(final IOSupplier\u003cInputStream\u003e input, final Charset charset, final IOSupplier\u003cString\u003e defaultString) throws IOException {\n        if (input \u003d\u003d null) {\n            return defaultString.get();\n        }\n        try (InputStream inputStream \u003d input.get()) {\n            return inputStream !\u003d null ? toString(inputStream, charset) : defaultString.get();\n        }\n    }",
    "begin_line": 3235,
    "end_line": 3242,
    "comment": "/** \n * Gets the contents of an  {@link InputStream} from a supplier as a Stringusing the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}. \u003c/p\u003e\n * @param input supplies the {@link InputStream} to read\n * @param charset the charset to use, null means platform default\n * @param defaultString the default return value if the supplier or its value is null.\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3256",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.Reader)",
    "snippet": "public static String toString(final Reader reader) throws IOException {\n        try (StringBuilderWriter sw \u003d new StringBuilderWriter()) {\n            copy(reader, sw);\n            return sw.toString();\n        }\n    }",
    "begin_line": 3256,
    "end_line": 3261,
    "comment": "/** \n * Gets the contents of a  {@link Reader} as a String.\u003cp\u003e This method buffers the input internally, so there is no need to use a {@link BufferedReader}. \u003c/p\u003e\n * @param reader the {@link Reader} to read\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3273",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URI)",
    "snippet": "@Deprecated\n    public static String toString(final URI uri) throws IOException {\n        return toString(uri, Charset.defaultCharset());\n    }",
    "begin_line": 3273,
    "end_line": 3275,
    "comment": "/** \n * Gets the contents at the given URI.\n * @param uri The URI source.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.1\n * @deprecated 2.5 use {@link #toString(URI,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3286",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URI, java.nio.charset.Charset)",
    "snippet": "public static String toString(final URI uri, final Charset encoding) throws IOException {\n        return toString(uri.toURL(), Charsets.toCharset(encoding));\n    }",
    "begin_line": 3286,
    "end_line": 3288,
    "comment": "/** \n * Gets the contents at the given URI.\n * @param uri The URI source.\n * @param encoding The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.3.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3302",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URI, java.lang.String)",
    "snippet": "public static String toString(final URI uri, final String charsetName) throws IOException {\n        return toString(uri, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3302,
    "end_line": 3304,
    "comment": "/** \n * Gets the contents at the given URI.\n * @param uri The URI source.\n * @param charsetName The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException                                  if an I/O exception occurs.\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3316",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URL)",
    "snippet": "@Deprecated\n    public static String toString(final URL url) throws IOException {\n        return toString(url, Charset.defaultCharset());\n    }",
    "begin_line": 3316,
    "end_line": 3318,
    "comment": "/** \n * Gets the contents at the given URL.\n * @param url The URL source.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.1\n * @deprecated 2.5 use {@link #toString(URL,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3329",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URL, java.nio.charset.Charset)",
    "snippet": "public static String toString(final URL url, final Charset encoding) throws IOException {\n        return toString(url::openStream, encoding);\n    }",
    "begin_line": 3329,
    "end_line": 3331,
    "comment": "/** \n * Gets the contents at the given URL.\n * @param url The URL source.\n * @param encoding The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#3345",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URL, java.lang.String)",
    "snippet": "public static String toString(final URL url, final String charsetName) throws IOException {\n        return toString(url, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3345,
    "end_line": 3347,
    "comment": "/** \n * Gets the contents at the given URL.\n * @param url The URL source.\n * @param charsetName The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException                                  if an I/O exception occurs.\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3359",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.OutputStream)",
    "snippet": "public static void write(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data !\u003d null) {\n            output.write(data);\n        }\n    }",
    "begin_line": 3359,
    "end_line": 3364,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to an {@link OutputStream}.\n * @param data the byte array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3382",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.Writer)",
    "snippet": "@Deprecated\n    public static void write(final byte[] data, final Writer writer) throws IOException {\n        write(data, writer, Charset.defaultCharset());\n    }",
    "begin_line": 3382,
    "end_line": 3384,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to chars on a {@link Writer}using the default character encoding of the platform. \u003cp\u003e This method uses  {@link String#String(byte[])}. \u003c/p\u003e\n * @param data the byte array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #write(byte[],Writer,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3401",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.Writer, java.nio.charset.Charset)",
    "snippet": "public static void write(final byte[] data, final Writer writer, final Charset charset) throws IOException {\n        if (data !\u003d null) {\n            writer.write(new String(data, Charsets.toCharset(charset)));\n        }\n    }",
    "begin_line": 3401,
    "end_line": 3405,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to chars on a {@link Writer}using the specified character encoding. \u003cp\u003e This method uses  {@link String#String(byte[],String)}. \u003c/p\u003e\n * @param data the byte array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3429",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.Writer, java.lang.String)",
    "snippet": "public static void write(final byte[] data, final Writer writer, final String charsetName) throws IOException {\n        write(data, writer, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3429,
    "end_line": 3431,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to chars on a {@link Writer}using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#String(byte[],String)}. \u003c/p\u003e\n * @param data the byte array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException                         if output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3450",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final char[] data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 3450,
    "end_line": 3453,
    "comment": "/** \n * Writes chars from a  {@code char[]} to bytes on an{@link OutputStream}. \u003cp\u003e This method uses  {@link String#String(char[])} and{@link String#getBytes()}. \u003c/p\u003e\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #write(char[],OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3471",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void write(final char[] data, final OutputStream output, final Charset charset) throws IOException {\n        if (data !\u003d null) {\n            write(new String(data), output, charset);\n        }\n    }",
    "begin_line": 3471,
    "end_line": 3475,
    "comment": "/** \n * Writes chars from a  {@code char[]} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e This method uses  {@link String#String(char[])} and{@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3499",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.OutputStream, java.lang.String)",
    "snippet": "public static void write(final char[] data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3499,
    "end_line": 3502,
    "comment": "/** \n * Writes chars from a  {@code char[]} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#String(char[])} and{@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException                         if output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3514",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.Writer)",
    "snippet": "public static void write(final char[] data, final Writer writer) throws IOException {\n        if (data !\u003d null) {\n            writer.write(data);\n        }\n    }",
    "begin_line": 3514,
    "end_line": 3518,
    "comment": "/** \n * Writes chars from a  {@code char[]} to a {@link Writer}\n * @param data the char array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3536",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final CharSequence data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 3536,
    "end_line": 3539,
    "comment": "/** \n * Writes chars from a  {@link CharSequence} to bytes on an{@link OutputStream} using the default character encoding of theplatform. \u003cp\u003e This method uses  {@link String#getBytes()}. \u003c/p\u003e\n * @param data the {@link CharSequence} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.0\n * @deprecated 2.5 use {@link #write(CharSequence,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3555",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void write(final CharSequence data, final OutputStream output, final Charset charset)\n            throws IOException {\n        if (data !\u003d null) {\n            write(data.toString(), output, charset);\n        }\n    }",
    "begin_line": 3555,
    "end_line": 3560,
    "comment": "/** \n * Writes chars from a  {@link CharSequence} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link CharSequence} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3582",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void write(final CharSequence data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3582,
    "end_line": 3585,
    "comment": "/** \n * Writes chars from a  {@link CharSequence} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link CharSequence} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException        if output is null\n * @throws IOException                 if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3596",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.Writer)",
    "snippet": "public static void write(final CharSequence data, final Writer writer) throws IOException {\n        if (data !\u003d null) {\n            write(data.toString(), writer);\n        }\n    }",
    "begin_line": 3596,
    "end_line": 3600,
    "comment": "/** \n * Writes chars from a  {@link CharSequence} to a {@link Writer}.\n * @param data the {@link CharSequence} to write, null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3618",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final String data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 3618,
    "end_line": 3621,
    "comment": "/** \n * Writes chars from a  {@link String} to bytes on an{@link OutputStream} using the default character encoding of theplatform. \u003cp\u003e This method uses  {@link String#getBytes()}. \u003c/p\u003e\n * @param data the {@link String} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #write(String,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3638",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "@SuppressWarnings(\"resource\")\n    public static void write(final String data, final OutputStream output, final Charset charset) throws IOException {\n        if (data !\u003d null) {\n            // Use Charset#encode(String), since calling String#getBytes(Charset) might result in\n            // NegativeArraySizeException or OutOfMemoryError.\n            // The underlying OutputStream should not be closed, so the channel is not closed.\n            Channels.newChannel(output).write(Charsets.toCharset(charset).encode(data));\n        }\n    }",
    "begin_line": 3638,
    "end_line": 3645,
    "comment": "/** \n * Writes chars from a  {@link String} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link String} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3667",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void write(final String data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3667,
    "end_line": 3670,
    "comment": "/** \n * Writes chars from a  {@link String} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link String} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException        if output is null\n * @throws IOException                 if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3681",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.Writer)",
    "snippet": "public static void write(final String data, final Writer writer) throws IOException {\n        if (data !\u003d null) {\n            writer.write(data);\n        }\n    }",
    "begin_line": 3681,
    "end_line": 3685,
    "comment": "/** \n * Writes chars from a  {@link String} to a {@link Writer}.\n * @param data the {@link String} to write, null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3703",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.StringBuffer, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final StringBuffer data, final OutputStream output) //NOSONAR\n            throws IOException {\n        write(data, output, (String) null);\n    }",
    "begin_line": 3703,
    "end_line": 3706,
    "comment": "/** \n * Writes chars from a  {@link StringBuffer} to bytes on an{@link OutputStream} using the default character encoding of theplatform. \u003cp\u003e This method uses  {@link String#getBytes()}. \u003c/p\u003e\n * @param data the {@link StringBuffer} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated Use {@link #write(CharSequence,OutputStream)}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3730",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.StringBuffer, java.io.OutputStream, java.lang.String)",
    "snippet": "@Deprecated\n    public static void write(final StringBuffer data, final OutputStream output, final String charsetName) //NOSONAR\n        throws IOException {\n        if (data !\u003d null) {\n            write(data.toString(), output, Charsets.toCharset(charsetName));\n        }\n    }",
    "begin_line": 3730,
    "end_line": 3735,
    "comment": "/** \n * Writes chars from a  {@link StringBuffer} to bytes on an{@link OutputStream} using the specified character encoding.\u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e \u003cp\u003e This method uses  {@link String#getBytes(String)}. \u003c/p\u003e\n * @param data the {@link StringBuffer} to write, null ignored\n * @param output the {@link OutputStream} to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException        if output is null\n * @throws IOException                 if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n * @deprecated Use {@link #write(CharSequence,OutputStream,String)}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3748",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.StringBuffer, java.io.Writer)",
    "snippet": "@Deprecated\n    public static void write(final StringBuffer data, final Writer writer) //NOSONAR\n            throws IOException {\n        if (data !\u003d null) {\n            writer.write(data.toString());\n        }\n    }",
    "begin_line": 3748,
    "end_line": 3753,
    "comment": "/** \n * Writes chars from a  {@link StringBuffer} to a {@link Writer}.\n * @param data the {@link StringBuffer} to write, null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated Use {@link #write(CharSequence,Writer)}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeChunked#3767",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeChunked(byte[], java.io.OutputStream)",
    "snippet": "public static void writeChunked(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data !\u003d null) {\n            int bytes \u003d data.length;\n            int offset \u003d 0;\n            while (bytes \u003e 0) {\n                final int chunk \u003d Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                output.write(data, offset, chunk);\n                bytes -\u003d chunk;\n                offset +\u003d chunk;\n            }\n        }\n    }",
    "begin_line": 3767,
    "end_line": 3779,
    "comment": "/** \n * Writes bytes from a  {@code byte[]} to an {@link OutputStream} using chunked writes.This is intended for writing very large byte arrays which might otherwise cause excessive memory usage if the native code has to allocate a copy.\n * @param data the byte array to write, do not modify during output,null ignored\n * @param output the {@link OutputStream} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeChunked#3793",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeChunked(char[], java.io.Writer)",
    "snippet": "public static void writeChunked(final char[] data, final Writer writer) throws IOException {\n        if (data !\u003d null) {\n            int bytes \u003d data.length;\n            int offset \u003d 0;\n            while (bytes \u003e 0) {\n                final int chunk \u003d Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                writer.write(data, offset, chunk);\n                bytes -\u003d chunk;\n                offset +\u003d chunk;\n            }\n        }\n    }",
    "begin_line": 3793,
    "end_line": 3804,
    "comment": "/** \n * Writes chars from a  {@code char[]} to a {@link Writer} using chunked writes.This is intended for writing very large byte arrays which might otherwise cause excessive memory usage if the native code has to allocate a copy.\n * @param data the char array to write, do not modify during output,null ignored\n * @param writer the {@link Writer} to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3820",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void writeLines(final Collection\u003c?\u003e lines, final String lineEnding,\n                                  final OutputStream output) throws IOException {\n        writeLines(lines, lineEnding, output, Charset.defaultCharset());\n    }",
    "begin_line": 3820,
    "end_line": 3823,
    "comment": "/** \n * Writes the  {@link #toString()} value of each item in a collection toan  {@link OutputStream} line by line, using the default characterencoding of the platform and the specified line ending.\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param output the {@link OutputStream} to write to, not null, not closed\n * @throws NullPointerException if the output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #writeLines(Collection,String,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3843",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void writeLines(final Collection\u003c?\u003e lines, String lineEnding, final OutputStream output,\n            Charset charset) throws IOException {\n        if (lines \u003d\u003d null) {\n            return;\n        }\n        if (lineEnding \u003d\u003d null) {\n            lineEnding \u003d System.lineSeparator();\n        }\n        if (StandardCharsets.UTF_16.equals(charset)) {\n            // don\u0027t write a BOM\n            charset \u003d StandardCharsets.UTF_16BE;\n        }\n        final byte[] eolBytes \u003d lineEnding.getBytes(charset);\n        for (final Object line : lines) {\n            if (line !\u003d null) {\n                write(line.toString(), output, charset);\n            }\n            output.write(eolBytes);\n        }\n    }",
    "begin_line": 3843,
    "end_line": 3862,
    "comment": "/** \n * Writes the  {@link #toString()} value of each item in a collection toan  {@link OutputStream} line by line, using the specified characterencoding and the specified line ending. \u003cp\u003e UTF-16 is written big-endian with no byte order mark. For little-endian, use UTF-16LE. For a BOM, write it to the stream before calling this method. \u003c/p\u003e\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param output the {@link OutputStream} to write to, not null, not closed\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3884",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void writeLines(final Collection\u003c?\u003e lines, final String lineEnding,\n                                  final OutputStream output, final String charsetName) throws IOException {\n        writeLines(lines, lineEnding, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3884,
    "end_line": 3887,
    "comment": "/** \n * Writes the  {@link #toString()} value of each item in a collection toan  {@link OutputStream} line by line, using the specified characterencoding and the specified line ending. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003c/p\u003e\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param output the {@link OutputStream} to write to, not null, not closed\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException                         if the output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3900",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.Writer)",
    "snippet": "public static void writeLines(final Collection\u003c?\u003e lines, String lineEnding,\n                                  final Writer writer) throws IOException {\n        if (lines \u003d\u003d null) {\n            return;\n        }\n        if (lineEnding \u003d\u003d null) {\n            lineEnding \u003d System.lineSeparator();\n        }\n        for (final Object line : lines) {\n            if (line !\u003d null) {\n                writer.write(line.toString());\n            }\n            writer.write(lineEnding);\n        }\n    }",
    "begin_line": 3900,
    "end_line": 3914,
    "comment": "/** \n * Writes the  {@link #toString()} value of each item in a collection toa  {@link Writer} line by line, using the specified line ending.\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param writer the {@link Writer} to write to, not null, not closed\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writer#3925",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writer(java.lang.Appendable)",
    "snippet": "public static Writer writer(final Appendable appendable) {\n        Objects.requireNonNull(appendable, \"appendable\");\n        if (appendable instanceof Writer) {\n            return (Writer) appendable;\n        }\n        if (appendable instanceof StringBuilder) {\n            return new StringBuilderWriter((StringBuilder) appendable);\n        }\n        return new AppendableWriter\u003c\u003e(appendable);\n    }",
    "begin_line": 3925,
    "end_line": 3934,
    "comment": "/** \n * Returns the given Appendable if it is already a  {@link Writer}, otherwise creates a Writer wrapper around the given Appendable.\n * @param appendable the Appendable to wrap or return (not null)\n * @return  the given Appendable or a Writer wrapper around the given Appendable\n * @throws NullPointerException if the input parameter is null\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.IOUtils#3941",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.IOUtils()",
    "snippet": "@Deprecated\n    public IOUtils() { //NOSONAR\n    }",
    "begin_line": 3941,
    "end_line": 3942,
    "comment": "/** \n * Instances should NOT be constructed in standard programming.\n * @deprecated Will be private in 3.0.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.StandardLineSeparator#52",
    "is_bug": true,
    "src_path": "org/apache/commons/io/StandardLineSeparator.java",
    "class_name": "org.apache.commons.io.StandardLineSeparator",
    "signature": "org.apache.commons.io.StandardLineSeparator.StandardLineSeparator(java.lang.String)",
    "snippet": " StandardLineSeparator(final String lineSeparator) {\n        this.lineSeparator \u003d Objects.requireNonNull(lineSeparator, \"lineSeparator\");\n    }",
    "begin_line": 52,
    "end_line": 54,
    "comment": "/** \n * Constructs a new instance for a non-null line separator.\n * @param lineSeparator a non-null line separator.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getBytes#62",
    "is_bug": true,
    "src_path": "org/apache/commons/io/StandardLineSeparator.java",
    "class_name": "org.apache.commons.io.StandardLineSeparator",
    "signature": "org.apache.commons.io.StandardLineSeparator.getBytes(java.nio.charset.Charset)",
    "snippet": "public byte[] getBytes(final Charset charset) {\n        return lineSeparator.getBytes(charset);\n    }",
    "begin_line": 62,
    "end_line": 64,
    "comment": "/** \n * Gets the bytes for this instance encoded using the given Charset.\n * @param charset the encoding Charset.\n * @return the bytes for this instance encoded using the given Charset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getString#71",
    "is_bug": true,
    "src_path": "org/apache/commons/io/StandardLineSeparator.java",
    "class_name": "org.apache.commons.io.StandardLineSeparator",
    "signature": "org.apache.commons.io.StandardLineSeparator.getString()",
    "snippet": "public String getString() {\n        return lineSeparator;\n    }",
    "begin_line": 71,
    "end_line": 73,
    "comment": "/** \n * Gets the String value of this instance.\n * @return the String value of this instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.RelativeSortedPaths#112",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.RelativeSortedPaths(java.nio.file.Path, java.nio.file.Path, int, java.nio.file.LinkOption[], java.nio.file.FileVisitOption[])",
    "snippet": "private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n                final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List\u003cPath\u003e tmpRelativeDirList1;\n            final List\u003cPath\u003e tmpRelativeDirList2;\n            List\u003cPath\u003e tmpRelativeFileList1 \u003d null;\n            List\u003cPath\u003e tmpRelativeFileList2 \u003d null;\n            if (dir1 \u003d\u003d null \u0026\u0026 dir2 \u003d\u003d null) {\n                equals \u003d true;\n            } else if (dir1 \u003d\u003d null ^ dir2 \u003d\u003d null) {\n                equals \u003d false;\n            } else {\n                final boolean parentDirNotExists1 \u003d Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 \u003d Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals \u003d parentDirNotExists1 \u0026\u0026 parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 \u003d accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 \u003d accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() !\u003d visitor2.getDirList().size() || visitor1.getFileList().size() !\u003d visitor2.getFileList().size()) {\n                        equals \u003d false;\n                    } else {\n                        tmpRelativeDirList1 \u003d visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 \u003d visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals \u003d false;\n                        } else {\n                            tmpRelativeFileList1 \u003d visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 \u003d visitor2.relativizeFiles(dir2, true, null);\n                            equals \u003d tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 \u003d tmpRelativeDirList1;\n            // relativeDirList2 \u003d tmpRelativeDirList2;\n            relativeFileList1 \u003d tmpRelativeFileList1;\n            relativeFileList2 \u003d tmpRelativeFileList2;\n        }",
    "begin_line": 112,
    "end_line": 149,
    "comment": "/** \n * Constructs and initializes a new instance by accumulating directory and file info.\n * @param dir1             First directory to compare.\n * @param dir2             Seconds directory to compare.\n * @param maxDepth         See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @param linkOptions      Options indicating how symbolic links are handled.\n * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.accumulate#224",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.accumulate(java.nio.file.Path, int, java.nio.file.FileVisitOption[])",
    "snippet": "private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }",
    "begin_line": 224,
    "end_line": 226,
    "comment": "/** \n * Accumulates file tree information in a  {@link AccumulatorPathVisitor}.\n * @param directory        The directory to accumulate information.\n * @param maxDepth         See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @throws IOException if an I/O error is thrown by a visitor method.\n * @return file tree information.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.cleanDirectory#235",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.cleanDirectory(java.nio.file.Path)",
    "snippet": "public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }",
    "begin_line": 235,
    "end_line": 237,
    "comment": "/** \n * Cleans a directory including subdirectories without deleting directories.\n * @param directory directory to clean.\n * @return The visitation path counters.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.cleanDirectory#248",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.cleanDirectory(java.nio.file.Path, org.apache.commons.io.file.DeleteOption)",
    "snippet": "public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }",
    "begin_line": 248,
    "end_line": 250,
    "comment": "/** \n * Cleans a directory including subdirectories without deleting directories.\n * @param directory     directory to clean.\n * @param deleteOptions How to handle deletion.\n * @return The visitation path counters.\n * @throws IOException if an I/O error is thrown by a visitor method.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.compareLastModifiedTimeTo#262",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.compareLastModifiedTimeTo(java.nio.file.Path, java.nio.file.attribute.FileTime, java.nio.file.LinkOption)",
    "snippet": "private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return getLastModifiedTime(file, options).compareTo(fileTime);\n    }",
    "begin_line": 262,
    "end_line": 264,
    "comment": "/** \n * Compares the given  {@link Path}\u0027s last modified time to the given file time.\n * @param file     the {@link Path} to test.\n * @param fileTime the time reference.\n * @param options  options indicating how to handle symbolic links.\n * @return See {@link FileTime#compareTo(FileTime)}\n * @throws IOException          if an I/O error occurs.\n * @throws NullPointerException if the file is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.copy#276",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.copy(org.apache.commons.io.function.IOSupplier\u003cjava.io.InputStream\u003e, java.nio.file.Path, java.nio.file.CopyOption)",
    "snippet": "public static long copy(final IOSupplier\u003cInputStream\u003e in, final Path target, final CopyOption... copyOptions) throws IOException {\n        try (InputStream inputStream \u003d in.get()) {\n            return Files.copy(inputStream, target, copyOptions);\n        }\n    }",
    "begin_line": 276,
    "end_line": 280,
    "comment": "/** \n * Copies the InputStream from the supplier with  {@link Files#copy(InputStream,Path,CopyOption...)}.\n * @param in          Supplies the InputStream.\n * @param target      See {@link Files#copy(InputStream,Path,CopyOption...)}.\n * @param copyOptions See {@link Files#copy(InputStream,Path,CopyOption...)}.\n * @return See {@link Files#copy(InputStream,Path,CopyOption...)}\n * @throws IOException See {@link Files#copy(InputStream,Path,CopyOption...)}\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.copyDirectory#291",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.copyDirectory(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption)",
    "snippet": "public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource \u003d sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n                .getPathCounters();\n    }",
    "begin_line": 291,
    "end_line": 295,
    "comment": "/** \n * Copies a directory to another directory.\n * @param sourceDirectory The source directory.\n * @param targetDirectory The target directory.\n * @param copyOptions     Specifies how the copying should be done.\n * @return The visitation path counters.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.copyFile#307",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.copyFile(java.net.URL, java.nio.file.Path, java.nio.file.CopyOption)",
    "snippet": "public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        copy(sourceFile::openStream, targetFile, copyOptions);\n        return targetFile;\n    }",
    "begin_line": 307,
    "end_line": 310,
    "comment": "/** \n * Copies a URL to a directory.\n * @param sourceFile  The source URL.\n * @param targetFile  The target file.\n * @param copyOptions Specifies how the copying should be done.\n * @return The target file\n * @throws IOException if an I/O error occurs.\n * @see Files#copy(InputStream,Path,CopyOption...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.copyFileToDirectory#322",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.copyFileToDirectory(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption)",
    "snippet": "public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }",
    "begin_line": 322,
    "end_line": 324,
    "comment": "/** \n * Copies a file to a directory.\n * @param sourceFile      The source file.\n * @param targetDirectory The target directory.\n * @param copyOptions     Specifies how the copying should be done.\n * @return The target file\n * @throws IOException if an I/O error occurs.\n * @see Files#copy(Path,Path,CopyOption...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.copyFileToDirectory#336",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.copyFileToDirectory(java.net.URL, java.nio.file.Path, java.nio.file.CopyOption)",
    "snippet": "public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path resolve \u003d targetDirectory.resolve(FilenameUtils.getName(sourceFile.getFile()));\n        copy(sourceFile::openStream, resolve, copyOptions);\n        return resolve;\n    }",
    "begin_line": 336,
    "end_line": 340,
    "comment": "/** \n * Copies a URL to a directory.\n * @param sourceFile      The source URL.\n * @param targetDirectory The target directory.\n * @param copyOptions     Specifies how the copying should be done.\n * @return The target file\n * @throws IOException if an I/O error occurs.\n * @see Files#copy(InputStream,Path,CopyOption...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.countDirectory#349",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.countDirectory(java.nio.file.Path)",
    "snippet": "public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(CountingPathVisitor.withLongCounters(), directory).getPathCounters();\n    }",
    "begin_line": 349,
    "end_line": 351,
    "comment": "/** \n * Counts aspects of a directory including subdirectories.\n * @param directory directory to delete.\n * @return The visitor used to count the given directory.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.countDirectoryAsBigInteger#361",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.countDirectoryAsBigInteger(java.nio.file.Path)",
    "snippet": "public static PathCounters countDirectoryAsBigInteger(final Path directory) throws IOException {\n        return visitFileTree(CountingPathVisitor.withBigIntegerCounters(), directory).getPathCounters();\n    }",
    "begin_line": 361,
    "end_line": 363,
    "comment": "/** \n * Counts aspects of a directory including subdirectories.\n * @param directory directory to count.\n * @return The visitor used to count the given directory.\n * @throws IOException if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.createParentDirectories#377",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.createParentDirectories(java.nio.file.Path, java.nio.file.attribute.FileAttribute\u003c?\u003e)",
    "snippet": "public static Path createParentDirectories(final Path path, final FileAttribute\u003c?\u003e... attrs) throws IOException {\n        return createParentDirectories(path, LinkOption.NOFOLLOW_LINKS, attrs);\n    }",
    "begin_line": 377,
    "end_line": 379,
    "comment": "/** \n * Creates the parent directories for the given  {@code path}. \u003cp\u003e If the parent directory already exists, then return it. \u003c/p\u003e\n * @param path  The path to a file (or directory).\n * @param attrs An optional list of file attributes to set atomically when creating the directories.\n * @return The Path for the {@code path}\u0027s parent directory or null if the given path has no parent.\n * @throws IOException if an I/O error occurs.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.createParentDirectories#394",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.createParentDirectories(java.nio.file.Path, java.nio.file.LinkOption, java.nio.file.attribute.FileAttribute\u003c?\u003e)",
    "snippet": "public static Path createParentDirectories(final Path path, final LinkOption linkOption, final FileAttribute\u003c?\u003e... attrs) throws IOException {\n        Path parent \u003d getParent(path);\n        parent \u003d linkOption \u003d\u003d LinkOption.NOFOLLOW_LINKS ? parent : readIfSymbolicLink(parent);\n        if (parent \u003d\u003d null) {\n            return null;\n        }\n        final boolean exists \u003d linkOption \u003d\u003d null ? Files.exists(parent) : Files.exists(parent, linkOption);\n        return exists ? parent : Files.createDirectories(parent, attrs);\n    }",
    "begin_line": 394,
    "end_line": 402,
    "comment": "/** \n * Creates the parent directories for the given  {@code path}. \u003cp\u003e If the parent directory already exists, then return it. \u003c/p\u003e\n * @param path       The path to a file (or directory).\n * @param linkOption A {@link LinkOption} or null.\n * @param attrs      An optional list of file attributes to set atomically when creating the directories.\n * @return The Path for the {@code path}\u0027s parent directory or null if the given path has no parent.\n * @throws IOException if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.current#411",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.current()",
    "snippet": "public static Path current() {\n        return Paths.get(\".\");\n    }",
    "begin_line": 411,
    "end_line": 413,
    "comment": "/** \n * Gets the current directory.\n * @return the current directory.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.delete#430",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.delete(java.nio.file.Path)",
    "snippet": "public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }",
    "begin_line": 430,
    "end_line": 432,
    "comment": "/** \n * Deletes a file or directory. If the path is a directory, delete it and all subdirectories. \u003cp\u003e The difference between File.delete() and this method are: \u003c/p\u003e \u003cul\u003e \u003cli\u003eA directory to delete does not have to be empty.\u003c/li\u003e \u003cli\u003eYou get exceptions when a file or directory cannot be deleted;  {@link java.io.File#delete()} returns a boolean.\u003c/ul\u003e\n * @param path file or directory to delete, must not be {@code null}\n * @return The visitor used to delete the given directory.\n * @throws NullPointerException if the directory is {@code null}\n * @throws IOException          if an I/O error is thrown by a visitor method or if an I/O error occurs.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.delete#451",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.delete(java.nio.file.Path, org.apache.commons.io.file.DeleteOption)",
    "snippet": "public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }",
    "begin_line": 451,
    "end_line": 454,
    "comment": "/** \n * Deletes a file or directory. If the path is a directory, delete it and all subdirectories. \u003cp\u003e The difference between File.delete() and this method are: \u003c/p\u003e \u003cul\u003e \u003cli\u003eA directory to delete does not have to be empty.\u003c/li\u003e \u003cli\u003eYou get exceptions when a file or directory cannot be deleted;  {@link java.io.File#delete()} returns a boolean.\u003c/ul\u003e\n * @param path          file or directory to delete, must not be {@code null}\n * @param deleteOptions How to handle deletion.\n * @return The visitor used to delete the given directory.\n * @throws NullPointerException if the directory is {@code null}\n * @throws IOException          if an I/O error is thrown by a visitor method or if an I/O error occurs.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.delete#474",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.delete(java.nio.file.Path, java.nio.file.LinkOption[], org.apache.commons.io.file.DeleteOption)",
    "snippet": "public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }",
    "begin_line": 474,
    "end_line": 477,
    "comment": "/** \n * Deletes a file or directory. If the path is a directory, delete it and all subdirectories. \u003cp\u003e The difference between File.delete() and this method are: \u003c/p\u003e \u003cul\u003e \u003cli\u003eA directory to delete does not have to be empty.\u003c/li\u003e \u003cli\u003eYou get exceptions when a file or directory cannot be deleted;  {@link java.io.File#delete()} returns a boolean.\u003c/ul\u003e\n * @param path          file or directory to delete, must not be {@code null}\n * @param linkOptions   How to handle symbolic links.\n * @param deleteOptions How to handle deletion.\n * @return The visitor used to delete the given directory.\n * @throws NullPointerException if the directory is {@code null}\n * @throws IOException          if an I/O error is thrown by a visitor method or if an I/O error occurs.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.deleteDirectory#486",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.deleteDirectory(java.nio.file.Path)",
    "snippet": "public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }",
    "begin_line": 486,
    "end_line": 488,
    "comment": "/** \n * Deletes a directory including subdirectories.\n * @param directory directory to delete.\n * @return The visitor used to delete the given directory.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.deleteDirectory#499",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.deleteDirectory(java.nio.file.Path, org.apache.commons.io.file.DeleteOption)",
    "snippet": "public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        final LinkOption[] linkOptions \u003d PathUtils.noFollowLinkOptionArray();\n        // POSIX ops will noop on non-POSIX.\n        return withPosixFileAttributes(getParent(directory), linkOptions, overrideReadOnly(deleteOptions),\n                pfa -\u003e visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters());\n    }",
    "begin_line": 499,
    "end_line": 504,
    "comment": "/** \n * Deletes a directory including subdirectories.\n * @param directory     directory to delete.\n * @param deleteOptions How to handle deletion.\n * @return The visitor used to delete the given directory.\n * @throws IOException if an I/O error is thrown by a visitor method.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.deleteDirectory#516",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.deleteDirectory(java.nio.file.Path, java.nio.file.LinkOption[], org.apache.commons.io.file.DeleteOption)",
    "snippet": "public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }",
    "begin_line": 516,
    "end_line": 518,
    "comment": "/** \n * Deletes a directory including subdirectories.\n * @param directory     directory to delete.\n * @param linkOptions   How to handle symbolic links.\n * @param deleteOptions How to handle deletion.\n * @return The visitor used to delete the given directory.\n * @throws IOException if an I/O error is thrown by a visitor method.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.deleteFile#528",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.deleteFile(java.nio.file.Path)",
    "snippet": "public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }",
    "begin_line": 528,
    "end_line": 530,
    "comment": "/** \n * Deletes the given file.\n * @param file The file to delete.\n * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n * @throws IOException         if an I/O error occurs.\n * @throws NoSuchFileException if the file is a directory.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.deleteFile#542",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.deleteFile(java.nio.file.Path, org.apache.commons.io.file.DeleteOption)",
    "snippet": "public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, noFollowLinkOptionArray(), deleteOptions);\n    }",
    "begin_line": 542,
    "end_line": 545,
    "comment": "/** \n * Deletes the given file.\n * @param file          The file to delete.\n * @param deleteOptions How to handle deletion.\n * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n * @throws IOException         if an I/O error occurs.\n * @throws NoSuchFileException if the file is a directory.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.deleteFile#558",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.deleteFile(java.nio.file.Path, java.nio.file.LinkOption[], org.apache.commons.io.file.DeleteOption)",
    "snippet": "public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n            throws NoSuchFileException, IOException {\n        //\n        // TODO Needs clean up\n        //\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts \u003d Counters.longPathCounters();\n        boolean exists \u003d exists(file, linkOptions);\n        long size \u003d exists \u0026\u0026 !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        try {\n            if (Files.deleteIfExists(file)) {\n                pathCounts.getFileCounter().increment();\n                pathCounts.getByteCounter().add(size);\n                return pathCounts;\n            }\n        } catch (final AccessDeniedException ignored) {\n            // Ignore and try again below.\n        }\n        final Path parent \u003d getParent(file);\n        PosixFileAttributes posixFileAttributes \u003d null;\n        try {\n            if (overrideReadOnly(deleteOptions)) {\n                posixFileAttributes \u003d readPosixFileAttributes(parent, linkOptions);\n                setReadOnly(file, false, linkOptions);\n            }\n            // Read size _after_ having read/execute access on POSIX.\n            exists \u003d exists(file, linkOptions);\n            size \u003d exists \u0026\u0026 !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n            if (Files.deleteIfExists(file)) {\n                pathCounts.getFileCounter().increment();\n                pathCounts.getByteCounter().add(size);\n            }\n        } finally {\n            if (posixFileAttributes !\u003d null) {\n                Files.setPosixFilePermissions(parent, posixFileAttributes.permissions());\n            }\n        }\n        return pathCounts;\n    }",
    "begin_line": 558,
    "end_line": 598,
    "comment": "/** \n * Deletes the given file.\n * @param file          The file to delete.\n * @param linkOptions   How to handle symbolic links.\n * @param deleteOptions How to handle deletion.\n * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n * @throws IOException         if an I/O error occurs.\n * @throws NoSuchFileException if the file is a directory.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.deleteOnExit#606",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.deleteOnExit(java.nio.file.Path)",
    "snippet": "public static void deleteOnExit(final Path path) {\n        Objects.requireNonNull(path.toFile()).deleteOnExit();\n    }",
    "begin_line": 606,
    "end_line": 608,
    "comment": "/** \n * Delegates to  {@link File#deleteOnExit()}.\n * @param path the path to delete.\n * @since 3.13.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.directoryAndFileContentEquals#619",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.directoryAndFileContentEquals(java.nio.file.Path, java.nio.file.Path)",
    "snippet": "public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }",
    "begin_line": 619,
    "end_line": 621,
    "comment": "/** \n * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The comparison includes all files in all subdirectories.\n * @param path1 The first directory.\n * @param path2 The second directory.\n * @return Whether the two directories contain the same files while considering file contents.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.directoryAndFileContentEquals#635",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.directoryAndFileContentEquals(java.nio.file.Path, java.nio.file.Path, java.nio.file.LinkOption[], java.nio.file.OpenOption[], java.nio.file.FileVisitOption[])",
    "snippet": "public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n            final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 \u003d\u003d null \u0026\u0026 path2 \u003d\u003d null) {\n            return true;\n        }\n        if (path1 \u003d\u003d null || path2 \u003d\u003d null) {\n            return false;\n        }\n        if (notExists(path1) \u0026\u0026 notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths \u003d new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List\u003cPath\u003e fileList1 \u003d relativeSortedPaths.relativeFileList1;\n        final List\u003cPath\u003e fileList2 \u003d relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch \u003d Collections.binarySearch(fileList2, path);\n            if (binarySearch \u003c\u003d -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 635,
    "end_line": 665,
    "comment": "/** \n * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The comparison includes all files in all subdirectories.\n * @param path1           The first directory.\n * @param path2           The second directory.\n * @param linkOptions     options to follow links.\n * @param openOptions     options to open files.\n * @param fileVisitOption options to configure traversal.\n * @return Whether the two directories contain the same files while considering file contents.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.directoryContentEquals#676",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.directoryContentEquals(java.nio.file.Path, java.nio.file.Path)",
    "snippet": "public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }",
    "begin_line": 676,
    "end_line": 678,
    "comment": "/** \n * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The comparison includes all files in all subdirectories.\n * @param path1 The first directory.\n * @param path2 The second directory.\n * @return Whether the two directories contain the same files without considering file contents.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.directoryContentEquals#692",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.directoryContentEquals(java.nio.file.Path, java.nio.file.Path, int, java.nio.file.LinkOption[], java.nio.file.FileVisitOption[])",
    "snippet": "public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }",
    "begin_line": 692,
    "end_line": 695,
    "comment": "/** \n * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The comparison includes all files in all subdirectories.\n * @param path1            The first directory.\n * @param path2            The second directory.\n * @param maxDepth         See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @param linkOptions      options to follow links.\n * @param fileVisitOptions options to configure the traversal\n * @return Whether the two directories contain the same files without considering file contents.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.exists#697",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.exists(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "private static boolean exists(final Path path, final LinkOption... options) {\n        Objects.requireNonNull(path, \"path\");\n        return options !\u003d null ? Files.exists(path, options) : Files.exists(path);\n    }",
    "begin_line": 697,
    "end_line": 700,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.fileContentEquals#715",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.fileContentEquals(java.nio.file.Path, java.nio.file.Path)",
    "snippet": "public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }",
    "begin_line": 715,
    "end_line": 717,
    "comment": "/** \n * Compares the file contents of two Paths to determine if they are equal or not. \u003cp\u003e File content is accessed through  {@link Files#newInputStream(Path,OpenOption...)}. \u003c/p\u003e\n * @param path1 the first stream.\n * @param path2 the second stream.\n * @return true if the content of the streams are equal or they both don\u0027t exist, false otherwise.\n * @throws NullPointerException if either input is null.\n * @throws IOException          if an I/O error occurs.\n * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File,java.io.File)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.fileContentEquals#734",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.fileContentEquals(java.nio.file.Path, java.nio.file.Path, java.nio.file.LinkOption[], java.nio.file.OpenOption[])",
    "snippet": "public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n            throws IOException {\n        if (path1 \u003d\u003d null \u0026\u0026 path2 \u003d\u003d null) {\n            return true;\n        }\n        if (path1 \u003d\u003d null || path2 \u003d\u003d null) {\n            return false;\n        }\n        final Path nPath1 \u003d path1.normalize();\n        final Path nPath2 \u003d path2.normalize();\n        final boolean path1Exists \u003d exists(nPath1, linkOptions);\n        if (path1Exists !\u003d exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don\u0027t compare directory contents.\n            throw new IOException(\"Can\u0027t compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don\u0027t compare directory contents.\n            throw new IOException(\"Can\u0027t compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) !\u003d Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        // Faster:\n        try (RandomAccessFile raf1 \u003d RandomAccessFileMode.READ_ONLY.create(path1.toRealPath(linkOptions));\n                RandomAccessFile raf2 \u003d RandomAccessFileMode.READ_ONLY.create(path2.toRealPath(linkOptions))) {\n            return RandomAccessFiles.contentEquals(raf1, raf2);\n        } catch (UnsupportedOperationException e) {\n            // Slower:\n            // Handle\n            // java.lang.UnsupportedOperationException\n            // at com.sun.nio.zipfs.ZipPath.toFile(ZipPath.java:656)\n            try (InputStream inputStream1 \u003d Files.newInputStream(nPath1, openOptions);\n                    InputStream inputStream2 \u003d Files.newInputStream(nPath2, openOptions)) {\n                return IOUtils.contentEquals(inputStream1, inputStream2);\n            }\n        }\n    }",
    "begin_line": 734,
    "end_line": 783,
    "comment": "/** \n * Compares the file contents of two Paths to determine if they are equal or not. \u003cp\u003e File content is accessed through  {@link RandomAccessFileMode#create(Path)}. \u003c/p\u003e\n * @param path1       the first stream.\n * @param path2       the second stream.\n * @param linkOptions options specifying how files are followed.\n * @param openOptions ignored.\n * @return true if the content of the streams are equal or they both don\u0027t exist, false otherwise.\n * @throws NullPointerException if openOptions is null.\n * @throws IOException          if an I/O error occurs.\n * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File,java.io.File)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.filter#810",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.filter(org.apache.commons.io.file.PathFilter, java.nio.file.Path)",
    "snippet": "public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths \u003d\u003d null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }",
    "begin_line": 810,
    "end_line": 816,
    "comment": "/** \n * \u003cp\u003e Applies an  {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original file list that matches the providedfilter. \u003c/p\u003e \u003cp\u003e The  {@link Set} returned by this method is not guaranteed to be thread safe.\u003c/p\u003e \u003cpre\u003e Set\u0026lt;File\u0026gt; allFiles \u003d ... Set\u0026lt;File\u0026gt; javaFiles \u003d FileFilterUtils.filterSet(allFiles, FileFilterUtils.suffixFileFilter(\".java\")); \u003c/pre\u003e\n * @param filter the filter to apply to the set of files.\n * @param paths  the array of files to apply the filter to.\n * @return a subset of {@code files} that is accepted by the file filter.\n * @throws NullPointerException     if the filter is {@code null}\n * @throws IllegalArgumentException if {@code files} contains a {@code null} value.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.filterPaths#818",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.filterPaths(org.apache.commons.io.file.PathFilter, java.util.stream.Stream\u003cjava.nio.file.Path\u003e, java.util.stream.Collector\u003c? super java.nio.file.Path,A,R\u003e)",
    "snippet": "private static \u003cR, A\u003e R filterPaths(final PathFilter filter, final Stream\u003cPath\u003e stream, final Collector\u003c? super Path, A, R\u003e collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream \u003d\u003d null) {\n            return Stream.\u003cPath\u003eempty().collect(collector);\n        }\n        return stream.filter(p -\u003e {\n            try {\n                return p !\u003d null \u0026\u0026 filter.accept(p, readBasicFileAttributes(p)) \u003d\u003d FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }",
    "begin_line": 818,
    "end_line": 831,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getAclEntryList#841",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getAclEntryList(java.nio.file.Path)",
    "snippet": "public static List\u003cAclEntry\u003e getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView \u003d getAclFileAttributeView(sourcePath);\n        return fileAttributeView \u003d\u003d null ? null : fileAttributeView.getAcl();\n    }",
    "begin_line": 841,
    "end_line": 844,
    "comment": "/** \n * Reads the access control list from a file attribute view.\n * @param sourcePath the path to the file.\n * @return a file attribute view of the given type, or null if the attribute view type is not available.\n * @throws IOException if an I/O error occurs.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getAclFileAttributeView#854",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getAclFileAttributeView(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static AclFileAttributeView getAclFileAttributeView(final Path path, final LinkOption... options) {\n        return Files.getFileAttributeView(path, AclFileAttributeView.class, options);\n    }",
    "begin_line": 854,
    "end_line": 856,
    "comment": "/** \n * Shorthand for  {@code Files.getFileAttributeView(path, AclFileAttributeView.class)}.\n * @param path    the path to the file.\n * @param options how to handle symbolic links.\n * @return a AclFileAttributeView, or {@code null} if the attribute view type is not available.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getDosFileAttributeView#866",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getDosFileAttributeView(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static DosFileAttributeView getDosFileAttributeView(final Path path, final LinkOption... options) {\n        return Files.getFileAttributeView(path, DosFileAttributeView.class, options);\n    }",
    "begin_line": 866,
    "end_line": 868,
    "comment": "/** \n * Shorthand for  {@code Files.getFileAttributeView(path, DosFileAttributeView.class)}.\n * @param path    the path to the file.\n * @param options how to handle symbolic links.\n * @return a DosFileAttributeView, or {@code null} if the attribute view type is not available.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getFileName#880",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getFileName(java.nio.file.Path, java.util.function.Function\u003cjava.nio.file.Path,R\u003e)",
    "snippet": "public static \u003cR\u003e R getFileName(final Path path, Function\u003cPath, R\u003e function) {\n        final Path fileName \u003d path !\u003d null ? path.getFileName() : null;\n        return fileName !\u003d null ? function.apply(fileName) : null;\n    }",
    "begin_line": 880,
    "end_line": 883,
    "comment": "/** \n * Gets the Path\u0027s file name and apply the given function if the file name is non-null.\n * @param \u003c R \u003e The function\u0027s result type.\n * @param path the path to query.\n * @param function function to apply to the file name.\n * @return the Path\u0027s file name as a string or null.\n * @see Path#getFileName()\n * @since 2.16.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getFileNameString#893",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getFileNameString(java.nio.file.Path)",
    "snippet": "public static String getFileNameString(final Path path) {\n        return getFileName(path, Path::toString);\n    }",
    "begin_line": 893,
    "end_line": 895,
    "comment": "/** \n * Gets the Path\u0027s file name as a string.\n * @param path the path to query.\n * @return the Path\u0027s file name as a string or null.\n * @see Path#getFileName()\n * @since 2.16.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getLastModifiedFileTime#909",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getLastModifiedFileTime(java.io.File)",
    "snippet": "public static FileTime getLastModifiedFileTime(final File file) throws IOException {\n        return getLastModifiedFileTime(file.toPath(), null, EMPTY_LINK_OPTION_ARRAY);\n    }",
    "begin_line": 909,
    "end_line": 911,
    "comment": "/** \n * Gets the file\u0027s last modified time or null if the file does not exist. \u003cp\u003e The method provides a workaround for bug \u003ca href\u003d\"https://bugs.openjdk.java.net/browse/JDK-8177809\"\u003eJDK-8177809\u003c/a\u003e where  {@link File#lastModified()}looses milliseconds and always ends in 000. This bug is in OpenJDK 8 and 9, and fixed in 11. \u003c/p\u003e\n * @param file the file to query.\n * @return the file\u0027s last modified time.\n * @throws IOException Thrown if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getLastModifiedFileTime#923",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getLastModifiedFileTime(java.nio.file.Path, java.nio.file.attribute.FileTime, java.nio.file.LinkOption)",
    "snippet": "public static FileTime getLastModifiedFileTime(final Path path, final FileTime defaultIfAbsent, final LinkOption... options) throws IOException {\n        return Files.exists(path) ? getLastModifiedTime(path, options) : defaultIfAbsent;\n    }",
    "begin_line": 923,
    "end_line": 925,
    "comment": "/** \n * Gets the file\u0027s last modified time or null if the file does not exist.\n * @param path            the file to query.\n * @param defaultIfAbsent Returns this file time of the file does not exist, may be null.\n * @param options         options indicating how symbolic links are handled.\n * @return the file\u0027s last modified time.\n * @throws IOException Thrown if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getLastModifiedFileTime#936",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getLastModifiedFileTime(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static FileTime getLastModifiedFileTime(final Path path, final LinkOption... options) throws IOException {\n        return getLastModifiedFileTime(path, null, options);\n    }",
    "begin_line": 936,
    "end_line": 938,
    "comment": "/** \n * Gets the file\u0027s last modified time or null if the file does not exist.\n * @param path    the file to query.\n * @param options options indicating how symbolic links are handled.\n * @return the file\u0027s last modified time.\n * @throws IOException Thrown if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getLastModifiedFileTime#948",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getLastModifiedFileTime(java.net.URI)",
    "snippet": "public static FileTime getLastModifiedFileTime(final URI uri) throws IOException {\n        return getLastModifiedFileTime(Paths.get(uri), null, EMPTY_LINK_OPTION_ARRAY);\n    }",
    "begin_line": 948,
    "end_line": 950,
    "comment": "/** \n * Gets the file\u0027s last modified time or null if the file does not exist.\n * @param uri the file to query.\n * @return the file\u0027s last modified time.\n * @throws IOException Thrown if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getLastModifiedFileTime#961",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getLastModifiedFileTime(java.net.URL)",
    "snippet": "public static FileTime getLastModifiedFileTime(final URL url) throws IOException, URISyntaxException {\n        return getLastModifiedFileTime(url.toURI());\n    }",
    "begin_line": 961,
    "end_line": 963,
    "comment": "/** \n * Gets the file\u0027s last modified time or null if the file does not exist.\n * @param url the file to query.\n * @return the file\u0027s last modified time.\n * @throws IOException        Thrown if an I/O error occurs.\n * @throws URISyntaxException if the URL is not formatted strictly according to RFC2396 and cannot be converted to a URI.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getLastModifiedTime#965",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getLastModifiedTime(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "private static FileTime getLastModifiedTime(final Path path, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(Objects.requireNonNull(path, \"path\"), options);\n    }",
    "begin_line": 965,
    "end_line": 967,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getParent#969",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getParent(java.nio.file.Path)",
    "snippet": "private static Path getParent(final Path path) {\n        return path \u003d\u003d null ? null : path.getParent();\n    }",
    "begin_line": 969,
    "end_line": 971,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getPosixFileAttributeView#981",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getPosixFileAttributeView(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static PosixFileAttributeView getPosixFileAttributeView(final Path path, final LinkOption... options) {\n        return Files.getFileAttributeView(path, PosixFileAttributeView.class, options);\n    }",
    "begin_line": 981,
    "end_line": 983,
    "comment": "/** \n * Shorthand for  {@code Files.getFileAttributeView(path, PosixFileAttributeView.class)}.\n * @param path    the path to the file.\n * @param options how to handle symbolic links.\n * @return a PosixFileAttributeView, or {@code null} if the attribute view type is not available.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.getTempDirectory#991",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.getTempDirectory()",
    "snippet": "public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }",
    "begin_line": 991,
    "end_line": 993,
    "comment": "/** \n * Gets a  {@link Path} representing the system temporary directory.\n * @return the system temporary directory.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isDirectory#1007",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isDirectory(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path !\u003d null \u0026\u0026 Files.isDirectory(path, options);\n    }",
    "begin_line": 1007,
    "end_line": 1009,
    "comment": "/** \n * Tests whether the given  {@link Path} is a directory or not. Implemented as a null-safe delegate to{@code Files.isDirectory(Path path, LinkOption... options)}.\n * @param path    the path to the file.\n * @param options options indicating how to handle symbolic links\n * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a directory, or it cannot bedetermined if the file is a directory or not.\n * @throws SecurityException In the case of the default provider, and a security manager is installed, the {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isEmpty#1018",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isEmpty(java.nio.file.Path)",
    "snippet": "public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }",
    "begin_line": 1018,
    "end_line": 1020,
    "comment": "/** \n * Tests whether the given file or directory is empty.\n * @param path the file or directory to query.\n * @return whether the file or directory is empty.\n * @throws IOException if an I/O error occurs.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isEmptyDirectory#1032",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isEmptyDirectory(java.nio.file.Path)",
    "snippet": "public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream\u003cPath\u003e directoryStream \u003d Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }",
    "begin_line": 1032,
    "end_line": 1036,
    "comment": "/** \n * Tests whether the directory is empty.\n * @param directory the directory to query.\n * @return whether the directory is empty.\n * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e.\n * @throws IOException           if an I/O error occurs.\n * @throws SecurityException     In the case of the default provider, and a security manager is installed, the {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isEmptyFile#1047",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isEmptyFile(java.nio.file.Path)",
    "snippet": "public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) \u003c\u003d 0;\n    }",
    "begin_line": 1047,
    "end_line": 1049,
    "comment": "/** \n * Tests whether the given file is empty.\n * @param file the file to query.\n * @return whether the file is empty.\n * @throws IOException       if an I/O error occurs.\n * @throws SecurityException In the case of the default provider, and a security manager is installed, its {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isNewer#1062",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isNewer(java.nio.file.Path, java.time.chrono.ChronoZonedDateTime\u003c?\u003e, java.nio.file.LinkOption)",
    "snippet": "public static boolean isNewer(final Path file, final ChronoZonedDateTime\u003c?\u003e czdt, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(czdt, \"czdt\");\n        return isNewer(file, czdt.toInstant(), options);\n    }",
    "begin_line": 1062,
    "end_line": 1065,
    "comment": "/** \n * Tests if the given  {@link Path} is newer than the given time reference.\n * @param file    the {@link Path} to test.\n * @param czdt    the time reference.\n * @param options options indicating how to handle symbolic links.\n * @return true if the {@link Path} exists and has been modified after the given time reference.\n * @throws IOException          if an I/O error occurs.\n * @throws NullPointerException if the file is {@code null}.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isNewer#1078",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isNewer(java.nio.file.Path, java.nio.file.attribute.FileTime, java.nio.file.LinkOption)",
    "snippet": "public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) \u003e 0;\n    }",
    "begin_line": 1078,
    "end_line": 1083,
    "comment": "/** \n * Tests if the given  {@link Path} is newer than the given time reference.\n * @param file     the {@link Path} to test.\n * @param fileTime the time reference.\n * @param options  options indicating how to handle symbolic links.\n * @return true if the {@link Path} exists and has been modified after the given time reference.\n * @throws IOException          if an I/O error occurs.\n * @throws NullPointerException if the file is {@code null}.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isNewer#1096",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isNewer(java.nio.file.Path, java.time.Instant, java.nio.file.LinkOption)",
    "snippet": "public static boolean isNewer(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.from(instant), options);\n    }",
    "begin_line": 1096,
    "end_line": 1098,
    "comment": "/** \n * Tests if the given  {@link Path} is newer than the given time reference.\n * @param file    the {@link Path} to test.\n * @param instant the time reference.\n * @param options options indicating how to handle symbolic links.\n * @return true if the {@link Path} exists and has been modified after the given time reference.\n * @throws IOException          if an I/O error occurs.\n * @throws NullPointerException if the file is {@code null}.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isNewer#1111",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isNewer(java.nio.file.Path, long, java.nio.file.LinkOption)",
    "snippet": "public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.fromMillis(timeMillis), options);\n    }",
    "begin_line": 1111,
    "end_line": 1113,
    "comment": "/** \n * Tests if the given  {@link Path} is newer than the given time reference.\n * @param file       the {@link Path} to test.\n * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n * @param options    options indicating how to handle symbolic links.\n * @return true if the {@link Path} exists and has been modified after the given time reference.\n * @throws IOException          if an I/O error occurs.\n * @throws NullPointerException if the file is {@code null}.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isNewer#1124",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isNewer(java.nio.file.Path, java.nio.file.Path)",
    "snippet": "public static boolean isNewer(final Path file, final Path reference) throws IOException {\n        return isNewer(file, getLastModifiedTime(reference));\n    }",
    "begin_line": 1124,
    "end_line": 1126,
    "comment": "/** \n * Tests if the given  {@link Path} is newer than the reference {@link Path}.\n * @param file      the {@link File} to test.\n * @param reference the {@link File} of which the modification date is used.\n * @return true if the {@link File} exists and has been modified more recently than the reference {@link File}.\n * @throws IOException if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isOlder#1139",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isOlder(java.nio.file.Path, java.nio.file.attribute.FileTime, java.nio.file.LinkOption)",
    "snippet": "public static boolean isOlder(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) \u003c 0;\n    }",
    "begin_line": 1139,
    "end_line": 1144,
    "comment": "/** \n * Tests if the given  {@link Path} is older than the given time reference.\n * @param file     the {@link Path} to test.\n * @param fileTime the time reference.\n * @param options  options indicating how to handle symbolic links.\n * @return true if the {@link Path} exists and has been modified before the given time reference.\n * @throws IOException          if an I/O error occurs.\n * @throws NullPointerException if the file is {@code null}.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isOlder#1157",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isOlder(java.nio.file.Path, java.time.Instant, java.nio.file.LinkOption)",
    "snippet": "public static boolean isOlder(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.from(instant), options);\n    }",
    "begin_line": 1157,
    "end_line": 1159,
    "comment": "/** \n * Tests if the given  {@link Path} is older than the given time reference.\n * @param file    the {@link Path} to test.\n * @param instant the time reference.\n * @param options options indicating how to handle symbolic links.\n * @return true if the {@link Path} exists and has been modified before the given time reference.\n * @throws IOException          if an I/O error occurs.\n * @throws NullPointerException if the file is {@code null}.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isOlder#1172",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isOlder(java.nio.file.Path, long, java.nio.file.LinkOption)",
    "snippet": "public static boolean isOlder(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.fromMillis(timeMillis), options);\n    }",
    "begin_line": 1172,
    "end_line": 1174,
    "comment": "/** \n * Tests if the given  {@link Path} is older than the given time reference.\n * @param file       the {@link Path} to test.\n * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n * @param options    options indicating how to handle symbolic links.\n * @return true if the {@link Path} exists and has been modified before the given time reference.\n * @throws IOException          if an I/O error occurs.\n * @throws NullPointerException if the file is {@code null}.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isOlder#1185",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isOlder(java.nio.file.Path, java.nio.file.Path)",
    "snippet": "public static boolean isOlder(final Path file, final Path reference) throws IOException {\n        return isOlder(file, getLastModifiedTime(reference));\n    }",
    "begin_line": 1185,
    "end_line": 1187,
    "comment": "/** \n * Tests if the given  {@link Path} is older than the reference {@link Path}.\n * @param file      the {@link File} to test.\n * @param reference the {@link File} of which the modification date is used.\n * @return true if the {@link File} exists and has been modified before than the reference {@link File}.\n * @throws IOException if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isPosix#1197",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isPosix(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static boolean isPosix(final Path test, final LinkOption... options) {\n        return exists(test, options) \u0026\u0026 readPosixFileAttributes(test, options) !\u003d null;\n    }",
    "begin_line": 1197,
    "end_line": 1199,
    "comment": "/** \n * Tests whether the given path is on a POSIX file system.\n * @param test    The Path to test.\n * @param options options indicating how to handle symbolic links.\n * @return true if test is on a POSIX file system.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.isRegularFile#1213",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.isRegularFile(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path !\u003d null \u0026\u0026 Files.isRegularFile(path, options);\n    }",
    "begin_line": 1213,
    "end_line": 1215,
    "comment": "/** \n * Tests whether the given  {@link Path} is a regular file or not. Implemented as a null-safe delegate to{@code Files.isRegularFile(Path path, LinkOption... options)}.\n * @param path    the path to the file.\n * @param options options indicating how to handle symbolic links.\n * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is not a directory, or it cannot bedetermined if the file is a regular file or not.\n * @throws SecurityException In the case of the default provider, and a security manager is installed, the {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.newDirectoryStream#1229",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.newDirectoryStream(java.nio.file.Path, org.apache.commons.io.file.PathFilter)",
    "snippet": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }",
    "begin_line": 1229,
    "end_line": 1231,
    "comment": "/** \n * Creates a new DirectoryStream for Paths rooted at the given directory. \u003cp\u003e If you don\u0027t use the try-with-resources construct, then you must call the stream\u0027s  {@link Stream#close()} method after iteration is complete to free anyresources held for the open directory. \u003c/p\u003e\n * @param dir        the path to the directory to stream.\n * @param pathFilter the directory stream filter.\n * @return a new instance.\n * @throws IOException if an I/O error occurs.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.newOutputStream#1243",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.newOutputStream(java.nio.file.Path, boolean)",
    "snippet": "public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        return newOutputStream(path, EMPTY_LINK_OPTION_ARRAY, append ? OPEN_OPTIONS_APPEND : OPEN_OPTIONS_TRUNCATE);\n    }",
    "begin_line": 1243,
    "end_line": 1245,
    "comment": "/** \n * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes to the file.\n * @param path   the Path.\n * @param append Whether or not to append.\n * @return a new OutputStream.\n * @throws IOException if an I/O error occurs.\n * @see Files#newOutputStream(Path,OpenOption...)\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.newOutputStream#1247",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.newOutputStream(java.nio.file.Path, java.nio.file.LinkOption[], java.nio.file.OpenOption)",
    "snippet": "static OutputStream newOutputStream(final Path path, final LinkOption[] linkOptions, final OpenOption... openOptions) throws IOException {\n        if (!exists(path, linkOptions)) {\n            createParentDirectories(path, linkOptions !\u003d null \u0026\u0026 linkOptions.length \u003e 0 ? linkOptions[0] : NULL_LINK_OPTION);\n        }\n        final List\u003cOpenOption\u003e list \u003d new ArrayList\u003c\u003e(Arrays.asList(openOptions !\u003d null ? openOptions : EMPTY_OPEN_OPTION_ARRAY));\n        list.addAll(Arrays.asList(linkOptions !\u003d null ? linkOptions : EMPTY_LINK_OPTION_ARRAY));\n        return Files.newOutputStream(path, list.toArray(EMPTY_OPEN_OPTION_ARRAY));\n    }",
    "begin_line": 1247,
    "end_line": 1254,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.noFollowLinkOptionArray#1261",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.noFollowLinkOptionArray()",
    "snippet": "public static LinkOption[] noFollowLinkOptionArray() {\n        return NOFOLLOW_LINK_OPTION_ARRAY.clone();\n    }",
    "begin_line": 1261,
    "end_line": 1263,
    "comment": "/** \n * Copy of the  {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n * @return Copy of the {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.notExists#1265",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.notExists(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "private static boolean notExists(final Path path, final LinkOption... options) {\n        return Files.notExists(Objects.requireNonNull(path, \"path\"), options);\n    }",
    "begin_line": 1265,
    "end_line": 1267,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.overrideReadOnly#1275",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.overrideReadOnly(org.apache.commons.io.file.DeleteOption)",
    "snippet": "private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions \u003d\u003d null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -\u003e e \u003d\u003d StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }",
    "begin_line": 1275,
    "end_line": 1280,
    "comment": "/** \n * Returns true if the given options contain  {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n * @param deleteOptions the array to test\n * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.readAttributes#1293",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.readAttributes(java.nio.file.Path, java.lang.Class\u003cA\u003e, java.nio.file.LinkOption)",
    "snippet": "public static \u003cA extends BasicFileAttributes\u003e A readAttributes(final Path path, final Class\u003cA\u003e type, final LinkOption... options) {\n        try {\n            return path \u003d\u003d null ? null : Files.readAttributes(path, type, options);\n        } catch (final UnsupportedOperationException | IOException e) {\n            // For example, on Windows.\n            return null;\n        }\n    }",
    "begin_line": 1293,
    "end_line": 1300,
    "comment": "/** \n * Reads the BasicFileAttributes from the given path. Returns null if the attributes can\u0027t be read.\n * @param \u003c A \u003e     The {@link BasicFileAttributes} type\n * @param path    The Path to test.\n * @param type    the {@link Class} of the file attributes required to read.\n * @param options options indicating how to handle symbolic links.\n * @return the file attributes or null if the attributes can\u0027t be read.\n * @see Files#readAttributes(Path,Class,LinkOption...)\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.readBasicFileAttributes#1310",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.readBasicFileAttributes(java.nio.file.Path)",
    "snippet": "public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }",
    "begin_line": 1310,
    "end_line": 1312,
    "comment": "/** \n * Reads the BasicFileAttributes from the given path.\n * @param path the path to read.\n * @return the path attributes.\n * @throws IOException if an I/O error occurs.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.readBasicFileAttributes#1322",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.readBasicFileAttributes(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static BasicFileAttributes readBasicFileAttributes(final Path path, final LinkOption... options) {\n        return readAttributes(path, BasicFileAttributes.class, options);\n    }",
    "begin_line": 1322,
    "end_line": 1324,
    "comment": "/** \n * Reads the BasicFileAttributes from the given path. Returns null if the attributes can\u0027t be read.\n * @param path    the path to read.\n * @param options options indicating how to handle symbolic links.\n * @return the path attributes.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.readBasicFileAttributesUnchecked#1335",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.readBasicFileAttributesUnchecked(java.nio.file.Path)",
    "snippet": "@Deprecated\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        return readBasicFileAttributes(path, EMPTY_LINK_OPTION_ARRAY);\n    }",
    "begin_line": 1335,
    "end_line": 1337,
    "comment": "/** \n * Reads the BasicFileAttributes from the given path. Returns null if the attributes can\u0027t be read.\n * @param path the path to read.\n * @return the path attributes.\n * @since 2.9.0\n * @deprecated Use {@link #readBasicFileAttributes(Path,LinkOption...)}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.readDosFileAttributes#1347",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.readDosFileAttributes(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static DosFileAttributes readDosFileAttributes(final Path path, final LinkOption... options) {\n        return readAttributes(path, DosFileAttributes.class, options);\n    }",
    "begin_line": 1347,
    "end_line": 1349,
    "comment": "/** \n * Reads the DosFileAttributes from the given path. Returns null if the attributes can\u0027t be read.\n * @param path    the path to read.\n * @param options options indicating how to handle symbolic links.\n * @return the path attributes.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.readIfSymbolicLink#1351",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.readIfSymbolicLink(java.nio.file.Path)",
    "snippet": "private static Path readIfSymbolicLink(final Path path) throws IOException {\n        return path !\u003d null ? Files.isSymbolicLink(path) ? Files.readSymbolicLink(path) : path : null;\n    }",
    "begin_line": 1351,
    "end_line": 1353,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.readOsFileAttributes#1363",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.readOsFileAttributes(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static BasicFileAttributes readOsFileAttributes(final Path path, final LinkOption... options) {\n        final PosixFileAttributes fileAttributes \u003d readPosixFileAttributes(path, options);\n        return fileAttributes !\u003d null ? fileAttributes : readDosFileAttributes(path, options);\n    }",
    "begin_line": 1363,
    "end_line": 1366,
    "comment": "/** \n * Reads the PosixFileAttributes or DosFileAttributes from the given path. Returns null if the attributes can\u0027t be read.\n * @param path    The Path to read.\n * @param options options indicating how to handle symbolic links.\n * @return the file attributes.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.readPosixFileAttributes#1376",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.readPosixFileAttributes(java.nio.file.Path, java.nio.file.LinkOption)",
    "snippet": "public static PosixFileAttributes readPosixFileAttributes(final Path path, final LinkOption... options) {\n        return readAttributes(path, PosixFileAttributes.class, options);\n    }",
    "begin_line": 1376,
    "end_line": 1378,
    "comment": "/** \n * Reads the PosixFileAttributes from the given path. Returns null instead of throwing  {@link UnsupportedOperationException}.\n * @param path    The Path to read.\n * @param options options indicating how to handle symbolic links.\n * @return the file attributes.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.readString#1390",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.readString(java.nio.file.Path, java.nio.charset.Charset)",
    "snippet": "public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }",
    "begin_line": 1390,
    "end_line": 1392,
    "comment": "/** \n * Reads the given path as a String.\n * @param path    The source path.\n * @param charset How to convert bytes to a String, null uses the default Charset.\n * @return a new String.\n * @throws IOException if an I/O error occurs reading from the stream.\n * @see Files#readAllBytes(Path)\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.relativize#1403",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.relativize(java.util.Collection\u003cjava.nio.file.Path\u003e, java.nio.file.Path, boolean, java.util.Comparator\u003c? super java.nio.file.Path\u003e)",
    "snippet": "static List\u003cPath\u003e relativize(final Collection\u003cPath\u003e collection, final Path parent, final boolean sort, final Comparator\u003c? super Path\u003e comparator) {\n        Stream\u003cPath\u003e stream \u003d collection.stream().map(parent::relativize);\n        if (sort) {\n            stream \u003d comparator \u003d\u003d null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }",
    "begin_line": 1403,
    "end_line": 1409,
    "comment": "/** \n * Relativizes all files in the given  {@code collection} against a {@code parent}.\n * @param collection The collection of paths to relativize.\n * @param parent     relativizes against this parent path.\n * @param sort       Whether to sort the result.\n * @param comparator How to sort.\n * @return A collection of relativized paths, optionally sorted.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.requireExists#1421",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.requireExists(java.nio.file.Path, java.lang.String, java.nio.file.LinkOption)",
    "snippet": "private static Path requireExists(final Path file, final String fileParamName, final LinkOption... options) {\n        Objects.requireNonNull(file, fileParamName);\n        if (!exists(file, options)) {\n            throw new IllegalArgumentException(\"File system element for parameter \u0027\" + fileParamName + \"\u0027 does not exist: \u0027\" + file + \"\u0027\");\n        }\n        return file;\n    }",
    "begin_line": 1421,
    "end_line": 1427,
    "comment": "/** \n * Requires that the given  {@link File} exists and throws an {@link IllegalArgumentException} if it doesn\u0027t.\n * @param file          The {@link File} to check.\n * @param fileParamName The parameter name to use in the exception message in case of {@code null} input.\n * @param options       options indicating how to handle symbolic links.\n * @return the given file.\n * @throws NullPointerException     if the given {@link File} is {@code null}.\n * @throws IllegalArgumentException if the given {@link File} does not exist.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.setDosReadOnly#1429",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.setDosReadOnly(java.nio.file.Path, boolean, java.nio.file.LinkOption)",
    "snippet": "private static boolean setDosReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final DosFileAttributeView dosFileAttributeView \u003d getDosFileAttributeView(path, linkOptions);\n        if (dosFileAttributeView !\u003d null) {\n            dosFileAttributeView.setReadOnly(readOnly);\n            return true;\n        }\n        return false;\n    }",
    "begin_line": 1429,
    "end_line": 1436,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.setLastModifiedTime#1448",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.setLastModifiedTime(java.nio.file.Path, java.nio.file.Path)",
    "snippet": "public static void setLastModifiedTime(final Path sourceFile, final Path targetFile) throws IOException {\n        Objects.requireNonNull(sourceFile, \"sourceFile\");\n        Files.setLastModifiedTime(targetFile, getLastModifiedTime(sourceFile));\n    }",
    "begin_line": 1448,
    "end_line": 1451,
    "comment": "/** \n * Sets the given  {@code targetFile}\u0027s last modified time to the value from  {@code sourceFile}.\n * @param sourceFile The source path to query.\n * @param targetFile The target path to set.\n * @throws NullPointerException if sourceFile is {@code null}.\n * @throws NullPointerException if targetFile is {@code null}.\n * @throws IOException          if setting the last-modified time failed.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.setPosixDeletePermissions#1462",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.setPosixDeletePermissions(java.nio.file.Path, boolean, java.nio.file.LinkOption)",
    "snippet": "private static boolean setPosixDeletePermissions(final Path parent, final boolean enableDeleteChildren, final LinkOption... linkOptions)\n            throws IOException {\n        // To delete a file in POSIX, you need write and execute permissions on its parent directory.\n        // @formatter:off\n        return setPosixPermissions(parent, enableDeleteChildren, Arrays.asList(\n            PosixFilePermission.OWNER_WRITE,\n            //PosixFilePermission.GROUP_WRITE,\n            //PosixFilePermission.OTHERS_WRITE,\n            PosixFilePermission.OWNER_EXECUTE\n            //PosixFilePermission.GROUP_EXECUTE,\n            //PosixFilePermission.OTHERS_EXECUTE\n            ), linkOptions);\n        // @formatter:on\n    }",
    "begin_line": 1462,
    "end_line": 1475,
    "comment": "/** \n * To delete a file in POSIX, you need Write and Execute permissions on its parent directory.\n * @param parent               The parent path for a file element to delete which needs RW permissions.\n * @param enableDeleteChildren true to set permissions to delete.\n * @param linkOptions          options indicating how handle symbolic links.\n * @return true if the operation was attempted and succeeded, false if parent is null.\n * @throws IOException if an I/O error occurs.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.setPosixPermissions#1487",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.setPosixPermissions(java.nio.file.Path, boolean, java.util.List\u003cjava.nio.file.attribute.PosixFilePermission\u003e, java.nio.file.LinkOption)",
    "snippet": "private static boolean setPosixPermissions(final Path path, final boolean addPermissions, final List\u003cPosixFilePermission\u003e updatePermissions,\n            final LinkOption... linkOptions) throws IOException {\n        if (path !\u003d null) {\n            final Set\u003cPosixFilePermission\u003e permissions \u003d Files.getPosixFilePermissions(path, linkOptions);\n            if (addPermissions) {\n                permissions.addAll(updatePermissions);\n            } else {\n                permissions.removeAll(updatePermissions);\n            }\n            Files.setPosixFilePermissions(path, permissions);\n            return true;\n        }\n        return false;\n    }",
    "begin_line": 1487,
    "end_line": 1500,
    "comment": "/** \n * Low-level POSIX permission operation to set permissions.\n * @param path              Set this path\u0027s permissions.\n * @param addPermissions    true to add, false to remove.\n * @param updatePermissions the List of PosixFilePermission to add or remove.\n * @param linkOptions       options indicating how handle symbolic links.\n * @return true if the operation was attempted and succeeded, false if parent is null.\n * @throws IOException if an I/O error occurs.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.setPosixReadOnlyFile#1502",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.setPosixReadOnlyFile(java.nio.file.Path, boolean, java.nio.file.LinkOption)",
    "snippet": "private static void setPosixReadOnlyFile(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        // Not Windows 10\n        final Set\u003cPosixFilePermission\u003e permissions \u003d Files.getPosixFilePermissions(path, linkOptions);\n        // @formatter:off\n        final List\u003cPosixFilePermission\u003e readPermissions \u003d Arrays.asList(\n                PosixFilePermission.OWNER_READ\n                //PosixFilePermission.GROUP_READ,\n                //PosixFilePermission.OTHERS_READ\n            );\n        final List\u003cPosixFilePermission\u003e writePermissions \u003d Arrays.asList(\n                PosixFilePermission.OWNER_WRITE\n                //PosixFilePermission.GROUP_WRITE,\n                //PosixFilePermission.OTHERS_WRITE\n            );\n        // @formatter:on\n        if (readOnly) {\n            // RO: We can read, we cannot write.\n            permissions.addAll(readPermissions);\n            permissions.removeAll(writePermissions);\n        } else {\n            // Not RO: We can read, we can write.\n            permissions.addAll(readPermissions);\n            permissions.addAll(writePermissions);\n        }\n        Files.setPosixFilePermissions(path, permissions);\n    }",
    "begin_line": 1502,
    "end_line": 1527,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.setReadOnly#1542",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.setReadOnly(java.nio.file.Path, boolean, java.nio.file.LinkOption)",
    "snippet": "public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        try {\n            // Windows is simplest\n            if (setDosReadOnly(path, readOnly, linkOptions)) {\n                return path;\n            }\n        } catch (final IOException ignored) {\n            // Retry with POSIX below.\n        }\n        final Path parent \u003d getParent(path);\n        if (!isPosix(parent, linkOptions)) { // Test parent because we may not the permissions to test the file.\n            throw new IOException(String.format(\"DOS or POSIX file operations not available for \u0027%s\u0027 %s\", path, Arrays.toString(linkOptions)));\n        }\n        // POSIX\n        if (readOnly) {\n            // RO\n            // File, then parent dir (if any).\n            setPosixReadOnlyFile(path, readOnly, linkOptions);\n            setPosixDeletePermissions(parent, false, linkOptions);\n        } else {\n            // RE\n            // Parent dir (if any), then file.\n            setPosixDeletePermissions(parent, true, linkOptions);\n        }\n        return path;\n    }",
    "begin_line": 1542,
    "end_line": 1567,
    "comment": "/** \n * Sets the given Path to the  {@code readOnly} value.\u003cp\u003e This behavior is OS dependent. \u003c/p\u003e\n * @param path        The path to set.\n * @param readOnly    true for read-only, false for not read-only.\n * @param linkOptions options indicating how to handle symbolic links.\n * @return The given path.\n * @throws IOException if an I/O error occurs.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.sizeOf#1584",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.sizeOf(java.nio.file.Path)",
    "snippet": "public static long sizeOf(final Path path) throws IOException {\n        requireExists(path, \"path\");\n        return Files.isDirectory(path) ? sizeOfDirectory(path) : Files.size(path);\n    }",
    "begin_line": 1584,
    "end_line": 1587,
    "comment": "/** \n * Returns the size of the given file or directory. If the provided  {@link Path} is a regular file, then the file\u0027s size is returned. If the argument is adirectory, then the size of the directory is calculated recursively. \u003cp\u003e Note that overflow is not detected, and the return value may be negative if overflow occurs. See  {@link #sizeOfAsBigInteger(Path)} for an alternativemethod that does not overflow. \u003c/p\u003e\n * @param path the regular file or directory to return the size of, must not be {@code null}.\n * @return the length of the file, or recursive size of the directory, in bytes.\n * @throws NullPointerException     if the file is {@code null}.\n * @throws IllegalArgumentException if the file does not exist.\n * @throws IOException              if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.sizeOfAsBigInteger#1600",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.sizeOfAsBigInteger(java.nio.file.Path)",
    "snippet": "public static BigInteger sizeOfAsBigInteger(final Path path) throws IOException {\n        requireExists(path, \"path\");\n        return Files.isDirectory(path) ? sizeOfDirectoryAsBigInteger(path) : BigInteger.valueOf(Files.size(path));\n    }",
    "begin_line": 1600,
    "end_line": 1603,
    "comment": "/** \n * Returns the size of the given file or directory. If the provided  {@link Path} is a regular file, then the file\u0027s size is returned. If the argument is adirectory, then the size of the directory is calculated recursively.\n * @param path the regular file or directory to return the size of (must not be {@code null}).\n * @return the length of the file, or recursive size of the directory, provided (in bytes).\n * @throws NullPointerException     if the file is {@code null}.\n * @throws IllegalArgumentException if the file does not exist.\n * @throws IOException              if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.sizeOfDirectory#1618",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.sizeOfDirectory(java.nio.file.Path)",
    "snippet": "public static long sizeOfDirectory(final Path directory) throws IOException {\n        return countDirectory(directory).getByteCounter().getLong();\n    }",
    "begin_line": 1618,
    "end_line": 1620,
    "comment": "/** \n * Counts the size of a directory recursively (sum of the size of all files). \u003cp\u003e Note that overflow is not detected, and the return value may be negative if overflow occurs. See  {@link #sizeOfDirectoryAsBigInteger(Path)} for analternative method that does not overflow. \u003c/p\u003e\n * @param directory directory to inspect, must not be {@code null}.\n * @return size of directory in bytes, 0 if directory is security restricted, a negative number when the real total is greater than {@link Long#MAX_VALUE}.\n * @throws NullPointerException if the directory is {@code null}.\n * @throws IOException          if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.sizeOfDirectoryAsBigInteger#1631",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.sizeOfDirectoryAsBigInteger(java.nio.file.Path)",
    "snippet": "public static BigInteger sizeOfDirectoryAsBigInteger(final Path directory) throws IOException {\n        return countDirectoryAsBigInteger(directory).getByteCounter().getBigInteger();\n    }",
    "begin_line": 1631,
    "end_line": 1633,
    "comment": "/** \n * Counts the size of a directory recursively (sum of the size of all files).\n * @param directory directory to inspect, must not be {@code null}.\n * @return size of directory in bytes, 0 if directory is security restricted.\n * @throws NullPointerException if the directory is {@code null}.\n * @throws IOException          if an I/O error occurs.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.toFileVisitOptionSet#1641",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.toFileVisitOptionSet(java.nio.file.FileVisitOption)",
    "snippet": "static Set\u003cFileVisitOption\u003e toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions \u003d\u003d null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }",
    "begin_line": 1641,
    "end_line": 1643,
    "comment": "/** \n * Converts an array of  {@link FileVisitOption} to a {@link Set}.\n * @param fileVisitOptions input array.\n * @return a new Set.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.touch#1655",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.touch(java.nio.file.Path)",
    "snippet": "public static Path touch(final Path file) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        if (!Files.exists(file)) {\n            createParentDirectories(file);\n            Files.createFile(file);\n        } else {\n            FileTimes.setLastModifiedTime(file);\n        }\n        return file;\n    }",
    "begin_line": 1655,
    "end_line": 1664,
    "comment": "/** \n * Implements behavior similar to the Unix \"touch\" utility. Creates a new file with size 0, or, if the file exists, just updates the file\u0027s modified time. this method creates parent directories if they do not exist.\n * @param file the file to touch.\n * @return The given file.\n * @throws NullPointerException if the parameter is {@code null}.\n * @throws IOException          if setting the last-modified time failed or an I/O problem occurs.\\\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.visitFileTree#1680",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.visitFileTree(T, java.nio.file.Path)",
    "snippet": "public static \u003cT extends FileVisitor\u003c? super Path\u003e\u003e T visitFileTree(final T visitor, final Path directory) throws IOException {\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }",
    "begin_line": 1680,
    "end_line": 1683,
    "comment": "/** \n * Performs  {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.Note that  {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n * @param visitor   See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @param \u003c T \u003e       See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @return the given visitor.\n * @throws NoSuchFileException  if the directory does not exist.\n * @throws IOException          if an I/O error is thrown by a visitor method.\n * @throws NullPointerException if the directory is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.visitFileTree#1699",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.visitFileTree(T, java.nio.file.Path, java.util.Set\u003cjava.nio.file.FileVisitOption\u003e, int)",
    "snippet": "public static \u003cT extends FileVisitor\u003c? super Path\u003e\u003e T visitFileTree(final T visitor, final Path start, final Set\u003cFileVisitOption\u003e options,\n            final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }",
    "begin_line": 1699,
    "end_line": 1703,
    "comment": "/** \n * Performs  {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.Note that  {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n * @param start    See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @param options  See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @param visitor  See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @param \u003c T \u003e      See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n * @return the given visitor.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.visitFileTree#1718",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.visitFileTree(T, java.lang.String, java.lang.String)",
    "snippet": "public static \u003cT extends FileVisitor\u003c? super Path\u003e\u003e T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }",
    "begin_line": 1718,
    "end_line": 1720,
    "comment": "/** \n * Performs  {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.Note that  {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @param first   See {@link Paths#get(String,String[])}.\n * @param more    See {@link Paths#get(String,String[])}.\n * @param \u003c T \u003e     See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @return the given visitor.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.visitFileTree#1734",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.visitFileTree(T, java.net.URI)",
    "snippet": "public static \u003cT extends FileVisitor\u003c? super Path\u003e\u003e T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }",
    "begin_line": 1734,
    "end_line": 1736,
    "comment": "/** \n * Performs  {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.Note that  {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @param uri     See {@link Paths#get(URI)}.\n * @param \u003c T \u003e     See {@link Files#walkFileTree(Path,FileVisitor)}.\n * @return the given visitor.\n * @throws IOException if an I/O error is thrown by a visitor method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.waitFor#1751",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.waitFor(java.nio.file.Path, java.time.Duration, java.nio.file.LinkOption)",
    "snippet": "public static boolean waitFor(final Path file, final Duration timeout, final LinkOption... options) {\n        Objects.requireNonNull(file, \"file\");\n        final Instant finishInstant \u003d Instant.now().plus(timeout);\n        boolean interrupted \u003d false;\n        final long minSleepMillis \u003d 100;\n        try {\n            while (!exists(file, options)) {\n                final Instant now \u003d Instant.now();\n                if (now.isAfter(finishInstant)) {\n                    return false;\n                }\n                try {\n                    ThreadUtils.sleep(Duration.ofMillis(Math.min(minSleepMillis, finishInstant.minusMillis(now.toEpochMilli()).toEpochMilli())));\n                } catch (final InterruptedException ignore) {\n                    interrupted \u003d true;\n                } catch (final Exception ex) {\n                    break;\n                }\n            }\n        } finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        return exists(file, options);\n    }",
    "begin_line": 1751,
    "end_line": 1776,
    "comment": "/** \n * Waits for the file system to propagate a file creation, with a timeout. \u003cp\u003e This method repeatedly tests  {@link Files#exists(Path,LinkOption...)} until it returns true up to the maximum time given.\u003c/p\u003e\n * @param file    the file to check, must not be {@code null}.\n * @param timeout the maximum time to wait.\n * @param options options indicating how to handle symbolic links.\n * @return true if file exists.\n * @throws NullPointerException if the file is {@code null}.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.walk#1795",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.walk(java.nio.file.Path, org.apache.commons.io.file.PathFilter, int, boolean, java.nio.file.FileVisitOption)",
    "snippet": "public static Stream\u003cPath\u003e walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n            final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n                .filter(path -\u003e pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) \u003d\u003d FileVisitResult.CONTINUE);\n    }",
    "begin_line": 1795,
    "end_line": 1799,
    "comment": "/** \n * Returns a stream of filtered paths. \u003cp\u003e The returned  {@link Stream} may wrap one or more {@link DirectoryStream}s. When you require timely disposal of file system resources, use a {@code try}-with-resources block to ensure invocation of the stream\u0027s  {@link Stream#close()} method after the stream operations are completed. Calling aclosed stream causes a  {@link IllegalStateException}. \u003c/p\u003e\n * @param start          the start path\n * @param pathFilter     the path filter\n * @param maxDepth       the maximum depth of directories to walk.\n * @param readAttributes whether to call the filters with file attributes (false passes null).\n * @param options        the options to configure the walk.\n * @return a filtered stream of paths.\n * @throws IOException if an I/O error is thrown when accessing the starting file.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.withPosixFileAttributes#1801",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.withPosixFileAttributes(java.nio.file.Path, java.nio.file.LinkOption[], boolean, org.apache.commons.io.function.IOFunction\u003cjava.nio.file.attribute.PosixFileAttributes,R\u003e)",
    "snippet": "private static \u003cR\u003e R withPosixFileAttributes(final Path path, final LinkOption[] linkOptions, final boolean overrideReadOnly,\n            final IOFunction\u003cPosixFileAttributes, R\u003e function) throws IOException {\n        final PosixFileAttributes posixFileAttributes \u003d overrideReadOnly ? readPosixFileAttributes(path, linkOptions) : null;\n        try {\n            return function.apply(posixFileAttributes);\n        } finally {\n            if (posixFileAttributes !\u003d null \u0026\u0026 path !\u003d null \u0026\u0026 Files.exists(path, linkOptions)) {\n                Files.setPosixFilePermissions(path, posixFileAttributes.permissions());\n            }\n        }\n    }",
    "begin_line": 1801,
    "end_line": 1811,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.writeString#1825",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.writeString(java.nio.file.Path, java.lang.CharSequence, java.nio.charset.Charset, java.nio.file.OpenOption)",
    "snippet": "public static Path writeString(final Path path, final CharSequence charSequence, final Charset charset, final OpenOption... openOptions)\n            throws IOException {\n        // Check the text is not null before opening file.\n        Objects.requireNonNull(path, \"path\");\n        Objects.requireNonNull(charSequence, \"charSequence\");\n        Files.write(path, String.valueOf(charSequence).getBytes(Charsets.toCharset(charset)), openOptions);\n        return path;\n    }",
    "begin_line": 1825,
    "end_line": 1832,
    "comment": "/** \n * Writes the given character sequence to a file at the given path.\n * @param path         The target file.\n * @param charSequence The character sequence text.\n * @param charset      The Charset to encode the text.\n * @param openOptions  options How to open the file.\n * @return The given path.\n * @throws IOException          if an I/O error occurs writing to or creating the file.\n * @throws NullPointerException if either {@code path} or {@code charSequence} is {@code null}.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "RelativeSortedPaths.PathUtils#1837",
    "is_bug": true,
    "src_path": "org/apache/commons/io/file/PathUtils.java",
    "class_name": "org.apache.commons.io.file.PathUtils",
    "signature": "org.apache.commons.io.file.PathUtils.PathUtils()",
    "snippet": "private PathUtils() {\n        // do not instantiate.\n    }",
    "begin_line": 1837,
    "end_line": 1839,
    "comment": "/** \n * Prevents instantiation.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.toDefaultFileVisitResult#44",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.toDefaultFileVisitResult(boolean)",
    "snippet": "static FileVisitResult toDefaultFileVisitResult(final boolean accept) {\n        return accept ? FileVisitResult.CONTINUE : FileVisitResult.TERMINATE;\n    }",
    "begin_line": 44,
    "end_line": 46,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.AbstractFileFilter#61",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.AbstractFileFilter()",
    "snippet": "public AbstractFileFilter() {\n        this(FileVisitResult.CONTINUE, FileVisitResult.TERMINATE);\n    }",
    "begin_line": 61,
    "end_line": 63,
    "comment": "/** \n * Constructs a new instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.AbstractFileFilter#72",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.AbstractFileFilter(java.nio.file.FileVisitResult, java.nio.file.FileVisitResult)",
    "snippet": "protected AbstractFileFilter(final FileVisitResult onAccept, final FileVisitResult onReject) {\n        this.onAccept \u003d onAccept;\n        this.onReject \u003d onReject;\n    }",
    "begin_line": 72,
    "end_line": 75,
    "comment": "/** \n * Constructs a new instance.\n * @param onAccept What to do on acceptance.\n * @param onReject What to do on rejection.\n * @since 2.12.0.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.accept#84",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        Objects.requireNonNull(file, \"file\");\n        return accept(file.getParentFile(), file.getName());\n    }",
    "begin_line": 84,
    "end_line": 87,
    "comment": "/** \n * Checks to see if the File should be accepted by this filter.\n * @param file the File to check\n * @return true if this file matches the test\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.accept#97",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.accept(java.io.File, java.lang.String)",
    "snippet": "@Override\n    public boolean accept(final File dir, final String name) {\n        Objects.requireNonNull(name, \"name\");\n        return accept(new File(dir, name));\n    }",
    "begin_line": 97,
    "end_line": 100,
    "comment": "/** \n * Checks to see if the File should be accepted by this filter.\n * @param dir the directory File to check\n * @param name the file name within the directory to check\n * @return true if this file matches the test\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.append#102",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.append(java.util.List\u003c?\u003e, java.lang.StringBuilder)",
    "snippet": "void append(final List\u003c?\u003e list, final StringBuilder buffer) {\n        for (int i \u003d 0; i \u003c list.size(); i++) {\n            if (i \u003e 0) {\n                buffer.append(\",\");\n            }\n            buffer.append(list.get(i));\n        }\n    }",
    "begin_line": 102,
    "end_line": 109,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.append#111",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.append(java.lang.Object[], java.lang.StringBuilder)",
    "snippet": "void append(final Object[] array, final StringBuilder buffer) {\n        for (int i \u003d 0; i \u003c array.length; i++) {\n            if (i \u003e 0) {\n                buffer.append(\",\");\n            }\n            buffer.append(array[i]);\n        }\n    }",
    "begin_line": 111,
    "end_line": 118,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.get#120",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.get(org.apache.commons.io.function.IOSupplier\u003cjava.nio.file.FileVisitResult\u003e)",
    "snippet": "FileVisitResult get(final IOSupplier\u003cFileVisitResult\u003e supplier) {\n        try {\n            return supplier.get();\n        } catch (IOException e) {\n            return handle(e);\n        }\n    }",
    "begin_line": 120,
    "end_line": 126,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.handle#135",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.handle(java.lang.Throwable)",
    "snippet": "protected FileVisitResult handle(final Throwable t) {\n        return FileVisitResult.TERMINATE;\n    }",
    "begin_line": 135,
    "end_line": 137,
    "comment": "/** \n * Handles exceptions caught while accepting.\n * @param t the caught Throwable.\n * @return the given Throwable.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.postVisitDirectory#140",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.postVisitDirectory(java.nio.file.Path, java.io.IOException)",
    "snippet": "@Override\n    public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n        return FileVisitResult.CONTINUE;\n    }",
    "begin_line": 140,
    "end_line": 142,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.preVisitDirectory#145",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.preVisitDirectory(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attributes) throws IOException {\n        return accept(dir, attributes);\n    }",
    "begin_line": 145,
    "end_line": 147,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.toFileVisitResult#155",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.toFileVisitResult(boolean)",
    "snippet": "FileVisitResult toFileVisitResult(final boolean accept) {\n        return accept ? onAccept : onReject;\n    }",
    "begin_line": 155,
    "end_line": 157,
    "comment": "/** \n * Converts a boolean into a FileVisitResult.\n * @param accept accepted or rejected.\n * @return a FileVisitResult.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.toString#165",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.toString()",
    "snippet": "@Override\n    public String toString() {\n        return getClass().getSimpleName();\n    }",
    "begin_line": 165,
    "end_line": 167,
    "comment": "/** \n * Provides a String representation of this file filter.\n * @return a String representation\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.visitFile#170",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.visitFile(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult visitFile(final Path file, final BasicFileAttributes attributes) throws IOException {\n        return accept(file, attributes);\n    }",
    "begin_line": 170,
    "end_line": 172,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFileFilter.visitFileFailed#175",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AbstractFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AbstractFileFilter",
    "signature": "org.apache.commons.io.filefilter.AbstractFileFilter.visitFileFailed(java.nio.file.Path, java.io.IOException)",
    "snippet": "@Override\n    public FileVisitResult visitFileFailed(final Path file, final IOException exc) throws IOException {\n        return FileVisitResult.CONTINUE;\n    }",
    "begin_line": 175,
    "end_line": 177,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.AndFileFilter#58",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.AndFileFilter()",
    "snippet": "public AndFileFilter() {\n        this(0);\n    }",
    "begin_line": 58,
    "end_line": 60,
    "comment": "/** \n * Constructs a new empty instance.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.AndFileFilter#67",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.AndFileFilter(java.util.ArrayList\u003corg.apache.commons.io.filefilter.IOFileFilter\u003e)",
    "snippet": "private AndFileFilter(final ArrayList\u003cIOFileFilter\u003e initialList) {\n        this.fileFilters \u003d Objects.requireNonNull(initialList, \"initialList\");\n    }",
    "begin_line": 67,
    "end_line": 69,
    "comment": "/** \n * Constructs a new instance with the given initial list.\n * @param initialList the initial list.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.AndFileFilter#76",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.AndFileFilter(int)",
    "snippet": "private AndFileFilter(final int initialCapacity) {\n        this(new ArrayList\u003c\u003e(initialCapacity));\n    }",
    "begin_line": 76,
    "end_line": 78,
    "comment": "/** \n * Constructs a new instance with the given initial capacity.\n * @param initialCapacity the initial capacity.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.AndFileFilter#86",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.AndFileFilter(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public AndFileFilter(final IOFileFilter... fileFilters) {\n        this(Objects.requireNonNull(fileFilters, \"fileFilters\").length);\n        addFileFilter(fileFilters);\n    }",
    "begin_line": 86,
    "end_line": 89,
    "comment": "/** \n * Constructs a new instance for the give filters.\n * @param fileFilters filters to OR.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.AndFileFilter#98",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.AndFileFilter(org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public AndFileFilter(final IOFileFilter filter1, final IOFileFilter filter2) {\n        this(2);\n        addFileFilter(filter1);\n        addFileFilter(filter2);\n    }",
    "begin_line": 98,
    "end_line": 102,
    "comment": "/** \n * Constructs a new file filter that ANDs the result of other filters.\n * @param filter1  the first filter, must second be null\n * @param filter2  the first filter, must not be null\n * @throws IllegalArgumentException if either filter is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.AndFileFilter#111",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.AndFileFilter(java.util.List\u003corg.apache.commons.io.filefilter.IOFileFilter\u003e)",
    "snippet": "public AndFileFilter(final List\u003cIOFileFilter\u003e fileFilters) {\n        this(new ArrayList\u003c\u003e(Objects.requireNonNull(fileFilters, \"fileFilters\")));\n    }",
    "begin_line": 111,
    "end_line": 113,
    "comment": "/** \n * Constructs a new instance of  {@link AndFileFilter}with the specified list of filters.\n * @param fileFilters  a List of IOFileFilter instances, copied.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.accept#119",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        return !isEmpty() \u0026\u0026 fileFilters.stream().allMatch(fileFilter -\u003e fileFilter.accept(file));\n    }",
    "begin_line": 119,
    "end_line": 121,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.accept#127",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.accept(java.io.File, java.lang.String)",
    "snippet": "@Override\n    public boolean accept(final File file, final String name) {\n        return !isEmpty() \u0026\u0026 fileFilters.stream().allMatch(fileFilter -\u003e fileFilter.accept(file, name));\n    }",
    "begin_line": 127,
    "end_line": 129,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.accept#136",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return isEmpty() ? FileVisitResult.TERMINATE\n                : toDefaultFileVisitResult(fileFilters.stream().allMatch(fileFilter -\u003e fileFilter.accept(file, attributes) \u003d\u003d FileVisitResult.CONTINUE));\n    }",
    "begin_line": 136,
    "end_line": 139,
    "comment": "/** \n * {@inheritDoc}\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.addFileFilter#145",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.addFileFilter(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "@Override\n    public void addFileFilter(final IOFileFilter fileFilter) {\n        this.fileFilters.add(Objects.requireNonNull(fileFilter, \"fileFilter\"));\n    }",
    "begin_line": 145,
    "end_line": 147,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.addFileFilter#155",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.addFileFilter(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public void addFileFilter(final IOFileFilter... fileFilters) {\n        Stream.of(Objects.requireNonNull(fileFilters, \"fileFilters\")).forEach(this::addFileFilter);\n    }",
    "begin_line": 155,
    "end_line": 157,
    "comment": "/** \n * Adds the given file filters.\n * @param fileFilters the filters to add.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.getFileFilters#163",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.getFileFilters()",
    "snippet": "@Override\n    public List\u003cIOFileFilter\u003e getFileFilters() {\n        return Collections.unmodifiableList(this.fileFilters);\n    }",
    "begin_line": 163,
    "end_line": 165,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.isEmpty#167",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.isEmpty()",
    "snippet": "private boolean isEmpty() {\n        return this.fileFilters.isEmpty();\n    }",
    "begin_line": 167,
    "end_line": 169,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.removeFileFilter#175",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.removeFileFilter(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "@Override\n    public boolean removeFileFilter(final IOFileFilter ioFileFilter) {\n        return this.fileFilters.remove(ioFileFilter);\n    }",
    "begin_line": 175,
    "end_line": 177,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.setFileFilters#183",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.setFileFilters(java.util.List\u003corg.apache.commons.io.filefilter.IOFileFilter\u003e)",
    "snippet": "@Override\n    public void setFileFilters(final List\u003cIOFileFilter\u003e fileFilters) {\n        this.fileFilters.clear();\n        this.fileFilters.addAll(fileFilters);\n    }",
    "begin_line": 183,
    "end_line": 186,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AndFileFilter.toString#194",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/AndFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.AndFileFilter",
    "signature": "org.apache.commons.io.filefilter.AndFileFilter.toString()",
    "snippet": "@Override\n    public String toString() {\n        final StringBuilder buffer \u003d new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        append(fileFilters, buffer);\n        buffer.append(\")\");\n        return buffer.toString();\n    }",
    "begin_line": 194,
    "end_line": 201,
    "comment": "/** \n * Provide a String representation of this file filter.\n * @return a String representation\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CanReadFileFilter.CanReadFileFilter#84",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/CanReadFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.CanReadFileFilter",
    "signature": "org.apache.commons.io.filefilter.CanReadFileFilter.CanReadFileFilter()",
    "snippet": "protected CanReadFileFilter() {\n    }",
    "begin_line": 84,
    "end_line": 85,
    "comment": "/** \n * Restrictive constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CanReadFileFilter.accept#94",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/CanReadFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.CanReadFileFilter",
    "signature": "org.apache.commons.io.filefilter.CanReadFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        return file.canRead();\n    }",
    "begin_line": 94,
    "end_line": 96,
    "comment": "/** \n * Checks to see if the file can be read.\n * @param file the File to check.\n * @return {@code true} if the file can be read, otherwise {@code false}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CanReadFileFilter.accept#106",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/CanReadFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.CanReadFileFilter",
    "signature": "org.apache.commons.io.filefilter.CanReadFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return toFileVisitResult(Files.isReadable(file));\n    }",
    "begin_line": 106,
    "end_line": 108,
    "comment": "/** \n * Checks to see if the file can be read.\n * @param file the File to check.\n * @return {@code true} if the file can be read, otherwise {@code false}.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CanWriteFileFilter.CanWriteFileFilter#72",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/CanWriteFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.CanWriteFileFilter",
    "signature": "org.apache.commons.io.filefilter.CanWriteFileFilter.CanWriteFileFilter()",
    "snippet": "protected CanWriteFileFilter() {\n    }",
    "begin_line": 72,
    "end_line": 73,
    "comment": "/** \n * Restrictive constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CanWriteFileFilter.accept#82",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/CanWriteFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.CanWriteFileFilter",
    "signature": "org.apache.commons.io.filefilter.CanWriteFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        return file.canWrite();\n    }",
    "begin_line": 82,
    "end_line": 84,
    "comment": "/** \n * Checks to see if the file can be written to.\n * @param file the File to check\n * @return {@code true} if the file can be written to, otherwise {@code false}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CanWriteFileFilter.accept#94",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/CanWriteFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.CanWriteFileFilter",
    "signature": "org.apache.commons.io.filefilter.CanWriteFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return toFileVisitResult(Files.isWritable(file));\n    }",
    "begin_line": 94,
    "end_line": 96,
    "comment": "/** \n * Checks to see if the file can be written to.\n * @param file the File to check\n * @return {@code true} if the file can be written to, otherwise {@code false}.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryFileFilter.DirectoryFileFilter#88",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/DirectoryFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.DirectoryFileFilter",
    "signature": "org.apache.commons.io.filefilter.DirectoryFileFilter.DirectoryFileFilter()",
    "snippet": "protected DirectoryFileFilter() {\n        // empty.\n    }",
    "begin_line": 88,
    "end_line": 90,
    "comment": "/** \n * Restrictive constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryFileFilter.accept#99",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/DirectoryFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.DirectoryFileFilter",
    "signature": "org.apache.commons.io.filefilter.DirectoryFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        return file.isDirectory();\n    }",
    "begin_line": 99,
    "end_line": 101,
    "comment": "/** \n * Checks to see if the file is a directory.\n * @param file the File to check\n * @return true if the file is a directory\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DirectoryFileFilter.accept#111",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/DirectoryFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.DirectoryFileFilter",
    "signature": "org.apache.commons.io.filefilter.DirectoryFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return toFileVisitResult(Files.isDirectory(file));\n    }",
    "begin_line": 111,
    "end_line": 113,
    "comment": "/** \n * Checks to see if the file is a directory.\n * @param file the File to check\n * @return true if the file is a directory\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EmptyFileFilter.EmptyFileFilter#96",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/EmptyFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.EmptyFileFilter",
    "signature": "org.apache.commons.io.filefilter.EmptyFileFilter.EmptyFileFilter()",
    "snippet": "protected EmptyFileFilter() {\n    }",
    "begin_line": 96,
    "end_line": 97,
    "comment": "/** \n * Restrictive constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EmptyFileFilter.accept#106",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/EmptyFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.EmptyFileFilter",
    "signature": "org.apache.commons.io.filefilter.EmptyFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        if (file.isDirectory()) {\n            final File[] files \u003d file.listFiles();\n            return IOUtils.length(files) \u003d\u003d 0;\n        }\n        return file.length() \u003d\u003d 0;\n    }",
    "begin_line": 106,
    "end_line": 112,
    "comment": "/** \n * Checks to see if the file is empty.\n * @param file the file or directory to check\n * @return {@code true} if the file or directory is \u003ci\u003eempty\u003c/i\u003e, otherwise {@code false}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EmptyFileFilter.accept#122",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/EmptyFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.EmptyFileFilter",
    "signature": "org.apache.commons.io.filefilter.EmptyFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return get(() -\u003e {\n            if (Files.isDirectory(file)) {\n                try (Stream\u003cPath\u003e stream \u003d Files.list(file)) {\n                    return toFileVisitResult(!stream.findFirst().isPresent());\n                }\n            }\n            return toFileVisitResult(Files.size(file) \u003d\u003d 0);\n        });\n    }",
    "begin_line": 122,
    "end_line": 131,
    "comment": "/** \n * Checks to see if the file is empty.\n * @param file the file or directory to check\n * @return {@code true} if the file or directory is \u003ci\u003eempty\u003c/i\u003e, otherwise {@code false}.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFileFilter.FileFileFilter#89",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.FileFileFilter",
    "signature": "org.apache.commons.io.filefilter.FileFileFilter.FileFileFilter()",
    "snippet": "protected FileFileFilter() {\n    }",
    "begin_line": 89,
    "end_line": 90,
    "comment": "/** \n * Restrictive constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFileFilter.accept#99",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.FileFileFilter",
    "signature": "org.apache.commons.io.filefilter.FileFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        return file.isFile();\n    }",
    "begin_line": 99,
    "end_line": 101,
    "comment": "/** \n * Checks to see if the file is a file.\n * @param file  the File to check\n * @return true if the file is a file\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFileFilter.accept#111",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.FileFileFilter",
    "signature": "org.apache.commons.io.filefilter.FileFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return toFileVisitResult(Files.isRegularFile(file));\n    }",
    "begin_line": 111,
    "end_line": 113,
    "comment": "/** \n * Checks to see if the file is a file.\n * @param file  the File to check\n * @return true if the file is a file\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.ageFileFilter#63",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.ageFileFilter(java.util.Date)",
    "snippet": "public static IOFileFilter ageFileFilter(final Date cutoffDate) {\n        return new AgeFileFilter(cutoffDate);\n    }",
    "begin_line": 63,
    "end_line": 65,
    "comment": "/** \n * Returns a filter that returns true if the file was last modified before or at the specified cutoff date.\n * @param cutoffDate  the time threshold\n * @return an appropriately configured age file filter\n * @see AgeFileFilter\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.ageFileFilter#76",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.ageFileFilter(java.util.Date, boolean)",
    "snippet": "public static IOFileFilter ageFileFilter(final Date cutoffDate, final boolean acceptOlder) {\n        return new AgeFileFilter(cutoffDate, acceptOlder);\n    }",
    "begin_line": 76,
    "end_line": 78,
    "comment": "/** \n * Returns a filter that filters files based on a cutoff date.\n * @param cutoffDate  the time threshold\n * @param acceptOlder  if true, older files get accepted, if false, newer\n * @return an appropriately configured age file filter\n * @see AgeFileFilter\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.ageFileFilter#90",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.ageFileFilter(java.io.File)",
    "snippet": "public static IOFileFilter ageFileFilter(final File cutoffReference) {\n        return new AgeFileFilter(cutoffReference);\n    }",
    "begin_line": 90,
    "end_line": 92,
    "comment": "/** \n * Returns a filter that returns true if the file was last modified before or at the same time as the specified reference file.\n * @param cutoffReference  the file whose last modificationtime is used as the threshold age of the files\n * @return an appropriately configured age file filter\n * @see AgeFileFilter\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.ageFileFilter#104",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.ageFileFilter(java.io.File, boolean)",
    "snippet": "public static IOFileFilter ageFileFilter(final File cutoffReference, final boolean acceptOlder) {\n        return new AgeFileFilter(cutoffReference, acceptOlder);\n    }",
    "begin_line": 104,
    "end_line": 106,
    "comment": "/** \n * Returns a filter that filters files based on a cutoff reference file.\n * @param cutoffReference  the file whose last modificationtime is used as the threshold age of the files\n * @param acceptOlder  if true, older files get accepted, if false, newer\n * @return an appropriately configured age file filter\n * @see AgeFileFilter\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.ageFileFilter#117",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.ageFileFilter(long)",
    "snippet": "public static IOFileFilter ageFileFilter(final long cutoffMillis) {\n        return new AgeFileFilter(cutoffMillis);\n    }",
    "begin_line": 117,
    "end_line": 119,
    "comment": "/** \n * Returns a filter that returns true if the file was last modified before or at the specified cutoff time.\n * @param cutoffMillis  the time threshold\n * @return an appropriately configured age file filter\n * @see AgeFileFilter\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.ageFileFilter#130",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.ageFileFilter(long, boolean)",
    "snippet": "public static IOFileFilter ageFileFilter(final long cutoffMillis, final boolean acceptOlder) {\n        return new AgeFileFilter(cutoffMillis, acceptOlder);\n    }",
    "begin_line": 130,
    "end_line": 132,
    "comment": "/** \n * Returns a filter that filters files based on a cutoff time.\n * @param cutoffMillis  the time threshold\n * @param acceptOlder  if true, older files get accepted, if false, newer\n * @return an appropriately configured age file filter\n * @see AgeFileFilter\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.and#145",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.and(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static IOFileFilter and(final IOFileFilter... filters) {\n        return new AndFileFilter(toList(filters));\n    }",
    "begin_line": 145,
    "end_line": 147,
    "comment": "/** \n * Returns a filter that ANDs the specified filters.\n * @param filters the IOFileFilters that will be ANDed together.\n * @return a filter that ANDs the specified filters\n * @throws IllegalArgumentException if the filters are null or contain anull value.\n * @see AndFileFilter\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.andFileFilter#160",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.andFileFilter(org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "@Deprecated\n    public static IOFileFilter andFileFilter(final IOFileFilter filter1, final IOFileFilter filter2) {\n        return new AndFileFilter(filter1, filter2);\n    }",
    "begin_line": 160,
    "end_line": 162,
    "comment": "/** \n * Returns a filter that ANDs the two specified filters.\n * @param filter1  the first filter\n * @param filter2  the second filter\n * @return a filter that ANDs the two specified filters\n * @see #and(IOFileFilter...)\n * @see AndFileFilter\n * @deprecated use {@link #and(IOFileFilter...)}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.asFileFilter#172",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.asFileFilter(java.io.FileFilter)",
    "snippet": "public static IOFileFilter asFileFilter(final FileFilter filter) {\n        return new DelegateFileFilter(filter);\n    }",
    "begin_line": 172,
    "end_line": 174,
    "comment": "/** \n * Returns an  {@link IOFileFilter} that wraps the{@link FileFilter} instance.\n * @param filter  the filter to be wrapped\n * @return a new filter that implements IOFileFilter\n * @see DelegateFileFilter\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.asFileFilter#184",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.asFileFilter(java.io.FilenameFilter)",
    "snippet": "public static IOFileFilter asFileFilter(final FilenameFilter filter) {\n        return new DelegateFileFilter(filter);\n    }",
    "begin_line": 184,
    "end_line": 186,
    "comment": "/** \n * Returns an  {@link IOFileFilter} that wraps the{@link FilenameFilter} instance.\n * @param filter  the filter to be wrapped\n * @return a new filter that implements IOFileFilter\n * @see DelegateFileFilter\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.directoryFileFilter#194",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.directoryFileFilter()",
    "snippet": "public static IOFileFilter directoryFileFilter() {\n        return DirectoryFileFilter.DIRECTORY;\n    }",
    "begin_line": 194,
    "end_line": 196,
    "comment": "/** \n * Returns a filter that checks if the file is a directory.\n * @return file filter that accepts only directories and not files\n * @see DirectoryFileFilter#DIRECTORY\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.falseFileFilter#204",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.falseFileFilter()",
    "snippet": "public static IOFileFilter falseFileFilter() {\n        return FalseFileFilter.FALSE;\n    }",
    "begin_line": 204,
    "end_line": 206,
    "comment": "/** \n * Returns a filter that always returns false.\n * @return a false filter\n * @see FalseFileFilter#FALSE\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.fileFileFilter#214",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.fileFileFilter()",
    "snippet": "public static IOFileFilter fileFileFilter() {\n        return FileFileFilter.INSTANCE;\n    }",
    "begin_line": 214,
    "end_line": 216,
    "comment": "/** \n * Returns a filter that checks if the file is a file (and not a directory).\n * @return file filter that accepts only files and not directories\n * @see FileFileFilter#INSTANCE\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.filter#240",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.filter(org.apache.commons.io.filefilter.IOFileFilter, java.io.File)",
    "snippet": "public static File[] filter(final IOFileFilter filter, final File... files) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (files \u003d\u003d null) {\n            return FileUtils.EMPTY_FILE_ARRAY;\n        }\n        return filterFiles(filter, Stream.of(files), Collectors.toList()).toArray(FileUtils.EMPTY_FILE_ARRAY);\n    }",
    "begin_line": 240,
    "end_line": 246,
    "comment": "/** \n * \u003cp\u003e Applies an  {@link IOFileFilter} to the provided {@link File}objects. The resulting array is a subset of the original file list that matches the provided filter. \u003c/p\u003e \u003cpre\u003e Set\u0026lt;File\u0026gt; allFiles \u003d ... Set\u0026lt;File\u0026gt; javaFiles \u003d FileFilterUtils.filterSet(allFiles, FileFilterUtils.suffixFileFilter(\".java\")); \u003c/pre\u003e\n * @param filter the filter to apply to the set of files.\n * @param files the array of files to apply the filter to.\n * @return a subset of {@code files} that is accepted by thefile filter.\n * @throws NullPointerException if the filter is {@code null}or  {@code files} contains a {@code null} value.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.filter#274",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.filter(org.apache.commons.io.filefilter.IOFileFilter, java.lang.Iterable\u003cjava.io.File\u003e)",
    "snippet": "public static File[] filter(final IOFileFilter filter, final Iterable\u003cFile\u003e files) {\n        return filterList(filter, files).toArray(FileUtils.EMPTY_FILE_ARRAY);\n    }",
    "begin_line": 274,
    "end_line": 276,
    "comment": "/** \n * \u003cp\u003e Applies an  {@link IOFileFilter} to the provided {@link File}objects. The resulting array is a subset of the original file list that matches the provided filter. \u003c/p\u003e \u003cp\u003e The  {@link Set} returned by this method is not guaranteed to be thread safe.\u003c/p\u003e \u003cpre\u003e Set\u0026lt;File\u0026gt; allFiles \u003d ... Set\u0026lt;File\u0026gt; javaFiles \u003d FileFilterUtils.filterSet(allFiles, FileFilterUtils.suffixFileFilter(\".java\")); \u003c/pre\u003e\n * @param filter the filter to apply to the set of files.\n * @param files the array of files to apply the filter to.\n * @return a subset of {@code files} that is accepted by thefile filter.\n * @throws IllegalArgumentException if the filter is {@code null}or  {@code files} contains a {@code null} value.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.filterFiles#292",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.filterFiles(org.apache.commons.io.filefilter.IOFileFilter, java.util.stream.Stream\u003cjava.io.File\u003e, java.util.stream.Collector\u003c? super java.io.File,A,R\u003e)",
    "snippet": "private static \u003cR, A\u003e R filterFiles(final IOFileFilter filter, final Stream\u003cFile\u003e stream,\n        final Collector\u003c? super File, A, R\u003e collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream \u003d\u003d null) {\n            return Stream.\u003cFile\u003eempty().collect(collector);\n        }\n        return stream.filter(filter::accept).collect(collector);\n    }",
    "begin_line": 292,
    "end_line": 300,
    "comment": "/** \n * \u003cp\u003e Applies an  {@link IOFileFilter} to the provided {@link File} stream and collects the accepted files.\u003c/p\u003e\n * @param filter the filter to apply to the stream of files.\n * @param stream the stream of files on which to apply the filter.\n * @param collector how to collect the end result.\n * @param \u003c R \u003e the return type.\n * @param \u003c A \u003e the mutable accumulation type of the reduction operation (often hidden as an implementation detail)\n * @return a subset of files from the stream that is accepted by the filter.\n * @throws NullPointerException if the filter is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.filterList#327",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.filterList(org.apache.commons.io.filefilter.IOFileFilter, java.io.File)",
    "snippet": "public static List\u003cFile\u003e filterList(final IOFileFilter filter, final File... files) {\n        return Arrays.asList(filter(filter, files));\n    }",
    "begin_line": 327,
    "end_line": 329,
    "comment": "/** \n * \u003cp\u003e Applies an  {@link IOFileFilter} to the provided {@link File}objects. The resulting list is a subset of the original files that matches the provided filter. \u003c/p\u003e \u003cp\u003e The  {@link List} returned by this method is not guaranteed to be thread safe.\u003c/p\u003e \u003cpre\u003e List\u0026lt;File\u0026gt; filesAndDirectories \u003d ... List\u0026lt;File\u0026gt; directories \u003d FileFilterUtils.filterList(filesAndDirectories, FileFilterUtils.directoryFileFilter()); \u003c/pre\u003e\n * @param filter the filter to apply to each files in the list.\n * @param files the collection of files to apply the filter to.\n * @return a subset of {@code files} that is accepted by thefile filter.\n * @throws IllegalArgumentException if the filter is {@code null}or  {@code files} contains a {@code null} value.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.filterList#355",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.filterList(org.apache.commons.io.filefilter.IOFileFilter, java.lang.Iterable\u003cjava.io.File\u003e)",
    "snippet": "public static List\u003cFile\u003e filterList(final IOFileFilter filter, final Iterable\u003cFile\u003e files) {\n        if (files \u003d\u003d null) {\n            return Collections.emptyList();\n        }\n        return filterFiles(filter, StreamSupport.stream(files.spliterator(), false), Collectors.toList());\n    }",
    "begin_line": 355,
    "end_line": 360,
    "comment": "/** \n * \u003cp\u003e Applies an  {@link IOFileFilter} to the provided {@link File}objects. The resulting list is a subset of the original files that matches the provided filter. \u003c/p\u003e \u003cp\u003e The  {@link List} returned by this method is not guaranteed to be thread safe.\u003c/p\u003e \u003cpre\u003e List\u0026lt;File\u0026gt; filesAndDirectories \u003d ... List\u0026lt;File\u0026gt; directories \u003d FileFilterUtils.filterList(filesAndDirectories, FileFilterUtils.directoryFileFilter()); \u003c/pre\u003e\n * @param filter the filter to apply to each files in the list.\n * @param files the collection of files to apply the filter to.\n * @return a subset of {@code files} that is accepted by thefile filter.\n * @throws IllegalArgumentException if the filter is {@code null}\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.filterSet#388",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.filterSet(org.apache.commons.io.filefilter.IOFileFilter, java.io.File)",
    "snippet": "public static Set\u003cFile\u003e filterSet(final IOFileFilter filter, final File... files) {\n        return new HashSet\u003c\u003e(Arrays.asList(filter(filter, files)));\n    }",
    "begin_line": 388,
    "end_line": 390,
    "comment": "/** \n * \u003cp\u003e Applies an  {@link IOFileFilter} to the provided {@link File}objects. The resulting set is a subset of the original file list that matches the provided filter. \u003c/p\u003e \u003cp\u003e The  {@link Set} returned by this method is not guaranteed to be thread safe.\u003c/p\u003e \u003cpre\u003e Set\u0026lt;File\u0026gt; allFiles \u003d ... Set\u0026lt;File\u0026gt; javaFiles \u003d FileFilterUtils.filterSet(allFiles, FileFilterUtils.suffixFileFilter(\".java\")); \u003c/pre\u003e\n * @param filter the filter to apply to the set of files.\n * @param files the collection of files to apply the filter to.\n * @return a subset of {@code files} that is accepted by thefile filter.\n * @throws IllegalArgumentException if the filter is {@code null}or  {@code files} contains a {@code null} value.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.filterSet#417",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.filterSet(org.apache.commons.io.filefilter.IOFileFilter, java.lang.Iterable\u003cjava.io.File\u003e)",
    "snippet": "public static Set\u003cFile\u003e filterSet(final IOFileFilter filter, final Iterable\u003cFile\u003e files) {\n        if (files \u003d\u003d null) {\n            return Collections.emptySet();\n        }\n        return filterFiles(filter, StreamSupport.stream(files.spliterator(), false), Collectors.toSet());\n    }",
    "begin_line": 417,
    "end_line": 422,
    "comment": "/** \n * \u003cp\u003e Applies an  {@link IOFileFilter} to the provided {@link File}objects. The resulting set is a subset of the original file list that matches the provided filter. \u003c/p\u003e \u003cp\u003e The  {@link Set} returned by this method is not guaranteed to be thread safe.\u003c/p\u003e \u003cpre\u003e Set\u0026lt;File\u0026gt; allFiles \u003d ... Set\u0026lt;File\u0026gt; javaFiles \u003d FileFilterUtils.filterSet(allFiles, FileFilterUtils.suffixFileFilter(\".java\")); \u003c/pre\u003e\n * @param filter the filter to apply to the set of files.\n * @param files the collection of files to apply the filter to.\n * @return a subset of {@code files} that is accepted by thefile filter.\n * @throws IllegalArgumentException if the filter is {@code null}\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.magicNumberFileFilter#439",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.magicNumberFileFilter(byte[])",
    "snippet": "public static IOFileFilter magicNumberFileFilter(final byte[] magicNumber) {\n        return new MagicNumberFileFilter(magicNumber);\n    }",
    "begin_line": 439,
    "end_line": 441,
    "comment": "/** \n * Returns a filter that accepts files that begin with the provided magic number.\n * @param magicNumber the magic number (byte sequence) to match at thebeginning of each file.\n * @return an IOFileFilter that accepts files beginning with the providedmagic number.\n * @throws IllegalArgumentException if {@code magicNumber} is{@code null} or is of length zero.\n * @see MagicNumberFileFilter\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.magicNumberFileFilter#460",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.magicNumberFileFilter(byte[], long)",
    "snippet": "public static IOFileFilter magicNumberFileFilter(final byte[] magicNumber, final long offset) {\n        return new MagicNumberFileFilter(magicNumber, offset);\n    }",
    "begin_line": 460,
    "end_line": 462,
    "comment": "/** \n * Returns a filter that accepts files that contains the provided magic number at a specified offset within the file.\n * @param magicNumber the magic number (byte sequence) to match at theprovided offset in each file.\n * @param offset the offset within the files to look for the magic number.\n * @return an IOFileFilter that accepts files containing the magic numberat the specified offset.\n * @throws IllegalArgumentException if {@code magicNumber} is{@code null}, or contains no bytes, or  {@code offset}is a negative number.\n * @see MagicNumberFileFilter\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.magicNumberFileFilter#479",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.magicNumberFileFilter(java.lang.String)",
    "snippet": "public static IOFileFilter magicNumberFileFilter(final String magicNumber) {\n        return new MagicNumberFileFilter(magicNumber);\n    }",
    "begin_line": 479,
    "end_line": 481,
    "comment": "/** \n * Returns a filter that accepts files that begin with the provided magic number.\n * @param magicNumber the magic number (byte sequence) to match at thebeginning of each file.\n * @return an IOFileFilter that accepts files beginning with the providedmagic number.\n * @throws IllegalArgumentException if {@code magicNumber} is{@code null} or the empty String.\n * @see MagicNumberFileFilter\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.magicNumberFileFilter#500",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.magicNumberFileFilter(java.lang.String, long)",
    "snippet": "public static IOFileFilter magicNumberFileFilter(final String magicNumber, final long offset) {\n        return new MagicNumberFileFilter(magicNumber, offset);\n    }",
    "begin_line": 500,
    "end_line": 502,
    "comment": "/** \n * Returns a filter that accepts files that contains the provided magic number at a specified offset within the file.\n * @param magicNumber the magic number (byte sequence) to match at theprovided offset in each file.\n * @param offset the offset within the files to look for the magic number.\n * @return an IOFileFilter that accepts files containing the magic numberat the specified offset.\n * @throws IllegalArgumentException if {@code magicNumber} is{@code null} or the empty String, or if offset is anegative number.\n * @see MagicNumberFileFilter\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.makeCVSAware#513",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.makeCVSAware(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static IOFileFilter makeCVSAware(final IOFileFilter filter) {\n        return filter \u003d\u003d null ? CVS_FILTER : and(filter, CVS_FILTER);\n    }",
    "begin_line": 513,
    "end_line": 515,
    "comment": "/** \n * Decorates a filter to make it ignore CVS directories. Passing in  {@code null} will return a filter that accepts everythingexcept CVS directories.\n * @param filter  the filter to decorate, null means an unrestricted filter\n * @return the decorated filter, never null\n * @since 1.1 (method existed but had a bug in 1.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.makeDirectoryOnly#525",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.makeDirectoryOnly(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static IOFileFilter makeDirectoryOnly(final IOFileFilter filter) {\n        if (filter \u003d\u003d null) {\n            return DirectoryFileFilter.DIRECTORY;\n        }\n        return DirectoryFileFilter.DIRECTORY.and(filter);\n    }",
    "begin_line": 525,
    "end_line": 530,
    "comment": "/** \n * Decorates a filter so that it only applies to directories and not to files.\n * @param filter  the filter to decorate, null means an unrestricted filter\n * @return the decorated filter, never null\n * @see DirectoryFileFilter#DIRECTORY\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.makeFileOnly#540",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.makeFileOnly(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static IOFileFilter makeFileOnly(final IOFileFilter filter) {\n        if (filter \u003d\u003d null) {\n            return FileFileFilter.INSTANCE;\n        }\n        return FileFileFilter.INSTANCE.and(filter);\n    }",
    "begin_line": 540,
    "end_line": 545,
    "comment": "/** \n * Decorates a filter so that it only applies to files and not to directories.\n * @param filter  the filter to decorate, null means an unrestricted filter\n * @return the decorated filter, never null\n * @see FileFileFilter#INSTANCE\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.makeSVNAware#556",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.makeSVNAware(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static IOFileFilter makeSVNAware(final IOFileFilter filter) {\n        return filter \u003d\u003d null ? SVN_FILTER : and(filter, SVN_FILTER);\n    }",
    "begin_line": 556,
    "end_line": 558,
    "comment": "/** \n * Decorates a filter to make it ignore SVN directories. Passing in  {@code null} will return a filter that accepts everythingexcept SVN directories.\n * @param filter  the filter to decorate, null means an unrestricted filter\n * @return the decorated filter, never null\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.nameFileFilter#567",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.nameFileFilter(java.lang.String)",
    "snippet": "public static IOFileFilter nameFileFilter(final String name) {\n        return new NameFileFilter(name);\n    }",
    "begin_line": 567,
    "end_line": 569,
    "comment": "/** \n * Returns a filter that returns true if the file name matches the specified text.\n * @param name  the file name\n * @return a name checking filter\n * @see NameFileFilter\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.nameFileFilter#580",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.nameFileFilter(java.lang.String, org.apache.commons.io.IOCase)",
    "snippet": "public static IOFileFilter nameFileFilter(final String name, final IOCase ioCase) {\n        return new NameFileFilter(name, ioCase);\n    }",
    "begin_line": 580,
    "end_line": 582,
    "comment": "/** \n * Returns a filter that returns true if the file name matches the specified text.\n * @param name  the file name\n * @param ioCase  how to handle case sensitivity, null means case-sensitive\n * @return a name checking filter\n * @see NameFileFilter\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.notFileFilter#591",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.notFileFilter(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static IOFileFilter notFileFilter(final IOFileFilter filter) {\n        return filter.negate();\n    }",
    "begin_line": 591,
    "end_line": 593,
    "comment": "/** \n * Returns a filter that NOTs the specified filter.\n * @param filter  the filter to invert\n * @return a filter that NOTs the specified filter\n * @see NotFileFilter\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.or#606",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.or(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static IOFileFilter or(final IOFileFilter... filters) {\n        return new OrFileFilter(toList(filters));\n    }",
    "begin_line": 606,
    "end_line": 608,
    "comment": "/** \n * Returns a filter that ORs the specified filters.\n * @param filters the IOFileFilters that will be ORed together.\n * @return a filter that ORs the specified filters\n * @throws IllegalArgumentException if the filters are null or contain anull value.\n * @see OrFileFilter\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.orFileFilter#621",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.orFileFilter(org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "@Deprecated\n    public static IOFileFilter orFileFilter(final IOFileFilter filter1, final IOFileFilter filter2) {\n        return new OrFileFilter(filter1, filter2);\n    }",
    "begin_line": 621,
    "end_line": 623,
    "comment": "/** \n * Returns a filter that ORs the two specified filters.\n * @param filter1  the first filter\n * @param filter2  the second filter\n * @return a filter that ORs the two specified filters\n * @see #or(IOFileFilter...)\n * @see OrFileFilter\n * @deprecated use {@link #or(IOFileFilter...)}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.prefixFileFilter#632",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.prefixFileFilter(java.lang.String)",
    "snippet": "public static IOFileFilter prefixFileFilter(final String prefix) {\n        return new PrefixFileFilter(prefix);\n    }",
    "begin_line": 632,
    "end_line": 634,
    "comment": "/** \n * Returns a filter that returns true if the file name starts with the specified text.\n * @param prefix  the file name prefix\n * @return a prefix checking filter\n * @see PrefixFileFilter\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.prefixFileFilter#645",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.prefixFileFilter(java.lang.String, org.apache.commons.io.IOCase)",
    "snippet": "public static IOFileFilter prefixFileFilter(final String prefix, final IOCase ioCase) {\n        return new PrefixFileFilter(prefix, ioCase);\n    }",
    "begin_line": 645,
    "end_line": 647,
    "comment": "/** \n * Returns a filter that returns true if the file name starts with the specified text.\n * @param prefix  the file name prefix\n * @param ioCase  how to handle case sensitivity, null means case-sensitive\n * @return a prefix checking filter\n * @see PrefixFileFilter\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.sizeFileFilter#657",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.sizeFileFilter(long)",
    "snippet": "public static IOFileFilter sizeFileFilter(final long threshold) {\n        return new SizeFileFilter(threshold);\n    }",
    "begin_line": 657,
    "end_line": 659,
    "comment": "/** \n * Returns a filter that returns true if the file is bigger than a certain size.\n * @param threshold  the file size threshold\n * @return an appropriately configured SizeFileFilter\n * @see SizeFileFilter\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.sizeFileFilter#670",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.sizeFileFilter(long, boolean)",
    "snippet": "public static IOFileFilter sizeFileFilter(final long threshold, final boolean acceptLarger) {\n        return new SizeFileFilter(threshold, acceptLarger);\n    }",
    "begin_line": 670,
    "end_line": 672,
    "comment": "/** \n * Returns a filter that filters based on file size.\n * @param threshold  the file size threshold\n * @param acceptLarger  if true, larger files get accepted, if false, smaller\n * @return an appropriately configured SizeFileFilter\n * @see SizeFileFilter\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.sizeRangeFileFilter#684",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.sizeRangeFileFilter(long, long)",
    "snippet": "public static IOFileFilter sizeRangeFileFilter(final long minSizeInclusive, final long maxSizeInclusive ) {\n        final IOFileFilter minimumFilter \u003d new SizeFileFilter(minSizeInclusive, true);\n        final IOFileFilter maximumFilter \u003d new SizeFileFilter(maxSizeInclusive + 1L, false);\n        return minimumFilter.and(maximumFilter);\n    }",
    "begin_line": 684,
    "end_line": 688,
    "comment": "/** \n * Returns a filter that accepts files whose size is \u0026gt;\u003d minimum size and \u0026lt;\u003d maximum size.\n * @param minSizeInclusive the minimum file size (inclusive)\n * @param maxSizeInclusive the maximum file size (inclusive)\n * @return an appropriately configured IOFileFilter\n * @see SizeFileFilter\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.suffixFileFilter#697",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.suffixFileFilter(java.lang.String)",
    "snippet": "public static IOFileFilter suffixFileFilter(final String suffix) {\n        return new SuffixFileFilter(suffix);\n    }",
    "begin_line": 697,
    "end_line": 699,
    "comment": "/** \n * Returns a filter that returns true if the file name ends with the specified text.\n * @param suffix  the file name suffix\n * @return a suffix checking filter\n * @see SuffixFileFilter\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.suffixFileFilter#710",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.suffixFileFilter(java.lang.String, org.apache.commons.io.IOCase)",
    "snippet": "public static IOFileFilter suffixFileFilter(final String suffix, final IOCase ioCase) {\n        return new SuffixFileFilter(suffix, ioCase);\n    }",
    "begin_line": 710,
    "end_line": 712,
    "comment": "/** \n * Returns a filter that returns true if the file name ends with the specified text.\n * @param suffix  the file name suffix\n * @param ioCase  how to handle case sensitivity, null means case-sensitive\n * @return a suffix checking filter\n * @see SuffixFileFilter\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.toList#723",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.toList(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public static List\u003cIOFileFilter\u003e toList(final IOFileFilter... filters) {\n        return Stream.of(Objects.requireNonNull(filters, \"filters\")).map(Objects::requireNonNull).collect(Collectors.toList());\n    }",
    "begin_line": 723,
    "end_line": 725,
    "comment": "/** \n * Create a List of file filters.\n * @param filters The file filters\n * @return The list of file filters\n * @throws NullPointerException if the filters are null or contain anull value.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.trueFileFilter#733",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.trueFileFilter()",
    "snippet": "public static IOFileFilter trueFileFilter() {\n        return TrueFileFilter.TRUE;\n    }",
    "begin_line": 733,
    "end_line": 735,
    "comment": "/** \n * Returns a filter that always returns true.\n * @return a true filter\n * @see TrueFileFilter#TRUE\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FileFilterUtils.FileFilterUtils#740",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/FileFilterUtils.java",
    "class_name": "org.apache.commons.io.filefilter.FileFilterUtils",
    "signature": "org.apache.commons.io.filefilter.FileFilterUtils.FileFilterUtils()",
    "snippet": "public FileFilterUtils() {\n    }",
    "begin_line": 740,
    "end_line": 741,
    "comment": "/** \n * FileFilterUtils is not normally instantiated.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HiddenFileFilter.HiddenFileFilter#92",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/HiddenFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.HiddenFileFilter",
    "signature": "org.apache.commons.io.filefilter.HiddenFileFilter.HiddenFileFilter()",
    "snippet": "protected HiddenFileFilter() {\n    }",
    "begin_line": 92,
    "end_line": 93,
    "comment": "/** \n * Restrictive constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HiddenFileFilter.accept#103",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/HiddenFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.HiddenFileFilter",
    "signature": "org.apache.commons.io.filefilter.HiddenFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        return file.isHidden();\n    }",
    "begin_line": 103,
    "end_line": 105,
    "comment": "/** \n * Checks to see if the file is hidden.\n * @param file  the File to check\n * @return {@code true} if the file is\u003ci\u003ehidden\u003c/i\u003e, otherwise  {@code false}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "HiddenFileFilter.accept#116",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/HiddenFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.HiddenFileFilter",
    "signature": "org.apache.commons.io.filefilter.HiddenFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return get(() -\u003e toFileVisitResult(Files.isHidden(file)));\n    }",
    "begin_line": 116,
    "end_line": 118,
    "comment": "/** \n * Checks to see if the file is hidden.\n * @param file  the File to check\n * @return {@code true} if the file is\u003ci\u003ehidden\u003c/i\u003e, otherwise  {@code false}.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.accept#51",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    boolean accept(File file);",
    "begin_line": 51,
    "end_line": 51,
    "comment": "/** \n * Tests if a File should be accepted by this filter. \u003cp\u003e Defined in  {@link java.io.FileFilter}. \u003c/p\u003e\n * @param file the File to check.\n * @return true if this file matches the test.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.accept#64",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.accept(java.io.File, java.lang.String)",
    "snippet": "@Override\n    boolean accept(File dir, String name);",
    "begin_line": 64,
    "end_line": 64,
    "comment": "/** \n * Tests if a File should be accepted by this filter. \u003cp\u003e Defined in  {@link java.io.FilenameFilter}. \u003c/p\u003e\n * @param dir the directory File to check.\n * @param name the file name within the directory to check.\n * @return true if this file matches the test.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.accept#74",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    default FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {\n        return AbstractFileFilter.toDefaultFileVisitResult(path !\u003d null \u0026\u0026 accept(path.toFile()));\n    }",
    "begin_line": 74,
    "end_line": 76,
    "comment": "/** \n * Checks to see if a Path should be accepted by this filter.\n * @param path the Path to check.\n * @return true if this path matches the test.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.and#85",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.and(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "default IOFileFilter and(final IOFileFilter fileFilter) {\n        return new AndFileFilter(this, fileFilter);\n    }",
    "begin_line": 85,
    "end_line": 87,
    "comment": "/** \n * Constructs a new \"and\" filter with this filter.\n * @param fileFilter the filter to \"and\".\n * @return a new filter.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.matches#97",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.matches(java.nio.file.Path)",
    "snippet": "@Override\n    default boolean matches(final Path path) {\n        return accept(path, null) !\u003d FileVisitResult.TERMINATE;\n    }",
    "begin_line": 97,
    "end_line": 99,
    "comment": "/** \n * Tests if a Path should be accepted by this filter.\n * @param path the Path to check.\n * @return true if this path matches the test.\n * @since 2.14.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.negate#107",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.negate()",
    "snippet": "default IOFileFilter negate() {\n        return new NotFileFilter(this);\n    }",
    "begin_line": 107,
    "end_line": 109,
    "comment": "/** \n * Constructs a new \"not\" filter with this filter.\n * @return a new filter.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOFileFilter.or#118",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/IOFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.IOFileFilter",
    "signature": "org.apache.commons.io.filefilter.IOFileFilter.or(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "default IOFileFilter or(final IOFileFilter fileFilter) {\n        return new OrFileFilter(this, fileFilter);\n    }",
    "begin_line": 118,
    "end_line": 120,
    "comment": "/** \n * Constructs a new \"or\" filter with this filter.\n * @param fileFilter the filter to \"or\".\n * @return a new filter.\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.NameFileFilter#90",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.NameFileFilter(java.util.List\u003cjava.lang.String\u003e)",
    "snippet": "public NameFileFilter(final List\u003cString\u003e names) {\n        this(names, null);\n    }",
    "begin_line": 90,
    "end_line": 92,
    "comment": "/** \n * Constructs a new case-sensitive name file filter for a list of names.\n * @param names  the names to allow, must not be null\n * @throws IllegalArgumentException if the name list is null\n * @throws ClassCastException if the list does not contain Strings\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.NameFileFilter#102",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.NameFileFilter(java.util.List\u003cjava.lang.String\u003e, org.apache.commons.io.IOCase)",
    "snippet": "public NameFileFilter(final List\u003cString\u003e names, final IOCase ioCase) {\n        Objects.requireNonNull(names, \"names\");\n        this.names \u003d names.toArray(EMPTY_STRING_ARRAY);\n        this.ioCase \u003d toIOCase(ioCase);\n    }",
    "begin_line": 102,
    "end_line": 106,
    "comment": "/** \n * Constructs a new name file filter for a list of names specifying case-sensitivity.\n * @param names  the names to allow, must not be null\n * @param ioCase  how to handle case sensitivity, null means case-sensitive\n * @throws NullPointerException if the name list is null\n * @throws ClassCastException if the list does not contain Strings\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.NameFileFilter#114",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.NameFileFilter(java.lang.String)",
    "snippet": "public NameFileFilter(final String name) {\n        this(name, IOCase.SENSITIVE);\n    }",
    "begin_line": 114,
    "end_line": 116,
    "comment": "/** \n * Constructs a new case-sensitive name file filter for a single name.\n * @param name  the name to allow, must not be null\n * @throws IllegalArgumentException if the name is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.NameFileFilter#128",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.NameFileFilter(java.lang.String)",
    "snippet": "public NameFileFilter(final String... names) {\n        this(names, IOCase.SENSITIVE);\n    }",
    "begin_line": 128,
    "end_line": 130,
    "comment": "/** \n * Constructs a new case-sensitive name file filter for an array of names. \u003cp\u003e The array is not cloned, so could be changed after constructing the instance. This would be inadvisable however. \u003c/p\u003e\n * @param names  the names to allow, must not be null\n * @throws IllegalArgumentException if the names array is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.NameFileFilter#139",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.NameFileFilter(java.lang.String, org.apache.commons.io.IOCase)",
    "snippet": "public NameFileFilter(final String name, final IOCase ioCase) {\n        Objects.requireNonNull(name, \"name\");\n        this.names \u003d new String[] {name};\n        this.ioCase \u003d toIOCase(ioCase);\n    }",
    "begin_line": 139,
    "end_line": 143,
    "comment": "/** \n * Constructs a new name file filter specifying case-sensitivity.\n * @param name  the name to allow, must not be null\n * @param ioCase  how to handle case sensitivity, null means case-sensitive\n * @throws NullPointerException if the name is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.NameFileFilter#152",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.NameFileFilter(java.lang.String[], org.apache.commons.io.IOCase)",
    "snippet": "public NameFileFilter(final String[] names, final IOCase ioCase) {\n        Objects.requireNonNull(names, \"names\");\n        this.names \u003d names.clone();\n        this.ioCase \u003d toIOCase(ioCase);\n    }",
    "begin_line": 152,
    "end_line": 156,
    "comment": "/** \n * Constructs a new name file filter for an array of names specifying case-sensitivity.\n * @param names  the names to allow, must not be null\n * @param ioCase  how to handle case sensitivity, null means case-sensitive\n * @throws NullPointerException if the names array is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.accept#165",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        return acceptBaseName(file.getName());\n    }",
    "begin_line": 165,
    "end_line": 167,
    "comment": "/** \n * Checks to see if the file name matches.\n * @param file  the File to check\n * @return true if the file name matches\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.accept#177",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.accept(java.io.File, java.lang.String)",
    "snippet": "@Override\n    public boolean accept(final File dir, final String name) {\n        return acceptBaseName(name);\n    }",
    "begin_line": 177,
    "end_line": 179,
    "comment": "/** \n * Checks to see if the file name matches.\n * @param dir  the File directory (ignored)\n * @param name  the file name\n * @return true if the file name matches\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.accept#189",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {\n        return toFileVisitResult(acceptBaseName(PathUtils.getFileNameString(path)));\n    }",
    "begin_line": 189,
    "end_line": 191,
    "comment": "/** \n * Checks to see if the file name matches.\n * @param path  the File to check\n * @return true if the file name matches\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.acceptBaseName#193",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.acceptBaseName(java.lang.String)",
    "snippet": "private boolean acceptBaseName(final String baseName) {\n        return Stream.of(names).anyMatch(testName -\u003e ioCase.checkEquals(baseName, testName));\n    }",
    "begin_line": 193,
    "end_line": 195,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.toIOCase#197",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.toIOCase(org.apache.commons.io.IOCase)",
    "snippet": "private IOCase toIOCase(final IOCase ioCase) {\n        return IOCase.value(ioCase, IOCase.SENSITIVE);\n    }",
    "begin_line": 197,
    "end_line": 199,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NameFileFilter.toString#207",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NameFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NameFileFilter",
    "signature": "org.apache.commons.io.filefilter.NameFileFilter.toString()",
    "snippet": "@Override\n    public String toString() {\n        final StringBuilder buffer \u003d new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        append(names, buffer);\n        buffer.append(\")\");\n        return buffer.toString();\n    }",
    "begin_line": 207,
    "end_line": 214,
    "comment": "/** \n * Provide a String representation of this file filter.\n * @return a String representation\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NotFileFilter.NotFileFilter#49",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NotFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NotFileFilter",
    "signature": "org.apache.commons.io.filefilter.NotFileFilter.NotFileFilter(org.apache.commons.io.filefilter.IOFileFilter)",
    "snippet": "public NotFileFilter(final IOFileFilter filter) {\n        Objects.requireNonNull(filter, \"filter\");\n        this.filter \u003d filter;\n    }",
    "begin_line": 49,
    "end_line": 52,
    "comment": "/** \n * Constructs a new file filter that NOTs the result of another filter.\n * @param filter the filter, must not be null\n * @throws NullPointerException if the filter is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NotFileFilter.accept#61",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NotFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NotFileFilter",
    "signature": "org.apache.commons.io.filefilter.NotFileFilter.accept(java.io.File)",
    "snippet": "@Override\n    public boolean accept(final File file) {\n        return !filter.accept(file);\n    }",
    "begin_line": 61,
    "end_line": 63,
    "comment": "/** \n * Returns the logical NOT of the underlying filter\u0027s return value for the same File.\n * @param file the File to check\n * @return true if the filter returns false\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NotFileFilter.accept#73",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NotFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NotFileFilter",
    "signature": "org.apache.commons.io.filefilter.NotFileFilter.accept(java.io.File, java.lang.String)",
    "snippet": "@Override\n    public boolean accept(final File file, final String name) {\n        return !filter.accept(file, name);\n    }",
    "begin_line": 73,
    "end_line": 75,
    "comment": "/** \n * Returns the logical NOT of the underlying filter\u0027s return value for the same arguments.\n * @param file the File directory\n * @param name the file name\n * @return true if the filter returns false\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NotFileFilter.accept#85",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NotFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NotFileFilter",
    "signature": "org.apache.commons.io.filefilter.NotFileFilter.accept(java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes)",
    "snippet": "@Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return not(filter.accept(file, attributes));\n    }",
    "begin_line": 85,
    "end_line": 87,
    "comment": "/** \n * Returns the logical NOT of the underlying filter\u0027s return value for the same File.\n * @param file the File to check\n * @return true if the filter returns false\n * @since 2.9.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NotFileFilter.not#89",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NotFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NotFileFilter",
    "signature": "org.apache.commons.io.filefilter.NotFileFilter.not(java.nio.file.FileVisitResult)",
    "snippet": "private FileVisitResult not(final FileVisitResult accept) {\n        return accept \u003d\u003d FileVisitResult.CONTINUE ? FileVisitResult.TERMINATE : FileVisitResult.CONTINUE;\n    }",
    "begin_line": 89,
    "end_line": 91,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "NotFileFilter.toString#99",
    "is_bug": true,
    "src_path": "org/apache/commons/io/filefilter/NotFileFilter.java",
    "class_name": "org.apache.commons.io.filefilter.NotFileFilter",
    "signature": "org.apache.commons.io.filefilter.NotFileFilter.toString()",
    "snippet": "@Override\n    public String toString() {\n        return \"NOT (\" + filter.toString() + \")\";\n    }",
    "begin_line": 99,
    "end_line": 101,
    "comment": "/** \n * Provide a String representation of this file filter.\n * @return a String representation\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]