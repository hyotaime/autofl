[
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.Base64OutputStreamTest(java.lang.String)",
    "snippet": "public Base64OutputStreamTest(String name) {\n        super(name);\n    }",
    "begin_line": 45,
    "end_line": 47,
    "comment": "/** \n * Construct a new instance of this test case.\n * @param name Name of the test case\n */\n",
    "child_ranges": [
      "(line 46,col 9)-(line 46,col 20)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testCodec98NPE()",
    "snippet": "public void testCodec98NPE() throws Exception {\n        byte[] codec98 \u003d StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n        byte[] codec98_1024 \u003d new byte[1024];\n        System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);\n        ByteArrayOutputStream data \u003d new ByteArrayOutputStream(1024);\n        Base64OutputStream stream \u003d new Base64OutputStream(data, false);\n        stream.write(codec98_1024, 0, 1024);\n        stream.close();\n\n        byte[] decodedBytes \u003d data.toByteArray();\n        String decoded \u003d StringUtils.newStringUtf8(decodedBytes);\n        assertEquals(\n            \"codec-98 NPE Base64OutputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n        );\n    }",
    "begin_line": 55,
    "end_line": 69,
    "comment": "/** \n * Test the Base64OutputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 56,col 9)-(line 56,col 79)",
      "(line 57,col 9)-(line 57,col 45)",
      "(line 58,col 9)-(line 58,col 70)",
      "(line 59,col 9)-(line 59,col 69)",
      "(line 60,col 9)-(line 60,col 72)",
      "(line 61,col 9)-(line 61,col 44)",
      "(line 62,col 9)-(line 62,col 23)",
      "(line 64,col 9)-(line 64,col 49)",
      "(line 65,col 9)-(line 65,col 65)",
      "(line 66,col 9)-(line 68,col 10)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testBase64EmptyOutputStreamMimeChunkSize()",
    "snippet": "public void testBase64EmptyOutputStreamMimeChunkSize() throws Exception {\n        testBase64EmptyOutputStream(Base64.MIME_CHUNK_SIZE);\n    }",
    "begin_line": 78,
    "end_line": 80,
    "comment": "/** \n * Test the Base64OutputStream implementation against empty input.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 79,col 9)-(line 79,col 60)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testBase64EmptyOutputStreamPemChunkSize()",
    "snippet": "public void testBase64EmptyOutputStreamPemChunkSize() throws Exception {\n        testBase64EmptyOutputStream(Base64.PEM_CHUNK_SIZE);\n    }",
    "begin_line": 88,
    "end_line": 90,
    "comment": "/** \n * Test the Base64OutputStream implementation against empty input.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 89,col 9)-(line 89,col 59)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testBase64EmptyOutputStream(int)",
    "snippet": "private void testBase64EmptyOutputStream(int chunkSize) throws Exception {\n        byte[] emptyEncoded \u003d new byte[0];\n        byte[] emptyDecoded \u003d new byte[0];\n        testByteByByte(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n        testByChunk(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n    }",
    "begin_line": 92,
    "end_line": 97,
    "comment": "",
    "child_ranges": [
      "(line 93,col 9)-(line 93,col 42)",
      "(line 94,col 9)-(line 94,col 42)",
      "(line 95,col 9)-(line 95,col 68)",
      "(line 96,col 9)-(line 96,col 65)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testBase64OutputStreamByChunk()",
    "snippet": "public void testBase64OutputStreamByChunk() throws Exception {\n        // Hello World test.\n        byte[] encoded \u003d StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ\u003d\\r\\n\");\n        byte[] decoded \u003d StringUtils.getBytesUtf8(STRING_FIXTURE);\n        testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n\n        // Single Byte test.\n        encoded \u003d StringUtils.getBytesUtf8(\"AA\u003d\u003d\\r\\n\");\n        decoded \u003d new byte[]{(byte) 0};\n        testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n\n        // OpenSSL interop test.\n        encoded \u003d StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n        decoded \u003d Base64TestData.DECODED;\n        testByChunk(encoded, decoded, Base64.PEM_CHUNK_SIZE, LF);\n\n        // Single Line test.\n        String singleLine \u003d Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n        encoded \u003d StringUtils.getBytesUtf8(singleLine);\n        decoded \u003d Base64TestData.DECODED;\n        testByChunk(encoded, decoded, 0, LF);\n\n        // test random data of sizes 0 thru 150\n        for (int i \u003d 0; i \u003c\u003d 150; i++) {\n            byte[][] randomData \u003d Base64TestData.randomData(i, false);\n            encoded \u003d randomData[1];\n            decoded \u003d randomData[0];\n            testByChunk(encoded, decoded, 0, LF);\n        }\n    }",
    "begin_line": 105,
    "end_line": 134,
    "comment": "/** \n * Test the Base64OutputStream implementation\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 107,col 9)-(line 107,col 74)",
      "(line 108,col 9)-(line 108,col 66)",
      "(line 109,col 9)-(line 109,col 68)",
      "(line 112,col 9)-(line 112,col 55)",
      "(line 113,col 9)-(line 113,col 39)",
      "(line 114,col 9)-(line 114,col 68)",
      "(line 117,col 9)-(line 117,col 85)",
      "(line 118,col 9)-(line 118,col 41)",
      "(line 119,col 9)-(line 119,col 65)",
      "(line 122,col 9)-(line 122,col 90)",
      "(line 123,col 9)-(line 123,col 55)",
      "(line 124,col 9)-(line 124,col 41)",
      "(line 125,col 9)-(line 125,col 45)",
      "(line 128,col 9)-(line 133,col 9)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testBase64OutputStreamByteByByte()",
    "snippet": "public void testBase64OutputStreamByteByByte() throws Exception {\n        // Hello World test.\n        byte[] encoded \u003d StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ\u003d\\r\\n\");\n        byte[] decoded \u003d StringUtils.getBytesUtf8(STRING_FIXTURE);\n        testByteByByte(encoded, decoded, 76, CRLF);\n\n        // Single Byte test.\n        encoded \u003d StringUtils.getBytesUtf8(\"AA\u003d\u003d\\r\\n\");\n        decoded \u003d new byte[]{(byte) 0};\n        testByteByByte(encoded, decoded, 76, CRLF);\n\n        // OpenSSL interop test.\n        encoded \u003d StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n        decoded \u003d Base64TestData.DECODED;\n        testByteByByte(encoded, decoded, 64, LF);\n\n        // Single Line test.\n        String singleLine \u003d Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n        encoded \u003d StringUtils.getBytesUtf8(singleLine);\n        decoded \u003d Base64TestData.DECODED;\n        testByteByByte(encoded, decoded, 0, LF);\n\n        // test random data of sizes 0 thru 150\n        for (int i \u003d 0; i \u003c\u003d 150; i++) {\n            byte[][] randomData \u003d Base64TestData.randomData(i, false);\n            encoded \u003d randomData[1];\n            decoded \u003d randomData[0];\n            testByteByByte(encoded, decoded, 0, LF);\n        }\n    }",
    "begin_line": 142,
    "end_line": 171,
    "comment": "/** \n * Test the Base64OutputStream implementation\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 144,col 9)-(line 144,col 74)",
      "(line 145,col 9)-(line 145,col 66)",
      "(line 146,col 9)-(line 146,col 51)",
      "(line 149,col 9)-(line 149,col 55)",
      "(line 150,col 9)-(line 150,col 39)",
      "(line 151,col 9)-(line 151,col 51)",
      "(line 154,col 9)-(line 154,col 85)",
      "(line 155,col 9)-(line 155,col 41)",
      "(line 156,col 9)-(line 156,col 49)",
      "(line 159,col 9)-(line 159,col 90)",
      "(line 160,col 9)-(line 160,col 55)",
      "(line 161,col 9)-(line 161,col 41)",
      "(line 162,col 9)-(line 162,col 48)",
      "(line 165,col 9)-(line 170,col 9)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testByChunk(byte[], byte[], int, byte[])",
    "snippet": "private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n\n        // Start with encode.\n        ByteArrayOutputStream byteOut \u003d new ByteArrayOutputStream();\n        OutputStream out \u003d new Base64OutputStream(byteOut, true, chunkSize, seperator);\n        out.write(decoded);\n        out.close();\n        byte[] output \u003d byteOut.toByteArray();\n        assertTrue(\"Streaming chunked base64 encode\", Arrays.equals(output, encoded));\n\n        // Now let\u0027s try decode.\n        byteOut \u003d new ByteArrayOutputStream();\n        out \u003d new Base64OutputStream(byteOut, false);\n        out.write(encoded);\n        out.close();\n        output \u003d byteOut.toByteArray();\n        assertTrue(\"Streaming chunked base64 decode\", Arrays.equals(output, decoded));\n\n        // I always wanted to do this! (wrap encoder with decoder etc etc).\n        byteOut \u003d new ByteArrayOutputStream();\n        out \u003d byteOut;\n        for (int i \u003d 0; i \u003c 10; i++) {\n            out \u003d new Base64OutputStream(out, false);\n            out \u003d new Base64OutputStream(out, true, chunkSize, seperator);\n        }\n        out.write(decoded);\n        out.close();\n        output \u003d byteOut.toByteArray();\n\n        assertTrue(\"Streaming chunked base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n    }",
    "begin_line": 191,
    "end_line": 221,
    "comment": "/** \n * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--\u003e decoded 2. decoded ---[ENCODE]--\u003e encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --\u003e decoded \u003cp/\u003e By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode mode over and over again.\n * @param encoded base64 encoded data\n * @param decoded the data from above, but decoded\n * @param chunkSize chunk size (line-length) of the base64 encoded data.\n * @param seperator Line separator in the base64 encoded data.\n * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n */\n",
    "child_ranges": [
      "(line 194,col 9)-(line 194,col 68)",
      "(line 195,col 9)-(line 195,col 87)",
      "(line 196,col 9)-(line 196,col 27)",
      "(line 197,col 9)-(line 197,col 20)",
      "(line 198,col 9)-(line 198,col 46)",
      "(line 199,col 9)-(line 199,col 86)",
      "(line 202,col 9)-(line 202,col 46)",
      "(line 203,col 9)-(line 203,col 53)",
      "(line 204,col 9)-(line 204,col 27)",
      "(line 205,col 9)-(line 205,col 20)",
      "(line 206,col 9)-(line 206,col 39)",
      "(line 207,col 9)-(line 207,col 86)",
      "(line 210,col 9)-(line 210,col 46)",
      "(line 211,col 9)-(line 211,col 22)",
      "(line 212,col 9)-(line 215,col 9)",
      "(line 216,col 9)-(line 216,col 27)",
      "(line 217,col 9)-(line 217,col 20)",
      "(line 218,col 9)-(line 218,col 39)",
      "(line 220,col 9)-(line 220,col 95)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
    "snippet": "private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n\n        // Start with encode.\n        ByteArrayOutputStream byteOut \u003d new ByteArrayOutputStream();\n        OutputStream out \u003d new Base64OutputStream(byteOut, true, chunkSize, seperator);\n        for (int i \u003d 0; i \u003c decoded.length; i++) {\n            out.write(decoded[i]);\n        }\n        out.close();\n        byte[] output \u003d byteOut.toByteArray();\n        assertTrue(\"Streaming byte-by-byte base64 encode\", Arrays.equals(output, encoded));\n\n        // Now let\u0027s try decode.\n        byteOut \u003d new ByteArrayOutputStream();\n        out \u003d new Base64OutputStream(byteOut, false);\n        for (int i \u003d 0; i \u003c encoded.length; i++) {\n            out.write(encoded[i]);\n        }\n        out.close();\n        output \u003d byteOut.toByteArray();\n        assertTrue(\"Streaming byte-by-byte base64 decode\", Arrays.equals(output, decoded));\n\n        // Now let\u0027s try decode with tonnes of flushes.\n        byteOut \u003d new ByteArrayOutputStream();\n        out \u003d new Base64OutputStream(byteOut, false);\n        for (int i \u003d 0; i \u003c encoded.length; i++) {\n            out.write(encoded[i]);\n            out.flush();\n        }\n        out.close();\n        output \u003d byteOut.toByteArray();\n        assertTrue(\"Streaming byte-by-byte flush() base64 decode\", Arrays.equals(output, decoded));\n\n        // I always wanted to do this! (wrap encoder with decoder etc etc).\n        byteOut \u003d new ByteArrayOutputStream();\n        out \u003d byteOut;\n        for (int i \u003d 0; i \u003c 10; i++) {\n            out \u003d new Base64OutputStream(out, false);\n            out \u003d new Base64OutputStream(out, true, chunkSize, seperator);\n        }\n        for (int i \u003d 0; i \u003c decoded.length; i++) {\n            out.write(decoded[i]);\n        }\n        out.close();\n        output \u003d byteOut.toByteArray();\n\n        assertTrue(\"Streaming byte-by-byte base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n    }",
    "begin_line": 241,
    "end_line": 288,
    "comment": "/** \n * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--\u003e decoded 2. decoded ---[ENCODE]--\u003e encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --\u003e decoded \u003cp/\u003e By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode mode over and over again.\n * @param encoded base64 encoded data\n * @param decoded the data from above, but decoded\n * @param chunkSize chunk size (line-length) of the base64 encoded data.\n * @param seperator Line separator in the base64 encoded data.\n * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n */\n",
    "child_ranges": [
      "(line 244,col 9)-(line 244,col 68)",
      "(line 245,col 9)-(line 245,col 87)",
      "(line 246,col 9)-(line 248,col 9)",
      "(line 249,col 9)-(line 249,col 20)",
      "(line 250,col 9)-(line 250,col 46)",
      "(line 251,col 9)-(line 251,col 91)",
      "(line 254,col 9)-(line 254,col 46)",
      "(line 255,col 9)-(line 255,col 53)",
      "(line 256,col 9)-(line 258,col 9)",
      "(line 259,col 9)-(line 259,col 20)",
      "(line 260,col 9)-(line 260,col 39)",
      "(line 261,col 9)-(line 261,col 91)",
      "(line 264,col 9)-(line 264,col 46)",
      "(line 265,col 9)-(line 265,col 53)",
      "(line 266,col 9)-(line 269,col 9)",
      "(line 270,col 9)-(line 270,col 20)",
      "(line 271,col 9)-(line 271,col 39)",
      "(line 272,col 9)-(line 272,col 99)",
      "(line 275,col 9)-(line 275,col 46)",
      "(line 276,col 9)-(line 276,col 22)",
      "(line 277,col 9)-(line 280,col 9)",
      "(line 281,col 9)-(line 283,col 9)",
      "(line 284,col 9)-(line 284,col 20)",
      "(line 285,col 9)-(line 285,col 39)",
      "(line 287,col 9)-(line 287,col 100)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testWriteOutOfBounds()",
    "snippet": "public void testWriteOutOfBounds() throws Exception {\n        byte[] buf \u003d new byte[1024];\n        ByteArrayOutputStream bout \u003d new ByteArrayOutputStream();\n        Base64OutputStream out \u003d new Base64OutputStream(bout);\n\n        try {\n            out.write(buf, -1, 1);\n            fail(\"Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException\");\n        } catch (IndexOutOfBoundsException ioobe) {\n            // Expected\n        }\n\n        try {\n            out.write(buf, 1, -1);\n            fail(\"Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException\");\n        } catch (IndexOutOfBoundsException ioobe) {\n            // Expected\n        }\n\n        try {\n            out.write(buf, buf.length + 1, 0);\n            fail(\"Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException\");\n        } catch (IndexOutOfBoundsException ioobe) {\n            // Expected\n        }\n\n        try {\n            out.write(buf, buf.length - 1, 2);\n            fail(\"Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException\");\n        } catch (IndexOutOfBoundsException ioobe) {\n            // Expected\n        }\n    }",
    "begin_line": 296,
    "end_line": 328,
    "comment": "/** \n * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 297,col 9)-(line 297,col 36)",
      "(line 298,col 9)-(line 298,col 65)",
      "(line 299,col 9)-(line 299,col 62)",
      "(line 301,col 9)-(line 306,col 9)",
      "(line 308,col 9)-(line 313,col 9)",
      "(line 315,col 9)-(line 320,col 9)",
      "(line 322,col 9)-(line 327,col 9)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64OutputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64OutputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testWriteToNullCoverage()",
    "snippet": "public void testWriteToNullCoverage() throws Exception {\n        ByteArrayOutputStream bout \u003d new ByteArrayOutputStream();\n        Base64OutputStream out \u003d new Base64OutputStream(bout);\n        try {\n            out.write(null, 0, 0);\n            fail(\"Expcted Base64OutputStream.write(null) to throw a NullPointerException\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n    }",
    "begin_line": 336,
    "end_line": 345,
    "comment": "/** \n * Tests Base64OutputStream.write(null).\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 337,col 9)-(line 337,col 65)",
      "(line 338,col 9)-(line 338,col 62)",
      "(line 339,col 9)-(line 344,col 9)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.Base64InputStreamTest(java.lang.String)",
    "snippet": "public Base64InputStreamTest(String name) {\n        super(name);\n    }",
    "begin_line": 45,
    "end_line": 47,
    "comment": "/** \n * Construct a new instance of this test case.\n * @param name Name of the test case\n */\n",
    "child_ranges": [
      "(line 46,col 9)-(line 46,col 20)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testCodec98NPE()",
    "snippet": "public void testCodec98NPE() throws Exception {\n        byte[] codec98 \u003d StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n        ByteArrayInputStream data \u003d new ByteArrayInputStream(codec98);\n        Base64InputStream stream \u003d new Base64InputStream(data);\n\n        // This line causes an NPE in commons-codec-1.4.jar:\n        byte[] decodedBytes \u003d Base64TestData.streamToBytes(stream, new byte[1024]);\n\n        String decoded \u003d StringUtils.newStringUtf8(decodedBytes);\n        assertEquals(\n            \"codec-98 NPE Base64InputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n        );\n    }",
    "begin_line": 55,
    "end_line": 67,
    "comment": "/** \n * Test the Base64InputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 56,col 9)-(line 56,col 79)",
      "(line 57,col 9)-(line 57,col 70)",
      "(line 58,col 9)-(line 58,col 63)",
      "(line 61,col 9)-(line 61,col 83)",
      "(line 63,col 9)-(line 63,col 65)",
      "(line 64,col 9)-(line 66,col 10)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testBase64EmptyInputStreamMimeChuckSize()",
    "snippet": "public void testBase64EmptyInputStreamMimeChuckSize() throws Exception {\n        testBase64EmptyInputStream(Base64.MIME_CHUNK_SIZE);\n    }",
    "begin_line": 75,
    "end_line": 77,
    "comment": "/** \n * Tests the Base64InputStream implementation against empty input.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 76,col 9)-(line 76,col 59)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testBase64EmptyInputStreamPemChuckSize()",
    "snippet": "public void testBase64EmptyInputStreamPemChuckSize() throws Exception {\n        testBase64EmptyInputStream(Base64.PEM_CHUNK_SIZE);\n    }",
    "begin_line": 85,
    "end_line": 87,
    "comment": "/** \n * Tests the Base64InputStream implementation against empty input.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 86,col 9)-(line 86,col 58)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testBase64EmptyInputStream(int)",
    "snippet": "private void testBase64EmptyInputStream(int chuckSize) throws Exception {\n        byte[] emptyEncoded \u003d new byte[0];\n        byte[] emptyDecoded \u003d new byte[0];\n        testByteByByte(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n        testByChunk(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n    }",
    "begin_line": 89,
    "end_line": 94,
    "comment": "",
    "child_ranges": [
      "(line 90,col 9)-(line 90,col 42)",
      "(line 91,col 9)-(line 91,col 42)",
      "(line 92,col 9)-(line 92,col 68)",
      "(line 93,col 9)-(line 93,col 65)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testBase64InputStreamByChunk()",
    "snippet": "public void testBase64InputStreamByChunk() throws Exception {\n        // Hello World test.\n        byte[] encoded \u003d StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ\u003d\\r\\n\");\n        byte[] decoded \u003d StringUtils.getBytesUtf8(STRING_FIXTURE);\n        testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n\n        // Single Byte test.\n        encoded \u003d StringUtils.getBytesUtf8(\"AA\u003d\u003d\\r\\n\");\n        decoded \u003d new byte[]{(byte) 0};\n        testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n\n        // OpenSSL interop test.\n        encoded \u003d StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n        decoded \u003d Base64TestData.DECODED;\n        testByChunk(encoded, decoded, Base64.PEM_CHUNK_SIZE, LF);\n\n        // Single Line test.\n        String singleLine \u003d Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n        encoded \u003d StringUtils.getBytesUtf8(singleLine);\n        decoded \u003d Base64TestData.DECODED;\n        testByChunk(encoded, decoded, 0, LF);\n\n        // test random data of sizes 0 thru 150\n        for (int i \u003d 0; i \u003c\u003d 150; i++) {\n            byte[][] randomData \u003d Base64TestData.randomData(i, false);\n            encoded \u003d randomData[1];\n            decoded \u003d randomData[0];\n            testByChunk(encoded, decoded, 0, LF);\n        }\n    }",
    "begin_line": 102,
    "end_line": 131,
    "comment": "/** \n * Tests the Base64InputStream implementation.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 104,col 9)-(line 104,col 74)",
      "(line 105,col 9)-(line 105,col 66)",
      "(line 106,col 9)-(line 106,col 68)",
      "(line 109,col 9)-(line 109,col 55)",
      "(line 110,col 9)-(line 110,col 39)",
      "(line 111,col 9)-(line 111,col 68)",
      "(line 114,col 9)-(line 114,col 85)",
      "(line 115,col 9)-(line 115,col 41)",
      "(line 116,col 9)-(line 116,col 65)",
      "(line 119,col 9)-(line 119,col 90)",
      "(line 120,col 9)-(line 120,col 55)",
      "(line 121,col 9)-(line 121,col 41)",
      "(line 122,col 9)-(line 122,col 45)",
      "(line 125,col 9)-(line 130,col 9)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testBase64InputStreamByteByByte()",
    "snippet": "public void testBase64InputStreamByteByByte() throws Exception {\n        // Hello World test.\n        byte[] encoded \u003d StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ\u003d\\r\\n\");\n        byte[] decoded \u003d StringUtils.getBytesUtf8(STRING_FIXTURE);\n        testByteByByte(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n\n        // Single Byte test.\n        encoded \u003d StringUtils.getBytesUtf8(\"AA\u003d\u003d\\r\\n\");\n        decoded \u003d new byte[]{(byte) 0};\n        testByteByByte(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n\n        // OpenSSL interop test.\n        encoded \u003d StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n        decoded \u003d Base64TestData.DECODED;\n        testByteByByte(encoded, decoded, Base64.PEM_CHUNK_SIZE, LF);\n\n        // Single Line test.\n        String singleLine \u003d Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n        encoded \u003d StringUtils.getBytesUtf8(singleLine);\n        decoded \u003d Base64TestData.DECODED;\n        testByteByByte(encoded, decoded, 0, LF);\n\n        // test random data of sizes 0 thru 150\n        for (int i \u003d 0; i \u003c\u003d 150; i++) {\n            byte[][] randomData \u003d Base64TestData.randomData(i, false);\n            encoded \u003d randomData[1];\n            decoded \u003d randomData[0];\n            testByteByByte(encoded, decoded, 0, LF);\n        }\n    }",
    "begin_line": 139,
    "end_line": 168,
    "comment": "/** \n * Tests the Base64InputStream implementation.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 141,col 9)-(line 141,col 74)",
      "(line 142,col 9)-(line 142,col 66)",
      "(line 143,col 9)-(line 143,col 71)",
      "(line 146,col 9)-(line 146,col 55)",
      "(line 147,col 9)-(line 147,col 39)",
      "(line 148,col 9)-(line 148,col 71)",
      "(line 151,col 9)-(line 151,col 85)",
      "(line 152,col 9)-(line 152,col 41)",
      "(line 153,col 9)-(line 153,col 68)",
      "(line 156,col 9)-(line 156,col 90)",
      "(line 157,col 9)-(line 157,col 55)",
      "(line 158,col 9)-(line 158,col 41)",
      "(line 159,col 9)-(line 159,col 48)",
      "(line 162,col 9)-(line 167,col 9)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testByChunk(byte[], byte[], int, byte[])",
    "snippet": "private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n\n        // Start with encode.\n        InputStream in \u003d new ByteArrayInputStream(decoded);\n        in \u003d new Base64InputStream(in, true, chunkSize, seperator);\n        byte[] output \u003d Base64TestData.streamToBytes(in);\n\n        assertEquals(\"EOF\", -1, in.read());\n        assertEquals(\"Still EOF\", -1, in.read());\n        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n\n        // Now let\u0027s try decode.\n        in \u003d new ByteArrayInputStream(encoded);\n        in \u003d new Base64InputStream(in);\n        output \u003d Base64TestData.streamToBytes(in);\n\n        assertEquals(\"EOF\", -1, in.read());\n        assertEquals(\"Still EOF\", -1, in.read());\n        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n\n        // I always wanted to do this! (wrap encoder with decoder etc etc).\n        in \u003d new ByteArrayInputStream(decoded);\n        for (int i \u003d 0; i \u003c 10; i++) {\n            in \u003d new Base64InputStream(in, true, chunkSize, seperator);\n            in \u003d new Base64InputStream(in, false);\n        }\n        output \u003d Base64TestData.streamToBytes(in);\n\n        assertEquals(\"EOF\", -1, in.read());\n        assertEquals(\"Still EOF\", -1, in.read());\n        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n    }",
    "begin_line": 188,
    "end_line": 219,
    "comment": "/** \n * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--\u003e decoded 2. decoded ---[ENCODE]--\u003e encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --\u003e decoded \u003cp/\u003e By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over again.\n * @param encoded base64 encoded data\n * @param decoded the data from above, but decoded\n * @param chunkSize chunk size (line-length) of the base64 encoded data.\n * @param seperator Line separator in the base64 encoded data.\n * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n */\n",
    "child_ranges": [
      "(line 191,col 9)-(line 191,col 59)",
      "(line 192,col 9)-(line 192,col 67)",
      "(line 193,col 9)-(line 193,col 57)",
      "(line 195,col 9)-(line 195,col 43)",
      "(line 196,col 9)-(line 196,col 49)",
      "(line 197,col 9)-(line 197,col 78)",
      "(line 200,col 9)-(line 200,col 47)",
      "(line 201,col 9)-(line 201,col 39)",
      "(line 202,col 9)-(line 202,col 50)",
      "(line 204,col 9)-(line 204,col 43)",
      "(line 205,col 9)-(line 205,col 49)",
      "(line 206,col 9)-(line 206,col 78)",
      "(line 209,col 9)-(line 209,col 47)",
      "(line 210,col 9)-(line 213,col 9)",
      "(line 214,col 9)-(line 214,col 50)",
      "(line 216,col 9)-(line 216,col 43)",
      "(line 217,col 9)-(line 217,col 49)",
      "(line 218,col 9)-(line 218,col 87)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
    "snippet": "private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n\n        // Start with encode.\n        InputStream in \u003d new ByteArrayInputStream(decoded);\n        in \u003d new Base64InputStream(in, true, chunkSize, seperator);\n        byte[] output \u003d new byte[encoded.length];\n        for (int i \u003d 0; i \u003c output.length; i++) {\n            output[i] \u003d (byte) in.read();\n        }\n\n        assertEquals(\"EOF\", -1, in.read());\n        assertEquals(\"Still EOF\", -1, in.read());\n        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n\n        // Now let\u0027s try decode.\n        in \u003d new ByteArrayInputStream(encoded);\n        in \u003d new Base64InputStream(in);\n        output \u003d new byte[decoded.length];\n        for (int i \u003d 0; i \u003c output.length; i++) {\n            output[i] \u003d (byte) in.read();\n        }\n\n        assertEquals(\"EOF\", -1, in.read());\n        assertEquals(\"Still EOF\", -1, in.read());\n        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n\n        // I always wanted to do this! (wrap encoder with decoder etc etc).\n        in \u003d new ByteArrayInputStream(decoded);\n        for (int i \u003d 0; i \u003c 10; i++) {\n            in \u003d new Base64InputStream(in, true, chunkSize, seperator);\n            in \u003d new Base64InputStream(in, false);\n        }\n        output \u003d new byte[decoded.length];\n        for (int i \u003d 0; i \u003c output.length; i++) {\n            output[i] \u003d (byte) in.read();\n        }\n\n        assertEquals(\"EOF\", -1, in.read());\n        assertEquals(\"Still EOF\", -1, in.read());\n        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n    }",
    "begin_line": 239,
    "end_line": 279,
    "comment": "/** \n * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--\u003e decoded 2. decoded ---[ENCODE]--\u003e encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --\u003e decoded \u003cp/\u003e By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over again.\n * @param encoded base64 encoded data\n * @param decoded the data from above, but decoded\n * @param chunkSize chunk size (line-length) of the base64 encoded data.\n * @param seperator Line separator in the base64 encoded data.\n * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n */\n",
    "child_ranges": [
      "(line 242,col 9)-(line 242,col 59)",
      "(line 243,col 9)-(line 243,col 67)",
      "(line 244,col 9)-(line 244,col 49)",
      "(line 245,col 9)-(line 247,col 9)",
      "(line 249,col 9)-(line 249,col 43)",
      "(line 250,col 9)-(line 250,col 49)",
      "(line 251,col 9)-(line 251,col 78)",
      "(line 254,col 9)-(line 254,col 47)",
      "(line 255,col 9)-(line 255,col 39)",
      "(line 256,col 9)-(line 256,col 42)",
      "(line 257,col 9)-(line 259,col 9)",
      "(line 261,col 9)-(line 261,col 43)",
      "(line 262,col 9)-(line 262,col 49)",
      "(line 263,col 9)-(line 263,col 78)",
      "(line 266,col 9)-(line 266,col 47)",
      "(line 267,col 9)-(line 270,col 9)",
      "(line 271,col 9)-(line 271,col 42)",
      "(line 272,col 9)-(line 274,col 9)",
      "(line 276,col 9)-(line 276,col 43)",
      "(line 277,col 9)-(line 277,col 49)",
      "(line 278,col 9)-(line 278,col 87)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testMarkSupported()",
    "snippet": "public void testMarkSupported() throws Exception {\n        byte[] decoded \u003d StringUtils.getBytesUtf8(STRING_FIXTURE);\n        ByteArrayInputStream bin \u003d new ByteArrayInputStream(decoded);\n        Base64InputStream in \u003d new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n        // Always returns false for now.\n        assertFalse(\"Base64InputStream.markSupported() is false\", in.markSupported());\n    }",
    "begin_line": 286,
    "end_line": 292,
    "comment": "/** \n * Tests markSupported.\n * @throws Exception\n */\n",
    "child_ranges": [
      "(line 287,col 9)-(line 287,col 66)",
      "(line 288,col 9)-(line 288,col 69)",
      "(line 289,col 9)-(line 289,col 88)",
      "(line 291,col 9)-(line 291,col 86)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testRead0()",
    "snippet": "public void testRead0() throws Exception {\n        byte[] decoded \u003d StringUtils.getBytesUtf8(STRING_FIXTURE);\n        byte[] buf \u003d new byte[1024];\n        int bytesRead \u003d 0;\n        ByteArrayInputStream bin \u003d new ByteArrayInputStream(decoded);\n        Base64InputStream in \u003d new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n        bytesRead \u003d in.read(buf, 0, 0);\n        assertEquals(\"Base64InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n    }",
    "begin_line": 299,
    "end_line": 307,
    "comment": "/** \n * Tests read returning 0\n * @throws Exception\n */\n",
    "child_ranges": [
      "(line 300,col 9)-(line 300,col 66)",
      "(line 301,col 9)-(line 301,col 36)",
      "(line 302,col 9)-(line 302,col 26)",
      "(line 303,col 9)-(line 303,col 69)",
      "(line 304,col 9)-(line 304,col 88)",
      "(line 305,col 9)-(line 305,col 39)",
      "(line 306,col 9)-(line 306,col 82)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testReadNull()",
    "snippet": "public void testReadNull() throws Exception {\n        byte[] decoded \u003d StringUtils.getBytesUtf8(STRING_FIXTURE);\n        ByteArrayInputStream bin \u003d new ByteArrayInputStream(decoded);\n        Base64InputStream in \u003d new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n        try {\n            in.read(null, 0, 0);\n            fail(\"Base64InputStream.read(null, 0, 0) to throw a NullPointerException\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n    }",
    "begin_line": 315,
    "end_line": 325,
    "comment": "/** \n * Tests read with null.\n * @throws Exception for some failure scenarios.\n */\n",
    "child_ranges": [
      "(line 316,col 9)-(line 316,col 66)",
      "(line 317,col 9)-(line 317,col 69)",
      "(line 318,col 9)-(line 318,col 88)",
      "(line 319,col 9)-(line 324,col 9)"
    ]
  },
  {
    "class_name": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "child_classes": [],
    "src_path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
    "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testReadOutOfBounds()",
    "snippet": "public void testReadOutOfBounds() throws Exception {\n        byte[] decoded \u003d StringUtils.getBytesUtf8(STRING_FIXTURE);\n        byte[] buf \u003d new byte[1024];\n        ByteArrayInputStream bin \u003d new ByteArrayInputStream(decoded);\n        Base64InputStream in \u003d new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n\n        try {\n            in.read(buf, -1, 0);\n            fail(\"Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException\");\n        } catch (IndexOutOfBoundsException e) {\n            // Expected\n        }\n\n        try {\n            in.read(buf, 0, -1);\n            fail(\"Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException\");\n        } catch (IndexOutOfBoundsException e) {\n            // Expected\n        }\n\n        try {\n            in.read(buf, buf.length + 1, 0);\n            fail(\"Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n        } catch (IndexOutOfBoundsException e) {\n            // Expected\n        }\n\n        try {\n            in.read(buf, buf.length - 1, 2);\n            fail(\"Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException\");\n        } catch (IndexOutOfBoundsException e) {\n            // Expected\n        }\n    }",
    "begin_line": 332,
    "end_line": 365,
    "comment": "/** \n * Tests read throwing IndexOutOfBoundsException\n * @throws Exception\n */\n",
    "child_ranges": [
      "(line 333,col 9)-(line 333,col 66)",
      "(line 334,col 9)-(line 334,col 36)",
      "(line 335,col 9)-(line 335,col 69)",
      "(line 336,col 9)-(line 336,col 88)",
      "(line 338,col 9)-(line 343,col 9)",
      "(line 345,col 9)-(line 350,col 9)",
      "(line 352,col 9)-(line 357,col 9)",
      "(line 359,col 9)-(line 364,col 9)"
    ]
  }
]