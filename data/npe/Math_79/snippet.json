[
  {
    "name": "Cluster.Cluster#45",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/Cluster.java",
    "class_name": "org.apache.commons.math.stat.clustering.Cluster",
    "signature": "org.apache.commons.math.stat.clustering.Cluster.Cluster(T)",
    "snippet": "public Cluster(final T center) {\n        this.center \u003d center;\n        points \u003d new ArrayList\u003cT\u003e();\n    }",
    "begin_line": 45,
    "end_line": 48,
    "comment": "/** \n * Build a cluster centered at a specified point.\n * @param center the point which is to be the center of this cluster\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Cluster.addPoint#54",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/Cluster.java",
    "class_name": "org.apache.commons.math.stat.clustering.Cluster",
    "signature": "org.apache.commons.math.stat.clustering.Cluster.addPoint(T)",
    "snippet": "public void addPoint(final T point) {\n        points.add(point);\n    }",
    "begin_line": 54,
    "end_line": 56,
    "comment": "/** \n * Add a point to this cluster.\n * @param point point to add\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Cluster.getPoints#62",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/Cluster.java",
    "class_name": "org.apache.commons.math.stat.clustering.Cluster",
    "signature": "org.apache.commons.math.stat.clustering.Cluster.getPoints()",
    "snippet": "public List\u003cT\u003e getPoints() {\n        return points;\n    }",
    "begin_line": 62,
    "end_line": 64,
    "comment": "/** \n * Get the points contained in the cluster.\n * @return points contained in the cluster\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Cluster.getCenter#70",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/Cluster.java",
    "class_name": "org.apache.commons.math.stat.clustering.Cluster",
    "signature": "org.apache.commons.math.stat.clustering.Cluster.getCenter()",
    "snippet": "public T getCenter() {\n        return center;\n    }",
    "begin_line": 70,
    "end_line": 72,
    "comment": "/** \n * Get the point chosen to be the center of this cluster.\n * @return chosen cluster center\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.EuclideanIntegerPoint#43",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.EuclideanIntegerPoint(int[])",
    "snippet": "public EuclideanIntegerPoint(final int[] point) {\n        this.point \u003d point;\n    }",
    "begin_line": 43,
    "end_line": 45,
    "comment": "/** \n * Build an instance wrapping an integer array. \u003cp\u003eThe wrapped array is referenced, it is \u003cem\u003enot\u003c/em\u003e copied.\u003c/p\u003e\n * @param point the n-dimensional point in integer space\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.getPoint#51",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.getPoint()",
    "snippet": "public int[] getPoint() {\n        return point;\n    }",
    "begin_line": 51,
    "end_line": 53,
    "comment": "/** \n * Get the n-dimensional point in integer space.\n * @return a reference (not a copy!) to the wrapped array\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.distanceFrom#56",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.distanceFrom(org.apache.commons.math.stat.clustering.EuclideanIntegerPoint)",
    "snippet": "public double distanceFrom(final EuclideanIntegerPoint p) {\n        return MathUtils.distance(point, p.getPoint());\n    }",
    "begin_line": 56,
    "end_line": 58,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.centroidOf#61",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.centroidOf(java.util.Collection\u003corg.apache.commons.math.stat.clustering.EuclideanIntegerPoint\u003e)",
    "snippet": "public EuclideanIntegerPoint centroidOf(final Collection\u003cEuclideanIntegerPoint\u003e points) {\n        int[] centroid \u003d new int[getPoint().length];\n        for (EuclideanIntegerPoint p : points) {\n            for (int i \u003d 0; i \u003c centroid.length; i++) {\n                centroid[i] +\u003d p.getPoint()[i];\n            }\n        }\n        for (int i \u003d 0; i \u003c centroid.length; i++) {\n            centroid[i] /\u003d points.size();\n        }\n        return new EuclideanIntegerPoint(centroid);\n    }",
    "begin_line": 61,
    "end_line": 72,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.equals#76",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.equals(java.lang.Object)",
    "snippet": "@Override\n    public boolean equals(final Object other) {\n        if (!(other instanceof EuclideanIntegerPoint)) {\n            return false;\n        }\n        final int[] otherPoint \u003d ((EuclideanIntegerPoint) other).getPoint();\n        if (point.length !\u003d otherPoint.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c point.length; i++) {\n            if (point[i] !\u003d otherPoint[i]) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 76,
    "end_line": 90,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.hashCode#94",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.hashCode()",
    "snippet": "@Override\n    public int hashCode() {\n        int hashCode \u003d 0;\n        for (Integer i : point) {\n            hashCode +\u003d i.hashCode() * 13 + 7;\n        }\n        return hashCode;\n    }",
    "begin_line": 94,
    "end_line": 100,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.toString#104",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.toString()",
    "snippet": "@Override\n    public String toString() {\n        final StringBuffer buff \u003d new StringBuffer(\"(\");\n        final int[] coordinates \u003d getPoint();\n        for (int i \u003d 0; i \u003c coordinates.length; i++) {\n            buff.append(coordinates[i]);\n            if (i \u003c coordinates.length - 1) {\n                buff.append(\",\");\n            }\n        }\n        buff.append(\")\");\n        return buff.toString();\n    }",
    "begin_line": 104,
    "end_line": 115,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.KMeansPlusPlusClusterer#40",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer(java.util.Random)",
    "snippet": "public KMeansPlusPlusClusterer(final Random random) {\n        this.random \u003d random;\n    }",
    "begin_line": 40,
    "end_line": 42,
    "comment": "/** \n * Build a clusterer.\n * @param random random generator to use for choosing initial centers\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.cluster#53",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.cluster(java.util.Collection\u003cT\u003e, int, int)",
    "snippet": "public List\u003cCluster\u003cT\u003e\u003e cluster(final Collection\u003cT\u003e points,\n                                    final int k, final int maxIterations) {\n        // create the initial clusters\n        List\u003cCluster\u003cT\u003e\u003e clusters \u003d chooseInitialCenters(points, k, random);\n        assignPointsToClusters(clusters, points);\n\n        // iterate through updating the centers until we\u0027re done\n        final int max \u003d (maxIterations \u003c 0) ? Integer.MAX_VALUE : maxIterations;\n        for (int count \u003d 0; count \u003c max; count++) {\n            boolean clusteringChanged \u003d false;\n            List\u003cCluster\u003cT\u003e\u003e newClusters \u003d new ArrayList\u003cCluster\u003cT\u003e\u003e();\n            for (final Cluster\u003cT\u003e cluster : clusters) {\n                final T newCenter \u003d cluster.getCenter().centroidOf(cluster.getPoints());\n                if (!newCenter.equals(cluster.getCenter())) {\n                    clusteringChanged \u003d true;\n                }\n                newClusters.add(new Cluster\u003cT\u003e(newCenter));\n            }\n            if (!clusteringChanged) {\n                return clusters;\n            }\n            assignPointsToClusters(newClusters, points);\n            clusters \u003d newClusters;\n        }\n        return clusters;\n    }",
    "begin_line": 53,
    "end_line": 78,
    "comment": "/** \n * Runs the K-means++ clustering algorithm.\n * @param points the points to cluster\n * @param k the number of clusters to split the data into\n * @param maxIterations the maximum number of iterations to run the algorithmfor.  If negative, no maximum will be used\n * @return a list of clusters containing the points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.assignPointsToClusters#88",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(java.util.Collection\u003corg.apache.commons.math.stat.clustering.Cluster\u003cT\u003e\u003e, java.util.Collection\u003cT\u003e)",
    "snippet": "private static \u003cT extends Clusterable\u003cT\u003e\u003e void assignPointsToClusters(final Collection\u003cCluster\u003cT\u003e\u003e clusters, final Collection\u003cT\u003e points) {\n        for (final T p : points) {\n            Cluster\u003cT\u003e cluster \u003d getNearestCluster(clusters, p);\n            cluster.addPoint(p);\n        }\n    }",
    "begin_line": 88,
    "end_line": 93,
    "comment": "/** \n * Adds the given points to the closest  {@link Cluster}.\n * @param \u003c T \u003e type of the points to cluster\n * @param clusters the {@link Cluster}s to add the points to\n * @param points the points to add to the given {@link Cluster}s\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.chooseInitialCenters#105",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.chooseInitialCenters(java.util.Collection\u003cT\u003e, int, java.util.Random)",
    "snippet": "private static \u003cT extends Clusterable\u003cT\u003e\u003e List\u003cCluster\u003cT\u003e\u003e chooseInitialCenters(final Collection\u003cT\u003e points, final int k, final Random random) {\n\n        final List\u003cT\u003e pointSet \u003d new ArrayList\u003cT\u003e(points);\n        final List\u003cCluster\u003cT\u003e\u003e resultSet \u003d new ArrayList\u003cCluster\u003cT\u003e\u003e();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint \u003d pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster\u003cT\u003e(firstPoint));\n\n        final double[] dx2 \u003d new double[pointSet.size()];\n        while (resultSet.size() \u003c k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            int sum \u003d 0;\n            for (int i \u003d 0; i \u003c pointSet.size(); i++) {\n                final T p \u003d pointSet.get(i);\n                final Cluster\u003cT\u003e nearest \u003d getNearestCluster(resultSet, p);\n                final double d \u003d p.distanceFrom(nearest.getCenter());\n                sum +\u003d d * d;\n                dx2[i] \u003d sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r \u003d random.nextDouble() * sum;\n            for (int i \u003d 0 ; i \u003c dx2.length; i++) {\n                if (dx2[i] \u003e\u003d r) {\n                    final T p \u003d pointSet.remove(i);\n                    resultSet.add(new Cluster\u003cT\u003e(p));\n                    break;\n                }\n            }\n        }\n\n        return resultSet;\n\n    }",
    "begin_line": 105,
    "end_line": 141,
    "comment": "/** \n * Use K-means++ to choose the initial centers.\n * @param \u003c T \u003e type of the points to cluster\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.getNearestCluster#152",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.getNearestCluster(java.util.Collection\u003corg.apache.commons.math.stat.clustering.Cluster\u003cT\u003e\u003e, T)",
    "snippet": "private static \u003cT extends Clusterable\u003cT\u003e\u003e Cluster\u003cT\u003e getNearestCluster(final Collection\u003cCluster\u003cT\u003e\u003e clusters, final T point) {\n        double minDistance \u003d Double.MAX_VALUE;\n        Cluster\u003cT\u003e minCluster \u003d null;\n        for (final Cluster\u003cT\u003e c : clusters) {\n            final double distance \u003d point.distanceFrom(c.getCenter());\n            if (distance \u003c minDistance) {\n                minDistance \u003d distance;\n                minCluster \u003d c;\n            }\n        }\n        return minCluster;\n    }",
    "begin_line": 152,
    "end_line": 163,
    "comment": "/** \n * Returns the nearest  {@link Cluster} to the given point\n * @param \u003c T \u003e type of the points to cluster\n * @param clusters the {@link Cluster}s to search\n * @param point the point to find the nearest {@link Cluster} for\n * @return the nearest {@link Cluster} to the given point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.MathUtils#81",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.MathUtils()",
    "snippet": "private MathUtils() {\n        super();\n    }",
    "begin_line": 81,
    "end_line": 83,
    "comment": "/** \n * Private Constructor\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.addAndCheck#95",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.addAndCheck(int, int)",
    "snippet": "public static int addAndCheck(int x, int y) {\n        long s \u003d (long)x + (long)y;\n        if (s \u003c Integer.MIN_VALUE || s \u003e Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }",
    "begin_line": 95,
    "end_line": 101,
    "comment": "/** \n * Add two integers, checking for overflow.\n * @param x an addend\n * @param y an addend\n * @return the sum \u003ccode\u003ex+y\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anint\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.addAndCheck#113",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.addAndCheck(long, long)",
    "snippet": "public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }",
    "begin_line": 113,
    "end_line": 115,
    "comment": "/** \n * Add two long integers, checking for overflow.\n * @param a an addend\n * @param b an addend\n * @return the sum \u003ccode\u003ea+b\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anlong\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.addAndCheck#128",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.addAndCheck(long, long, java.lang.String)",
    "snippet": "private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a \u003e b) {\n            // use symmetry to reduce boundary cases\n            ret \u003d addAndCheck(b, a, msg);\n        } else {\n            // assert a \u003c\u003d b\n\n            if (a \u003c 0) {\n                if (b \u003c 0) {\n                    // check for negative overflow\n                    if (Long.MIN_VALUE - b \u003c\u003d a) {\n                        ret \u003d a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    // opposite sign addition is always safe\n                    ret \u003d a + b;\n                }\n            } else {\n                // assert a \u003e\u003d 0\n                // assert b \u003e\u003d 0\n\n                // check for positive overflow\n                if (a \u003c\u003d Long.MAX_VALUE - b) {\n                    ret \u003d a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }",
    "begin_line": 128,
    "end_line": 161,
    "comment": "/** \n * Add two long integers, checking for overflow.\n * @param a an addend\n * @param b an addend\n * @param msg the message to use for any thrown exception.\n * @return the sum \u003ccode\u003ea+b\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anlong\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.binomialCoefficient#188",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.binomialCoefficient(int, int)",
    "snippet": "public static long binomialCoefficient(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n \u003d\u003d k) || (k \u003d\u003d 0)) {\n            return 1;\n        }\n        if ((k \u003d\u003d 1) || (k \u003d\u003d n - 1)) {\n            return n;\n        }\n        // Use symmetry for large k\n        if (k \u003e n / 2)\n            return binomialCoefficient(n, n - k);\n\n        // We use the formula\n        // (n choose k) \u003d n! / (n-k)! / k!\n        // (n choose k) \u003d\u003d ((n-k+1)*...*n) / (1*...*k)\n        // which could be written\n        // (n choose k) \u003d\u003d (n-1 choose k-1) * n / k\n        long result \u003d 1;\n        if (n \u003c\u003d 61) {\n            // For n \u003c\u003d 61, the naive implementation cannot overflow.\n            int i \u003d n - k + 1;\n            for (int j \u003d 1; j \u003c\u003d k; j++) {\n                result \u003d result * i / j;\n                i++;\n            }\n        } else if (n \u003c\u003d 66) {\n            // For n \u003e 61 but n \u003c\u003d 66, the result cannot overflow,\n            // but we must take care not to overflow intermediate values.\n            int i \u003d n - k + 1;\n            for (int j \u003d 1; j \u003c\u003d k; j++) {\n                // We know that (result * i) is divisible by j,\n                // but (result * i) may overflow, so we split j:\n                // Filter out the gcd, d, so j/d and i/d are integer.\n                // result is divisible by (j/d) because (j/d)\n                // is relative prime to (i/d) and is a divisor of\n                // result * (i/d).\n                final long d \u003d gcd(i, j);\n                result \u003d (result / (j / d)) * (i / d);\n                i++;\n            }\n        } else {\n            // For n \u003e 66, a result overflow might occur, so we check\n            // the multiplication, taking care to not overflow\n            // unnecessary.\n            int i \u003d n - k + 1;\n            for (int j \u003d 1; j \u003c\u003d k; j++) {\n                final long d \u003d gcd(i, j);\n                result \u003d mulAndCheck(result / (j / d), i / d);\n                i++;\n            }\n        }\n        return result;\n    }",
    "begin_line": 188,
    "end_line": 240,
    "comment": "/** \n * Returns an exact representation of the \u003ca href\u003d\"http://mathworld.wolfram.com/BinomialCoefficient.html\"\u003e Binomial Coefficient\u003c/a\u003e, \"\u003ccode\u003en choose k\u003c/code\u003e\", the number of \u003ccode\u003ek\u003c/code\u003e-element subsets that can be selected from an \u003ccode\u003en\u003c/code\u003e-element set. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003e0 \u003c\u003d k \u003c\u003d n \u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003cli\u003e The result is small enough to fit into a \u003ccode\u003elong\u003c/code\u003e. The largest value of \u003ccode\u003en\u003c/code\u003e for which all coefficients are \u003ccode\u003e \u003c Long.MAX_VALUE\u003c/code\u003e is 66. If the computed value exceeds \u003ccode\u003eLong.MAX_VALUE\u003c/code\u003e an \u003ccode\u003eArithMeticException\u003c/code\u003e is thrown.\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return \u003ccode\u003en choose k\u003c/code\u003e\n * @throws IllegalArgumentException if preconditions are not met.\n * @throws ArithmeticException if the result is too large to be representedby a long integer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.binomialCoefficientDouble#264",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.binomialCoefficientDouble(int, int)",
    "snippet": "public static double binomialCoefficientDouble(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n \u003d\u003d k) || (k \u003d\u003d 0)) {\n            return 1d;\n        }\n        if ((k \u003d\u003d 1) || (k \u003d\u003d n - 1)) {\n            return n;\n        }\n        if (k \u003e n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n \u003c 67) {\n            return binomialCoefficient(n,k);\n        }\n\n        double result \u003d 1d;\n        for (int i \u003d 1; i \u003c\u003d k; i++) {\n             result *\u003d (double)(n - k + i) / (double)i;\n        }\n\n        return Math.floor(result + 0.5);\n    }",
    "begin_line": 264,
    "end_line": 285,
    "comment": "/** \n * Returns a \u003ccode\u003edouble\u003c/code\u003e representation of the \u003ca href\u003d\"http://mathworld.wolfram.com/BinomialCoefficient.html\"\u003e Binomial Coefficient\u003c/a\u003e, \"\u003ccode\u003en choose k\u003c/code\u003e\", the number of \u003ccode\u003ek\u003c/code\u003e-element subsets that can be selected from an \u003ccode\u003en\u003c/code\u003e-element set. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003e0 \u003c\u003d k \u003c\u003d n \u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003cli\u003e The result is small enough to fit into a \u003ccode\u003edouble\u003c/code\u003e. The largest value of \u003ccode\u003en\u003c/code\u003e for which all coefficients are \u003c Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return \u003ccode\u003en choose k\u003c/code\u003e\n * @throws IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.binomialCoefficientLog#305",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.binomialCoefficientLog(int, int)",
    "snippet": "public static double binomialCoefficientLog(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n \u003d\u003d k) || (k \u003d\u003d 0)) {\n            return 0;\n        }\n        if ((k \u003d\u003d 1) || (k \u003d\u003d n - 1)) {\n            return Math.log(n);\n        }\n\n        /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value\n         */\n        if (n \u003c 67) {\n            return Math.log(binomialCoefficient(n,k));\n        }\n\n        /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n        if (n \u003c 1030) {\n            return Math.log(binomialCoefficientDouble(n, k));\n        }\n\n        if (k \u003e n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        /*\n         * Sum logs for values that could overflow\n         */\n        double logSum \u003d 0;\n\n        // n!/(n-k)!\n        for (int i \u003d n - k + 1; i \u003c\u003d n; i++) {\n            logSum +\u003d Math.log(i);\n        }\n\n        // divide by k!\n        for (int i \u003d 2; i \u003c\u003d k; i++) {\n            logSum -\u003d Math.log(i);\n        }\n\n        return logSum;\n    }",
    "begin_line": 305,
    "end_line": 350,
    "comment": "/** \n * Returns the natural \u003ccode\u003elog\u003c/code\u003e of the \u003ca href\u003d\"http://mathworld.wolfram.com/BinomialCoefficient.html\"\u003e Binomial Coefficient\u003c/a\u003e, \"\u003ccode\u003en choose k\u003c/code\u003e\", the number of \u003ccode\u003ek\u003c/code\u003e-element subsets that can be selected from an \u003ccode\u003en\u003c/code\u003e-element set. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003e0 \u003c\u003d k \u003c\u003d n \u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return \u003ccode\u003en choose k\u003c/code\u003e\n * @throws IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkBinomial#358",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkBinomial(int, int)",
    "snippet": "private static void checkBinomial(final int n, final int k)\n        throws IllegalArgumentException {\n        if (n \u003c k) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"must have n \u003e\u003d k for binomial coefficient (n,k), got n \u003d {0}, k \u003d {1}\",\n                n, k);\n        }\n        if (n \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n \u003e\u003d 0 for binomial coefficient (n,k), got n \u003d {0}\",\n                  n);\n        }\n    }",
    "begin_line": 358,
    "end_line": 370,
    "comment": "/** \n * Check binomial preconditions.\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @exception IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.compareTo#382",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.compareTo(double, double, double)",
    "snippet": "public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x \u003c y) {\n          return -1;\n        }\n        return 1;\n    }",
    "begin_line": 382,
    "end_line": 389,
    "comment": "/** \n * Compares two numbers given some amount of allowed error.\n * @param x the first number\n * @param y the second number\n * @param eps the amount of error to allow when checking for equality\n * @return \u003cul\u003e\u003cli\u003e0 if  {@link #equals(double,double,double) equals(x, y, eps)}\u003c/li\u003e \u003cli\u003e\u0026lt; 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u0026lt; y\u003c/li\u003e\u003cli\u003e\u003e 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u003e y\u003c/li\u003e\u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.cosh#398",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.cosh(double)",
    "snippet": "public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }",
    "begin_line": 398,
    "end_line": 400,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/HyperbolicCosine.html\"\u003e hyperbolic cosine\u003c/a\u003e of x.\n * @param x double value for which to find the hyperbolic cosine\n * @return hyperbolic cosine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#410",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double, double)",
    "snippet": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) \u0026\u0026 Double.isNaN(y)) || x \u003d\u003d y;\n    }",
    "begin_line": 410,
    "end_line": 412,
    "comment": "/** \n * Returns true iff both arguments are NaN or neither is NaN and they are equal\n * @param x first value\n * @param y second value\n * @return true if the values are equal or both are NaN\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#426",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double, double, double)",
    "snippet": "public static boolean equals(double x, double y, double eps) {\n      return equals(x, y) || (Math.abs(y - x) \u003c\u003d eps);\n    }",
    "begin_line": 426,
    "end_line": 428,
    "comment": "/** \n * Returns true iff both arguments are equal or within the range of allowed error (inclusive). \u003cp\u003e Two NaNs are considered equals, as are two infinities with same sign. \u003c/p\u003e\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow\n * @return true if the values are equal or within range of each other\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#444",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double, double, int)",
    "snippet": "public static boolean equals(double x, double y, int maxUlps) {\n        // Check that \"maxUlps\" is non-negative and small enough so that the\n        // default NAN won\u0027t compare as equal to anything.\n        assert maxUlps \u003e 0 \u0026\u0026 maxUlps \u003c NAN_GAP;\n\n        long xInt \u003d Double.doubleToLongBits(x);\n        long yInt \u003d Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two\u0027s-complement integer.\n        if (xInt \u003c 0) {\n            xInt \u003d SGN_MASK - xInt;\n        }\n        if (yInt \u003c 0) {\n            yInt \u003d SGN_MASK - yInt;\n        }\n\n        return Math.abs(xInt - yInt) \u003c\u003d maxUlps;\n    }",
    "begin_line": 444,
    "end_line": 461,
    "comment": "/** \n * Returns true iff both arguments are equal or within the range of allowed error (inclusive). Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if there are less than {@code maxUlps} floatingpoint values between  {@code x} and {@code y}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#473",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double[], double[])",
    "snippet": "public static boolean equals(double[] x, double[] y) {\n        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n        }\n        if (x.length !\u003d y.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 473,
    "end_line": 486,
    "comment": "/** \n * Returns true iff both arguments are null or have same dimensions and all their elements are  {@link #equals(double,double) equals}\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimensionand equal elements\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.factorial#510",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.factorial(int)",
    "snippet": "public static long factorial(final int n) {\n        if (n \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n \u003e\u003d 0 for n!, got n \u003d {0}\",\n                  n);\n        }\n        if (n \u003e 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return FACTORIALS[n];\n    }",
    "begin_line": 510,
    "end_line": 521,
    "comment": "/** \n * Returns n!. Shorthand for \u003ccode\u003en\u003c/code\u003e \u003ca href\u003d\"http://mathworld.wolfram.com/Factorial.html\"\u003e Factorial\u003c/a\u003e, the product of the numbers \u003ccode\u003e1,...,n\u003c/code\u003e. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003en \u003e\u003d 0\u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003cli\u003e The result is small enough to fit into a \u003ccode\u003elong\u003c/code\u003e. The largest value of \u003ccode\u003en\u003c/code\u003e for which \u003ccode\u003en!\u003c/code\u003e \u003c Long.MAX_VALUE\u003c/code\u003e is 20. If the computed value exceeds \u003ccode\u003eLong.MAX_VALUE\u003c/code\u003e an \u003ccode\u003eArithMeticException \u003c/code\u003e is thrown.\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e\n * @param n argument\n * @return \u003ccode\u003en!\u003c/code\u003e\n * @throws ArithmeticException if the result is too large to be representedby a long integer.\n * @throws IllegalArgumentException if n \u003c 0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.factorialDouble#543",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.factorialDouble(int)",
    "snippet": "public static double factorialDouble(final int n) {\n        if (n \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n \u003e\u003d 0 for n!, got n \u003d {0}\",\n                  n);\n        }\n        if (n \u003c 21) {\n            return factorial(n);\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }",
    "begin_line": 543,
    "end_line": 553,
    "comment": "/** \n * Returns n!. Shorthand for \u003ccode\u003en\u003c/code\u003e \u003ca href\u003d\"http://mathworld.wolfram.com/Factorial.html\"\u003e Factorial\u003c/a\u003e, the product of the numbers \u003ccode\u003e1,...,n\u003c/code\u003e as a \u003ccode\u003edouble\u003c/code\u003e. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003en \u003e\u003d 0\u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003cli\u003e The result is small enough to fit into a \u003ccode\u003edouble\u003c/code\u003e. The largest value of \u003ccode\u003en\u003c/code\u003e for which \u003ccode\u003en!\u003c/code\u003e \u003c Double.MAX_VALUE\u003c/code\u003e is 170. If the computed value exceeds Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e\n * @param n argument\n * @return \u003ccode\u003en!\u003c/code\u003e\n * @throws IllegalArgumentException if n \u003c 0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.factorialLog#568",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.factorialLog(int)",
    "snippet": "public static double factorialLog(final int n) {\n        if (n \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n \u003e\u003d 0 for n!, got n \u003d {0}\",\n                  n);\n        }\n        if (n \u003c 21) {\n            return Math.log(factorial(n));\n        }\n        double logSum \u003d 0;\n        for (int i \u003d 2; i \u003c\u003d n; i++) {\n            logSum +\u003d Math.log(i);\n        }\n        return logSum;\n    }",
    "begin_line": 568,
    "end_line": 582,
    "comment": "/** \n * Returns the natural logarithm of n!. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003en \u003e\u003d 0\u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n argument\n * @return \u003ccode\u003en!\u003c/code\u003e\n * @throws IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.gcd#614",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.gcd(int, int)",
    "snippet": "public static int gcd(final int p, final int q) {\n        int u \u003d p;\n        int v \u003d q;\n        if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n            if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow: gcd({0}, {1}) is 2^31\",\n                        p, q);\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can\u0027t necessarily negate a negative number without\n        // overflow)\n        /* assert u!\u003d0 \u0026\u0026 v!\u003d0; */\n        if (u \u003e 0) {\n            u \u003d -u;\n        } // make u negative\n        if (v \u003e 0) {\n            v \u003d -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k \u003d 0;\n        while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) { // while u and v are\n                                                            // both even...\n            u /\u003d 2;\n            v /\u003d 2;\n            k++; // cast out twos.\n        }\n        if (k \u003d\u003d 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u\u003c0 \u0026\u0026 v\u003c0; */\n            // B4/B3: cast out twos from t.\n            while ((t \u0026 1) \u003d\u003d 0) { // while t is even..\n                t /\u003d 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t \u003e 0) {\n                u \u003d -t;\n            } else {\n                v \u003d t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t \u003d (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t !\u003d 0);\n        return -u * (1 \u003c\u003c k); // gcd is u*2^k\n    }",
    "begin_line": 614,
    "end_line": 672,
    "comment": "/** \n * \u003cp\u003e Gets the greatest common divisor of the absolute value of two numbers, using the \"binary gcd\" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). \u003c/p\u003e Special cases: \u003cul\u003e \u003cli\u003eThe invocations \u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e, \u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and \u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an \u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which is too large for an int value.\u003c/li\u003e \u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and \u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except for the special cases above. \u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns \u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e \u003c/ul\u003e\n * @param p any number\n * @param q any number\n * @return the greatest common divisor, never negative\n * @throws ArithmeticException if the result cannot be represented as a nonnegative int value\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.hash#680",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.hash(double)",
    "snippet": "public static int hash(double value) {\n        return new Double(value).hashCode();\n    }",
    "begin_line": 680,
    "end_line": 682,
    "comment": "/** \n * Returns an integer hash code representing the given double value.\n * @param value the value to be hashed\n * @return the hash code\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.hash#691",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.hash(double[])",
    "snippet": "public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }",
    "begin_line": 691,
    "end_line": 693,
    "comment": "/** \n * Returns an integer hash code representing the given double array.\n * @param value the value to be hashed (may be null)\n * @return the hash code\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#702",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(byte)",
    "snippet": "public static byte indicator(final byte x) {\n        return (x \u003e\u003d ZB) ? PB : NB;\n    }",
    "begin_line": 702,
    "end_line": 704,
    "comment": "/** \n * For a byte value x, this method returns (byte)(+1) if x \u003e\u003d 0 and (byte)(-1) if x \u003c 0.\n * @param x the value, a byte\n * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#714",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(double)",
    "snippet": "public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x \u003e\u003d 0.0) ? 1.0 : -1.0;\n    }",
    "begin_line": 714,
    "end_line": 719,
    "comment": "/** \n * For a double precision value x, this method returns +1.0 if x \u003e\u003d 0 and -1.0 if x \u003c 0. Returns \u003ccode\u003eNaN\u003c/code\u003e if \u003ccode\u003ex\u003c/code\u003e is \u003ccode\u003eNaN\u003c/code\u003e.\n * @param x the value, a double\n * @return +1.0 or -1.0, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#728",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(float)",
    "snippet": "public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x \u003e\u003d 0.0F) ? 1.0F : -1.0F;\n    }",
    "begin_line": 728,
    "end_line": 733,
    "comment": "/** \n * For a float value x, this method returns +1.0F if x \u003e\u003d 0 and -1.0F if x \u003c 0. Returns \u003ccode\u003eNaN\u003c/code\u003e if \u003ccode\u003ex\u003c/code\u003e is \u003ccode\u003eNaN\u003c/code\u003e.\n * @param x the value, a float\n * @return +1.0F or -1.0F, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#741",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(int)",
    "snippet": "public static int indicator(final int x) {\n        return (x \u003e\u003d 0) ? 1 : -1;\n    }",
    "begin_line": 741,
    "end_line": 743,
    "comment": "/** \n * For an int value x, this method returns +1 if x \u003e\u003d 0 and -1 if x \u003c 0.\n * @param x the value, an int\n * @return +1 or -1, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#751",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(long)",
    "snippet": "public static long indicator(final long x) {\n        return (x \u003e\u003d 0L) ? 1L : -1L;\n    }",
    "begin_line": 751,
    "end_line": 753,
    "comment": "/** \n * For a long value x, this method returns +1L if x \u003e\u003d 0 and -1L if x \u003c 0.\n * @param x the value, a long\n * @return +1L or -1L, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#762",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(short)",
    "snippet": "public static short indicator(final short x) {\n        return (x \u003e\u003d ZS) ? PS : NS;\n    }",
    "begin_line": 762,
    "end_line": 764,
    "comment": "/** \n * For a short value x, this method returns (short)(+1) if x \u003e\u003d 0 and (short)(-1) if x \u003c 0.\n * @param x the value, a short\n * @return (short)(+1) or (short)(-1), depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.lcm#789",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.lcm(int, int)",
    "snippet": "public static int lcm(int a, int b) {\n        if (a\u003d\u003d0 || b\u003d\u003d0){\n            return 0;\n        }\n        int lcm \u003d Math.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm \u003d\u003d Integer.MIN_VALUE){\n            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n        }\n        return lcm;\n    }",
    "begin_line": 789,
    "end_line": 798,
    "comment": "/** \n * \u003cp\u003e Returns the least common multiple of the absolute value of two numbers, using the formula \u003ccode\u003elcm(a,b) \u003d (a / gcd(a,b)) * b\u003c/code\u003e. \u003c/p\u003e Special cases: \u003cul\u003e \u003cli\u003eThe invocations \u003ccode\u003elcm(Integer.MIN_VALUE, n)\u003c/code\u003e and \u003ccode\u003elcm(n, Integer.MIN_VALUE)\u003c/code\u003e, where \u003ccode\u003eabs(n)\u003c/code\u003e is a power of 2, throw an \u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which is too large for an int value.\u003c/li\u003e \u003cli\u003eThe result of \u003ccode\u003elcm(0, x)\u003c/code\u003e and \u003ccode\u003elcm(x, 0)\u003c/code\u003e is \u003ccode\u003e0\u003c/code\u003e for any \u003ccode\u003ex\u003c/code\u003e. \u003c/ul\u003e\n * @param a any number\n * @param b any number\n * @return the least common multiple, never negative\n * @throws ArithmeticException if the result cannot be represented as a nonnegative int value\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.log#816",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.log(double, double)",
    "snippet": "public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }",
    "begin_line": 816,
    "end_line": 818,
    "comment": "/** \n * \u003cp\u003eReturns the \u003ca href\u003d\"http://mathworld.wolfram.com/Logarithm.html\"\u003elogarithm\u003c/a\u003e for base \u003ccode\u003eb\u003c/code\u003e of \u003ccode\u003ex\u003c/code\u003e. \u003c/p\u003e \u003cp\u003eReturns \u003ccode\u003eNaN\u003ccode\u003e if either argument is negative.  If \u003ccode\u003ebase\u003c/code\u003e is 0 and \u003ccode\u003ex\u003c/code\u003e is positive, 0 is returned. If \u003ccode\u003ebase\u003c/code\u003e is positive and \u003ccode\u003ex\u003c/code\u003e is 0, \u003ccode\u003eDouble.NEGATIVE_INFINITY\u003c/code\u003e is returned.  If both arguments are 0, the result is \u003ccode\u003eNaN\u003c/code\u003e.\u003c/p\u003e\n * @param base the base of the logarithm, must be greater than 0\n * @param x argument, must be greater than 0\n * @return the value of the logarithm - the number y such that base^y \u003d x.\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.mulAndCheck#830",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.mulAndCheck(int, int)",
    "snippet": "public static int mulAndCheck(int x, int y) {\n        long m \u003d ((long)x) * ((long)y);\n        if (m \u003c Integer.MIN_VALUE || m \u003e Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }",
    "begin_line": 830,
    "end_line": 836,
    "comment": "/** \n * Multiply two integers, checking for overflow.\n * @param x a factor\n * @param y a factor\n * @return the product \u003ccode\u003ex*y\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anint\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.mulAndCheck#848",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.mulAndCheck(long, long)",
    "snippet": "public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg \u003d \"overflow: multiply\";\n        if (a \u003e b) {\n            // use symmetry to reduce boundary cases\n            ret \u003d mulAndCheck(b, a);\n        } else {\n            if (a \u003c 0) {\n                if (b \u003c 0) {\n                    // check for positive overflow with negative a, negative b\n                    if (a \u003e\u003d Long.MAX_VALUE / b) {\n                        ret \u003d a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b \u003e 0) {\n                    // check for negative overflow with negative a, positive b\n                    if (Long.MIN_VALUE / b \u003c\u003d a) {\n                        ret \u003d a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n\n                    }\n                } else {\n                    // assert b \u003d\u003d 0\n                    ret \u003d 0;\n                }\n            } else if (a \u003e 0) {\n                // assert a \u003e 0\n                // assert b \u003e 0\n\n                // check for positive overflow with positive a, positive b\n                if (a \u003c\u003d Long.MAX_VALUE / b) {\n                    ret \u003d a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                // assert a \u003d\u003d 0\n                ret \u003d 0;\n            }\n        }\n        return ret;\n    }",
    "begin_line": 848,
    "end_line": 891,
    "comment": "/** \n * Multiply two long integers, checking for overflow.\n * @param a first value\n * @param b second value\n * @return the product \u003ccode\u003ea * b\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anlong\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.nextAfter#910",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.nextAfter(double, double)",
    "snippet": "public static double nextAfter(double d, double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d \u003d\u003d 0) {\n                return (direction \u003c 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        // split the double in raw components\n        long bits     \u003d Double.doubleToLongBits(d);\n        long sign     \u003d bits \u0026 0x8000000000000000L;\n        long exponent \u003d bits \u0026 0x7ff0000000000000L;\n        long mantissa \u003d bits \u0026 0x000fffffffffffffL;\n\n        if (d * (direction - d) \u003e\u003d 0) {\n                // we should increase the mantissa\n                if (mantissa \u003d\u003d 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                // we should decrease the mantissa\n                if (mantissa \u003d\u003d 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }",
    "begin_line": 910,
    "end_line": 948,
    "comment": "/** \n * Get the next machine representable number after a number, moving in the direction of another number. \u003cp\u003e If \u003ccode\u003edirection\u003c/code\u003e is greater than or equal to\u003ccode\u003ed\u003c/code\u003e, the smallest machine representable number strictly greater than \u003ccode\u003ed\u003c/code\u003e is returned; otherwise the largest representable number strictly less than \u003ccode\u003ed\u003c/code\u003e is returned.\u003c/p\u003e \u003cp\u003e If \u003ccode\u003ed\u003c/code\u003e is NaN or Infinite, it is returned unchanged.\u003c/p\u003e\n * @param d base number\n * @param direction (the only important thing is whetherdirection is greater or smaller than d)\n * @return the next machine representable number in the specified direction\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.scalb#959",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.scalb(double, int)",
    "snippet": "public static double scalb(final double d, final int scaleFactor) {\n\n        // handling of some important special cases\n        if ((d \u003d\u003d 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        // split the double in raw components\n        final long bits     \u003d Double.doubleToLongBits(d);\n        final long exponent \u003d bits \u0026 0x7ff0000000000000L;\n        final long rest     \u003d bits \u0026 0x800fffffffffffffL;\n\n        // shift the exponent\n        final long newBits \u003d rest | (exponent + (((long) scaleFactor) \u003c\u003c 52));\n        return Double.longBitsToDouble(newBits);\n\n    }",
    "begin_line": 959,
    "end_line": 975,
    "comment": "/** \n * Scale a number by 2\u003csup\u003escaleFactor\u003c/sup\u003e. \u003cp\u003eIf \u003ccode\u003ed\u003c/code\u003e is 0 or NaN or Infinite, it is returned unchanged.\u003c/p\u003e\n * @param d base number\n * @param scaleFactor power of two by which d sould be multiplied\n * @return d \u0026times; 2\u003csup\u003escaleFactor\u003c/sup\u003e\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.normalizeAngle#996",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.normalizeAngle(double, double)",
    "snippet": "public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }",
    "begin_line": 996,
    "end_line": 998,
    "comment": "/** \n * Normalize an angle in a 2\u0026pi wide interval around a center value. \u003cp\u003eThis method has three main uses:\u003c/p\u003e \u003cul\u003e \u003cli\u003enormalize an angle between 0 and 2\u0026pi;:\u003cbr/\u003e \u003ccode\u003ea \u003d MathUtils.normalizeAngle(a, Math.PI);\u003c/code\u003e\u003c/li\u003e \u003cli\u003enormalize an angle between -\u0026pi; and +\u0026pi;\u003cbr/\u003e \u003ccode\u003ea \u003d MathUtils.normalizeAngle(a, 0.0);\u003c/code\u003e\u003c/li\u003e \u003cli\u003ecompute the angle between two defining angular positions:\u003cbr\u003e \u003ccode\u003eangle \u003d MathUtils.normalizeAngle(end, start) - start;\u003c/code\u003e\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eNote that due to numerical accuracy and since \u0026pi; cannot be represented exactly, the result interval is \u003cem\u003eclosed\u003c/em\u003e, it cannot be half-closed as would be more satisfactory in a purely mathematical view.\u003c/p\u003e\n * @param a angle to normalize\n * @param center center of the desired 2\u0026pi; interval for the result\n * @return a-2k\u0026pi; with integer k and center-\u0026pi; \u0026lt;\u003d a-2k\u0026pi; \u0026lt;\u003d center+\u0026pi;\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.normalizeArray#1020",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.normalizeArray(double[], double)",
    "snippet": "public static double[] normalizeArray(double[] values, double normalizedSum)\n       throws ArithmeticException, IllegalArgumentException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"Cannot normalize to an infinite value\");\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"Cannot normalize to NaN\");\n         }\n         double sum \u003d 0d;\n         final int len \u003d values.length;\n         double[] out \u003d new double[len];\n         for (int i \u003d 0; i \u003c len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw MathRuntimeException.createArithmeticException(\n                         \"Array contains an infinite element, {0} at index {1}\", values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum +\u003d values[i];\n             }\n         }\n         if (sum \u003d\u003d 0) {\n             throw MathRuntimeException.createArithmeticException(\n                     \"Array sums to zero\");\n         }\n         for (int i \u003d 0; i \u003c len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] \u003d Double.NaN;\n             } else {\n                 out[i] \u003d values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }",
    "begin_line": 1020,
    "end_line": 1054,
    "comment": "/** \n * \u003cp\u003eNormalizes an array to make it sum to a specified value. Returns the result of the transformation \u003cpre\u003e x |-\u003e x * normalizedSum / sum \u003c/pre\u003e applied to each non-NaN element x of the input array, where sum is the sum of the non-NaN entries in the input array.\u003c/p\u003e \u003cp\u003eThrows IllegalArgumentException if \u003ccode\u003enormalizedSum\u003c/code\u003e is infinite or NaN and ArithmeticException if the input array contains any infinite elements or sums to 0\u003c/p\u003e \u003cp\u003eIgnores (i.e., copies unchanged to the output array) NaNs in the input array.\u003c/p\u003e\n * @param values input array to be normalized\n * @param normalizedSum target sum for the normalized array\n * @return normalized array\n * @throws ArithmeticException if the input array contains infinite elements or sums to zero\n * @throws IllegalArgumentException if the target sum is infinite or NaN\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1065",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(double, int)",
    "snippet": "public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }",
    "begin_line": 1065,
    "end_line": 1067,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounded using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1081",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(double, int, int)",
    "snippet": "public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;\n            } else {\n                return Double.NaN;\n            }\n        }\n    }",
    "begin_line": 1081,
    "end_line": 1094,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in {@link BigDecimal}.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @param roundingMethod the rounding method as defined in{@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1105",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(float, int)",
    "snippet": "public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }",
    "begin_line": 1105,
    "end_line": 1107,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounding using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1121",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(float, int, int)",
    "snippet": "public static float round(float x, int scale, int roundingMethod) {\n        float sign \u003d indicator(x);\n        float factor \u003d (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }",
    "begin_line": 1121,
    "end_line": 1125,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in {@link BigDecimal}.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @param roundingMethod the rounding method as defined in{@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.roundUnscaled#1139",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.roundUnscaled(double, double, int)",
    "snippet": "private static double roundUnscaled(double unscaled, double sign,\n        int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign \u003d\u003d -1) {\n                unscaled \u003d Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled \u003d Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled \u003d Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign \u003d\u003d -1) {\n                unscaled \u003d Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled \u003d Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled \u003d nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction \u003d unscaled - Math.floor(unscaled);\n            if (fraction \u003e 0.5) {\n                unscaled \u003d Math.ceil(unscaled);\n            } else {\n                unscaled \u003d Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction \u003d unscaled - Math.floor(unscaled);\n            if (fraction \u003e 0.5) {\n                unscaled \u003d Math.ceil(unscaled);\n            } else if (fraction \u003c 0.5) {\n                unscaled \u003d Math.floor(unscaled);\n            } else {\n                // The following equality test is intentional and needed for rounding purposes\n                if (Math.floor(unscaled) / 2.0 \u003d\u003d Math.floor(Math\n                    .floor(unscaled) / 2.0)) { // even\n                    unscaled \u003d Math.floor(unscaled);\n                } else { // odd\n                    unscaled \u003d Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled \u003d nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction \u003d unscaled - Math.floor(unscaled);\n            if (fraction \u003e\u003d 0.5) {\n                unscaled \u003d Math.ceil(unscaled);\n            } else {\n                unscaled \u003d Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled !\u003d Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled \u003d Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" +\n                  \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n                  roundingMethod,\n                  \"ROUND_CEILING\",     BigDecimal.ROUND_CEILING,\n                  \"ROUND_DOWN\",        BigDecimal.ROUND_DOWN,\n                  \"ROUND_FLOOR\",       BigDecimal.ROUND_FLOOR,\n                  \"ROUND_HALF_DOWN\",   BigDecimal.ROUND_HALF_DOWN,\n                  \"ROUND_HALF_EVEN\",   BigDecimal.ROUND_HALF_EVEN,\n                  \"ROUND_HALF_UP\",     BigDecimal.ROUND_HALF_UP,\n                  \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n                  \"ROUND_UP\",          BigDecimal.ROUND_UP);\n        }\n        return unscaled;\n    }",
    "begin_line": 1139,
    "end_line": 1219,
    "comment": "/** \n * Round the given non-negative, value to the \"nearest\" integer. Nearest is determined by the rounding method specified. Rounding methods are defined in  {@link BigDecimal}.\n * @param unscaled the value to round.\n * @param sign the sign of the original, scaled value.\n * @param roundingMethod the rounding method as defined in{@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1231",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(byte)",
    "snippet": "public static byte sign(final byte x) {\n        return (x \u003d\u003d ZB) ? ZB : (x \u003e ZB) ? PB : NB;\n    }",
    "begin_line": 1231,
    "end_line": 1233,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for byte value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a byte value x, this method returns (byte)(+1) if x \u003e 0, (byte)(0) if x \u003d 0, and (byte)(-1) if x \u003c 0.\u003c/p\u003e\n * @param x the value, a byte\n * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1247",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(double)",
    "snippet": "public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x \u003d\u003d 0.0) ? 0.0 : (x \u003e 0.0) ? 1.0 : -1.0;\n    }",
    "begin_line": 1247,
    "end_line": 1252,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for double precision \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a double value \u003ccode\u003ex\u003c/code\u003e, this method returns \u003ccode\u003e+1.0\u003c/code\u003e if \u003ccode\u003ex \u003e 0\u003c/code\u003e, \u003ccode\u003e0.0\u003c/code\u003e if \u003ccode\u003ex \u003d 0.0\u003c/code\u003e, and \u003ccode\u003e-1.0\u003c/code\u003e if \u003ccode\u003ex \u003c 0\u003c/code\u003e. Returns \u003ccode\u003eNaN\u003c/code\u003e if \u003ccode\u003ex\u003c/code\u003e is \u003ccode\u003eNaN\u003c/code\u003e.\u003c/p\u003e\n * @param x the value, a double\n * @return +1.0, 0.0, or -1.0, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1265",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(float)",
    "snippet": "public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x \u003d\u003d 0.0F) ? 0.0F : (x \u003e 0.0F) ? 1.0F : -1.0F;\n    }",
    "begin_line": 1265,
    "end_line": 1270,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for float value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a float value x, this method returns +1.0F if x \u003e 0, 0.0F if x \u003d 0.0F, and -1.0F if x \u003c 0. Returns \u003ccode\u003eNaN\u003c/code\u003e if \u003ccode\u003ex\u003c/code\u003e is \u003ccode\u003eNaN\u003c/code\u003e.\u003c/p\u003e\n * @param x the value, a float\n * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1282",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(int)",
    "snippet": "public static int sign(final int x) {\n        return (x \u003d\u003d 0) ? 0 : (x \u003e 0) ? 1 : -1;\n    }",
    "begin_line": 1282,
    "end_line": 1284,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for int value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For an int value x, this method returns +1 if x \u003e 0, 0 if x \u003d 0, and -1 if x \u003c 0.\u003c/p\u003e\n * @param x the value, an int\n * @return +1, 0, or -1, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1296",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(long)",
    "snippet": "public static long sign(final long x) {\n        return (x \u003d\u003d 0L) ? 0L : (x \u003e 0L) ? 1L : -1L;\n    }",
    "begin_line": 1296,
    "end_line": 1298,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for long value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a long value x, this method returns +1L if x \u003e 0, 0L if x \u003d 0, and -1L if x \u003c 0.\u003c/p\u003e\n * @param x the value, a long\n * @return +1L, 0L, or -1L, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1311",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(short)",
    "snippet": "public static short sign(final short x) {\n        return (x \u003d\u003d ZS) ? ZS : (x \u003e ZS) ? PS : NS;\n    }",
    "begin_line": 1311,
    "end_line": 1313,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for short value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a short value x, this method returns (short)(+1) if x \u003e 0, (short)(0) if x \u003d 0, and (short)(-1) if x \u003c 0.\u003c/p\u003e\n * @param x the value, a short\n * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign ofx\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sinh#1322",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sinh(double)",
    "snippet": "public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }",
    "begin_line": 1322,
    "end_line": 1324,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/HyperbolicSine.html\"\u003e hyperbolic sine\u003c/a\u003e of x.\n * @param x double value for which to find the hyperbolic sine\n * @return hyperbolic sine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.subAndCheck#1336",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.subAndCheck(int, int)",
    "snippet": "public static int subAndCheck(int x, int y) {\n        long s \u003d (long)x - (long)y;\n        if (s \u003c Integer.MIN_VALUE || s \u003e Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }",
    "begin_line": 1336,
    "end_line": 1342,
    "comment": "/** \n * Subtract two integers, checking for overflow.\n * @param x the minuend\n * @param y the subtrahend\n * @return the difference \u003ccode\u003ex-y\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anint\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.subAndCheck#1354",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.subAndCheck(long, long)",
    "snippet": "public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg \u003d \"overflow: subtract\";\n        if (b \u003d\u003d Long.MIN_VALUE) {\n            if (a \u003c 0) {\n                ret \u003d a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            // use additive inverse\n            ret \u003d addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }",
    "begin_line": 1354,
    "end_line": 1368,
    "comment": "/** \n * Subtract two long integers, checking for overflow.\n * @param a first value\n * @param b second value\n * @return the difference \u003ccode\u003ea-b\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anlong\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1377",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(int, int)",
    "snippet": "public static int pow(final int k, int e)\n        throws IllegalArgumentException {\n\n        if (e \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        int result \u003d 1;\n        int k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result *\u003d k2p;\n            }\n            k2p *\u003d k2p;\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n\n    }",
    "begin_line": 1377,
    "end_line": 1398,
    "comment": "/** \n * Raise an int to an int power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1407",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(int, long)",
    "snippet": "public static int pow(final int k, long e)\n        throws IllegalArgumentException {\n\n        if (e \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        int result \u003d 1;\n        int k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result *\u003d k2p;\n            }\n            k2p *\u003d k2p;\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n\n    }",
    "begin_line": 1407,
    "end_line": 1428,
    "comment": "/** \n * Raise an int to a long power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1437",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(long, int)",
    "snippet": "public static long pow(final long k, int e)\n        throws IllegalArgumentException {\n\n        if (e \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        long result \u003d 1l;\n        long k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result *\u003d k2p;\n            }\n            k2p *\u003d k2p;\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n\n    }",
    "begin_line": 1437,
    "end_line": 1458,
    "comment": "/** \n * Raise a long to an int power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1467",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(long, long)",
    "snippet": "public static long pow(final long k, long e)\n        throws IllegalArgumentException {\n\n        if (e \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        long result \u003d 1l;\n        long k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result *\u003d k2p;\n            }\n            k2p *\u003d k2p;\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n\n    }",
    "begin_line": 1467,
    "end_line": 1488,
    "comment": "/** \n * Raise a long to a long power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1497",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(java.math.BigInteger, int)",
    "snippet": "public static BigInteger pow(final BigInteger k, int e)\n        throws IllegalArgumentException {\n\n        if (e \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        return k.pow(e);\n\n    }",
    "begin_line": 1497,
    "end_line": 1508,
    "comment": "/** \n * Raise a BigInteger to an int power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1517",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(java.math.BigInteger, long)",
    "snippet": "public static BigInteger pow(final BigInteger k, long e)\n        throws IllegalArgumentException {\n\n        if (e \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        BigInteger result \u003d BigInteger.ONE;\n        BigInteger k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result \u003d result.multiply(k2p);\n            }\n            k2p \u003d k2p.multiply(k2p);\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n\n    }",
    "begin_line": 1517,
    "end_line": 1538,
    "comment": "/** \n * Raise a BigInteger to a long power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1547",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(java.math.BigInteger, java.math.BigInteger)",
    "snippet": "public static BigInteger pow(final BigInteger k, BigInteger e)\n        throws IllegalArgumentException {\n\n        if (e.compareTo(BigInteger.ZERO) \u003c 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        BigInteger result \u003d BigInteger.ONE;\n        BigInteger k2p    \u003d k;\n        while (!BigInteger.ZERO.equals(e)) {\n            if (e.testBit(0)) {\n                result \u003d result.multiply(k2p);\n            }\n            k2p \u003d k2p.multiply(k2p);\n            e \u003d e.shiftRight(1);\n        }\n\n        return result;\n\n    }",
    "begin_line": 1547,
    "end_line": 1568,
    "comment": "/** \n * Raise a BigInteger to a BigInteger power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance1#1577",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance1(double[], double[])",
    "snippet": "public static double distance1(double[] p1, double[] p2) {\n        double sum \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            sum +\u003d Math.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }",
    "begin_line": 1577,
    "end_line": 1583,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance1#1592",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance1(int[], int[])",
    "snippet": "public static int distance1(int[] p1, int[] p2) {\n      int sum \u003d 0;\n      for (int i \u003d 0; i \u003c p1.length; i++) {\n          sum +\u003d Math.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }",
    "begin_line": 1592,
    "end_line": 1598,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance#1607",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance(double[], double[])",
    "snippet": "public static double distance(double[] p1, double[] p2) {\n        double sum \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            final double dp \u003d p1[i] - p2[i];\n            sum +\u003d dp * dp;\n        }\n        return Math.sqrt(sum);\n    }",
    "begin_line": 1607,
    "end_line": 1614,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance#1623",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance(int[], int[])",
    "snippet": "public static double distance(int[] p1, int[] p2) {\n      int sum \u003d 0;\n      for (int i \u003d 0; i \u003c p1.length; i++) {\n          final int dp \u003d p1[i] - p2[i];\n          sum +\u003d dp * dp;\n      }\n      return Math.sqrt(sum);\n    }",
    "begin_line": 1623,
    "end_line": 1630,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distanceInf#1639",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distanceInf(double[], double[])",
    "snippet": "public static double distanceInf(double[] p1, double[] p2) {\n        double max \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            max \u003d Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }",
    "begin_line": 1639,
    "end_line": 1645,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distanceInf#1654",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distanceInf(int[], int[])",
    "snippet": "public static int distanceInf(int[] p1, int[] p2) {\n        int max \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            max \u003d Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }",
    "begin_line": 1654,
    "end_line": 1660,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]