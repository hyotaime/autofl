[
  {
    "name": "ClassUtils.ClassUtils#145",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.ClassUtils()",
    "snippet": "public ClassUtils() {\n      super();\n    }",
    "begin_line": 145,
    "end_line": 147,
    "comment": "/** \n * \u003cp\u003eClassUtils instances should NOT be constructed in standard programming. Instead, the class should be used as {@code ClassUtils.getShortClassName(cls)}.\u003c/p\u003e \u003cp\u003eThis constructor is public to permit tools that require a JavaBean instance to operate.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getShortClassName#158",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getShortClassName(java.lang.Object, java.lang.String)",
    "snippet": "public static String getShortClassName(final Object object, final String valueIfNull) {\n        if (object \u003d\u003d null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }",
    "begin_line": 158,
    "end_line": 163,
    "comment": "/** \n * \u003cp\u003eGets the class name minus the package name for an  {@code Object}.\u003c/p\u003e\n * @param object  the class to get the short name for, may be null\n * @param valueIfNull  the value to return if null\n * @return the class name of the object without the package name, or the null value\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getShortClassName#175",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getShortClassName(java.lang.Class\u003c?\u003e)",
    "snippet": "public static String getShortClassName(final Class\u003c?\u003e cls) {\n        if (cls \u003d\u003d null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }",
    "begin_line": 175,
    "end_line": 180,
    "comment": "/** \n * \u003cp\u003eGets the class name minus the package name from a  {@code Class}.\u003c/p\u003e \u003cp\u003eConsider using the Java 5 API  {@link Class#getSimpleName()} instead.The one known difference is that this code will return  {@code \"Map.Entry\"} whilethe  {@code java.lang.Class} variant will simply return {@code \"Entry\"}. \u003c/p\u003e\n * @param cls  the class to get the short name for.\n * @return the class name without the package name or an empty string\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getShortClassName#194",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getShortClassName(java.lang.String)",
    "snippet": "public static String getShortClassName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        final StringBuilder arrayPrefix \u003d new StringBuilder();\n\n        // Handle array encoding\n        if (className.startsWith(\"[\")) {\n            while (className.charAt(0) \u003d\u003d \u0027[\u0027) {\n                className \u003d className.substring(1);\n                arrayPrefix.append(\"[]\");\n            }\n            // Strip Object type encoding\n            if (className.charAt(0) \u003d\u003d \u0027L\u0027 \u0026\u0026 className.charAt(className.length() - 1) \u003d\u003d \u0027;\u0027) {\n                className \u003d className.substring(1, className.length() - 1);\n            }\n\n            if (reverseAbbreviationMap.containsKey(className)) {\n                className \u003d reverseAbbreviationMap.get(className);\n            }\n        }\n\n        final int lastDotIdx \u003d className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        final int innerIdx \u003d className.indexOf(\n                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx \u003d\u003d -1 ? 0 : lastDotIdx + 1);\n        String out \u003d className.substring(lastDotIdx + 1);\n        if (innerIdx !\u003d -1) {\n            out \u003d out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out + arrayPrefix;\n    }",
    "begin_line": 194,
    "end_line": 225,
    "comment": "/** \n * \u003cp\u003eGets the class name minus the package name from a String.\u003c/p\u003e \u003cp\u003eThe string passed in is assumed to be a class name - it is not checked.\u003c/p\u003e \u003cp\u003eNote that this method differs from Class.getSimpleName() in that this will return  {@code \"Map.Entry\"} whilst the {@code java.lang.Class} variant will simplyreturn  {@code \"Entry\"}. \u003c/p\u003e\n * @param className  the className to get the short name for\n * @return the class name of the class without the package name or an empty string\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getSimpleName#235",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getSimpleName(java.lang.Class\u003c?\u003e)",
    "snippet": "public static String getSimpleName(final Class\u003c?\u003e cls) {\n        if (cls \u003d\u003d null) {\n            return StringUtils.EMPTY;\n        }\n        return cls.getSimpleName();\n    }",
    "begin_line": 235,
    "end_line": 240,
    "comment": "/** \n * \u003cp\u003eNull-safe version of \u003ccode\u003eaClass.getSimpleName()\u003c/code\u003e\u003c/p\u003e\n * @param cls the class for which to get the simple name.\n * @return the simple class name.\n * @since 3.0\n * @see Class#getSimpleName()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getSimpleName#251",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getSimpleName(java.lang.Object, java.lang.String)",
    "snippet": "public static String getSimpleName(final Object object, final String valueIfNull) {\n        if (object \u003d\u003d null) {\n            return valueIfNull;\n        }\n        return getSimpleName(object.getClass());\n    }",
    "begin_line": 251,
    "end_line": 256,
    "comment": "/** \n * \u003cp\u003eNull-safe version of \u003ccode\u003eaClass.getSimpleName()\u003c/code\u003e\u003c/p\u003e\n * @param object the object for which to get the simple class name.\n * @param valueIfNull the value to return if \u003ccode\u003eobject\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e\n * @return the simple class name.\n * @since 3.0\n * @see Class#getSimpleName()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getPackageName#267",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getPackageName(java.lang.Object, java.lang.String)",
    "snippet": "public static String getPackageName(final Object object, final String valueIfNull) {\n        if (object \u003d\u003d null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }",
    "begin_line": 267,
    "end_line": 272,
    "comment": "/** \n * \u003cp\u003eGets the package name of an  {@code Object}.\u003c/p\u003e\n * @param object  the class to get the package name for, may be null\n * @param valueIfNull  the value to return if null\n * @return the package name of the object, or the null value\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getPackageName#280",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getPackageName(java.lang.Class\u003c?\u003e)",
    "snippet": "public static String getPackageName(final Class\u003c?\u003e cls) {\n        if (cls \u003d\u003d null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }",
    "begin_line": 280,
    "end_line": 285,
    "comment": "/** \n * \u003cp\u003eGets the package name of a  {@code Class}.\u003c/p\u003e\n * @param cls  the class to get the package name for, may be {@code null}.\n * @return the package name or an empty string\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getPackageName#296",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getPackageName(java.lang.String)",
    "snippet": "public static String getPackageName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        // Strip array encoding\n        while (className.charAt(0) \u003d\u003d \u0027[\u0027) {\n            className \u003d className.substring(1);\n        }\n        // Strip Object type encoding\n        if (className.charAt(0) \u003d\u003d \u0027L\u0027 \u0026\u0026 className.charAt(className.length() - 1) \u003d\u003d \u0027;\u0027) {\n            className \u003d className.substring(1);\n        }\n\n        final int i \u003d className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i \u003d\u003d -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }",
    "begin_line": 296,
    "end_line": 315,
    "comment": "/** \n * \u003cp\u003eGets the package name from a  {@code String}.\u003c/p\u003e \u003cp\u003eThe string passed in is assumed to be a class name - it is not checked.\u003c/p\u003e \u003cp\u003eIf the class is unpackaged, return an empty string.\u003c/p\u003e\n * @param className  the className to get the package name for, may be {@code null}\n * @return the package name or an empty string\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getAbbreviatedName#329",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getAbbreviatedName(java.lang.Class\u003c?\u003e, int)",
    "snippet": "public static String getAbbreviatedName(final Class\u003c?\u003e cls, int len) {\n      if (cls \u003d\u003d null) {\n        return StringUtils.EMPTY;\n      }\n      return getAbbreviatedName(cls.getName(), len);\n    }",
    "begin_line": 329,
    "end_line": 334,
    "comment": "/** \n * \u003cp\u003eGets the abbreviated name of a  {@code Class}.\u003c/p\u003e\n * @param cls  the class to get the abbreviated name for, may be {@code null}\n * @param len  the desired length of the abbreviated name\n * @return the abbreviated name or an empty string\n * @throws IllegalArgumentException if len \u0026lt;\u003d 0\n * @see #getAbbreviatedName(String,int)\n * @since 3.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getAbbreviatedName#361",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getAbbreviatedName(java.lang.String, int)",
    "snippet": "public static String getAbbreviatedName(String className, int len) {\n      if (len \u003c\u003d 0) {\n        throw new IllegalArgumentException(\"len must be \u003e 0\");\n      }\n      if (className \u003d\u003d null) {\n        return StringUtils.EMPTY;\n      }\n\n      int availableSpace \u003d len;\n      int packageLevels \u003d StringUtils.countMatches(className, \u0027.\u0027);\n      String[] output \u003d new String[packageLevels + 1];\n      int endIndex \u003d className.length() - 1;\n      for (int level \u003d packageLevels; level \u003e\u003d 0; level--) {\n        int startIndex \u003d className.lastIndexOf(\u0027.\u0027, endIndex);\n        String part \u003d className.substring(startIndex + 1, endIndex + 1);\n        availableSpace -\u003d part.length();\n        if (level \u003e 0) {\n          // all elements except top level require an additional char space\n          availableSpace--;\n        }\n        if (level \u003d\u003d packageLevels) {\n          // ClassName is always complete\n          output[level] \u003d part;\n        } else {\n          if (availableSpace \u003e 0) {\n            output[level] \u003d part;\n          } else {\n            // if no space is left still the first char is used\n            output[level] \u003d part.substring(0, 1);\n          }\n        }\n        endIndex \u003d startIndex - 1;\n      }\n\n      return StringUtils.join(output, \u0027.\u0027);\n    }",
    "begin_line": 361,
    "end_line": 396,
    "comment": "/** \n * \u003cp\u003eGets the abbreviated class name from a  {@code String}.\u003c/p\u003e \u003cp\u003eThe string passed in is assumed to be a class name - it is not checked.\u003c/p\u003e \u003cp\u003eThe abbreviation algorithm will shorten the class name, usually without significant loss of meaning.\u003c/p\u003e \u003cp\u003eThe abbreviated class name will always include the complete package hierarchy. If enough space is available, rightmost sub-packages will be displayed in full length.\u003c/p\u003e \u003cp\u003eThe following table illustrates the algorithm:\u003c/p\u003e \u003ctable summary\u003d\"abbreviation examples\"\u003e \u003ctr\u003e\u003ctd\u003eclassName\u003c/td\u003e\u003ctd\u003elen\u003c/td\u003e\u003ctd\u003ereturn\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e              null\u003c/td\u003e\u003ctd\u003e 1\u003c/td\u003e\u003ctd\u003e\"\"\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e\"java.lang.String\"\u003c/td\u003e\u003ctd\u003e 5\u003c/td\u003e\u003ctd\u003e\"j.l.String\"\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e\"java.lang.String\"\u003c/td\u003e\u003ctd\u003e15\u003c/td\u003e\u003ctd\u003e\"j.lang.String\"\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e\"java.lang.String\"\u003c/td\u003e\u003ctd\u003e30\u003c/td\u003e\u003ctd\u003e\"java.lang.String\"\u003c/td\u003e\u003c/tr\u003e \u003c/table\u003e\n * @param className  the className to get the abbreviated name for, may be {@code null}\n * @param len  the desired length of the abbreviated name\n * @return the abbreviated name or an empty string\n * @throws IllegalArgumentException if len \u0026lt;\u003d 0\n * @since 3.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getAllSuperclasses#407",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getAllSuperclasses(java.lang.Class\u003c?\u003e)",
    "snippet": "public static List\u003cClass\u003c?\u003e\u003e getAllSuperclasses(final Class\u003c?\u003e cls) {\n        if (cls \u003d\u003d null) {\n            return null;\n        }\n        final List\u003cClass\u003c?\u003e\u003e classes \u003d new ArrayList\u003cClass\u003c?\u003e\u003e();\n        Class\u003c?\u003e superclass \u003d cls.getSuperclass();\n        while (superclass !\u003d null) {\n            classes.add(superclass);\n            superclass \u003d superclass.getSuperclass();\n        }\n        return classes;\n    }",
    "begin_line": 407,
    "end_line": 418,
    "comment": "/** \n * \u003cp\u003eGets a  {@code List} of superclasses for the given class.\u003c/p\u003e\n * @param cls  the class to look up, may be {@code null}\n * @return the {@code List} of superclasses in order going up from this one{@code null} if null input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getAllInterfaces#433",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getAllInterfaces(java.lang.Class\u003c?\u003e)",
    "snippet": "public static List\u003cClass\u003c?\u003e\u003e getAllInterfaces(final Class\u003c?\u003e cls) {\n        if (cls \u003d\u003d null) {\n            return null;\n        }\n\n        final LinkedHashSet\u003cClass\u003c?\u003e\u003e interfacesFound \u003d new LinkedHashSet\u003cClass\u003c?\u003e\u003e();\n        getAllInterfaces(cls, interfacesFound);\n\n        return new ArrayList\u003cClass\u003c?\u003e\u003e(interfacesFound);\n    }",
    "begin_line": 433,
    "end_line": 442,
    "comment": "/** \n * \u003cp\u003eGets a  {@code List} of all interfaces implemented by the givenclass and its superclasses.\u003c/p\u003e \u003cp\u003eThe order is determined by looking through each interface in turn as declared in the source file and following its hierarchy up. Then each superclass is considered in the same way. Later duplicates are ignored, so the order is maintained.\u003c/p\u003e\n * @param cls  the class to look up, may be {@code null}\n * @return the {@code List} of interfaces in order,{@code null} if null input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getAllInterfaces#450",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getAllInterfaces(java.lang.Class\u003c?\u003e, java.util.HashSet\u003cjava.lang.Class\u003c?\u003e\u003e)",
    "snippet": "private static void getAllInterfaces(Class\u003c?\u003e cls, final HashSet\u003cClass\u003c?\u003e\u003e interfacesFound) {\n        while (cls !\u003d null) {\n            final Class\u003c?\u003e[] interfaces \u003d cls.getInterfaces();\n\n            for (final Class\u003c?\u003e i : interfaces) {\n                if (interfacesFound.add(i)) {\n                    getAllInterfaces(i, interfacesFound);\n                }\n            }\n\n            cls \u003d cls.getSuperclass();\n         }\n     }",
    "begin_line": 450,
    "end_line": 462,
    "comment": "/** \n * Get the interfaces for the specified class.\n * @param cls  the class to look up, may be {@code null}\n * @param interfacesFound the {@code Set} of interfaces for the class\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.convertClassNamesToClasses#478",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.convertClassNamesToClasses(java.util.List\u003cjava.lang.String\u003e)",
    "snippet": "public static List\u003cClass\u003c?\u003e\u003e convertClassNamesToClasses(final List\u003cString\u003e classNames) {\n        if (classNames \u003d\u003d null) {\n            return null;\n        }\n        final List\u003cClass\u003c?\u003e\u003e classes \u003d new ArrayList\u003cClass\u003c?\u003e\u003e(classNames.size());\n        for (final String className : classNames) {\n            try {\n                classes.add(Class.forName(className));\n            } catch (final Exception ex) {\n                classes.add(null);\n            }\n        }\n        return classes;\n    }",
    "begin_line": 478,
    "end_line": 491,
    "comment": "/** \n * \u003cp\u003eGiven a  {@code List} of class names, this method converts them into classes.\u003c/p\u003e\u003cp\u003eA new  {@code List} is returned. If the class name cannot be found, {@code null}is stored in the  {@code List}. If the class name in the  {@code List} is{@code null},  {@code null} is stored in the output {@code List}.\u003c/p\u003e\n * @param classNames  the classNames to change\n * @return a {@code List} of Class objects corresponding to the class names,{@code null} if null input\n * @throws ClassCastException if classNames contains a non String entry\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.convertClassesToClassNames#505",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.convertClassesToClassNames(java.util.List\u003cjava.lang.Class\u003c?\u003e\u003e)",
    "snippet": "public static List\u003cString\u003e convertClassesToClassNames(final List\u003cClass\u003c?\u003e\u003e classes) {\n        if (classes \u003d\u003d null) {\n            return null;\n        }\n        final List\u003cString\u003e classNames \u003d new ArrayList\u003cString\u003e(classes.size());\n        for (final Class\u003c?\u003e cls : classes) {\n            if (cls \u003d\u003d null) {\n                classNames.add(null);\n            } else {\n                classNames.add(cls.getName());\n            }\n        }\n        return classNames;\n    }",
    "begin_line": 505,
    "end_line": 518,
    "comment": "/** \n * \u003cp\u003eGiven a  {@code List} of {@code Class} objects, this method convertsthem into class names.\u003c/p\u003e \u003cp\u003eA new  {@code List} is returned. {@code null} objects will be copied intothe returned list as  {@code null}.\u003c/p\u003e\n * @param classes  the classes to change\n * @return a {@code List} of class names corresponding to the Class objects,{@code null} if null input\n * @throws ClassCastException if {@code classes} contains a non-{@code Class} entry\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.isAssignable#558",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.isAssignable(java.lang.Class\u003c?\u003e[], java.lang.Class\u003c?\u003e)",
    "snippet": "public static boolean isAssignable(final Class\u003c?\u003e[] classArray, final Class\u003c?\u003e... toClassArray) {\n        return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));\n    }",
    "begin_line": 558,
    "end_line": 560,
    "comment": "/** \n * \u003cp\u003eChecks if an array of Classes can be assigned to another array of Classes.\u003c/p\u003e \u003cp\u003eThis method calls  {@link #isAssignable(Class,Class) isAssignable} for eachClass pair in the input arrays. It can be used to check if a set of arguments (the first parameter) are suitably compatible with a set of method parameter types (the second parameter).\u003c/p\u003e \u003cp\u003eUnlike the  {@link Class#isAssignableFrom(java.lang.Class)} method, thismethod takes into account widenings of primitive classes and {@code null}s.\u003c/p\u003e \u003cp\u003ePrimitive widenings allow an int to be assigned to a  {@code long}, {@code float} or {@code double}. This method returns the correct result for these cases.\u003c/p\u003e \u003cp\u003e {@code Null} may be assigned to any reference type. This method willreturn  {@code true} if {@code null} is passed in and the toClass isnon-primitive.\u003c/p\u003e \u003cp\u003eSpecifically, this method tests whether the type represented by the specified  {@code Class} parameter can be converted to the typerepresented by this  {@code Class} object via an identity conversionwidening primitive or widening reference conversion. See \u003cem\u003e\u003ca href\u003d\"http://docs.oracle.com/javase/specs/\"\u003eThe Java Language Specification\u003c/a\u003e\u003c/em\u003e, sections 5.1.1, 5.1.2 and 5.1.4 for details.\u003c/p\u003e \u003cp\u003e\u003cstrong\u003eSince Lang 3.0,\u003c/strong\u003e this method will default behavior for calculating assignability between primitive and wrapper types \u003cem\u003ecorresponding to the running Java version\u003c/em\u003e; i.e. autoboxing will be the default behavior in VMs running Java versions \u0026gt; 1.5.\u003c/p\u003e\n * @param classArray  the array of Classes to check, may be {@code null}\n * @param toClassArray  the array of Classes to try to assign into, may be {@code null}\n * @return {@code true} if assignment possible\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.isAssignable#594",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.isAssignable(java.lang.Class\u003c?\u003e[], java.lang.Class\u003c?\u003e[], boolean)",
    "snippet": "public static boolean isAssignable(Class\u003c?\u003e[] classArray, Class\u003c?\u003e[] toClassArray, final boolean autoboxing) {\n        if (ArrayUtils.isSameLength(classArray, toClassArray) \u003d\u003d false) {\n            return false;\n        }\n        if (classArray \u003d\u003d null) {\n            classArray \u003d ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        if (toClassArray \u003d\u003d null) {\n            toClassArray \u003d ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        for (int i \u003d 0; i \u003c classArray.length; i++) {\n            if (isAssignable(classArray[i], toClassArray[i], autoboxing) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 594,
    "end_line": 610,
    "comment": "/** \n * \u003cp\u003eChecks if an array of Classes can be assigned to another array of Classes.\u003c/p\u003e \u003cp\u003eThis method calls  {@link #isAssignable(Class,Class) isAssignable} for eachClass pair in the input arrays. It can be used to check if a set of arguments (the first parameter) are suitably compatible with a set of method parameter types (the second parameter).\u003c/p\u003e \u003cp\u003eUnlike the  {@link Class#isAssignableFrom(java.lang.Class)} method, thismethod takes into account widenings of primitive classes and {@code null}s.\u003c/p\u003e \u003cp\u003ePrimitive widenings allow an int to be assigned to a  {@code long}, {@code float} or {@code double}. This method returns the correct result for these cases.\u003c/p\u003e \u003cp\u003e {@code Null} may be assigned to any reference type. This method willreturn  {@code true} if {@code null} is passed in and the toClass isnon-primitive.\u003c/p\u003e \u003cp\u003eSpecifically, this method tests whether the type represented by the specified  {@code Class} parameter can be converted to the typerepresented by this  {@code Class} object via an identity conversionwidening primitive or widening reference conversion. See \u003cem\u003e\u003ca href\u003d\"http://docs.oracle.com/javase/specs/\"\u003eThe Java Language Specification\u003c/a\u003e\u003c/em\u003e, sections 5.1.1, 5.1.2 and 5.1.4 for details.\u003c/p\u003e\n * @param classArray  the array of Classes to check, may be {@code null}\n * @param toClassArray  the array of Classes to try to assign into, may be {@code null}\n * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n * @return {@code true} if assignment possible\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.isPrimitiveOrWrapper#622",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.isPrimitiveOrWrapper(java.lang.Class\u003c?\u003e)",
    "snippet": "public static boolean isPrimitiveOrWrapper(final Class\u003c?\u003e type) {\n        if (type \u003d\u003d null) {\n            return false;\n        }\n        return type.isPrimitive() || isPrimitiveWrapper(type);\n    }",
    "begin_line": 622,
    "end_line": 627,
    "comment": "/** \n * Returns whether the given  {@code type} is a primitive or primitive wrapper ({@link Boolean},  {@link Byte},  {@link Character}, {@link Short},  {@link Integer},  {@link Long},  {@link Double},  {@link Float}).\n * @param type The class to query or null.\n * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Boolean},  {@link Byte},  {@link Character}, {@link Short},  {@link Integer},  {@link Long},  {@link Double},  {@link Float}).\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.isPrimitiveWrapper#639",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.isPrimitiveWrapper(java.lang.Class\u003c?\u003e)",
    "snippet": "public static boolean isPrimitiveWrapper(final Class\u003c?\u003e type) {\n        return wrapperPrimitiveMap.containsKey(type);\n    }",
    "begin_line": 639,
    "end_line": 641,
    "comment": "/** \n * Returns whether the given  {@code type} is a primitive wrapper ({@link Boolean},  {@link Byte},  {@link Character},  {@link Short}, {@link Integer},  {@link Long},  {@link Double},  {@link Float}).\n * @param type The class to query or null.\n * @return true if the given {@code type} is a primitive wrapper ({@link Boolean},  {@link Byte},  {@link Character},  {@link Short}, {@link Integer},  {@link Long},  {@link Double},  {@link Float}).\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.isAssignable#674",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.isAssignable(java.lang.Class\u003c?\u003e, java.lang.Class\u003c?\u003e)",
    "snippet": "public static boolean isAssignable(final Class\u003c?\u003e cls, final Class\u003c?\u003e toClass) {\n        return isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));\n    }",
    "begin_line": 674,
    "end_line": 676,
    "comment": "/** \n * \u003cp\u003eChecks if one  {@code Class} can be assigned to a variable ofanother  {@code Class}.\u003c/p\u003e \u003cp\u003eUnlike the  {@link Class#isAssignableFrom(java.lang.Class)} method,this method takes into account widenings of primitive classes and {@code null}s.\u003c/p\u003e \u003cp\u003ePrimitive widenings allow an int to be assigned to a long, float or double. This method returns the correct result for these cases.\u003c/p\u003e \u003cp\u003e {@code Null} may be assigned to any reference type. This methodwill return  {@code true} if {@code null} is passed in and thetoClass is non-primitive.\u003c/p\u003e \u003cp\u003eSpecifically, this method tests whether the type represented by the specified  {@code Class} parameter can be converted to the typerepresented by this  {@code Class} object via an identity conversionwidening primitive or widening reference conversion. See \u003cem\u003e\u003ca href\u003d\"http://docs.oracle.com/javase/specs/\"\u003eThe Java Language Specification\u003c/a\u003e\u003c/em\u003e, sections 5.1.1, 5.1.2 and 5.1.4 for details.\u003c/p\u003e \u003cp\u003e\u003cstrong\u003eSince Lang 3.0,\u003c/strong\u003e this method will default behavior for calculating assignability between primitive and wrapper types \u003cem\u003ecorresponding to the running Java version\u003c/em\u003e; i.e. autoboxing will be the default behavior in VMs running Java versions \u0026gt; 1.5.\u003c/p\u003e\n * @param cls  the Class to check, may be null\n * @param toClass  the Class to try to assign into, returns false if null\n * @return {@code true} if assignment possible\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.isAssignable#705",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.isAssignable(java.lang.Class\u003c?\u003e, java.lang.Class\u003c?\u003e, boolean)",
    "snippet": "public static boolean isAssignable(Class\u003c?\u003e cls, final Class\u003c?\u003e toClass, final boolean autoboxing) {\n        if (toClass \u003d\u003d null) {\n            return false;\n        }\n        // have to check for null, as isAssignableFrom doesn\u0027t\n        if (cls \u003d\u003d null) {\n            return !toClass.isPrimitive();\n        }\n        //autoboxing:\n        if (autoboxing) {\n            if (cls.isPrimitive() \u0026\u0026 !toClass.isPrimitive()) {\n                cls \u003d primitiveToWrapper(cls);\n                if (cls \u003d\u003d null) {\n                    return false;\n                }\n            }\n            if (toClass.isPrimitive() \u0026\u0026 !cls.isPrimitive()) {\n                cls \u003d wrapperToPrimitive(cls);\n                if (cls \u003d\u003d null) {\n                    return false;\n                }\n            }\n        }\n        if (cls.equals(toClass)) {\n            return true;\n        }\n        if (cls.isPrimitive()) {\n            if (toClass.isPrimitive() \u003d\u003d false) {\n                return false;\n            }\n            if (Integer.TYPE.equals(cls)) {\n                return Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Long.TYPE.equals(cls)) {\n                return Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Boolean.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Double.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Float.TYPE.equals(cls)) {\n                return Double.TYPE.equals(toClass);\n            }\n            if (Character.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Short.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Byte.TYPE.equals(cls)) {\n                return Short.TYPE.equals(toClass)\n                    || Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            // should never get here\n            return false;\n        }\n        return toClass.isAssignableFrom(cls);\n    }",
    "begin_line": 705,
    "end_line": 776,
    "comment": "/** \n * \u003cp\u003eChecks if one  {@code Class} can be assigned to a variable ofanother  {@code Class}.\u003c/p\u003e \u003cp\u003eUnlike the  {@link Class#isAssignableFrom(java.lang.Class)} method,this method takes into account widenings of primitive classes and {@code null}s.\u003c/p\u003e \u003cp\u003ePrimitive widenings allow an int to be assigned to a long, float or double. This method returns the correct result for these cases.\u003c/p\u003e \u003cp\u003e {@code Null} may be assigned to any reference type. This methodwill return  {@code true} if {@code null} is passed in and thetoClass is non-primitive.\u003c/p\u003e \u003cp\u003eSpecifically, this method tests whether the type represented by the specified  {@code Class} parameter can be converted to the typerepresented by this  {@code Class} object via an identity conversionwidening primitive or widening reference conversion. See \u003cem\u003e\u003ca href\u003d\"http://docs.oracle.com/javase/specs/\"\u003eThe Java Language Specification\u003c/a\u003e\u003c/em\u003e, sections 5.1.1, 5.1.2 and 5.1.4 for details.\u003c/p\u003e\n * @param cls  the Class to check, may be null\n * @param toClass  the Class to try to assign into, returns false if null\n * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n * @return {@code true} if assignment possible\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.primitiveToWrapper#790",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.primitiveToWrapper(java.lang.Class\u003c?\u003e)",
    "snippet": "public static Class\u003c?\u003e primitiveToWrapper(final Class\u003c?\u003e cls) {\n        Class\u003c?\u003e convertedClass \u003d cls;\n        if (cls !\u003d null \u0026\u0026 cls.isPrimitive()) {\n            convertedClass \u003d primitiveWrapperMap.get(cls);\n        }\n        return convertedClass;\n    }",
    "begin_line": 790,
    "end_line": 796,
    "comment": "/** \n * \u003cp\u003eConverts the specified primitive Class object to its corresponding wrapper Class object.\u003c/p\u003e \u003cp\u003eNOTE: From v2.2, this method handles  {@code Void.TYPE}, returning  {@code Void.TYPE}.\u003c/p\u003e\n * @param cls  the class to convert, may be null\n * @return the wrapper class for {@code cls} or {@code cls} if{@code cls} is not a primitive. {@code null} if null input.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.primitivesToWrappers#808",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.primitivesToWrappers(java.lang.Class\u003c?\u003e)",
    "snippet": "public static Class\u003c?\u003e[] primitivesToWrappers(final Class\u003c?\u003e... classes) {\n        if (classes \u003d\u003d null) {\n            return null;\n        }\n\n        if (classes.length \u003d\u003d 0) {\n            return classes;\n        }\n\n        final Class\u003c?\u003e[] convertedClasses \u003d new Class[classes.length];\n        for (int i \u003d 0; i \u003c classes.length; i++) {\n            convertedClasses[i] \u003d primitiveToWrapper(classes[i]);\n        }\n        return convertedClasses;\n    }",
    "begin_line": 808,
    "end_line": 822,
    "comment": "/** \n * \u003cp\u003eConverts the specified array of primitive Class objects to an array of its corresponding wrapper Class objects.\u003c/p\u003e\n * @param classes  the class array to convert, may be null or empty\n * @return an array which contains for each given class, the wrapper class orthe original class if class is not a primitive.  {@code null} if null input.Empty array if an empty array passed in.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.wrapperToPrimitive#840",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.wrapperToPrimitive(java.lang.Class\u003c?\u003e)",
    "snippet": "public static Class\u003c?\u003e wrapperToPrimitive(final Class\u003c?\u003e cls) {\n        return wrapperPrimitiveMap.get(cls);\n    }",
    "begin_line": 840,
    "end_line": 842,
    "comment": "/** \n * \u003cp\u003eConverts the specified wrapper class to its corresponding primitive class.\u003c/p\u003e \u003cp\u003eThis method is the counter part of  {@code primitiveToWrapper()}. If the passed in class is a wrapper class for a primitive type, this primitive type will be returned (e.g.  {@code Integer.TYPE} for{@code Integer.class}). For other classes, or if the parameter is \u003cb\u003enull\u003c/b\u003e, the return value is \u003cb\u003enull\u003c/b\u003e.\u003c/p\u003e\n * @param cls the class to convert, may be \u003cb\u003enull\u003c/b\u003e\n * @return the corresponding primitive type if {@code cls} is awrapper class, \u003cb\u003enull\u003c/b\u003e otherwise\n * @see #primitiveToWrapper(Class)\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.wrappersToPrimitives#858",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.wrappersToPrimitives(java.lang.Class\u003c?\u003e)",
    "snippet": "public static Class\u003c?\u003e[] wrappersToPrimitives(final Class\u003c?\u003e... classes) {\n        if (classes \u003d\u003d null) {\n            return null;\n        }\n\n        if (classes.length \u003d\u003d 0) {\n            return classes;\n        }\n\n        final Class\u003c?\u003e[] convertedClasses \u003d new Class[classes.length];\n        for (int i \u003d 0; i \u003c classes.length; i++) {\n            convertedClasses[i] \u003d wrapperToPrimitive(classes[i]);\n        }\n        return convertedClasses;\n    }",
    "begin_line": 858,
    "end_line": 872,
    "comment": "/** \n * \u003cp\u003eConverts the specified array of wrapper Class objects to an array of its corresponding primitive Class objects.\u003c/p\u003e \u003cp\u003eThis method invokes  {@code wrapperToPrimitive()} for each elementof the passed in array.\u003c/p\u003e\n * @param classes  the class array to convert, may be null or empty\n * @return an array which contains for each given class, the primitive class or\u003cb\u003enull\u003c/b\u003e if the original class is not a wrapper class.  {@code null} if null input.Empty array if an empty array passed in.\n * @see #wrapperToPrimitive(Class)\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.isInnerClass#883",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.isInnerClass(java.lang.Class\u003c?\u003e)",
    "snippet": "public static boolean isInnerClass(final Class\u003c?\u003e cls) {\n        return cls !\u003d null \u0026\u0026 cls.getEnclosingClass() !\u003d null;\n    }",
    "begin_line": 883,
    "end_line": 885,
    "comment": "/** \n * \u003cp\u003eIs the specified class an inner class or static nested class.\u003c/p\u003e\n * @param cls  the class to check, may be null\n * @return {@code true} if the class is an inner or static nested class,false if not or  {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getClass#901",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getClass(java.lang.ClassLoader, java.lang.String, boolean)",
    "snippet": "public static Class\u003c?\u003e getClass(\n            final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n        try {\n            Class\u003c?\u003e clazz;\n            if (abbreviationMap.containsKey(className)) {\n                final String clsName \u003d \"[\" + abbreviationMap.get(className);\n                clazz \u003d Class.forName(clsName, initialize, classLoader).getComponentType();\n            } else {\n                clazz \u003d Class.forName(toCanonicalName(className), initialize, classLoader);\n            }\n            return clazz;\n        } catch (final ClassNotFoundException ex) {\n            // allow path separators (.) as inner class name separators\n            final int lastDotIndex \u003d className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n\n            if (lastDotIndex !\u003d -1) {\n                try {\n                    return getClass(classLoader, className.substring(0, lastDotIndex) +\n                            INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n                            initialize);\n                } catch (final ClassNotFoundException ex2) { // NOPMD\n                    // ignore exception\n                }\n            }\n\n            throw ex;\n        }\n    }",
    "begin_line": 901,
    "end_line": 928,
    "comment": "/** \n * Returns the class represented by  {@code className} using the{@code classLoader}.  This implementation supports the syntaxes \" {@code java.util.Map.Entry[]}\", \" {@code java.util.Map$Entry[]}\", \" {@code [Ljava.util.Map.Entry;}\", and \" {@code [Ljava.util.Map$Entry;}\".\n * @param classLoader  the class loader to use to load the class\n * @param className  the class name\n * @param initialize  whether the class must be initialized\n * @return the class represented by {@code className} using the {@code classLoader}\n * @throws ClassNotFoundException if the class is not found\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getClass#942",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getClass(java.lang.ClassLoader, java.lang.String)",
    "snippet": "public static Class\u003c?\u003e getClass(final ClassLoader classLoader, final String className) throws ClassNotFoundException {\n        return getClass(classLoader, className, true);\n    }",
    "begin_line": 942,
    "end_line": 944,
    "comment": "/** \n * Returns the (initialized) class represented by  {@code className}using the  {@code classLoader}.  This implementation supports the syntaxes \" {@code java.util.Map.Entry[]}\", \" {@code java.util.Map$Entry[]}\", \" {@code [Ljava.util.Map.Entry;}\", and \" {@code [Ljava.util.Map$Entry;}\".\n * @param classLoader  the class loader to use to load the class\n * @param className  the class name\n * @return the class represented by {@code className} using the {@code classLoader}\n * @throws ClassNotFoundException if the class is not found\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getClass#957",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getClass(java.lang.String)",
    "snippet": "public static Class\u003c?\u003e getClass(final String className) throws ClassNotFoundException {\n        return getClass(className, true);\n    }",
    "begin_line": 957,
    "end_line": 959,
    "comment": "/** \n * Returns the (initialized) class represented by  {@code className}using the current thread\u0027s context class loader. This implementation supports the syntaxes \" {@code java.util.Map.Entry[]}\", \" {@code java.util.Map$Entry[]}\", \" {@code [Ljava.util.Map.Entry;}\", and \" {@code [Ljava.util.Map$Entry;}\".\n * @param className  the class name\n * @return the class represented by {@code className} using the current thread\u0027s context class loader\n * @throws ClassNotFoundException if the class is not found\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getClass#972",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getClass(java.lang.String, boolean)",
    "snippet": "public static Class\u003c?\u003e getClass(final String className, final boolean initialize) throws ClassNotFoundException {\n        final ClassLoader contextCL \u003d Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader \u003d contextCL \u003d\u003d null ? ClassUtils.class.getClassLoader() : contextCL;\n        return getClass(loader, className, initialize);\n    }",
    "begin_line": 972,
    "end_line": 976,
    "comment": "/** \n * Returns the class represented by  {@code className} using thecurrent thread\u0027s context class loader. This implementation supports the syntaxes \" {@code java.util.Map.Entry[]}\", \" {@code java.util.Map$Entry[]}\", \" {@code [Ljava.util.Map.Entry;}\", and \" {@code [Ljava.util.Map$Entry;}\".\n * @param className  the class name\n * @param initialize  whether the class must be initialized\n * @return the class represented by {@code className} using the current thread\u0027s context class loader\n * @throws ClassNotFoundException if the class is not found\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getPublicMethod#1002",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getPublicMethod(java.lang.Class\u003c?\u003e, java.lang.String, java.lang.Class\u003c?\u003e)",
    "snippet": "public static Method getPublicMethod(final Class\u003c?\u003e cls, final String methodName, final Class\u003c?\u003e... parameterTypes)\n            throws SecurityException, NoSuchMethodException {\n\n        final Method declaredMethod \u003d cls.getMethod(methodName, parameterTypes);\n        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n            return declaredMethod;\n        }\n\n        final List\u003cClass\u003c?\u003e\u003e candidateClasses \u003d new ArrayList\u003cClass\u003c?\u003e\u003e();\n        candidateClasses.addAll(getAllInterfaces(cls));\n        candidateClasses.addAll(getAllSuperclasses(cls));\n\n        for (final Class\u003c?\u003e candidateClass : candidateClasses) {\n            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                continue;\n            }\n            Method candidateMethod;\n            try {\n                candidateMethod \u003d candidateClass.getMethod(methodName, parameterTypes);\n            } catch (final NoSuchMethodException ex) {\n                continue;\n            }\n            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n                return candidateMethod;\n            }\n        }\n\n        throw new NoSuchMethodException(\"Can\u0027t find a public method for \" +\n                methodName + \" \" + ArrayUtils.toString(parameterTypes));\n    }",
    "begin_line": 1002,
    "end_line": 1031,
    "comment": "/** \n * \u003cp\u003eReturns the desired Method much like  {@code Class.getMethod}, however it ensures that the returned Method is from a public class or interface and not from an anonymous inner class. This means that the Method is invokable and doesn\u0027t fall foul of Java bug \u003ca href\u003d\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id\u003d4071957\"\u003e4071957\u003c/a\u003e).\u003c/p\u003e \u003cpre\u003e \u003ccode\u003eSet set \u003d Collections.unmodifiableSet(...); Method method \u003d ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]); Object result \u003d method.invoke(set, new Object[]);\u003c/code\u003e \u003c/pre\u003e\n * @param cls  the class to check, not null\n * @param methodName  the name of the method\n * @param parameterTypes  the list of parameters\n * @return the method\n * @throws NullPointerException if the class is null\n * @throws SecurityException if a security violation occurred\n * @throws NoSuchMethodException if the method is not found in the given classor if the method doesn\u0027t conform with the requirements\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.toCanonicalName#1040",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.toCanonicalName(java.lang.String)",
    "snippet": "private static String toCanonicalName(String className) {\n        className \u003d StringUtils.deleteWhitespace(className);\n        if (className \u003d\u003d null) {\n            throw new NullPointerException(\"className must not be null.\");\n        } else if (className.endsWith(\"[]\")) {\n            final StringBuilder classNameBuffer \u003d new StringBuilder();\n            while (className.endsWith(\"[]\")) {\n                className \u003d className.substring(0, className.length() - 2);\n                classNameBuffer.append(\"[\");\n            }\n            final String abbreviation \u003d abbreviationMap.get(className);\n            if (abbreviation !\u003d null) {\n                classNameBuffer.append(abbreviation);\n            } else {\n                classNameBuffer.append(\"L\").append(className).append(\";\");\n            }\n            className \u003d classNameBuffer.toString();\n        }\n        return className;\n    }",
    "begin_line": 1040,
    "end_line": 1059,
    "comment": "/** \n * Converts a class name to a JLS style class name.\n * @param className  the class name\n * @return the converted name\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.toClass#1071",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.toClass(java.lang.Object)",
    "snippet": "public static Class\u003c?\u003e[] toClass(final Object... array) {\n        if (array \u003d\u003d null) {\n            return null;\n        } else if (array.length \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        final Class\u003c?\u003e[] classes \u003d new Class[array.length];\n        for (int i \u003d 0; i \u003c array.length; i++) {\n            classes[i] \u003d array[i] \u003d\u003d null ? null : array[i].getClass();\n        }\n        return classes;\n    }",
    "begin_line": 1071,
    "end_line": 1082,
    "comment": "/** \n * \u003cp\u003eConverts an array of  {@code Object} in to an array of {@code Class} objects.If any of these objects is null, a null element will be inserted into the array.\u003c/p\u003e \u003cp\u003eThis method returns  {@code null} for a {@code null} input array.\u003c/p\u003e\n * @param array an {@code Object} array\n * @return a {@code Class} array, {@code null} if null array input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getShortCanonicalName#1094",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getShortCanonicalName(java.lang.Object, java.lang.String)",
    "snippet": "public static String getShortCanonicalName(final Object object, final String valueIfNull) {\n        if (object \u003d\u003d null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }",
    "begin_line": 1094,
    "end_line": 1099,
    "comment": "/** \n * \u003cp\u003eGets the canonical name minus the package name for an  {@code Object}.\u003c/p\u003e\n * @param object  the class to get the short name for, may be null\n * @param valueIfNull  the value to return if null\n * @return the canonical name of the object without the package name, or the null value\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getShortCanonicalName#1108",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getShortCanonicalName(java.lang.Class\u003c?\u003e)",
    "snippet": "public static String getShortCanonicalName(final Class\u003c?\u003e cls) {\n        if (cls \u003d\u003d null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortCanonicalName(cls.getName());\n    }",
    "begin_line": 1108,
    "end_line": 1113,
    "comment": "/** \n * \u003cp\u003eGets the canonical name minus the package name from a  {@code Class}.\u003c/p\u003e\n * @param cls  the class to get the short name for.\n * @return the canonical name without the package name or an empty string\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getShortCanonicalName#1124",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getShortCanonicalName(java.lang.String)",
    "snippet": "public static String getShortCanonicalName(final String canonicalName) {\n        return ClassUtils.getShortClassName(getCanonicalName(canonicalName));\n    }",
    "begin_line": 1124,
    "end_line": 1126,
    "comment": "/** \n * \u003cp\u003eGets the canonical name minus the package name from a String.\u003c/p\u003e \u003cp\u003eThe string passed in is assumed to be a canonical name - it is not checked.\u003c/p\u003e\n * @param canonicalName  the class name to get the short name for\n * @return the canonical name of the class without the package name or an empty string\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getPackageCanonicalName#1138",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getPackageCanonicalName(java.lang.Object, java.lang.String)",
    "snippet": "public static String getPackageCanonicalName(final Object object, final String valueIfNull) {\n        if (object \u003d\u003d null) {\n            return valueIfNull;\n        }\n        return getPackageCanonicalName(object.getClass().getName());\n    }",
    "begin_line": 1138,
    "end_line": 1143,
    "comment": "/** \n * \u003cp\u003eGets the package name from the canonical name of an  {@code Object}.\u003c/p\u003e\n * @param object  the class to get the package name for, may be null\n * @param valueIfNull  the value to return if null\n * @return the package name of the object, or the null value\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getPackageCanonicalName#1152",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getPackageCanonicalName(java.lang.Class\u003c?\u003e)",
    "snippet": "public static String getPackageCanonicalName(final Class\u003c?\u003e cls) {\n        if (cls \u003d\u003d null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageCanonicalName(cls.getName());\n    }",
    "begin_line": 1152,
    "end_line": 1157,
    "comment": "/** \n * \u003cp\u003eGets the package name from the canonical name of a  {@code Class}.\u003c/p\u003e\n * @param cls  the class to get the package name for, may be {@code null}.\n * @return the package name or an empty string\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getPackageCanonicalName#1169",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getPackageCanonicalName(java.lang.String)",
    "snippet": "public static String getPackageCanonicalName(final String canonicalName) {\n        return ClassUtils.getPackageName(getCanonicalName(canonicalName));\n    }",
    "begin_line": 1169,
    "end_line": 1171,
    "comment": "/** \n * \u003cp\u003eGets the package name from the canonical name. \u003c/p\u003e \u003cp\u003eThe string passed in is assumed to be a canonical name - it is not checked.\u003c/p\u003e \u003cp\u003eIf the class is unpackaged, return an empty string.\u003c/p\u003e\n * @param canonicalName  the canonical name to get the package name for, may be {@code null}\n * @return the package name or an empty string\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.getCanonicalName#1189",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.getCanonicalName(java.lang.String)",
    "snippet": "private static String getCanonicalName(String className) {\n        className \u003d StringUtils.deleteWhitespace(className);\n        if (className \u003d\u003d null) {\n            return null;\n        }\n        int dim \u003d 0;\n        while (className.startsWith(\"[\")) {\n            dim++;\n            className \u003d className.substring(1);\n        }\n        if (dim \u003c 1) {\n            return className;\n        }\n        if (className.startsWith(\"L\")) {\n            className \u003d className.substring(\n                1,\n                className.endsWith(\";\")\n                    ? className.length() - 1\n                    : className.length());\n        } else {\n            if (className.length() \u003e 0) {\n                className \u003d reverseAbbreviationMap.get(className.substring(0, 1));\n            }\n        }\n        final StringBuilder canonicalClassNameBuffer \u003d new StringBuilder(className);\n        for (int i \u003d 0; i \u003c dim; i++) {\n            canonicalClassNameBuffer.append(\"[]\");\n        }\n        return canonicalClassNameBuffer.toString();\n    }",
    "begin_line": 1189,
    "end_line": 1218,
    "comment": "/** \n * \u003cp\u003eConverts a given name of class into canonical format. If name of class is not a name of array class it returns unchanged name.\u003c/p\u003e \u003cp\u003eExample: \u003cul\u003e \u003cli\u003e {@code getCanonicalName(\"[I\") \u003d \"int[]\"}\u003c/li\u003e \u003cli\u003e {@code getCanonicalName(\"[Ljava.lang.String;\") \u003d \"java.lang.String[]\"}\u003c/li\u003e \u003cli\u003e {@code getCanonicalName(\"java.lang.String\") \u003d \"java.lang.String\"}\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e\n * @param className the name of class\n * @return canonical form of class name\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.hierarchy#1228",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.hierarchy(java.lang.Class\u003c?\u003e)",
    "snippet": "public static Iterable\u003cClass\u003c?\u003e\u003e hierarchy(final Class\u003c?\u003e type) {\n        return hierarchy(type, Interfaces.EXCLUDE);\n    }",
    "begin_line": 1228,
    "end_line": 1230,
    "comment": "/** \n * Get an  {@link Iterable} that can iterate over a class hierarchy in ascending (subclass to superclass) order,excluding interfaces.\n * @param type the type to get the class hierarchy from\n * @return Iterable an Iterable over the class hierarchy of the given class\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.hierarchy#1240",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.hierarchy(java.lang.Class\u003c?\u003e, org.apache.commons.lang3.ClassUtils.Interfaces)",
    "snippet": "public static Iterable\u003cClass\u003c?\u003e\u003e hierarchy(final Class\u003c?\u003e type, final Interfaces interfacesBehavior) {\n        final Iterable\u003cClass\u003c?\u003e\u003e classes \u003d new Iterable\u003cClass\u003c?\u003e\u003e() {\n    \n            @Override\n            public Iterator\u003cClass\u003c?\u003e\u003e iterator() {\n                final MutableObject\u003cClass\u003c?\u003e\u003e next \u003d new MutableObject\u003cClass\u003c?\u003e\u003e(type);\n                return new Iterator\u003cClass\u003c?\u003e\u003e() {\n    \n                    @Override\n                    public boolean hasNext() {\n                        return next.getValue() !\u003d null;\n                    }\n    \n                    @Override\n                    public Class\u003c?\u003e next() {\n                        final Class\u003c?\u003e result \u003d next.getValue();\n                        next.setValue(result.getSuperclass());\n                        return result;\n                    }\n    \n                    @Override\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }\n    \n                };\n            }\n    \n        };\n        if (interfacesBehavior !\u003d Interfaces.INCLUDE) {\n            return classes;\n        }\n        return new Iterable\u003cClass\u003c?\u003e\u003e() {\n    \n            @Override\n            public Iterator\u003cClass\u003c?\u003e\u003e iterator() {\n                final Set\u003cClass\u003c?\u003e\u003e seenInterfaces \u003d new HashSet\u003cClass\u003c?\u003e\u003e();\n                final Iterator\u003cClass\u003c?\u003e\u003e wrapped \u003d classes.iterator();\n    \n                return new Iterator\u003cClass\u003c?\u003e\u003e() {\n                    Iterator\u003cClass\u003c?\u003e\u003e interfaces \u003d Collections.\u003cClass\u003c?\u003e\u003e emptySet().iterator();\n    \n                    @Override\n                    public boolean hasNext() {\n                        return interfaces.hasNext() || wrapped.hasNext();\n                    }\n    \n                    @Override\n                    public Class\u003c?\u003e next() {\n                        if (interfaces.hasNext()) {\n                            final Class\u003c?\u003e nextInterface \u003d interfaces.next();\n                            seenInterfaces.add(nextInterface);\n                            return nextInterface;\n                        }\n                        final Class\u003c?\u003e nextSuperclass \u003d wrapped.next();\n                        final Set\u003cClass\u003c?\u003e\u003e currentInterfaces \u003d new LinkedHashSet\u003cClass\u003c?\u003e\u003e();\n                        walkInterfaces(currentInterfaces, nextSuperclass);\n                        interfaces \u003d currentInterfaces.iterator();\n                        return nextSuperclass;\n                    }\n    \n                    private void walkInterfaces(final Set\u003cClass\u003c?\u003e\u003e addTo, final Class\u003c?\u003e c) {\n                        for (final Class\u003c?\u003e iface : c.getInterfaces()) {\n                            if (!seenInterfaces.contains(iface)) {\n                                addTo.add(iface);\n                            }\n                            walkInterfaces(addTo, iface);\n                        }\n                    }\n    \n                    @Override\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }\n    \n                };\n            }\n        };\n    }",
    "begin_line": 1240,
    "end_line": 1318,
    "comment": "/** \n * Get an  {@link Iterable} that can iterate over a class hierarchy in ascending (subclass to superclass) order.\n * @param type the type to get the class hierarchy from\n * @param interfacesBehavior switch indicating whether to include or exclude interfaces\n * @return Iterable an Iterable over the class hierarchy of the given class\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.iterator#1244",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.iterator()",
    "snippet": "@Override\n            public Iterator\u003cClass\u003c?\u003e\u003e iterator() {\n                final MutableObject\u003cClass\u003c?\u003e\u003e next \u003d new MutableObject\u003cClass\u003c?\u003e\u003e(type);\n                return new Iterator\u003cClass\u003c?\u003e\u003e() {\n    \n                    @Override\n                    public boolean hasNext() {\n                        return next.getValue() !\u003d null;\n                    }\n    \n                    @Override\n                    public Class\u003c?\u003e next() {\n                        final Class\u003c?\u003e result \u003d next.getValue();\n                        next.setValue(result.getSuperclass());\n                        return result;\n                    }\n    \n                    @Override\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }\n    \n                };\n            }",
    "begin_line": 1244,
    "end_line": 1266,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.hasNext#1249",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.hasNext()",
    "snippet": "@Override\n                    public boolean hasNext() {\n                        return next.getValue() !\u003d null;\n                    }",
    "begin_line": 1249,
    "end_line": 1251,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.next#1254",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.next()",
    "snippet": "@Override\n                    public Class\u003c?\u003e next() {\n                        final Class\u003c?\u003e result \u003d next.getValue();\n                        next.setValue(result.getSuperclass());\n                        return result;\n                    }",
    "begin_line": 1254,
    "end_line": 1258,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.remove#1261",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.remove()",
    "snippet": "@Override\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }",
    "begin_line": 1261,
    "end_line": 1263,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.iterator#1275",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.iterator()",
    "snippet": "@Override\n            public Iterator\u003cClass\u003c?\u003e\u003e iterator() {\n                final Set\u003cClass\u003c?\u003e\u003e seenInterfaces \u003d new HashSet\u003cClass\u003c?\u003e\u003e();\n                final Iterator\u003cClass\u003c?\u003e\u003e wrapped \u003d classes.iterator();\n    \n                return new Iterator\u003cClass\u003c?\u003e\u003e() {\n                    Iterator\u003cClass\u003c?\u003e\u003e interfaces \u003d Collections.\u003cClass\u003c?\u003e\u003e emptySet().iterator();\n    \n                    @Override\n                    public boolean hasNext() {\n                        return interfaces.hasNext() || wrapped.hasNext();\n                    }\n    \n                    @Override\n                    public Class\u003c?\u003e next() {\n                        if (interfaces.hasNext()) {\n                            final Class\u003c?\u003e nextInterface \u003d interfaces.next();\n                            seenInterfaces.add(nextInterface);\n                            return nextInterface;\n                        }\n                        final Class\u003c?\u003e nextSuperclass \u003d wrapped.next();\n                        final Set\u003cClass\u003c?\u003e\u003e currentInterfaces \u003d new LinkedHashSet\u003cClass\u003c?\u003e\u003e();\n                        walkInterfaces(currentInterfaces, nextSuperclass);\n                        interfaces \u003d currentInterfaces.iterator();\n                        return nextSuperclass;\n                    }\n    \n                    private void walkInterfaces(final Set\u003cClass\u003c?\u003e\u003e addTo, final Class\u003c?\u003e c) {\n                        for (final Class\u003c?\u003e iface : c.getInterfaces()) {\n                            if (!seenInterfaces.contains(iface)) {\n                                addTo.add(iface);\n                            }\n                            walkInterfaces(addTo, iface);\n                        }\n                    }\n    \n                    @Override\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }\n    \n                };\n            }",
    "begin_line": 1275,
    "end_line": 1316,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.hasNext#1283",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.hasNext()",
    "snippet": "@Override\n                    public boolean hasNext() {\n                        return interfaces.hasNext() || wrapped.hasNext();\n                    }",
    "begin_line": 1283,
    "end_line": 1285,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.next#1288",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.next()",
    "snippet": "@Override\n                    public Class\u003c?\u003e next() {\n                        if (interfaces.hasNext()) {\n                            final Class\u003c?\u003e nextInterface \u003d interfaces.next();\n                            seenInterfaces.add(nextInterface);\n                            return nextInterface;\n                        }\n                        final Class\u003c?\u003e nextSuperclass \u003d wrapped.next();\n                        final Set\u003cClass\u003c?\u003e\u003e currentInterfaces \u003d new LinkedHashSet\u003cClass\u003c?\u003e\u003e();\n                        walkInterfaces(currentInterfaces, nextSuperclass);\n                        interfaces \u003d currentInterfaces.iterator();\n                        return nextSuperclass;\n                    }",
    "begin_line": 1288,
    "end_line": 1299,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.walkInterfaces#1301",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.walkInterfaces(java.util.Set\u003cjava.lang.Class\u003c?\u003e\u003e, java.lang.Class\u003c?\u003e)",
    "snippet": "private void walkInterfaces(final Set\u003cClass\u003c?\u003e\u003e addTo, final Class\u003c?\u003e c) {\n                        for (final Class\u003c?\u003e iface : c.getInterfaces()) {\n                            if (!seenInterfaces.contains(iface)) {\n                                addTo.add(iface);\n                            }\n                            walkInterfaces(addTo, iface);\n                        }\n                    }",
    "begin_line": 1301,
    "end_line": 1308,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ClassUtils.remove#1311",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ClassUtils.java",
    "class_name": "org.apache.commons.lang3.ClassUtils",
    "signature": "org.apache.commons.lang3.ClassUtils.remove()",
    "snippet": "@Override\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }",
    "begin_line": 1311,
    "end_line": 1313,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.JavaVersion#98",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/JavaVersion.java",
    "class_name": "org.apache.commons.lang3.JavaVersion",
    "signature": "org.apache.commons.lang3.JavaVersion.JavaVersion(float, java.lang.String)",
    "snippet": " JavaVersion(final float value, final String name) {\n        this.value \u003d value;\n        this.name \u003d name;\n    }",
    "begin_line": 98,
    "end_line": 101,
    "comment": "/** \n * Constructor.\n * @param value  the float value\n * @param name  the standard name, not null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.atLeast#113",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/JavaVersion.java",
    "class_name": "org.apache.commons.lang3.JavaVersion",
    "signature": "org.apache.commons.lang3.JavaVersion.atLeast(org.apache.commons.lang3.JavaVersion)",
    "snippet": "public boolean atLeast(final JavaVersion requiredVersion) {\n        return this.value \u003e\u003d requiredVersion.value;\n    }",
    "begin_line": 113,
    "end_line": 115,
    "comment": "/** \n * \u003cp\u003eWhether this version of Java is at least the version of Java passed in.\u003c/p\u003e \u003cp\u003eFor example:\u003cbr\u003e {@code myVersion.atLeast(JavaVersion.JAVA_1_4)}\u003cp\u003e\n * @param requiredVersion  the version to check against, not null\n * @return true if this version is equal to or greater than the specified version\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getJavaVersion#127",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/JavaVersion.java",
    "class_name": "org.apache.commons.lang3.JavaVersion",
    "signature": "org.apache.commons.lang3.JavaVersion.getJavaVersion(java.lang.String)",
    "snippet": " getJavaVersion(final String nom) {\n        return get(nom);\n    }",
    "begin_line": 127,
    "end_line": 129,
    "comment": "/** \n * Transforms the given string with a Java version number to the corresponding constant of this enumeration class. This method is used internally.\n * @param nom the Java version as string\n * @return the corresponding enumeration constant or \u003cb\u003enull\u003c/b\u003e if theversion is unknown\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.get#140",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/JavaVersion.java",
    "class_name": "org.apache.commons.lang3.JavaVersion",
    "signature": "org.apache.commons.lang3.JavaVersion.get(java.lang.String)",
    "snippet": "static JavaVersion get(final String nom) {\n        if (\"0.9\".equals(nom)) {\n            return JAVA_0_9;\n        } else if (\"1.1\".equals(nom)) {\n            return JAVA_1_1;\n        } else if (\"1.2\".equals(nom)) {\n            return JAVA_1_2;\n        } else if (\"1.3\".equals(nom)) {\n            return JAVA_1_3;\n        } else if (\"1.4\".equals(nom)) {\n            return JAVA_1_4;\n        } else if (\"1.5\".equals(nom)) {\n            return JAVA_1_5;\n        } else if (\"1.6\".equals(nom)) {\n            return JAVA_1_6;\n        } else if (\"1.7\".equals(nom)) {\n            return JAVA_1_7;\n        } else if (\"1.8\".equals(nom)) {\n            return JAVA_1_8;\n        } else if (\"1.9\".equals(nom)) {\n            return JAVA_1_9;\n        }\n        if (nom \u003d\u003d null) {\n            return null;\n        }\n        final float v \u003d toFloatVersion(nom);\n        if ((v - 1.) \u003c 1.) { // then we need to check decimals \u003e .9\n            final int firstComma \u003d Math.max(nom.indexOf(\u0027.\u0027), nom.indexOf(\u0027,\u0027));\n            final int end \u003d Math.max(nom.length(), nom.indexOf(\u0027,\u0027, firstComma));\n            if (Float.parseFloat(nom.substring(firstComma + 1, end)) \u003e .9f) {\n                return JAVA_RECENT;\n            }\n        }\n        return null;\n    }",
    "begin_line": 140,
    "end_line": 174,
    "comment": "/** \n * Transforms the given string with a Java version number to the corresponding constant of this enumeration class. This method is used internally.\n * @param nom the Java version as string\n * @return the corresponding enumeration constant or \u003cb\u003enull\u003c/b\u003e if theversion is unknown\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.toString#185",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/JavaVersion.java",
    "class_name": "org.apache.commons.lang3.JavaVersion",
    "signature": "org.apache.commons.lang3.JavaVersion.toString()",
    "snippet": "@Override\n    public String toString() {\n        return name;\n    }",
    "begin_line": 185,
    "end_line": 187,
    "comment": "/** \n * \u003cp\u003eThe string value is overridden to return the standard name.\u003c/p\u003e \u003cp\u003eFor example, \u003ccode\u003e\"1.5\"\u003c/code\u003e.\u003c/p\u003e\n * @return the name, not null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.maxVersion#194",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/JavaVersion.java",
    "class_name": "org.apache.commons.lang3.JavaVersion",
    "signature": "org.apache.commons.lang3.JavaVersion.maxVersion()",
    "snippet": "private static float maxVersion() {\n        final float v \u003d toFloatVersion(System.getProperty(\"java.version\", \"2.0\"));\n        if (v \u003e 0) {\n            return v;\n        }\n        return 2f;\n    }",
    "begin_line": 194,
    "end_line": 200,
    "comment": "/** \n * Gets the Java Version from the system or 2.0 if the  {@code java.version} system property is not set.\n * @return the value of {@code java.version} system property or 2.0 if it is not set.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.toFloatVersion#208",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/JavaVersion.java",
    "class_name": "org.apache.commons.lang3.JavaVersion",
    "signature": "org.apache.commons.lang3.JavaVersion.toFloatVersion(java.lang.String)",
    "snippet": "private static float toFloatVersion(final String value) {\n        final String[] toParse \u003d value.split(\"\\\\.\");\n        if (toParse.length \u003e\u003d 2) {\n            try {\n                return Float.parseFloat(toParse[0] + \u0027.\u0027 + toParse[1]);\n            } catch (final NumberFormatException nfe) {\n                // no-op, let use default\n            }\n        }\n        return -1;\n    }",
    "begin_line": 208,
    "end_line": 218,
    "comment": "/** \n * Parses a float value from a String.\n * @param value the String to parse.\n * @return the float value represented by teh string or -1 if the given String can not be parsed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.ObjectUtils#72",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.ObjectUtils()",
    "snippet": "public ObjectUtils() {\n        super();\n    }",
    "begin_line": 72,
    "end_line": 74,
    "comment": "/** \n * \u003cp\u003e {@code ObjectUtils} instances should NOT be constructed instandard programming. Instead, the static methods on the class should be used, such as  {@code ObjectUtils.defaultIfNull(\"a\",\"b\");}.\u003c/p\u003e \u003cp\u003eThis constructor is public to permit tools that require a JavaBean instance to operate.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.defaultIfNull#94",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.defaultIfNull(T, T)",
    "snippet": "public static \u003cT\u003e T defaultIfNull(final T object, final T defaultValue) {\n        return object !\u003d null ? object : defaultValue;\n    }",
    "begin_line": 94,
    "end_line": 96,
    "comment": "/** \n * \u003cp\u003eReturns a default value if the object passed is  {@code null}.\u003c/p\u003e \u003cpre\u003e ObjectUtils.defaultIfNull(null, null)      \u003d null ObjectUtils.defaultIfNull(null, \"\")        \u003d \"\" ObjectUtils.defaultIfNull(null, \"zz\")      \u003d \"zz\" ObjectUtils.defaultIfNull(\"abc\", *)        \u003d \"abc\" ObjectUtils.defaultIfNull(Boolean.TRUE, *) \u003d Boolean.TRUE \u003c/pre\u003e\n * @param \u003c T \u003e the type of the object\n * @param object  the {@code Object} to test, may be {@code null}\n * @param defaultValue  the default value to return, may be {@code null}\n * @return {@code object} if it is not {@code null}, defaultValue otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.firstNonNull#120",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.firstNonNull(T)",
    "snippet": "public static \u003cT\u003e T firstNonNull(final T... values) {\n        if (values !\u003d null) {\n            for (final T val : values) {\n                if (val !\u003d null) {\n                    return val;\n                }\n            }\n        }\n        return null;\n    }",
    "begin_line": 120,
    "end_line": 129,
    "comment": "/** \n * \u003cp\u003eReturns the first value in the array which is not  {@code null}. If all the values are  {@code null} or the array is {@code null}or empty then  {@code null} is returned.\u003c/p\u003e\u003cpre\u003e ObjectUtils.firstNonNull(null, null)      \u003d null ObjectUtils.firstNonNull(null, \"\")        \u003d \"\" ObjectUtils.firstNonNull(null, null, \"\")  \u003d \"\" ObjectUtils.firstNonNull(null, \"zz\")      \u003d \"zz\" ObjectUtils.firstNonNull(\"abc\", *)        \u003d \"abc\" ObjectUtils.firstNonNull(null, \"xyz\", *)  \u003d \"xyz\" ObjectUtils.firstNonNull(Boolean.TRUE, *) \u003d Boolean.TRUE ObjectUtils.firstNonNull()                \u003d null \u003c/pre\u003e\n * @param \u003c T \u003e the component type of the array\n * @param values  the values to test, may be {@code null} or empty\n * @return the first value from {@code values} which is not {@code null}, or  {@code null} if there are no non-null values\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.anyNotNull#151",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.anyNotNull(java.lang.Object)",
    "snippet": "public static boolean anyNotNull(final Object... values) {\n        return firstNonNull(values) !\u003d null;\n    }",
    "begin_line": 151,
    "end_line": 153,
    "comment": "/** \n * \u003cp\u003eChecks if any value in the array is not  {@code null}. If all the values are  {@code null} or the array is {@code null}or empty then  {@code false} is returned. Otherwise {@code true} is returned.\u003c/p\u003e\u003cpre\u003e ObjectUtils.anyNotNull(*)                \u003d true ObjectUtils.anyNotNull(*, null)          \u003d true ObjectUtils.anyNotNull(null, *)          \u003d true ObjectUtils.anyNotNull(null, null, *, *) \u003d true ObjectUtils.anyNotNull(null)             \u003d false ObjectUtils.anyNotNull(null, null)       \u003d false \u003c/pre\u003e\n * @param values  the values to test, may be {@code null} or empty\n * @return {@code true} if there is at least one non-null value in the array,{@code false} if all values in the array are {@code null}s. If the array is  {@code null} or empty {@code false} is also returned.\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.allNotNull#177",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.allNotNull(java.lang.Object)",
    "snippet": "public static boolean allNotNull(final Object... values) {\n        if (values \u003d\u003d null) {\n            return false;\n        }\n\n        for (final Object val : values) {\n            if (val \u003d\u003d null) {\n                return false;\n            }\n        }\n\n        return true;\n    }",
    "begin_line": 177,
    "end_line": 189,
    "comment": "/** \n * \u003cp\u003eChecks if all values in the array are not  {@code null}s. If any value is  {@code null} or the array is {@code null}then  {@code false} is returned.If all elements in array are not  {@code null} or the array is empty (contains no elements){@code true} is returned.\u003c/p\u003e\u003cpre\u003e ObjectUtils.allNotNull(*)             \u003d true ObjectUtils.allNotNull(*, *)          \u003d true ObjectUtils.allNotNull(null)          \u003d false ObjectUtils.allNotNull(null, null)    \u003d false ObjectUtils.allNotNull(null, *)       \u003d false ObjectUtils.allNotNull(*, null)       \u003d false ObjectUtils.allNotNull(*, *, null, *) \u003d false \u003c/pre\u003e\n * @param values  the values to test, may be {@code null} or empty\n * @return {@code false} if there is at least one {@code null} value in the array or the array is {@code null}, {@code true} if all values in the array are not {@code null}s or array contains no elements.\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.equals#215",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.equals(java.lang.Object, java.lang.Object)",
    "snippet": "@Deprecated\n    public static boolean equals(final Object object1, final Object object2) {\n        if (object1 \u003d\u003d object2) {\n            return true;\n        }\n        if (object1 \u003d\u003d null || object2 \u003d\u003d null) {\n            return false;\n        }\n        return object1.equals(object2);\n    }",
    "begin_line": 215,
    "end_line": 223,
    "comment": "/** \n * \u003cp\u003eCompares two objects for equality, where either one or both objects may be  {@code null}.\u003c/p\u003e \u003cpre\u003e ObjectUtils.equals(null, null)                  \u003d true ObjectUtils.equals(null, \"\")                    \u003d false ObjectUtils.equals(\"\", null)                    \u003d false ObjectUtils.equals(\"\", \"\")                      \u003d true ObjectUtils.equals(Boolean.TRUE, null)          \u003d false ObjectUtils.equals(Boolean.TRUE, \"true\")        \u003d false ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  \u003d true ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) \u003d false \u003c/pre\u003e\n * @param object1  the first object, may be {@code null}\n * @param object2  the second object, may be {@code null}\n * @return {@code true} if the values of both objects are the same\n * @deprecated this method has been replaced by {@code java.util.Objects.equals(Object, Object)} in Java 7 and willbe removed from future releases.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.notEqual#244",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.notEqual(java.lang.Object, java.lang.Object)",
    "snippet": "public static boolean notEqual(final Object object1, final Object object2) {\n        return ObjectUtils.equals(object1, object2) \u003d\u003d false;\n    }",
    "begin_line": 244,
    "end_line": 246,
    "comment": "/** \n * \u003cp\u003eCompares two objects for inequality, where either one or both objects may be  {@code null}.\u003c/p\u003e \u003cpre\u003e ObjectUtils.notEqual(null, null)                  \u003d false ObjectUtils.notEqual(null, \"\")                    \u003d true ObjectUtils.notEqual(\"\", null)                    \u003d true ObjectUtils.notEqual(\"\", \"\")                      \u003d false ObjectUtils.notEqual(Boolean.TRUE, null)          \u003d true ObjectUtils.notEqual(Boolean.TRUE, \"true\")        \u003d true ObjectUtils.notEqual(Boolean.TRUE, Boolean.TRUE)  \u003d false ObjectUtils.notEqual(Boolean.TRUE, Boolean.FALSE) \u003d true \u003c/pre\u003e\n * @param object1  the first object, may be {@code null}\n * @param object2  the second object, may be {@code null}\n * @return {@code false} if the values of both objects are the same\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.hashCode#264",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.hashCode(java.lang.Object)",
    "snippet": "@Deprecated\n    public static int hashCode(final Object obj) {\n        // hashCode(Object) retained for performance, as hash code is often critical\n        return obj \u003d\u003d null ? 0 : obj.hashCode();\n    }",
    "begin_line": 264,
    "end_line": 267,
    "comment": "/** \n * \u003cp\u003eGets the hash code of an object returning zero when the object is  {@code null}.\u003c/p\u003e \u003cpre\u003e ObjectUtils.hashCode(null)   \u003d 0 ObjectUtils.hashCode(obj)    \u003d obj.hashCode() \u003c/pre\u003e\n * @param obj  the object to obtain the hash code of, may be {@code null}\n * @return the hash code of the object, or zero if null\n * @since 2.1\n * @deprecated this method has been replaced by {@code java.util.Objects.hashCode(Object)} in Java 7 and will beremoved in future releases\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.hashCodeMulti#292",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.hashCodeMulti(java.lang.Object)",
    "snippet": "@Deprecated\n    public static int hashCodeMulti(final Object... objects) {\n        int hash \u003d 1;\n        if (objects !\u003d null) {\n            for (final Object object : objects) {\n                final int tmpHash \u003d ObjectUtils.hashCode(object);\n                hash \u003d hash * 31 + tmpHash;\n            }\n        }\n        return hash;\n    }",
    "begin_line": 292,
    "end_line": 301,
    "comment": "/** \n * \u003cp\u003eGets the hash code for multiple objects.\u003c/p\u003e \u003cp\u003eThis allows a hash code to be rapidly calculated for a number of objects. The hash code for a single object is the \u003cem\u003enot\u003c/em\u003e same as  {@link #hashCode(Object)}. The hash code for multiple objects is the same as that calculated by an {@code ArrayList} containing the specified objects.\u003c/p\u003e\u003cpre\u003e ObjectUtils.hashCodeMulti()                 \u003d 1 ObjectUtils.hashCodeMulti((Object[]) null)  \u003d 1 ObjectUtils.hashCodeMulti(a)                \u003d 31 + a.hashCode() ObjectUtils.hashCodeMulti(a,b)              \u003d (31 + a.hashCode()) * 31 + b.hashCode() ObjectUtils.hashCodeMulti(a,b,c)            \u003d ((31 + a.hashCode()) * 31 + b.hashCode()) * 31 + c.hashCode() \u003c/pre\u003e\n * @param objects  the objects to obtain the hash code of, may be {@code null}\n * @return the hash code of the objects, or zero if null\n * @since 3.0\n * @deprecated this method has been replaced by {@code java.util.Objects.hash(Object...)} in Java 7 and will beremoved in future releases.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.identityToString#321",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.identityToString(java.lang.Object)",
    "snippet": "public static String identityToString(final Object object) {\n        if (object \u003d\u003d null) {\n            return null;\n        }\n        final StringBuilder builder \u003d new StringBuilder();\n        identityToString(builder, object);\n        return builder.toString();\n    }",
    "begin_line": 321,
    "end_line": 328,
    "comment": "/** \n * \u003cp\u003eGets the toString that would be produced by  {@code Object}if a class did not override toString itself.  {@code null}will return  {@code null}.\u003c/p\u003e \u003cpre\u003e ObjectUtils.identityToString(null)         \u003d null ObjectUtils.identityToString(\"\")           \u003d \"java.lang.String@1e23\" ObjectUtils.identityToString(Boolean.TRUE) \u003d \"java.lang.Boolean@7fa\" \u003c/pre\u003e\n * @param object  the object to create a toString for, may be{@code null}\n * @return the default toString text, or {@code null} if{@code null} passed in\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.identityToString#346",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.identityToString(java.lang.Appendable, java.lang.Object)",
    "snippet": "public static void identityToString(final Appendable appendable, final Object object) throws IOException {\n        if (object \u003d\u003d null) {\n            throw new NullPointerException(\"Cannot get the toString of a null identity\");\n        }\n        appendable.append(object.getClass().getName())\n              .append(\u0027@\u0027)\n              .append(Integer.toHexString(System.identityHashCode(object)));\n    }",
    "begin_line": 346,
    "end_line": 353,
    "comment": "/** \n * \u003cp\u003eAppends the toString that would be produced by  {@code Object}if a class did not override toString itself.  {@code null}will throw a NullPointerException for either of the two parameters. \u003c/p\u003e \u003cpre\u003e ObjectUtils.identityToString(appendable, \"\")            \u003d appendable.append(\"java.lang.String@1e23\" ObjectUtils.identityToString(appendable, Boolean.TRUE)  \u003d appendable.append(\"java.lang.Boolean@7fa\" ObjectUtils.identityToString(appendable, Boolean.TRUE)  \u003d appendable.append(\"java.lang.Boolean@7fa\") \u003c/pre\u003e\n * @param appendable  the appendable to append to\n * @param object  the object to create a toString for\n * @throws IOException if an I/O error occurs\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.identityToString#370",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.identityToString(org.apache.commons.lang3.text.StrBuilder, java.lang.Object)",
    "snippet": "public static void identityToString(final StrBuilder builder, final Object object) {\n        if (object \u003d\u003d null) {\n            throw new NullPointerException(\"Cannot get the toString of a null identity\");\n        }\n        builder.append(object.getClass().getName())\n              .append(\u0027@\u0027)\n              .append(Integer.toHexString(System.identityHashCode(object)));\n    }",
    "begin_line": 370,
    "end_line": 377,
    "comment": "/** \n * \u003cp\u003eAppends the toString that would be produced by  {@code Object}if a class did not override toString itself.  {@code null}will throw a NullPointerException for either of the two parameters. \u003c/p\u003e \u003cpre\u003e ObjectUtils.identityToString(builder, \"\")            \u003d builder.append(\"java.lang.String@1e23\" ObjectUtils.identityToString(builder, Boolean.TRUE)  \u003d builder.append(\"java.lang.Boolean@7fa\" ObjectUtils.identityToString(builder, Boolean.TRUE)  \u003d builder.append(\"java.lang.Boolean@7fa\") \u003c/pre\u003e\n * @param builder  the builder to append to\n * @param object  the object to create a toString for\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.identityToString#394",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.identityToString(java.lang.StringBuffer, java.lang.Object)",
    "snippet": "public static void identityToString(final StringBuffer buffer, final Object object) {\n        if (object \u003d\u003d null) {\n            throw new NullPointerException(\"Cannot get the toString of a null identity\");\n        }\n        buffer.append(object.getClass().getName())\n              .append(\u0027@\u0027)\n              .append(Integer.toHexString(System.identityHashCode(object)));\n    }",
    "begin_line": 394,
    "end_line": 401,
    "comment": "/** \n * \u003cp\u003eAppends the toString that would be produced by  {@code Object}if a class did not override toString itself.  {@code null}will throw a NullPointerException for either of the two parameters. \u003c/p\u003e \u003cpre\u003e ObjectUtils.identityToString(buf, \"\")            \u003d buf.append(\"java.lang.String@1e23\" ObjectUtils.identityToString(buf, Boolean.TRUE)  \u003d buf.append(\"java.lang.Boolean@7fa\" ObjectUtils.identityToString(buf, Boolean.TRUE)  \u003d buf.append(\"java.lang.Boolean@7fa\") \u003c/pre\u003e\n * @param buffer  the buffer to append to\n * @param object  the object to create a toString for\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.identityToString#418",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.identityToString(java.lang.StringBuilder, java.lang.Object)",
    "snippet": "public static void identityToString(final StringBuilder builder, final Object object) {\n        if (object \u003d\u003d null) {\n            throw new NullPointerException(\"Cannot get the toString of a null identity\");\n        }\n        builder.append(object.getClass().getName())\n              .append(\u0027@\u0027)\n              .append(Integer.toHexString(System.identityHashCode(object)));\n    }",
    "begin_line": 418,
    "end_line": 425,
    "comment": "/** \n * \u003cp\u003eAppends the toString that would be produced by  {@code Object}if a class did not override toString itself.  {@code null}will throw a NullPointerException for either of the two parameters. \u003c/p\u003e \u003cpre\u003e ObjectUtils.identityToString(builder, \"\")            \u003d builder.append(\"java.lang.String@1e23\" ObjectUtils.identityToString(builder, Boolean.TRUE)  \u003d builder.append(\"java.lang.Boolean@7fa\" ObjectUtils.identityToString(builder, Boolean.TRUE)  \u003d builder.append(\"java.lang.Boolean@7fa\") \u003c/pre\u003e\n * @param builder  the builder to append to\n * @param object  the object to create a toString for\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.toString#450",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.toString(java.lang.Object)",
    "snippet": "@Deprecated\n    public static String toString(final Object obj) {\n        return obj \u003d\u003d null ? StringUtils.EMPTY : obj.toString();\n    }",
    "begin_line": 450,
    "end_line": 452,
    "comment": "/** \n * \u003cp\u003eGets the  {@code toString} of an {@code Object} returningan empty string (\"\") if  {@code null} input.\u003c/p\u003e\u003cpre\u003e ObjectUtils.toString(null)         \u003d \"\" ObjectUtils.toString(\"\")           \u003d \"\" ObjectUtils.toString(\"bat\")        \u003d \"bat\" ObjectUtils.toString(Boolean.TRUE) \u003d \"true\" \u003c/pre\u003e\n * @see StringUtils#defaultString(String)\n * @see String#valueOf(Object)\n * @param obj  the Object to {@code toString}, may be null\n * @return the passed in Object\u0027s toString, or {@code \"\"} if {@code null} input\n * @since 2.0\n * @deprecated this method has been replaced by {@code java.util.Objects.toString(Object)} in Java 7 and will beremoved in future releases. Note however that said method will return \"null\" for null references, while this method returns and empty String. To preserve behavior use  {@code java.util.Objects.toString(myObject, \"\")}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.toString#476",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.toString(java.lang.Object, java.lang.String)",
    "snippet": "@Deprecated\n    public static String toString(final Object obj, final String nullStr) {\n        return obj \u003d\u003d null ? nullStr : obj.toString();\n    }",
    "begin_line": 476,
    "end_line": 478,
    "comment": "/** \n * \u003cp\u003eGets the  {@code toString} of an {@code Object} returninga specified text if  {@code null} input.\u003c/p\u003e\u003cpre\u003e ObjectUtils.toString(null, null)           \u003d null ObjectUtils.toString(null, \"null\")         \u003d \"null\" ObjectUtils.toString(\"\", \"null\")           \u003d \"\" ObjectUtils.toString(\"bat\", \"null\")        \u003d \"bat\" ObjectUtils.toString(Boolean.TRUE, \"null\") \u003d \"true\" \u003c/pre\u003e\n * @see StringUtils#defaultString(String,String)\n * @see String#valueOf(Object)\n * @param obj  the Object to {@code toString}, may be null\n * @param nullStr  the String to return if {@code null} input, may be null\n * @return the passed in Object\u0027s toString, or {@code nullStr} if {@code null} input\n * @since 2.0\n * @deprecated this method has been replaced by {@code java.util.Objects.toString(Object, String)} in Java 7 andwill be removed in future releases.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.min#495",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.min(T)",
    "snippet": "public static \u003cT extends Comparable\u003c? super T\u003e\u003e T min(final T... values) {\n        T result \u003d null;\n        if (values !\u003d null) {\n            for (final T value : values) {\n                if (compare(value, result, true) \u003c 0) {\n                    result \u003d value;\n                }\n            }\n        }\n        return result;\n    }",
    "begin_line": 495,
    "end_line": 505,
    "comment": "/** \n * \u003cp\u003eNull safe comparison of Comparables.\u003c/p\u003e\n * @param \u003c T \u003e type of the values processed by this method\n * @param values the set of comparable values, may be null\n * @return \u003cul\u003e \u003cli\u003eIf any objects are non-null and unequal, the lesser object. \u003cli\u003eIf all objects are non-null and equal, the first. \u003cli\u003eIf any of the comparables are null, the lesser of the non-null objects. \u003cli\u003eIf all the comparables are null, null is returned. \u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.max#520",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.max(T)",
    "snippet": "public static \u003cT extends Comparable\u003c? super T\u003e\u003e T max(final T... values) {\n        T result \u003d null;\n        if (values !\u003d null) {\n            for (final T value : values) {\n                if (compare(value, result, false) \u003e 0) {\n                    result \u003d value;\n                }\n            }\n        }\n        return result;\n    }",
    "begin_line": 520,
    "end_line": 530,
    "comment": "/** \n * \u003cp\u003eNull safe comparison of Comparables.\u003c/p\u003e\n * @param \u003c T \u003e type of the values processed by this method\n * @param values the set of comparable values, may be null\n * @return \u003cul\u003e \u003cli\u003eIf any objects are non-null and unequal, the greater object. \u003cli\u003eIf all objects are non-null and equal, the first. \u003cli\u003eIf any of the comparables are null, the greater of the non-null objects. \u003cli\u003eIf all the comparables are null, null is returned. \u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.compare#542",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.compare(T, T)",
    "snippet": "public static \u003cT extends Comparable\u003c? super T\u003e\u003e int compare(final T c1, final T c2) {\n        return compare(c1, c2, false);\n    }",
    "begin_line": 542,
    "end_line": 544,
    "comment": "/** \n * \u003cp\u003eNull safe comparison of Comparables. {@code null} is assumed to be less than a non-{@code null} value.\u003c/p\u003e\n * @param \u003c T \u003e type of the values processed by this method\n * @param c1  the first comparable, may be null\n * @param c2  the second comparable, may be null\n * @return a negative value if c1 \u0026lt; c2, zero if c1 \u003d c2and a positive value if c1 \u0026gt; c2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.compare#559",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.compare(T, T, boolean)",
    "snippet": "public static \u003cT extends Comparable\u003c? super T\u003e\u003e int compare(final T c1, final T c2, final boolean nullGreater) {\n        if (c1 \u003d\u003d c2) {\n            return 0;\n        } else if (c1 \u003d\u003d null) {\n            return nullGreater ? 1 : -1;\n        } else if (c2 \u003d\u003d null) {\n            return nullGreater ? -1 : 1;\n        }\n        return c1.compareTo(c2);\n    }",
    "begin_line": 559,
    "end_line": 568,
    "comment": "/** \n * \u003cp\u003eNull safe comparison of Comparables.\u003c/p\u003e\n * @param \u003c T \u003e type of the values processed by this method\n * @param c1  the first comparable, may be null\n * @param c2  the second comparable, may be null\n * @param nullGreater if true {@code null} is considered greaterthan a non- {@code null} value or if false {@code null} isconsidered less than a Non- {@code null} value\n * @return a negative value if c1 \u0026lt; c2, zero if c1 \u003d c2and a positive value if c1 \u0026gt; c2\n * @see java.util.Comparator#compare(Object,Object)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.median#580",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.median(T)",
    "snippet": "public static \u003cT extends Comparable\u003c? super T\u003e\u003e T median(final T... items) {\n        Validate.notEmpty(items);\n        Validate.noNullElements(items);\n        final TreeSet\u003cT\u003e sort \u003d new TreeSet\u003cT\u003e();\n        Collections.addAll(sort, items);\n        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n        final\n        T result \u003d (T) sort.toArray()[(sort.size() - 1) / 2];\n        return result;\n    }",
    "begin_line": 580,
    "end_line": 589,
    "comment": "/** \n * Find the \"best guess\" middle value among comparables. If there is an even number of total values, the lower of the two middle values will be returned.\n * @param \u003c T \u003e type of values processed by this method\n * @param items to compare\n * @return T at middle position\n * @throws NullPointerException if items is {@code null}\n * @throws IllegalArgumentException if items is empty or contains {@code null} values\n * @since 3.0.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.median#602",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.median(java.util.Comparator\u003cT\u003e, T)",
    "snippet": "public static \u003cT\u003e T median(final Comparator\u003cT\u003e comparator, final T... items) {\n        Validate.notEmpty(items, \"null/empty items\");\n        Validate.noNullElements(items);\n        Validate.notNull(comparator, \"null comparator\");\n        final TreeSet\u003cT\u003e sort \u003d new TreeSet\u003cT\u003e(comparator);\n        Collections.addAll(sort, items);\n        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n        final\n        T result \u003d (T) sort.toArray()[(sort.size() - 1) / 2];\n        return result;\n    }",
    "begin_line": 602,
    "end_line": 612,
    "comment": "/** \n * Find the \"best guess\" middle value among comparables. If there is an even number of total values, the lower of the two middle values will be returned.\n * @param \u003c T \u003e type of values processed by this method\n * @param comparator to use for comparisons\n * @param items to compare\n * @return T at middle position\n * @throws NullPointerException if items or comparator is {@code null}\n * @throws IllegalArgumentException if items is empty or contains {@code null} values\n * @since 3.0.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.mode#624",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.mode(T)",
    "snippet": "public static \u003cT\u003e T mode(final T... items) {\n        if (ArrayUtils.isNotEmpty(items)) {\n            final HashMap\u003cT, MutableInt\u003e occurrences \u003d new HashMap\u003cT, MutableInt\u003e(items.length);\n            for (final T t : items) {\n                final MutableInt count \u003d occurrences.get(t);\n                if (count \u003d\u003d null) {\n                    occurrences.put(t, new MutableInt(1));\n                } else {\n                    count.increment();\n                }\n            }\n            T result \u003d null;\n            int max \u003d 0;\n            for (final Map.Entry\u003cT, MutableInt\u003e e : occurrences.entrySet()) {\n                final int cmp \u003d e.getValue().intValue();\n                if (cmp \u003d\u003d max) {\n                    result \u003d null;\n                } else if (cmp \u003e max) {\n                    max \u003d cmp;\n                    result \u003d e.getKey();\n                }\n            }\n            return result;\n        }\n        return null;\n    }",
    "begin_line": 624,
    "end_line": 649,
    "comment": "/** \n * Find the most frequently occurring item.\n * @param \u003c T \u003e type of values processed by this method\n * @param items to check\n * @return most populous T, {@code null} if non-unique or no items supplied\n * @since 3.0.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.clone#662",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.clone(T)",
    "snippet": "public static \u003cT\u003e T clone(final T obj) {\n        if (obj instanceof Cloneable) {\n            final Object result;\n            if (obj.getClass().isArray()) {\n                final Class\u003c?\u003e componentType \u003d obj.getClass().getComponentType();\n                if (!componentType.isPrimitive()) {\n                    result \u003d ((Object[]) obj).clone();\n                } else {\n                    int length \u003d Array.getLength(obj);\n                    result \u003d Array.newInstance(componentType, length);\n                    while (length-- \u003e 0) {\n                        Array.set(result, length, Array.get(obj, length));\n                    }\n                }\n            } else {\n                try {\n                    final Method clone \u003d obj.getClass().getMethod(\"clone\");\n                    result \u003d clone.invoke(obj);\n                } catch (final NoSuchMethodException e) {\n                    throw new CloneFailedException(\"Cloneable type \"\n                        + obj.getClass().getName()\n                        + \" has no clone method\", e);\n                } catch (final IllegalAccessException e) {\n                    throw new CloneFailedException(\"Cannot clone Cloneable type \"\n                        + obj.getClass().getName(), e);\n                } catch (final InvocationTargetException e) {\n                    throw new CloneFailedException(\"Exception cloning Cloneable type \"\n                        + obj.getClass().getName(), e.getCause());\n                }\n            }\n            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n            final T checked \u003d (T) result;\n            return checked;\n        }\n\n        return null;\n    }",
    "begin_line": 662,
    "end_line": 698,
    "comment": "/** \n * \u003cp\u003eClone an object.\u003c/p\u003e\n * @param \u003c T \u003e the type of the object\n * @param obj  the object to clone, null returns null\n * @return the clone if the object implements {@link Cloneable} otherwise {@code null}\n * @throws CloneFailedException if the object is cloneable and the clone operation fails\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectUtils.cloneIfPossible#716",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.cloneIfPossible(T)",
    "snippet": "public static \u003cT\u003e T cloneIfPossible(final T obj) {\n        final T clone \u003d clone(obj);\n        return clone \u003d\u003d null ? obj : clone;\n    }",
    "begin_line": 716,
    "end_line": 719,
    "comment": "/** \n * \u003cp\u003eClone an object if possible.\u003c/p\u003e \u003cp\u003eThis method is similar to  {@link #clone(Object)}, but will return the provided instance as the return value instead of  {@code null} if the instanceis not cloneable. This is more convenient if the caller uses different implementations (e.g. of a service) and some of the implementations do not allow concurrent processing or have state. In such cases the implementation can simply provide a proper clone implementation and the caller\u0027s code does not have to change.\u003c/p\u003e\n * @param \u003c T \u003e the type of the object\n * @param obj  the object to clone, null returns null\n * @return the clone if the object implements {@link Cloneable} otherwise the object itself\n * @throws CloneFailedException if the object is cloneable and the clone operation fails\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.Null#747",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.Null()",
    "snippet": " Null() {\n            super();\n        }",
    "begin_line": 747,
    "end_line": 749,
    "comment": "/** \n * Restricted constructor - singleton.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.readResolve#756",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.readResolve()",
    "snippet": "private Object readResolve() {\n            return ObjectUtils.NULL;\n        }",
    "begin_line": 756,
    "end_line": 758,
    "comment": "/** \n * \u003cp\u003eEnsure singleton.\u003c/p\u003e\n * @return the singleton value\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST#800",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST(boolean)",
    "snippet": "public static boolean CONST(final boolean v) { return v; }",
    "begin_line": 800,
    "end_line": 800,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static boolean MAGIC_FLAG \u003d ObjectUtils.CONST(true); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the boolean value to return\n * @return the boolean v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST#819",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST(byte)",
    "snippet": "public static byte CONST(final byte v) { return v; }",
    "begin_line": 819,
    "end_line": 819,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static byte MAGIC_BYTE \u003d ObjectUtils.CONST((byte) 127); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the byte value to return\n * @return the byte v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST_BYTE#841",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST_BYTE(int)",
    "snippet": "public static byte CONST_BYTE(final int v) throws IllegalArgumentException {\n        if (v \u003c Byte.MIN_VALUE || v \u003e Byte.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -128 and 127: [\" + v + \"]\");\n        }\n        return (byte) v;\n    }",
    "begin_line": 841,
    "end_line": 846,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static byte MAGIC_BYTE \u003d ObjectUtils.CONST_BYTE(127); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the byte literal (as an int) value to return\n * @throws IllegalArgumentException if the value passed to vis larger than a byte, that is, smaller than -128 or larger than 127.\n * @return the byte v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST#865",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST(char)",
    "snippet": "public static char CONST(final char v) { return v; }",
    "begin_line": 865,
    "end_line": 865,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static char MAGIC_CHAR \u003d ObjectUtils.CONST(\u0027a\u0027); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the char value to return\n * @return the char v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST#884",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST(short)",
    "snippet": "public static short CONST(final short v) { return v; }",
    "begin_line": 884,
    "end_line": 884,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static short MAGIC_SHORT \u003d ObjectUtils.CONST((short) 123); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the short value to return\n * @return the short v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST_SHORT#906",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST_SHORT(int)",
    "snippet": "public static short CONST_SHORT(final int v) throws IllegalArgumentException {\n        if (v \u003c Short.MIN_VALUE || v \u003e Short.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -32768 and 32767: [\" + v + \"]\");\n        }\n        return (short) v;\n    }",
    "begin_line": 906,
    "end_line": 911,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static short MAGIC_SHORT \u003d ObjectUtils.CONST_SHORT(127); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the short literal (as an int) value to return\n * @throws IllegalArgumentException if the value passed to vis larger than a short, that is, smaller than -32768 or larger than 32767.\n * @return the byte v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST#931",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST(int)",
    "snippet": "public static int CONST(final int v) { return v; }",
    "begin_line": 931,
    "end_line": 931,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static int MAGIC_INT \u003d ObjectUtils.CONST(123); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the int value to return\n * @return the int v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST#950",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST(long)",
    "snippet": "public static long CONST(final long v) { return v; }",
    "begin_line": 950,
    "end_line": 950,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static long MAGIC_LONG \u003d ObjectUtils.CONST(123L); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the long value to return\n * @return the long v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST#969",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST(float)",
    "snippet": "public static float CONST(final float v) { return v; }",
    "begin_line": 969,
    "end_line": 969,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static float MAGIC_FLOAT \u003d ObjectUtils.CONST(1.0f); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the float value to return\n * @return the float v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST#988",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST(double)",
    "snippet": "public static double CONST(final double v) { return v; }",
    "begin_line": 988,
    "end_line": 988,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static double MAGIC_DOUBLE \u003d ObjectUtils.CONST(1.0); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param v the double value to return\n * @return the double v, unchanged\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Null.CONST#1008",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/ObjectUtils.java",
    "class_name": "org.apache.commons.lang3.ObjectUtils",
    "signature": "org.apache.commons.lang3.ObjectUtils.CONST(T)",
    "snippet": "public static \u003cT\u003e T CONST(final T v) { return v; }",
    "begin_line": 1008,
    "end_line": 1008,
    "comment": "/** \n * This method returns the provided value unchanged. This can prevent javac from inlining a constant field, e.g., \u003cpre\u003e public final static String MAGIC_STRING \u003d ObjectUtils.CONST(\"abc\"); \u003c/pre\u003e This way any jars that refer to this field do not have to recompile themselves if the field\u0027s value changes at some future date.\n * @param \u003c T \u003e the Object type \n * @param v the genericized Object value to return (typically a String).\n * @return the genericized Object v, unchanged (typically a String).\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.getJavaHome#1477",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.getJavaHome()",
    "snippet": "public static File getJavaHome() {\n        return new File(System.getProperty(JAVA_HOME_KEY));\n    }",
    "begin_line": 1477,
    "end_line": 1479,
    "comment": "/** \n * \u003cp\u003e Gets the Java home directory as a  {@code File}. \u003c/p\u003e\n * @return a directory\n * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn\u0027t allowaccess to the specified system property.\n * @see System#getProperty(String)\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.getJavaIoTmpDir#1492",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.getJavaIoTmpDir()",
    "snippet": "public static File getJavaIoTmpDir() {\n        return new File(System.getProperty(JAVA_IO_TMPDIR_KEY));\n    }",
    "begin_line": 1492,
    "end_line": 1494,
    "comment": "/** \n * \u003cp\u003e Gets the Java IO temporary directory as a  {@code File}. \u003c/p\u003e\n * @return a directory\n * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn\u0027t allowaccess to the specified system property.\n * @see System#getProperty(String)\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.getJavaVersionMatches#1504",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.getJavaVersionMatches(java.lang.String)",
    "snippet": "private static boolean getJavaVersionMatches(final String versionPrefix) {\n        return isJavaVersionMatch(JAVA_SPECIFICATION_VERSION, versionPrefix);\n    }",
    "begin_line": 1504,
    "end_line": 1506,
    "comment": "/** \n * \u003cp\u003e Decides if the Java version matches. \u003c/p\u003e\n * @param versionPrefix the prefix for the java version\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.getOSMatches#1515",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.getOSMatches(java.lang.String, java.lang.String)",
    "snippet": "private static boolean getOSMatches(final String osNamePrefix, final String osVersionPrefix) {\n        return isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix);\n    }",
    "begin_line": 1515,
    "end_line": 1517,
    "comment": "/** \n * Decides if the operating system matches.\n * @param osNamePrefix the prefix for the os name\n * @param osVersionPrefix the prefix for the version\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.getOSMatchesName#1525",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.getOSMatchesName(java.lang.String)",
    "snippet": "private static boolean getOSMatchesName(final String osNamePrefix) {\n        return isOSNameMatch(OS_NAME, osNamePrefix);\n    }",
    "begin_line": 1525,
    "end_line": 1527,
    "comment": "/** \n * Decides if the operating system matches.\n * @param osNamePrefix the prefix for the os name\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.getSystemProperty#1542",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.getSystemProperty(java.lang.String)",
    "snippet": "private static String getSystemProperty(final String property) {\n        try {\n            return System.getProperty(property);\n        } catch (final SecurityException ex) {\n            // we are not allowed to look at this property\n            System.err.println(\"Caught a SecurityException reading the system property \u0027\" + property\n                    + \"\u0027; the SystemUtils property value will default to null.\");\n            return null;\n        }\n    }",
    "begin_line": 1542,
    "end_line": 1551,
    "comment": "/** \n * \u003cp\u003e Gets a System property, defaulting to  {@code null} if the property cannot be read.\u003c/p\u003e \u003cp\u003e If a  {@code SecurityException} is caught, the return value is {@code null} and a message is written to{@code System.err}. \u003c/p\u003e\n * @param property the system property name\n * @return the system property value or {@code null} if a security problem occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.getUserDir#1564",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.getUserDir()",
    "snippet": "public static File getUserDir() {\n        return new File(System.getProperty(USER_DIR_KEY));\n    }",
    "begin_line": 1564,
    "end_line": 1566,
    "comment": "/** \n * \u003cp\u003e Gets the user directory as a  {@code File}. \u003c/p\u003e\n * @return a directory\n * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn\u0027t allowaccess to the specified system property.\n * @see System#getProperty(String)\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.getUserHome#1579",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.getUserHome()",
    "snippet": "public static File getUserHome() {\n        return new File(System.getProperty(USER_HOME_KEY));\n    }",
    "begin_line": 1579,
    "end_line": 1581,
    "comment": "/** \n * \u003cp\u003e Gets the user home directory as a  {@code File}. \u003c/p\u003e\n * @return a directory\n * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn\u0027t allowaccess to the specified system property.\n * @see System#getProperty(String)\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.isJavaAwtHeadless#1591",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.isJavaAwtHeadless()",
    "snippet": "public static boolean isJavaAwtHeadless() {\n        return JAVA_AWT_HEADLESS !\u003d null ? JAVA_AWT_HEADLESS.equals(Boolean.TRUE.toString()) : false;\n    }",
    "begin_line": 1591,
    "end_line": 1593,
    "comment": "/** \n * Returns whether the  {@link #JAVA_AWT_HEADLESS} value is {@code true}.\n * @return {@code true} if {@code JAVA_AWT_HEADLESS} is {@code \"true\"},  {@code false} otherwise.\n * @see #JAVA_AWT_HEADLESS\n * @since 2.1\n * @since Java 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.isJavaVersionAtLeast#1610",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.isJavaVersionAtLeast(org.apache.commons.lang3.JavaVersion)",
    "snippet": "public static boolean isJavaVersionAtLeast(final JavaVersion requiredVersion) {\n        return JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);\n    }",
    "begin_line": 1610,
    "end_line": 1612,
    "comment": "/** \n * \u003cp\u003e Is the Java version at least the requested version. \u003c/p\u003e \u003cp\u003e Example input: \u003c/p\u003e \u003cul\u003e \u003cli\u003e {@code 1.2f} to test for Java 1.2\u003c/li\u003e\u003cli\u003e {@code 1.31f} to test for Java 1.3.1\u003c/li\u003e\u003c/ul\u003e\n * @param requiredVersion the required version, for example 1.31f\n * @return {@code true} if the actual version is equal or greater than the required version\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.isJavaVersionMatch#1626",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.isJavaVersionMatch(java.lang.String, java.lang.String)",
    "snippet": "static boolean isJavaVersionMatch(final String version, final String versionPrefix) {\n        if (version \u003d\u003d null) {\n            return false;\n        }\n        return version.startsWith(versionPrefix);\n    }",
    "begin_line": 1626,
    "end_line": 1631,
    "comment": "/** \n * \u003cp\u003e Decides if the Java version matches. \u003c/p\u003e \u003cp\u003e This method is package private instead of private to support unit test invocation. \u003c/p\u003e\n * @param version the actual Java version\n * @param versionPrefix the prefix for the expected Java version\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.isOSMatch#1645",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.isOSMatch(java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) {\n        if (osName \u003d\u003d null || osVersion \u003d\u003d null) {\n            return false;\n        }\n        return isOSNameMatch(osName, osNamePrefix) \u0026\u0026 isOSVersionMatch(osVersion, osVersionPrefix);\n    }",
    "begin_line": 1645,
    "end_line": 1650,
    "comment": "/** \n * Decides if the operating system matches. \u003cp\u003e This method is package private instead of private to support unit test invocation. \u003c/p\u003e\n * @param osName the actual OS name\n * @param osVersion the actual OS version\n * @param osNamePrefix the prefix for the expected OS name\n * @param osVersionPrefix the prefix for the expected OS version\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.isOSNameMatch#1662",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.isOSNameMatch(java.lang.String, java.lang.String)",
    "snippet": "static boolean isOSNameMatch(final String osName, final String osNamePrefix) {\n        if (osName \u003d\u003d null) {\n            return false;\n        }\n        return osName.startsWith(osNamePrefix);\n    }",
    "begin_line": 1662,
    "end_line": 1667,
    "comment": "/** \n * Decides if the operating system matches. \u003cp\u003e This method is package private instead of private to support unit test invocation. \u003c/p\u003e\n * @param osName the actual OS name\n * @param osNamePrefix the prefix for the expected OS name\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.isOSVersionMatch#1679",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.isOSVersionMatch(java.lang.String, java.lang.String)",
    "snippet": "static boolean isOSVersionMatch(final String osVersion, final String osVersionPrefix) {\n        if (StringUtils.isEmpty(osVersion)) {\n            return false;\n        }\n        // Compare parts of the version string instead of using String.startsWith(String) because otherwise\n        // osVersionPrefix 10.1 would also match osVersion 10.10\n        String[] versionPrefixParts \u003d osVersionPrefix.split(\"\\\\.\");\n        String[] versionParts \u003d osVersion.split(\"\\\\.\");\n        for (int i \u003d 0; i \u003c Math.min(versionPrefixParts.length, versionParts.length); i++) {\n            if (!versionPrefixParts[i].equals(versionParts[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 1679,
    "end_line": 1693,
    "comment": "/** \n * Decides if the operating system version matches. \u003cp\u003e This method is package private instead of private to support unit test invocation. \u003c/p\u003e\n * @param osVersion the actual OS version\n * @param osVersionPrefix the prefix for the expected OS version\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SystemUtils.SystemUtils#1705",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/SystemUtils.java",
    "class_name": "org.apache.commons.lang3.SystemUtils",
    "signature": "org.apache.commons.lang3.SystemUtils.SystemUtils()",
    "snippet": "public SystemUtils() {\n        super();\n    }",
    "begin_line": 1705,
    "end_line": 1707,
    "comment": "/** \n * \u003cp\u003e SystemUtils instances should NOT be constructed in standard programming. Instead, the class should be used as {@code SystemUtils.FILE_SEPARATOR}. \u003c/p\u003e \u003cp\u003e This constructor is public to permit tools that require a JavaBean instance to operate. \u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.Validate#91",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.Validate()",
    "snippet": "public Validate() {\n      super();\n    }",
    "begin_line": 91,
    "end_line": 93,
    "comment": "/** \n * Constructor. This class should not normally be instantiated.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.isTrue#117",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.isTrue(boolean, java.lang.String, long)",
    "snippet": "public static void isTrue(final boolean expression, final String message, final long value) {\n        if (expression \u003d\u003d false) {\n            throw new IllegalArgumentException(String.format(message, Long.valueOf(value)));\n        }\n    }",
    "begin_line": 117,
    "end_line": 121,
    "comment": "/** \n * \u003cp\u003eValidate that the argument condition is  {@code true}; otherwise throwing an exception with the specified message. This method is useful when validating according to an arbitrary boolean expression, such as validating a primitive number or using your own custom validation expression.\u003c/p\u003e \u003cpre\u003eValidate.isTrue(i \u0026gt; 0.0, \"The value must be greater than zero: \u0026#37;d\", i);\u003c/pre\u003e \u003cp\u003eFor performance reasons, the long value is passed as a separate parameter and appended to the exception message only in the case of an error.\u003c/p\u003e\n * @param expression  the boolean expression to check\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param value  the value to append to the message when invalid\n * @throws IllegalArgumentException if expression is {@code false}\n * @see #isTrue(boolean)\n * @see #isTrue(boolean,String,double)\n * @see #isTrue(boolean,String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.isTrue#142",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.isTrue(boolean, java.lang.String, double)",
    "snippet": "public static void isTrue(final boolean expression, final String message, final double value) {\n        if (expression \u003d\u003d false) {\n            throw new IllegalArgumentException(String.format(message, Double.valueOf(value)));\n        }\n    }",
    "begin_line": 142,
    "end_line": 146,
    "comment": "/** \n * \u003cp\u003eValidate that the argument condition is  {@code true}; otherwise throwing an exception with the specified message. This method is useful when validating according to an arbitrary boolean expression, such as validating a primitive number or using your own custom validation expression.\u003c/p\u003e \u003cpre\u003eValidate.isTrue(d \u0026gt; 0.0, \"The value must be greater than zero: \u0026#37;s\", d);\u003c/pre\u003e \u003cp\u003eFor performance reasons, the double value is passed as a separate parameter and appended to the exception message only in the case of an error.\u003c/p\u003e\n * @param expression  the boolean expression to check\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param value  the value to append to the message when invalid\n * @throws IllegalArgumentException if expression is {@code false}\n * @see #isTrue(boolean)\n * @see #isTrue(boolean,String,long)\n * @see #isTrue(boolean,String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.isTrue#166",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.isTrue(boolean, java.lang.String, java.lang.Object)",
    "snippet": "public static void isTrue(final boolean expression, final String message, final Object... values) {\n        if (expression \u003d\u003d false) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 166,
    "end_line": 170,
    "comment": "/** \n * \u003cp\u003eValidate that the argument condition is  {@code true}; otherwise throwing an exception with the specified message. This method is useful when validating according to an arbitrary boolean expression, such as validating a primitive number or using your own custom validation expression.\u003c/p\u003e \u003cpre\u003e Validate.isTrue(i \u0026gt;\u003d min \u0026amp;\u0026amp; i \u0026lt;\u003d max, \"The value must be between \u0026#37;d and \u0026#37;d\", min, max); Validate.isTrue(myObject.isOk(), \"The object is not okay\");\u003c/pre\u003e\n * @param expression  the boolean expression to check\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if expression is {@code false}\n * @see #isTrue(boolean)\n * @see #isTrue(boolean,String,long)\n * @see #isTrue(boolean,String,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.isTrue#191",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.isTrue(boolean)",
    "snippet": "public static void isTrue(final boolean expression) {\n        if (expression \u003d\u003d false) {\n            throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);\n        }\n    }",
    "begin_line": 191,
    "end_line": 195,
    "comment": "/** \n * \u003cp\u003eValidate that the argument condition is  {@code true}; otherwise throwing an exception. This method is useful when validating according to an arbitrary boolean expression, such as validating a primitive number or using your own custom validation expression.\u003c/p\u003e \u003cpre\u003e Validate.isTrue(i \u0026gt; 0); Validate.isTrue(myObject.isOk());\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The validated expression is false\u0026quot;.\u003c/p\u003e\n * @param expression  the boolean expression to check\n * @throws IllegalArgumentException if expression is {@code false}\n * @see #isTrue(boolean,String,long)\n * @see #isTrue(boolean,String,double)\n * @see #isTrue(boolean,String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notNull#215",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notNull(T)",
    "snippet": "public static \u003cT\u003e T notNull(final T object) {\n        return notNull(object, DEFAULT_IS_NULL_EX_MESSAGE);\n    }",
    "begin_line": 215,
    "end_line": 217,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument is not  {@code null}; otherwise throwing an exception. \u003cpre\u003eValidate.notNull(myObject, \"The object must not be null\");\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e the object type\n * @param object  the object to check\n * @return the validated object (never {@code null} for method chaining)\n * @throws NullPointerException if the object is {@code null}\n * @see #notNull(Object,String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notNull#233",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notNull(T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e T notNull(final T object, final String message, final Object... values) {\n        if (object \u003d\u003d null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        return object;\n    }",
    "begin_line": 233,
    "end_line": 238,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument is not  {@code null}; otherwise throwing an exception with the specified message. \u003cpre\u003eValidate.notNull(myObject, \"The object must not be null\");\u003c/pre\u003e\n * @param \u003c T \u003e the object type\n * @param object  the object to check\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @return the validated object (never {@code null} for method chaining)\n * @throws NullPointerException if the object is {@code null}\n * @see #notNull(Object)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notEmpty#259",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notEmpty(T[], java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e T[] notEmpty(final T[] array, final String message, final Object... values) {\n        if (array \u003d\u003d null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (array.length \u003d\u003d 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return array;\n    }",
    "begin_line": 259,
    "end_line": 267,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument array is neither  {@code null}nor a length of zero (no elements); otherwise throwing an exception with the specified message. \u003cpre\u003eValidate.notEmpty(myArray, \"The array must not be empty\");\u003c/pre\u003e\n * @param \u003c T \u003e the array type\n * @param array  the array to check, validated not null by this method\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated array (never {@code null} method for chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IllegalArgumentException if the array is empty\n * @see #notEmpty(Object[])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notEmpty#285",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notEmpty(T[])",
    "snippet": "public static \u003cT\u003e T[] notEmpty(final T[] array) {\n        return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE);\n    }",
    "begin_line": 285,
    "end_line": 287,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument array is neither  {@code null}nor a length of zero (no elements); otherwise throwing an exception. \u003cpre\u003eValidate.notEmpty(myArray);\u003c/pre\u003e \u003cp\u003eThe message in the exception is \u0026quot;The validated array is empty\u0026quot;.\n * @param \u003c T \u003e the array type\n * @param array  the array to check, validated not null by this method\n * @return the validated array (never {@code null} method for chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IllegalArgumentException if the array is empty\n * @see #notEmpty(Object[],String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notEmpty#308",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notEmpty(T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT extends Collection\u003c?\u003e\u003e T notEmpty(final T collection, final String message, final Object... values) {\n        if (collection \u003d\u003d null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (collection.isEmpty()) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return collection;\n    }",
    "begin_line": 308,
    "end_line": 316,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument collection is neither  {@code null}nor a size of zero (no elements); otherwise throwing an exception with the specified message. \u003cpre\u003eValidate.notEmpty(myCollection, \"The collection must not be empty\");\u003c/pre\u003e\n * @param \u003c T \u003e the collection type\n * @param collection  the collection to check, validated not null by this method\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated collection (never {@code null} method for chaining)\n * @throws NullPointerException if the collection is {@code null}\n * @throws IllegalArgumentException if the collection is empty\n * @see #notEmpty(Object[])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notEmpty#334",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notEmpty(T)",
    "snippet": "public static \u003cT extends Collection\u003c?\u003e\u003e T notEmpty(final T collection) {\n        return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE);\n    }",
    "begin_line": 334,
    "end_line": 336,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument collection is neither  {@code null}nor a size of zero (no elements); otherwise throwing an exception. \u003cpre\u003eValidate.notEmpty(myCollection);\u003c/pre\u003e \u003cp\u003eThe message in the exception is \u0026quot;The validated collection is empty\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e the collection type\n * @param collection  the collection to check, validated not null by this method\n * @return the validated collection (never {@code null} method for chaining)\n * @throws NullPointerException if the collection is {@code null}\n * @throws IllegalArgumentException if the collection is empty\n * @see #notEmpty(Collection,String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notEmpty#357",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notEmpty(T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT extends Map\u003c?, ?\u003e\u003e T notEmpty(final T map, final String message, final Object... values) {\n        if (map \u003d\u003d null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (map.isEmpty()) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return map;\n    }",
    "begin_line": 357,
    "end_line": 365,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument map is neither  {@code null}nor a size of zero (no elements); otherwise throwing an exception with the specified message. \u003cpre\u003eValidate.notEmpty(myMap, \"The map must not be empty\");\u003c/pre\u003e\n * @param \u003c T \u003e the map type\n * @param map  the map to check, validated not null by this method\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated map (never {@code null} method for chaining)\n * @throws NullPointerException if the map is {@code null}\n * @throws IllegalArgumentException if the map is empty\n * @see #notEmpty(Object[])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notEmpty#383",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notEmpty(T)",
    "snippet": "public static \u003cT extends Map\u003c?, ?\u003e\u003e T notEmpty(final T map) {\n        return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE);\n    }",
    "begin_line": 383,
    "end_line": 385,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument map is neither  {@code null}nor a size of zero (no elements); otherwise throwing an exception. \u003cpre\u003eValidate.notEmpty(myMap);\u003c/pre\u003e \u003cp\u003eThe message in the exception is \u0026quot;The validated map is empty\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e the map type\n * @param map  the map to check, validated not null by this method\n * @return the validated map (never {@code null} method for chaining)\n * @throws NullPointerException if the map is {@code null}\n * @throws IllegalArgumentException if the map is empty\n * @see #notEmpty(Map,String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notEmpty#406",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notEmpty(T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT extends CharSequence\u003e T notEmpty(final T chars, final String message, final Object... values) {\n        if (chars \u003d\u003d null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (chars.length() \u003d\u003d 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return chars;\n    }",
    "begin_line": 406,
    "end_line": 414,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument character sequence is neither  {@code null} nor a length of zero (no characters);otherwise throwing an exception with the specified message. \u003cpre\u003eValidate.notEmpty(myString, \"The string must not be empty\");\u003c/pre\u003e\n * @param \u003c T \u003e the character sequence type\n * @param chars  the character sequence to check, validated not null by this method\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated character sequence (never {@code null} method for chaining)\n * @throws NullPointerException if the character sequence is {@code null}\n * @throws IllegalArgumentException if the character sequence is empty\n * @see #notEmpty(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notEmpty#433",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notEmpty(T)",
    "snippet": "public static \u003cT extends CharSequence\u003e T notEmpty(final T chars) {\n        return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);\n    }",
    "begin_line": 433,
    "end_line": 435,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument character sequence is neither  {@code null} nor a length of zero (no characters);otherwise throwing an exception with the specified message. \u003cpre\u003eValidate.notEmpty(myString);\u003c/pre\u003e \u003cp\u003eThe message in the exception is \u0026quot;The validated character sequence is empty\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e the character sequence type\n * @param chars  the character sequence to check, validated not null by this method\n * @return the validated character sequence (never {@code null} method for chaining)\n * @throws NullPointerException if the character sequence is {@code null}\n * @throws IllegalArgumentException if the character sequence is empty\n * @see #notEmpty(CharSequence,String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notBlank#459",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notBlank(T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT extends CharSequence\u003e T notBlank(final T chars, final String message, final Object... values) {\n        if (chars \u003d\u003d null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (StringUtils.isBlank(chars)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return chars;\n    }",
    "begin_line": 459,
    "end_line": 467,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument character sequence is neither  {@code null}, a length of zero (no characters), empty nor whitespace; otherwise throwing an exception with the specified message. \u003cpre\u003eValidate.notBlank(myString, \"The string must not be blank\");\u003c/pre\u003e\n * @param \u003c T \u003e the character sequence type\n * @param chars  the character sequence to check, validated not null by this method\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated character sequence (never {@code null} method for chaining)\n * @throws NullPointerException if the character sequence is {@code null}\n * @throws IllegalArgumentException if the character sequence is blank\n * @see #notBlank(CharSequence)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notBlank#488",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notBlank(T)",
    "snippet": "public static \u003cT extends CharSequence\u003e T notBlank(final T chars) {\n        return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);\n    }",
    "begin_line": 488,
    "end_line": 490,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument character sequence is neither  {@code null}, a length of zero (no characters), empty nor whitespace; otherwise throwing an exception. \u003cpre\u003eValidate.notBlank(myString);\u003c/pre\u003e \u003cp\u003eThe message in the exception is \u0026quot;The validated character sequence is blank\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e the character sequence type\n * @param chars  the character sequence to check, validated not null by this method\n * @return the validated character sequence (never {@code null} method for chaining)\n * @throws NullPointerException if the character sequence is {@code null}\n * @throws IllegalArgumentException if the character sequence is blank\n * @see #notBlank(CharSequence,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.noNullElements#518",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.noNullElements(T[], java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e T[] noNullElements(final T[] array, final String message, final Object... values) {\n        Validate.notNull(array);\n        for (int i \u003d 0; i \u003c array.length; i++) {\n            if (array[i] \u003d\u003d null) {\n                final Object[] values2 \u003d ArrayUtils.add(values, Integer.valueOf(i));\n                throw new IllegalArgumentException(String.format(message, values2));\n            }\n        }\n        return array;\n    }",
    "begin_line": 518,
    "end_line": 527,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument array is neither {@code null} nor contains any elements that are {@code null}; otherwise throwing an exception with the specified message. \u003cpre\u003eValidate.noNullElements(myArray, \"The array contain null at position %d\");\u003c/pre\u003e \u003cp\u003eIf the array is  {@code null}, then the message in the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e \u003cp\u003eIf the array has a  {@code null} element, then the iterationindex of the invalid element is appended to the  {@code values}argument.\u003c/p\u003e\n * @param \u003c T \u003e the array type\n * @param array  the array to check, validated not null by this method\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated array (never {@code null} method for chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IllegalArgumentException if an element is {@code null}\n * @see #noNullElements(Object[])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.noNullElements#550",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.noNullElements(T[])",
    "snippet": "public static \u003cT\u003e T[] noNullElements(final T[] array) {\n        return noNullElements(array, DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE);\n    }",
    "begin_line": 550,
    "end_line": 552,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument array is neither {@code null} nor contains any elements that are {@code null}; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.noNullElements(myArray);\u003c/pre\u003e \u003cp\u003eIf the array is  {@code null}, then the message in the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e \u003cp\u003eIf the array has a  {@code null} element, then the message in theexception is \u0026quot;The validated array contains null element at index: \u0026quot; followed by the index.\u003c/p\u003e\n * @param \u003c T \u003e the array type\n * @param array  the array to check, validated not null by this method\n * @return the validated array (never {@code null} method for chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IllegalArgumentException if an element is {@code null}\n * @see #noNullElements(Object[],String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.noNullElements#580",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.noNullElements(T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT extends Iterable\u003c?\u003e\u003e T noNullElements(final T iterable, final String message, final Object... values) {\n        Validate.notNull(iterable);\n        int i \u003d 0;\n        for (final Iterator\u003c?\u003e it \u003d iterable.iterator(); it.hasNext(); i++) {\n            if (it.next() \u003d\u003d null) {\n                final Object[] values2 \u003d ArrayUtils.addAll(values, Integer.valueOf(i));\n                throw new IllegalArgumentException(String.format(message, values2));\n            }\n        }\n        return iterable;\n    }",
    "begin_line": 580,
    "end_line": 590,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument iterable is neither {@code null} nor contains any elements that are {@code null}; otherwise throwing an exception with the specified message. \u003cpre\u003eValidate.noNullElements(myCollection, \"The collection contains null at position %d\");\u003c/pre\u003e \u003cp\u003eIf the iterable is  {@code null}, then the message in the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e \u003cp\u003eIf the iterable has a  {@code null} element, then the iterationindex of the invalid element is appended to the  {@code values}argument.\u003c/p\u003e\n * @param \u003c T \u003e the iterable type\n * @param iterable  the iterable to check, validated not null by this method\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated iterable (never {@code null} method for chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IllegalArgumentException if an element is {@code null}\n * @see #noNullElements(Iterable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.noNullElements#613",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.noNullElements(T)",
    "snippet": "public static \u003cT extends Iterable\u003c?\u003e\u003e T noNullElements(final T iterable) {\n        return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);\n    }",
    "begin_line": 613,
    "end_line": 615,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument iterable is neither {@code null} nor contains any elements that are {@code null}; otherwise throwing an exception. \u003cpre\u003eValidate.noNullElements(myCollection);\u003c/pre\u003e \u003cp\u003eIf the iterable is  {@code null}, then the message in the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e \u003cp\u003eIf the array has a  {@code null} element, then the message in theexception is \u0026quot;The validated iterable contains null element at index: \u0026quot; followed by the index.\u003c/p\u003e\n * @param \u003c T \u003e the iterable type\n * @param iterable  the iterable to check, validated not null by this method\n * @return the validated iterable (never {@code null} method for chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IllegalArgumentException if an element is {@code null}\n * @see #noNullElements(Iterable,String,Object...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.validIndex#641",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.validIndex(T[], int, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e T[] validIndex(final T[] array, final int index, final String message, final Object... values) {\n        Validate.notNull(array);\n        if (index \u003c 0 || index \u003e\u003d array.length) {\n            throw new IndexOutOfBoundsException(String.format(message, values));\n        }\n        return array;\n    }",
    "begin_line": 641,
    "end_line": 647,
    "comment": "/** \n * \u003cp\u003eValidates that the index is within the bounds of the argument array; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.validIndex(myArray, 2, \"The array index is invalid: \");\u003c/pre\u003e \u003cp\u003eIf the array is  {@code null}, then the message of the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e the array type\n * @param array  the array to check, validated not null by this method\n * @param index  the index to check\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated array (never {@code null} for method chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IndexOutOfBoundsException if the index is invalid\n * @see #validIndex(Object[],int)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.validIndex#672",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.validIndex(T[], int)",
    "snippet": "public static \u003cT\u003e T[] validIndex(final T[] array, final int index) {\n        return validIndex(array, index, DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE, Integer.valueOf(index));\n    }",
    "begin_line": 672,
    "end_line": 674,
    "comment": "/** \n * \u003cp\u003eValidates that the index is within the bounds of the argument array; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.validIndex(myArray, 2);\u003c/pre\u003e \u003cp\u003eIf the array is  {@code null}, then the message of the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e \u003cp\u003eIf the index is invalid, then the message of the exception is \u0026quot;The validated array index is invalid: \u0026quot; followed by the index.\u003c/p\u003e\n * @param \u003c T \u003e the array type\n * @param array  the array to check, validated not null by this method\n * @param index  the index to check\n * @return the validated array (never {@code null} for method chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IndexOutOfBoundsException if the index is invalid\n * @see #validIndex(Object[],int,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.validIndex#700",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.validIndex(T, int, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT extends Collection\u003c?\u003e\u003e T validIndex(final T collection, final int index, final String message, final Object... values) {\n        Validate.notNull(collection);\n        if (index \u003c 0 || index \u003e\u003d collection.size()) {\n            throw new IndexOutOfBoundsException(String.format(message, values));\n        }\n        return collection;\n    }",
    "begin_line": 700,
    "end_line": 706,
    "comment": "/** \n * \u003cp\u003eValidates that the index is within the bounds of the argument collection; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.validIndex(myCollection, 2, \"The collection index is invalid: \");\u003c/pre\u003e \u003cp\u003eIf the collection is  {@code null}, then the message of the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e the collection type\n * @param collection  the collection to check, validated not null by this method\n * @param index  the index to check\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated collection (never {@code null} for chaining)\n * @throws NullPointerException if the collection is {@code null}\n * @throws IndexOutOfBoundsException if the index is invalid\n * @see #validIndex(Collection,int)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.validIndex#728",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.validIndex(T, int)",
    "snippet": "public static \u003cT extends Collection\u003c?\u003e\u003e T validIndex(final T collection, final int index) {\n        return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index));\n    }",
    "begin_line": 728,
    "end_line": 730,
    "comment": "/** \n * \u003cp\u003eValidates that the index is within the bounds of the argument collection; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.validIndex(myCollection, 2);\u003c/pre\u003e \u003cp\u003eIf the index is invalid, then the message of the exception is \u0026quot;The validated collection index is invalid: \u0026quot; followed by the index.\u003c/p\u003e\n * @param \u003c T \u003e the collection type\n * @param collection  the collection to check, validated not null by this method\n * @param index  the index to check\n * @return the validated collection (never {@code null} for method chaining)\n * @throws NullPointerException if the collection is {@code null}\n * @throws IndexOutOfBoundsException if the index is invalid\n * @see #validIndex(Collection,int,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.validIndex#757",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.validIndex(T, int, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT extends CharSequence\u003e T validIndex(final T chars, final int index, final String message, final Object... values) {\n        Validate.notNull(chars);\n        if (index \u003c 0 || index \u003e\u003d chars.length()) {\n            throw new IndexOutOfBoundsException(String.format(message, values));\n        }\n        return chars;\n    }",
    "begin_line": 757,
    "end_line": 763,
    "comment": "/** \n * \u003cp\u003eValidates that the index is within the bounds of the argument character sequence; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.validIndex(myStr, 2, \"The string index is invalid: \");\u003c/pre\u003e \u003cp\u003eIf the character sequence is  {@code null}, then the message of the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e the character sequence type\n * @param chars  the character sequence to check, validated not null by this method\n * @param index  the index to check\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated character sequence (never {@code null} for method chaining)\n * @throws NullPointerException if the character sequence is {@code null}\n * @throws IndexOutOfBoundsException if the index is invalid\n * @see #validIndex(CharSequence,int)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.validIndex#789",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.validIndex(T, int)",
    "snippet": "public static \u003cT extends CharSequence\u003e T validIndex(final T chars, final int index) {\n        return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));\n    }",
    "begin_line": 789,
    "end_line": 791,
    "comment": "/** \n * \u003cp\u003eValidates that the index is within the bounds of the argument character sequence; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.validIndex(myStr, 2);\u003c/pre\u003e \u003cp\u003eIf the character sequence is  {@code null}, then the message of the exception is \u0026quot;The validated object is null\u0026quot;.\u003c/p\u003e \u003cp\u003eIf the index is invalid, then the message of the exception is \u0026quot;The validated character sequence index is invalid: \u0026quot; followed by the index.\u003c/p\u003e\n * @param \u003c T \u003e the character sequence type\n * @param chars  the character sequence to check, validated not null by this method\n * @param index  the index to check\n * @return the validated character sequence (never {@code null} for method chaining)\n * @throws NullPointerException if the character sequence is {@code null}\n * @throws IndexOutOfBoundsException if the index is invalid\n * @see #validIndex(CharSequence,int,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.validState#815",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.validState(boolean)",
    "snippet": "public static void validState(final boolean expression) {\n        if (expression \u003d\u003d false) {\n            throw new IllegalStateException(DEFAULT_VALID_STATE_EX_MESSAGE);\n        }\n    }",
    "begin_line": 815,
    "end_line": 819,
    "comment": "/** \n * \u003cp\u003eValidate that the stateful condition is  {@code true}; otherwise throwing an exception. This method is useful when validating according to an arbitrary boolean expression, such as validating a primitive number or using your own custom validation expression.\u003c/p\u003e \u003cpre\u003e Validate.validState(field \u0026gt; 0); Validate.validState(this.isOk());\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The validated state is false\u0026quot;.\u003c/p\u003e\n * @param expression  the boolean expression to check\n * @throws IllegalStateException if expression is {@code false}\n * @see #validState(boolean,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.validState#837",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.validState(boolean, java.lang.String, java.lang.Object)",
    "snippet": "public static void validState(final boolean expression, final String message, final Object... values) {\n        if (expression \u003d\u003d false) {\n            throw new IllegalStateException(String.format(message, values));\n        }\n    }",
    "begin_line": 837,
    "end_line": 841,
    "comment": "/** \n * \u003cp\u003eValidate that the stateful condition is  {@code true}; otherwise throwing an exception with the specified message. This method is useful when validating according to an arbitrary boolean expression, such as validating a primitive number or using your own custom validation expression.\u003c/p\u003e \u003cpre\u003eValidate.validState(this.isOk(), \"The state is not OK: %s\", myObject);\u003c/pre\u003e\n * @param expression  the boolean expression to check\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalStateException if expression is {@code false}\n * @see #validState(boolean)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.matchesPattern#861",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.matchesPattern(java.lang.CharSequence, java.lang.String)",
    "snippet": "public static void matchesPattern(final CharSequence input, final String pattern) {\n        // TODO when breaking BC, consider returning input\n        if (Pattern.matches(pattern, input) \u003d\u003d false) {\n            throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern));\n        }\n    }",
    "begin_line": 861,
    "end_line": 866,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument character sequence matches the specified regular expression pattern; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.matchesPattern(\"hi\", \"[a-z]*\");\u003c/pre\u003e \u003cp\u003eThe syntax of the pattern is the one used in the  {@link Pattern} class.\u003c/p\u003e\n * @param input  the character sequence to validate, not null\n * @param pattern  the regular expression pattern, not null\n * @throws IllegalArgumentException if the character sequence does not match the pattern\n * @see #matchesPattern(CharSequence,String,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.matchesPattern#885",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.matchesPattern(java.lang.CharSequence, java.lang.String, java.lang.String, java.lang.Object)",
    "snippet": "public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {\n        // TODO when breaking BC, consider returning input\n        if (Pattern.matches(pattern, input) \u003d\u003d false) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 885,
    "end_line": 890,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument character sequence matches the specified regular expression pattern; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.matchesPattern(\"hi\", \"[a-z]*\", \"%s does not match %s\", \"hi\" \"[a-z]*\");\u003c/pre\u003e \u003cp\u003eThe syntax of the pattern is the one used in the  {@link Pattern} class.\u003c/p\u003e\n * @param input  the character sequence to validate, not null\n * @param pattern  the regular expression pattern, not null\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if the character sequence does not match the pattern\n * @see #matchesPattern(CharSequence,String)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notNaN#910",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notNaN(double)",
    "snippet": "public static void notNaN(final double value) {\n        notNaN(value, DEFAULT_NOT_NAN_EX_MESSAGE);\n    }",
    "begin_line": 910,
    "end_line": 912,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is not  {@code NaN}; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.notNaN(myDouble);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The validated value is not a number\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @throws IllegalArgumentException if the value is not a number\n * @see #notNaN(double,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.notNaN#928",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.notNaN(double, java.lang.String, java.lang.Object)",
    "snippet": "public static void notNaN(final double value, final String message, final Object... values) {\n        if (Double.isNaN(value)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 928,
    "end_line": 932,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is not  {@code NaN}; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.notNaN(myDouble, \"The value must be a number\");\u003c/pre\u003e\n * @param value  the value to validate\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if the value is not a number\n * @see #notNaN(double)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.finite#951",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.finite(double)",
    "snippet": "public static void finite(final double value) {\n        finite(value, DEFAULT_FINITE_EX_MESSAGE, value);\n    }",
    "begin_line": 951,
    "end_line": 953,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is not infinite or  {@code NaN}; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.finite(myDouble);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value is invalid: %f\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @throws IllegalArgumentException if the value is infinite or {@code NaN}\n * @see #finite(double,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.finite#969",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.finite(double, java.lang.String, java.lang.Object)",
    "snippet": "public static void finite(final double value, final String message, final Object... values) {\n        if (Double.isNaN(value) || Double.isInfinite(value)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 969,
    "end_line": 973,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is not infinite or  {@code NaN}; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.finite(myDouble, \"The argument must contain a numeric value\");\u003c/pre\u003e\n * @param value the value to validate\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if the value is infinite or {@code NaN}\n * @see #finite(double)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greaterObj#995",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greaterObj(java.lang.Comparable\u003cT\u003e, T)",
    "snippet": "public static \u003cT\u003e void greaterObj(final Comparable\u003cT\u003e value, final T min) {\n        greaterObj(value, min, DEFAULT_GREATER_EX_MESSAGE, value, min);\n    }",
    "begin_line": 995,
    "end_line": 997,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly greater than a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.greaterObj(myObject, refObject);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notgreater than  {@code min}\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param min  the reference value\n * @throws IllegalArgumentException if {@code value} is smaller than or equal to {@code min}\n * @see #greaterObj(java.lang.Comparable,java.lang.Object,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greaterObj#1015",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greaterObj(java.lang.Comparable\u003cT\u003e, T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e void greaterObj(final Comparable\u003cT\u003e value, final T min, final String message, final Object... values) {\n        if (value.compareTo(min) \u003c\u003d 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1015,
    "end_line": 1019,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly greater than a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.greaterObj(myObject, refObject, \"The value must be greater than the reference\");\u003c/pre\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param min  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is smaller than or equal to {@code min}\n * @see #greaterObj(java.lang.Comparable,java.lang.Object)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greater#1037",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greater(long, long)",
    "snippet": "public static void greater(final long value, final long min) {\n        greater(value, min, DEFAULT_GREATER_EX_MESSAGE, value, min);\n    }",
    "begin_line": 1037,
    "end_line": 1039,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly greater than a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.greater(myLong, 0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notgreater than  {@code min}\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param min  the reference value\n * @throws IllegalArgumentException if {@code value} is smaller than or equal to {@code min}\n * @see #greater(long,long,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greater#1056",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greater(long, long, java.lang.String, java.lang.Object)",
    "snippet": "public static void greater(final long value, final long min, final String message, final Object... values) {\n        if (value \u003c\u003d min) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1056,
    "end_line": 1060,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly greater than a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.greater(myLong, 0);\u003c/pre\u003e\n * @param value  the value to validate\n * @param min  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is smaller than or equal to {@code min}\n * @see #greater(long,long)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greater#1081",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greater(double, double)",
    "snippet": "public static void greater(final double value, final double min) {\n        greater(value, min, DEFAULT_GREATER_EX_MESSAGE, value, min);\n    }",
    "begin_line": 1081,
    "end_line": 1083,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly greater than a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cp\u003eIf  {@code min} or {@code value} is {@code NaN}, the test will fail and the exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.greater(myDouble, 0.0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notgreater than  {@code min}\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param min  the reference value\n * @throws IllegalArgumentException if {@code value} is smaller than or equal to {@code min}\n * @see #greater(double,double,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greater#1103",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greater(double, double, java.lang.String, java.lang.Object)",
    "snippet": "public static void greater(final double value, final double min, final String message, final Object... values) {\n        if (!(value \u003e min)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1103,
    "end_line": 1107,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly greater than a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cp\u003eIf  {@code min} or {@code value} is {@code NaN}, the test will fail and the exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.greater(myDouble, 0.0);\u003c/pre\u003e\n * @param value  the value to validate\n * @param min  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is smaller than or equal to {@code min}\n * @see #greater(double,double)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greaterOrEqualObj#1129",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greaterOrEqualObj(java.lang.Comparable\u003cT\u003e, T)",
    "snippet": "public static \u003cT\u003e void greaterOrEqualObj(final Comparable\u003cT\u003e value, final T min) {\n        greaterOrEqualObj(value, min, DEFAULT_GREATER_OR_EQUAL_EX_MESSAGE, value, min);\n    }",
    "begin_line": 1129,
    "end_line": 1131,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is greater than, or equal to, a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.greaterOrEqualObj(myObject, refObject);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notgreater than or equal to  {@code min}\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param min  the reference value\n * @throws IllegalArgumentException if {@code value} is smaller than {@code min}\n * @see #greaterOrEqualObj(java.lang.Comparable,java.lang.Object,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greaterOrEqualObj#1149",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greaterOrEqualObj(java.lang.Comparable\u003cT\u003e, T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e void greaterOrEqualObj(final Comparable\u003cT\u003e value, final T min, final String message, final Object... values) {\n        if (value.compareTo(min) \u003c 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1149,
    "end_line": 1153,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is greater than, or equal to, a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.greaterOrEqualObj(myObject, refObject, \"The value must be greater than the reference\");\u003c/pre\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param min  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is smaller than {@code min}\n * @see #greaterOrEqualObj(java.lang.Comparable,java.lang.Object)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greaterOrEqual#1171",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greaterOrEqual(long, long)",
    "snippet": "public static void greaterOrEqual(final long value, final long min) {\n        greaterOrEqual(value, min, DEFAULT_GREATER_OR_EQUAL_EX_MESSAGE, value, min);\n    }",
    "begin_line": 1171,
    "end_line": 1173,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is greater than, or equal to, a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.greaterOrEqual(myLong, 0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notgreater than or equal to  {@code min}\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param min  the reference value\n * @throws IllegalArgumentException if {@code value} is smaller than {@code min}\n * @see #greaterOrEqual(long,long,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greaterOrEqual#1190",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greaterOrEqual(long, long, java.lang.String, java.lang.Object)",
    "snippet": "public static void greaterOrEqual(final long value, final long min, final String message, final Object... values) {\n        if (value \u003c min) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1190,
    "end_line": 1194,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is greater than, or equal to, a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.greaterOrEqual(myLong, 0);\u003c/pre\u003e\n * @param value  the value to validate\n * @param min  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is smaller than {@code min}\n * @see #greaterOrEqual(long,long)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greaterOrEqual#1215",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greaterOrEqual(double, double)",
    "snippet": "public static void greaterOrEqual(final double value, final double min) {\n        greaterOrEqual(value, min, DEFAULT_GREATER_OR_EQUAL_EX_MESSAGE, value, min);\n    }",
    "begin_line": 1215,
    "end_line": 1217,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is greater than, or equal to, a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cp\u003eIf  {@code min} or {@code value} is {@code NaN}, the test will fail and the exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.greaterOrEqual(myDouble, 0.0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notgreater than or equal to  {@code min}\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param min  the reference value\n * @throws IllegalArgumentException if {@code value} is smaller than {@code min}\n * @see #greaterOrEqual(double,double,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.greaterOrEqual#1237",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.greaterOrEqual(double, double, java.lang.String, java.lang.Object)",
    "snippet": "public static void greaterOrEqual(final double value, final double min, final String message, final Object... values) {\n        if (!(value \u003e\u003d min)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1237,
    "end_line": 1241,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is greater than, or equal to, a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cp\u003eIf  {@code min} or {@code value} is {@code NaN}, the test will fail and the exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.greaterOrEqual(myDouble, 0.0);\u003c/pre\u003e\n * @param value  the value to validate\n * @param min  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is smaller than {@code min}\n * @see #greaterOrEqual(double,double)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smallerObj#1263",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smallerObj(java.lang.Comparable\u003cT\u003e, T)",
    "snippet": "public static \u003cT\u003e void smallerObj(final Comparable\u003cT\u003e value, final T max) {\n        smallerObj(value, max, DEFAULT_SMALLER_EX_MESSAGE, value, max);\n    }",
    "begin_line": 1263,
    "end_line": 1265,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly smaller than a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.smallerObj(myObject, refObject);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notsmaller than  {@code max}\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param max  the reference value\n * @throws IllegalArgumentException if {@code value} is greater than or equal to {@code max}\n * @see #smallerObj(java.lang.Comparable,java.lang.Object,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smallerObj#1283",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smallerObj(java.lang.Comparable\u003cT\u003e, T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e void smallerObj(final Comparable\u003cT\u003e value, final T max, final String message, final Object... values) {\n        if (value.compareTo(max) \u003e\u003d 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1283,
    "end_line": 1287,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly smaller than a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.smallerObj(myObject, refObject, \"The value must be greater than the reference\");\u003c/pre\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param max  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is greater than or equal to {@code max}\n * @see #smallerObj(java.lang.Comparable,java.lang.Object)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smaller#1305",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smaller(long, long)",
    "snippet": "public static void smaller(final long value, final long max) {\n        smaller(value, max, DEFAULT_SMALLER_EX_MESSAGE, value, max);\n    }",
    "begin_line": 1305,
    "end_line": 1307,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly smaller than a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.smaller(myLong, 0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notsmaller than  {@code max}\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param max  the reference value\n * @throws IllegalArgumentException if {@code value} is greater than or equal to {@code max}\n * @see #smaller(long,long,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smaller#1324",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smaller(long, long, java.lang.String, java.lang.Object)",
    "snippet": "public static void smaller(final long value, final long max, final String message, final Object... values) {\n        if (value \u003e\u003d max) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1324,
    "end_line": 1328,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly smaller than a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.smaller(myLong, 0);\u003c/pre\u003e\n * @param value  the value to validate\n * @param max  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is greater than or equal to {@code max}\n * @see #smaller(long,long)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smaller#1349",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smaller(double, double)",
    "snippet": "public static void smaller(final double value, final double max) {\n        smaller(value, max, DEFAULT_SMALLER_EX_MESSAGE, value, max);\n    }",
    "begin_line": 1349,
    "end_line": 1351,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly smaller than a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cp\u003eIf  {@code min} or {@code value} is {@code NaN}, the test will fail and the exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.smaller(myDouble, 0.0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notsmaller than  {@code max}\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param max  the reference value\n * @throws IllegalArgumentException if {@code value} is greater than or equal to {@code max}\n * @see #smaller(double,double,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smaller#1371",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smaller(double, double, java.lang.String, java.lang.Object)",
    "snippet": "public static void smaller(final double value, final double max, final String message, final Object... values) {\n        if (!(value \u003c max)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1371,
    "end_line": 1375,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is strictly smaller than a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cp\u003eIf  {@code min} or {@code value} is {@code NaN}, the test will fail and the exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.smaller(myDouble, 0.0);\u003c/pre\u003e\n * @param value  the value to validate\n * @param max  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is greater than or equal to {@code max}\n * @see #smaller(double,double)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smallerOrEqualObj#1397",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smallerOrEqualObj(java.lang.Comparable\u003cT\u003e, T)",
    "snippet": "public static \u003cT\u003e void smallerOrEqualObj(final Comparable\u003cT\u003e value, final T max) {\n        smallerOrEqualObj(value, max, DEFAULT_SMALLER_OR_EQUAL_EX_MESSAGE, value, max);\n    }",
    "begin_line": 1397,
    "end_line": 1399,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is smaller than, or equal to, a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.smallerOrEqualObj(myObject, refObject);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notsmaller than or equal to  {@code max}\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param max  the reference value\n * @throws IllegalArgumentException if {@code value} is greater than {@code max}\n * @see #smallerOrEqualObj(java.lang.Comparable,java.lang.Object,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smallerOrEqualObj#1417",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smallerOrEqualObj(java.lang.Comparable\u003cT\u003e, T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e void smallerOrEqualObj(final Comparable\u003cT\u003e value, final T max, final String message, final Object... values) {\n        if (value.compareTo(max) \u003e 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1417,
    "end_line": 1421,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is smaller than, or equal to, a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.smallerOrEqualObj(myObject, refObject, \"The value must be greater than the reference\");\u003c/pre\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param max  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is greater than {@code max}\n * @see #smallerOrEqualObj(java.lang.Comparable,java.lang.Object)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smallerOrEqual#1439",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smallerOrEqual(long, long)",
    "snippet": "public static void smallerOrEqual(final long value, final long max) {\n        smallerOrEqual(value, max, DEFAULT_SMALLER_OR_EQUAL_EX_MESSAGE, value, max);\n    }",
    "begin_line": 1439,
    "end_line": 1441,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is smaller than, or equal to, a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.smallerOrEqual(myLong, 0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notsmaller than or equal to  {@code max}\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param max  the reference value\n * @throws IllegalArgumentException if {@code value} is greater than {@code max}\n * @see #smallerOrEqual(long,long,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smallerOrEqual#1458",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smallerOrEqual(long, long, java.lang.String, java.lang.Object)",
    "snippet": "public static void smallerOrEqual(final long value, final long max, final String message, final Object... values) {\n        if (value \u003e max) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1458,
    "end_line": 1462,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is smaller than, or equal to, a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.smallerOrEqual(myLong, 0);\u003c/pre\u003e\n * @param value  the value to validate\n * @param max  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is greater than {@code max}\n * @see #smallerOrEqual(long,long)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smallerOrEqual#1483",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smallerOrEqual(double, double)",
    "snippet": "public static void smallerOrEqual(final double value, final double max) {\n        smallerOrEqual(value, max, DEFAULT_SMALLER_OR_EQUAL_EX_MESSAGE, value, max);\n    }",
    "begin_line": 1483,
    "end_line": 1485,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is smaller than, or equal to, a given reference; otherwise throwing an exception.\u003c/p\u003e \u003cp\u003eIf  {@code min} or {@code value} is {@code NaN}, the test will fail and the exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.smallerOrEqual(myDouble, 0.0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} is notsmaller than or equal to  {@code max}\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param max  the reference value\n * @throws IllegalArgumentException if {@code value} is greater than {@code max}\n * @see #smallerOrEqual(double,double,java.lang.String,java.lang.Object...)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.smallerOrEqual#1505",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.smallerOrEqual(double, double, java.lang.String, java.lang.Object)",
    "snippet": "public static void smallerOrEqual(final double value, final double max, final String message, final Object... values) {\n        if (!(value \u003c\u003d max)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1505,
    "end_line": 1509,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is smaller than, or equal to, a given reference; otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cp\u003eIf  {@code min} or {@code value} is {@code NaN}, the test will fail and the exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.smallerOrEqual(myDouble, 0.0);\u003c/pre\u003e\n * @param value  the value to validate\n * @param max  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is greater than {@code max}\n * @see #smallerOrEqual(double,double)\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.differentObj#1533",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.differentObj(java.lang.Comparable\u003cT\u003e, T)",
    "snippet": "public static \u003cT\u003e void differentObj(final Comparable\u003cT\u003e value, final T reference) {\n        differentObj(value, reference, DEFAULT_DIFFERENT_EX_MESSAGE, value);\n    }",
    "begin_line": 1533,
    "end_line": 1535,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is different from a given value (reference); otherwise throwing an exception.\u003c/p\u003e \u003cp\u003eTwo objects are considered different if {@code value.compareTo(reference) !\u003d 0}\u003c/p\u003e \u003cpre\u003eValidate.differentObj(myObject, refObject);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} isinvalid\u0026quot;.\u003c/p\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param reference  the reference value\n * @throws IllegalArgumentException if {@code value} is equal to {@code reference}\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.differentObj#1555",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.differentObj(java.lang.Comparable\u003cT\u003e, T, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e void differentObj(final Comparable\u003cT\u003e value, final T reference, final String message, final Object... values) {\n        if (value.compareTo(reference) \u003d\u003d 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1555,
    "end_line": 1559,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is different from a given value (reference); otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cp\u003eTwo objects are considered different if {@code value.compareTo(reference) !\u003d 0}\u003c/p\u003e \u003cpre\u003eValidate.differentObj(myObject, refObject, \"The value is invalid\");\u003c/pre\u003e\n * @param \u003c T \u003e  the type of the argument object\n * @param value  the object to validate\n * @param reference  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is equal to {@code reference}\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.different#1576",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.different(long, long)",
    "snippet": "public static void different(final long value, final long reference) {\n        different(value, reference, DEFAULT_DIFFERENT_EX_MESSAGE, value);\n    }",
    "begin_line": 1576,
    "end_line": 1578,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is not equal to a given value (reference); otherwise throwing an exception.\u003c/p\u003e \u003cpre\u003eValidate.different(myLong, 0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} isinvalid\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param reference  the reference value\n * @throws IllegalArgumentException if {@code value} is equal to {@code reference}\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.different#1594",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.different(long, long, java.lang.String, java.lang.Object)",
    "snippet": "public static void different(final long value, final long reference, final String message, final Object... values) {\n        if (value \u003d\u003d reference) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1594,
    "end_line": 1598,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is not equal to a given value (reference); otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.different(myLong, 0, \"The value is invalid\");\u003c/pre\u003e\n * @param value  the value to validate\n * @param reference  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is equal to {@code reference}\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.different#1617",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.different(double, double)",
    "snippet": "public static void different(final double value, final double reference) {\n        different(value, reference, DEFAULT_DIFFERENT_EX_MESSAGE, value);\n    }",
    "begin_line": 1617,
    "end_line": 1619,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is not equal to a given value (reference); otherwise throwing an exception.\u003c/p\u003e \u003cp\u003eIf  {@code value} or {@code reference} is {@code NaN}, no exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.different(myDouble, 0.0);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The value  {@code value} isinvalid\u0026quot;.\u003c/p\u003e\n * @param value  the value to validate\n * @param reference  the reference value\n * @throws IllegalArgumentException if {@code value} is equal to {@code reference}\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.different#1637",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.different(double, double, java.lang.String, java.lang.Object)",
    "snippet": "public static void different(final double value, final double reference, final String message, final Object... values) {\n        if (value \u003d\u003d reference) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1637,
    "end_line": 1641,
    "comment": "/** \n * \u003cp\u003eValidates that the specified argument is not equal to a given value (reference); otherwise throwing an exception with the specified message.\u003c/p\u003e \u003cp\u003eIf  {@code value} or {@code reference} is {@code NaN}, no exception will be thrown.\u003c/p\u003e \u003cpre\u003eValidate.different(myDouble, 0.0, \"The value is invalid\");\u003c/pre\u003e\n * @param value  the value to validate\n * @param reference  the reference value\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if {@code value} is equal to {@code reference}\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.inclusiveBetween#1661",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.inclusiveBetween(T, T, java.lang.Comparable\u003cT\u003e)",
    "snippet": "public static \u003cT\u003e void inclusiveBetween(final T start, final T end, final Comparable\u003cT\u003e value) {\n        // TODO when breaking BC, consider returning value\n        if (value.compareTo(start) \u003c 0 || value.compareTo(end) \u003e 0) {\n            throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n        }\n    }",
    "begin_line": 1661,
    "end_line": 1666,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument object fall between the two inclusive values specified; otherwise, throws an exception.\u003c/p\u003e \u003cpre\u003eValidate.inclusiveBetween(0, 2, 1);\u003c/pre\u003e\n * @param \u003c T \u003e the type of the argument object\n * @param start  the inclusive start value, not null\n * @param end  the inclusive end value, not null\n * @param value  the object to validate, not null\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @see #inclusiveBetween(Object,Object,Comparable,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.inclusiveBetween#1686",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.inclusiveBetween(T, T, java.lang.Comparable\u003cT\u003e, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e void inclusiveBetween(final T start, final T end, final Comparable\u003cT\u003e value, final String message, final Object... values) {\n        // TODO when breaking BC, consider returning value\n        if (value.compareTo(start) \u003c 0 || value.compareTo(end) \u003e 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1686,
    "end_line": 1691,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument object fall between the two inclusive values specified; otherwise, throws an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.inclusiveBetween(0, 2, 1, \"Not in boundaries\");\u003c/pre\u003e\n * @param \u003c T \u003e the type of the argument object\n * @param start  the inclusive start value, not null\n * @param end  the inclusive end value, not null\n * @param value  the object to validate, not null\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @see #inclusiveBetween(Object,Object,Comparable)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.inclusiveBetween#1707",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.inclusiveBetween(long, long, long)",
    "snippet": "@SuppressWarnings(\"boxing\")\n    public static void inclusiveBetween(final long start, final long end, final long value) {\n        // TODO when breaking BC, consider returning value\n        if (value \u003c start || value \u003e end) {\n            throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n        }\n    }",
    "begin_line": 1707,
    "end_line": 1712,
    "comment": "/** \n * Validate that the specified primitive value falls between the two inclusive values specified; otherwise, throws an exception. \u003cpre\u003eValidate.inclusiveBetween(0, 2, 1);\u003c/pre\u003e\n * @param start the inclusive start value\n * @param end   the inclusive end value\n * @param value the value to validate\n * @throws IllegalArgumentException if the value falls outside the boundaries (inclusive)\n * @since 3.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.inclusiveBetween#1730",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.inclusiveBetween(long, long, long, java.lang.String)",
    "snippet": "public static void inclusiveBetween(final long start, final long end, final long value, final String message) {\n        // TODO when breaking BC, consider returning value\n        if (value \u003c start || value \u003e end) {\n            throw new IllegalArgumentException(String.format(message));\n        }\n    }",
    "begin_line": 1730,
    "end_line": 1735,
    "comment": "/** \n * Validate that the specified primitive value falls between the two inclusive values specified; otherwise, throws an exception with the specified message. \u003cpre\u003eValidate.inclusiveBetween(0, 2, 1, \"Not in range\");\u003c/pre\u003e\n * @param start the inclusive start value\n * @param end   the inclusive end value\n * @param value the value to validate\n * @param message the exception message if invalid, not null\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @since 3.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.inclusiveBetween#1751",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.inclusiveBetween(double, double, double)",
    "snippet": "@SuppressWarnings(\"boxing\")\n    public static void inclusiveBetween(final double start, final double end, final double value) {\n        // TODO when breaking BC, consider returning value\n        if (value \u003c start || value \u003e end) {\n            throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n        }\n    }",
    "begin_line": 1751,
    "end_line": 1756,
    "comment": "/** \n * Validate that the specified primitive value falls between the two inclusive values specified; otherwise, throws an exception. \u003cpre\u003eValidate.inclusiveBetween(0.1, 2.1, 1.1);\u003c/pre\u003e\n * @param start the inclusive start value\n * @param end   the inclusive end value\n * @param value the value to validate\n * @throws IllegalArgumentException if the value falls outside the boundaries (inclusive)\n * @since 3.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.inclusiveBetween#1774",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.inclusiveBetween(double, double, double, java.lang.String)",
    "snippet": "public static void inclusiveBetween(final double start, final double end, final double value, final String message) {\n        // TODO when breaking BC, consider returning value\n        if (value \u003c start || value \u003e end) {\n            throw new IllegalArgumentException(String.format(message));\n        }\n    }",
    "begin_line": 1774,
    "end_line": 1779,
    "comment": "/** \n * Validate that the specified primitive value falls between the two inclusive values specified; otherwise, throws an exception with the specified message. \u003cpre\u003eValidate.inclusiveBetween(0.1, 2.1, 1.1, \"Not in range\");\u003c/pre\u003e\n * @param start the inclusive start value\n * @param end   the inclusive end value\n * @param value the value to validate\n * @param message the exception message if invalid, not null\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @since 3.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.exclusiveBetween#1799",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.exclusiveBetween(T, T, java.lang.Comparable\u003cT\u003e)",
    "snippet": "public static \u003cT\u003e void exclusiveBetween(final T start, final T end, final Comparable\u003cT\u003e value) {\n        // TODO when breaking BC, consider returning value\n        if (value.compareTo(start) \u003c\u003d 0 || value.compareTo(end) \u003e\u003d 0) {\n            throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n        }\n    }",
    "begin_line": 1799,
    "end_line": 1804,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument object fall between the two exclusive values specified; otherwise, throws an exception.\u003c/p\u003e \u003cpre\u003eValidate.exclusiveBetween(0, 2, 1);\u003c/pre\u003e\n * @param \u003c T \u003e the type of the argument object\n * @param start  the exclusive start value, not null\n * @param end  the exclusive end value, not null\n * @param value  the object to validate, not null\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @see #exclusiveBetween(Object,Object,Comparable,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.exclusiveBetween#1824",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.exclusiveBetween(T, T, java.lang.Comparable\u003cT\u003e, java.lang.String, java.lang.Object)",
    "snippet": "public static \u003cT\u003e void exclusiveBetween(final T start, final T end, final Comparable\u003cT\u003e value, final String message, final Object... values) {\n        // TODO when breaking BC, consider returning value\n        if (value.compareTo(start) \u003c\u003d 0 || value.compareTo(end) \u003e\u003d 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1824,
    "end_line": 1829,
    "comment": "/** \n * \u003cp\u003eValidate that the specified argument object fall between the two exclusive values specified; otherwise, throws an exception with the specified message.\u003c/p\u003e \u003cpre\u003eValidate.exclusiveBetween(0, 2, 1, \"Not in boundaries\");\u003c/pre\u003e\n * @param \u003c T \u003e the type of the argument object\n * @param start  the exclusive start value, not null\n * @param end  the exclusive end value, not null\n * @param value  the object to validate, not null\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @see #exclusiveBetween(Object,Object,Comparable)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.exclusiveBetween#1845",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.exclusiveBetween(long, long, long)",
    "snippet": "@SuppressWarnings(\"boxing\")\n    public static void exclusiveBetween(final long start, final long end, final long value) {\n        // TODO when breaking BC, consider returning value\n        if (value \u003c\u003d start || value \u003e\u003d end) {\n            throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n        }\n    }",
    "begin_line": 1845,
    "end_line": 1850,
    "comment": "/** \n * Validate that the specified primitive value falls between the two exclusive values specified; otherwise, throws an exception. \u003cpre\u003eValidate.exclusiveBetween(0, 2, 1);\u003c/pre\u003e\n * @param start the exclusive start value\n * @param end   the exclusive end value\n * @param value the value to validate\n * @throws IllegalArgumentException if the value falls out of the boundaries\n * @since 3.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.exclusiveBetween#1868",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.exclusiveBetween(long, long, long, java.lang.String)",
    "snippet": "public static void exclusiveBetween(final long start, final long end, final long value, final String message) {\n        // TODO when breaking BC, consider returning value\n        if (value \u003c\u003d start || value \u003e\u003d end) {\n            throw new IllegalArgumentException(String.format(message));\n        }\n    }",
    "begin_line": 1868,
    "end_line": 1873,
    "comment": "/** \n * Validate that the specified primitive value falls between the two exclusive values specified; otherwise, throws an exception with the specified message. \u003cpre\u003eValidate.exclusiveBetween(0, 2, 1, \"Not in range\");\u003c/pre\u003e\n * @param start the exclusive start value\n * @param end   the exclusive end value\n * @param value the value to validate\n * @param message the exception message if invalid, not null\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @since 3.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.exclusiveBetween#1889",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.exclusiveBetween(double, double, double)",
    "snippet": "@SuppressWarnings(\"boxing\")\n    public static void exclusiveBetween(final double start, final double end, final double value) {\n        // TODO when breaking BC, consider returning value\n        if (value \u003c\u003d start || value \u003e\u003d end) {\n            throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n        }\n    }",
    "begin_line": 1889,
    "end_line": 1894,
    "comment": "/** \n * Validate that the specified primitive value falls between the two exclusive values specified; otherwise, throws an exception. \u003cpre\u003eValidate.exclusiveBetween(0.1, 2.1, 1.1);\u003c/pre\u003e\n * @param start the exclusive start value\n * @param end   the exclusive end value\n * @param value the value to validate\n * @throws IllegalArgumentException if the value falls out of the boundaries\n * @since 3.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.exclusiveBetween#1912",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.exclusiveBetween(double, double, double, java.lang.String)",
    "snippet": "public static void exclusiveBetween(final double start, final double end, final double value, final String message) {\n        // TODO when breaking BC, consider returning value\n        if (value \u003c\u003d start || value \u003e\u003d end) {\n            throw new IllegalArgumentException(String.format(message));\n        }\n    }",
    "begin_line": 1912,
    "end_line": 1917,
    "comment": "/** \n * Validate that the specified primitive value falls between the two exclusive values specified; otherwise, throws an exception with the specified message. \u003cpre\u003eValidate.exclusiveBetween(0.1, 2.1, 1.1, \"Not in range\");\u003c/pre\u003e\n * @param start the exclusive start value\n * @param end   the exclusive end value\n * @param value the value to validate\n * @param message the exception message if invalid, not null\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @since 3.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.isInstanceOf#1938",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.isInstanceOf(java.lang.Class\u003c?\u003e, java.lang.Object)",
    "snippet": "public static void isInstanceOf(final Class\u003c?\u003e type, final Object obj) {\n        // TODO when breaking BC, consider returning obj\n        if (type.isInstance(obj) \u003d\u003d false) {\n            throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(),\n                    obj \u003d\u003d null ? \"null\" : obj.getClass().getName()));\n        }\n    }",
    "begin_line": 1938,
    "end_line": 1944,
    "comment": "/** \n * Validates that the argument is an instance of the specified class, if not throws an exception. \u003cp\u003eThis method is useful when validating according to an arbitrary class\u003c/p\u003e \u003cpre\u003eValidate.isInstanceOf(OkClass.class, object);\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;Expected type: {type}, actual: {obj_type}\u0026quot;\u003c/p\u003e\n * @param type  the class the object must be validated against, not null\n * @param obj  the object to check, null throws an exception\n * @throws IllegalArgumentException if argument is not of specified class\n * @see #isInstanceOf(Class,Object,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.isInstanceOf#1963",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.isInstanceOf(java.lang.Class\u003c?\u003e, java.lang.Object, java.lang.String, java.lang.Object)",
    "snippet": "public static void isInstanceOf(final Class\u003c?\u003e type, final Object obj, final String message, final Object... values) {\n        // TODO when breaking BC, consider returning obj\n        if (type.isInstance(obj) \u003d\u003d false) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 1963,
    "end_line": 1968,
    "comment": "/** \n * \u003cp\u003eValidate that the argument is an instance of the specified class; otherwise throwing an exception with the specified message. This method is useful when validating according to an arbitrary class\u003c/p\u003e \u003cpre\u003eValidate.isInstanceOf(OkClass.class, object, \"Wrong class, object is of class %s\", object.getClass().getName());\u003c/pre\u003e\n * @param type  the class the object must be validated against, not null\n * @param obj  the object to check, null throws an exception\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if argument is not of specified class\n * @see #isInstanceOf(Class,Object)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.isAssignableFrom#1989",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.isAssignableFrom(java.lang.Class\u003c?\u003e, java.lang.Class\u003c?\u003e)",
    "snippet": "public static void isAssignableFrom(final Class\u003c?\u003e superType, final Class\u003c?\u003e type) {\n        // TODO when breaking BC, consider returning type\n        if (superType.isAssignableFrom(type) \u003d\u003d false) {\n            throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, type \u003d\u003d null ? \"null\" : type.getName(),\n                    superType.getName()));\n        }\n    }",
    "begin_line": 1989,
    "end_line": 1995,
    "comment": "/** \n * Validates that the argument can be converted to the specified class, if not, throws an exception. \u003cp\u003eThis method is useful when validating that there will be no casting errors.\u003c/p\u003e \u003cpre\u003eValidate.isAssignableFrom(SuperClass.class, object.getClass());\u003c/pre\u003e \u003cp\u003eThe message format of the exception is \u0026quot;Cannot assign {type} to {superType}\u0026quot;\u003c/p\u003e\n * @param superType  the class the class must be validated against, not null\n * @param type  the class to check, not null\n * @throws IllegalArgumentException if type argument is not assignable to the specified superType\n * @see #isAssignableFrom(Class,Class,String,Object...)\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Validate.isAssignableFrom#2014",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/Validate.java",
    "class_name": "org.apache.commons.lang3.Validate",
    "signature": "org.apache.commons.lang3.Validate.isAssignableFrom(java.lang.Class\u003c?\u003e, java.lang.Class\u003c?\u003e, java.lang.String, java.lang.Object)",
    "snippet": "public static void isAssignableFrom(final Class\u003c?\u003e superType, final Class\u003c?\u003e type, final String message, final Object... values) {\n        // TODO when breaking BC, consider returning type\n        if (superType.isAssignableFrom(type) \u003d\u003d false) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }",
    "begin_line": 2014,
    "end_line": 2019,
    "comment": "/** \n * Validates that the argument can be converted to the specified class, if not throws an exception. \u003cp\u003eThis method is useful when validating if there will be no casting errors.\u003c/p\u003e \u003cpre\u003eValidate.isAssignableFrom(SuperClass.class, object.getClass());\u003c/pre\u003e \u003cp\u003eThe message of the exception is \u0026quot;The validated object can not be converted to the\u0026quot; followed by the name of the class and \u0026quot;class\u0026quot;\u003c/p\u003e\n * @param superType  the class the class must be validated against, not null\n * @param type  the class to check, not null\n * @param message  the {@link String#format(String,Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if argument can not be converted to the specified class\n * @see #isAssignableFrom(Class,Class)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeBuilder.WildcardTypeBuilder#56",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.WildcardTypeBuilder()",
    "snippet": "private WildcardTypeBuilder() {\n        }",
    "begin_line": 56,
    "end_line": 57,
    "comment": "/** \n * Constructor\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeBuilder.withUpperBounds#67",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.withUpperBounds(java.lang.reflect.Type)",
    "snippet": "public WildcardTypeBuilder withUpperBounds(final Type... bounds) {\n            this.upperBounds \u003d bounds;\n            return this;\n        }",
    "begin_line": 67,
    "end_line": 70,
    "comment": "/** \n * Specify upper bounds of the wildcard type to build.\n * @param bounds to set\n * @return {@code this}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeBuilder.withLowerBounds#77",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.withLowerBounds(java.lang.reflect.Type)",
    "snippet": "public WildcardTypeBuilder withLowerBounds(final Type... bounds) {\n            this.lowerBounds \u003d bounds;\n            return this;\n        }",
    "begin_line": 77,
    "end_line": 80,
    "comment": "/** \n * Specify lower bounds of the wildcard type to build.\n * @param bounds to set\n * @return {@code this}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeBuilder.build#86",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.build()",
    "snippet": "@Override\n        public WildcardType build() {\n            return new WildcardTypeImpl(upperBounds, lowerBounds);\n        }",
    "begin_line": 86,
    "end_line": 88,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GenericArrayTypeImpl.GenericArrayTypeImpl#102",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.GenericArrayTypeImpl(java.lang.reflect.Type)",
    "snippet": "private GenericArrayTypeImpl(final Type componentType) {\n            this.componentType \u003d componentType;\n        }",
    "begin_line": 102,
    "end_line": 104,
    "comment": "/** \n * Constructor\n * @param componentType of this array type\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GenericArrayTypeImpl.getGenericComponentType#110",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getGenericComponentType()",
    "snippet": "@Override\n        public Type getGenericComponentType() {\n            return componentType;\n        }",
    "begin_line": 110,
    "end_line": 112,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GenericArrayTypeImpl.toString#118",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.toString()",
    "snippet": "@Override\n        public String toString() {\n            return TypeUtils.toString(this);\n        }",
    "begin_line": 118,
    "end_line": 120,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GenericArrayTypeImpl.equals#126",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.equals(java.lang.Object)",
    "snippet": "@Override\n        public boolean equals(final Object obj) {\n            return obj \u003d\u003d this || obj instanceof GenericArrayType \u0026\u0026 TypeUtils.equals(this, (GenericArrayType) obj);\n        }",
    "begin_line": 126,
    "end_line": 128,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "GenericArrayTypeImpl.hashCode#134",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.hashCode()",
    "snippet": "@Override\n        public int hashCode() {\n            int result \u003d 67 \u003c\u003c 4;\n            result |\u003d componentType.hashCode();\n            return result;\n        }",
    "begin_line": 134,
    "end_line": 138,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ParameterizedTypeImpl.ParameterizedTypeImpl#156",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.ParameterizedTypeImpl(java.lang.Class\u003c?\u003e, java.lang.reflect.Type, java.lang.reflect.Type[])",
    "snippet": "private ParameterizedTypeImpl(final Class\u003c?\u003e raw, final Type useOwner, final Type[] typeArguments) {\n            this.raw \u003d raw;\n            this.useOwner \u003d useOwner;\n            this.typeArguments \u003d typeArguments.clone();\n        }",
    "begin_line": 156,
    "end_line": 160,
    "comment": "/** \n * Constructor\n * @param raw type\n * @param useOwner owner type to use, if any\n * @param typeArguments formal type arguments\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ParameterizedTypeImpl.getRawType#166",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getRawType()",
    "snippet": "@Override\n        public Type getRawType() {\n            return raw;\n        }",
    "begin_line": 166,
    "end_line": 168,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ParameterizedTypeImpl.getOwnerType#174",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getOwnerType()",
    "snippet": "@Override\n        public Type getOwnerType() {\n            return useOwner;\n        }",
    "begin_line": 174,
    "end_line": 176,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ParameterizedTypeImpl.getActualTypeArguments#182",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getActualTypeArguments()",
    "snippet": "@Override\n        public Type[] getActualTypeArguments() {\n            return typeArguments.clone();\n        }",
    "begin_line": 182,
    "end_line": 184,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ParameterizedTypeImpl.toString#190",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.toString()",
    "snippet": "@Override\n        public String toString() {\n            return TypeUtils.toString(this);\n        }",
    "begin_line": 190,
    "end_line": 192,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ParameterizedTypeImpl.equals#198",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.equals(java.lang.Object)",
    "snippet": "@Override\n        public boolean equals(final Object obj) {\n            return obj \u003d\u003d this || obj instanceof ParameterizedType \u0026\u0026 TypeUtils.equals(this, ((ParameterizedType) obj));\n        }",
    "begin_line": 198,
    "end_line": 200,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ParameterizedTypeImpl.hashCode#207",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.hashCode()",
    "snippet": "@SuppressWarnings( \"deprecation\" ) hashCode() {\n            int result \u003d 71 \u003c\u003c 4;\n            result |\u003d raw.hashCode();\n            result \u003c\u003c\u003d 4;\n            result |\u003d ObjectUtils.hashCode(useOwner);\n            result \u003c\u003c\u003d 8;\n            result |\u003d Arrays.hashCode(typeArguments);\n            return result;\n        }",
    "begin_line": 207,
    "end_line": 215,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.WildcardTypeImpl#233",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.WildcardTypeImpl(java.lang.reflect.Type[], java.lang.reflect.Type[])",
    "snippet": "private WildcardTypeImpl(final Type[] upperBounds, final Type[] lowerBounds) {\n            this.upperBounds \u003d ObjectUtils.defaultIfNull(upperBounds, EMPTY_BOUNDS);\n            this.lowerBounds \u003d ObjectUtils.defaultIfNull(lowerBounds, EMPTY_BOUNDS);\n        }",
    "begin_line": 233,
    "end_line": 236,
    "comment": "/** \n * Constructor\n * @param upperBounds of this type\n * @param lowerBounds of this type\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getUpperBounds#242",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getUpperBounds()",
    "snippet": "@Override\n        public Type[] getUpperBounds() {\n            return upperBounds.clone();\n        }",
    "begin_line": 242,
    "end_line": 244,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getLowerBounds#250",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getLowerBounds()",
    "snippet": "@Override\n        public Type[] getLowerBounds() {\n            return lowerBounds.clone();\n        }",
    "begin_line": 250,
    "end_line": 252,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.toString#258",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.toString()",
    "snippet": "@Override\n        public String toString() {\n            return TypeUtils.toString(this);\n        }",
    "begin_line": 258,
    "end_line": 260,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.equals#266",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.equals(java.lang.Object)",
    "snippet": "@Override\n        public boolean equals(final Object obj) {\n            return obj \u003d\u003d this || obj instanceof WildcardType \u0026\u0026 TypeUtils.equals(this, (WildcardType) obj);\n        }",
    "begin_line": 266,
    "end_line": 268,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.hashCode#274",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.hashCode()",
    "snippet": "@Override\n        public int hashCode() {\n            int result \u003d 73 \u003c\u003c 8;\n            result |\u003d Arrays.hashCode(upperBounds);\n            result \u003c\u003c\u003d 8;\n            result |\u003d Arrays.hashCode(lowerBounds);\n            return result;\n        }",
    "begin_line": 274,
    "end_line": 280,
    "comment": "/** \n * {@inheritDoc}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.TypeUtils#296",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.TypeUtils()",
    "snippet": "public TypeUtils() {\n        super();\n    }",
    "begin_line": 296,
    "end_line": 298,
    "comment": "/** \n * \u003cp\u003e {@code TypeUtils} instances should NOT be constructed in standardprogramming. Instead, the class should be used as {@code TypeUtils.isAssignable(cls, toClass)}.\u003c/p\u003e \u003cp\u003eThis constructor is public to permit tools that require a JavaBean instance to operate.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.isAssignable#310",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.isAssignable(java.lang.reflect.Type, java.lang.reflect.Type)",
    "snippet": "public static boolean isAssignable(final Type type, final Type toType) {\n        return isAssignable(type, toType, null);\n    }",
    "begin_line": 310,
    "end_line": 312,
    "comment": "/** \n * \u003cp\u003eChecks if the subject type may be implicitly cast to the target type following the Java generics rules. If both types are  {@link Class}objects, the method returns the result of {@link ClassUtils#isAssignable(Class,Class)}.\u003c/p\u003e\n * @param type the subject type to be assigned to the target type\n * @param toType the target type\n * @return {@code true} if {@code type} is assignable to {@code toType}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.isAssignable#323",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.isAssignable(java.lang.reflect.Type, java.lang.reflect.Type, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean isAssignable(final Type type, final Type toType,\n            final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns) {\n        if (toType \u003d\u003d null || toType instanceof Class\u003c?\u003e) {\n            return isAssignable(type, (Class\u003c?\u003e) toType);\n        }\n\n        if (toType instanceof ParameterizedType) {\n            return isAssignable(type, (ParameterizedType) toType, typeVarAssigns);\n        }\n\n        if (toType instanceof GenericArrayType) {\n            return isAssignable(type, (GenericArrayType) toType, typeVarAssigns);\n        }\n\n        if (toType instanceof WildcardType) {\n            return isAssignable(type, (WildcardType) toType, typeVarAssigns);\n        }\n\n        if (toType instanceof TypeVariable\u003c?\u003e) {\n            return isAssignable(type, (TypeVariable\u003c?\u003e) toType, typeVarAssigns);\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + toType);\n    }",
    "begin_line": 323,
    "end_line": 346,
    "comment": "/** \n * \u003cp\u003eChecks if the subject type may be implicitly cast to the target type following the Java generics rules.\u003c/p\u003e\n * @param type the subject type to be assigned to the target type\n * @param toType the target type\n * @param typeVarAssigns optional map of type variable assignments\n * @return {@code true} if {@code type} is assignable to {@code toType}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.isAssignable#356",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.isAssignable(java.lang.reflect.Type, java.lang.Class\u003c?\u003e)",
    "snippet": "private static boolean isAssignable(final Type type, final Class\u003c?\u003e toClass) {\n        if (type \u003d\u003d null) {\n            // consistency with ClassUtils.isAssignable() behavior\n            return toClass \u003d\u003d null || !toClass.isPrimitive();\n        }\n\n        // only a null type can be assigned to null type which\n        // would have cause the previous to return true\n        if (toClass \u003d\u003d null) {\n            return false;\n        }\n\n        // all types are assignable to themselves\n        if (toClass.equals(type)) {\n            return true;\n        }\n\n        if (type instanceof Class\u003c?\u003e) {\n            // just comparing two classes\n            return ClassUtils.isAssignable((Class\u003c?\u003e) type, toClass);\n        }\n\n        if (type instanceof ParameterizedType) {\n            // only have to compare the raw type to the class\n            return isAssignable(getRawType((ParameterizedType) type), toClass);\n        }\n\n        // *\n        if (type instanceof TypeVariable\u003c?\u003e) {\n            // if any of the bounds are assignable to the class, then the\n            // type is assignable to the class.\n            for (final Type bound : ((TypeVariable\u003c?\u003e) type).getBounds()) {\n                if (isAssignable(bound, toClass)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // the only classes to which a generic array type can be assigned\n        // are class Object and array classes\n        if (type instanceof GenericArrayType) {\n            return toClass.equals(Object.class)\n                    || toClass.isArray()\n                    \u0026\u0026 isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass\n                            .getComponentType());\n        }\n\n        // wildcard types are not assignable to a class (though one would think\n        // \"? super Object\" would be assignable to Object)\n        if (type instanceof WildcardType) {\n            return false;\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }",
    "begin_line": 356,
    "end_line": 412,
    "comment": "/** \n * \u003cp\u003eChecks if the subject type may be implicitly cast to the target class following the Java generics rules.\u003c/p\u003e\n * @param type the subject type to be assigned to the target type\n * @param toClass the target class\n * @return {@code true} if {@code type} is assignable to {@code toClass}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.isAssignable#423",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.isAssignable(java.lang.reflect.Type, java.lang.reflect.ParameterizedType, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType,\n            final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns) {\n        if (type \u003d\u003d null) {\n            return true;\n        }\n\n        // only a null type can be assigned to null type which\n        // would have cause the previous to return true\n        if (toParameterizedType \u003d\u003d null) {\n            return false;\n        }\n\n        // all types are assignable to themselves\n        if (toParameterizedType.equals(type)) {\n            return true;\n        }\n\n        // get the target type\u0027s raw type\n        final Class\u003c?\u003e toClass \u003d getRawType(toParameterizedType);\n        // get the subject type\u0027s type arguments including owner type arguments\n        // and supertype arguments up to and including the target class.\n        final Map\u003cTypeVariable\u003c?\u003e, Type\u003e fromTypeVarAssigns \u003d getTypeArguments(type, toClass, null);\n\n        // null means the two types are not compatible\n        if (fromTypeVarAssigns \u003d\u003d null) {\n            return false;\n        }\n\n        // compatible types, but there\u0027s no type arguments. this is equivalent\n        // to comparing Map\u003c ?, ? \u003e to Map, and raw types are always assignable\n        // to parameterized types.\n        if (fromTypeVarAssigns.isEmpty()) {\n            return true;\n        }\n\n        // get the target type\u0027s type arguments including owner type arguments\n        final Map\u003cTypeVariable\u003c?\u003e, Type\u003e toTypeVarAssigns \u003d getTypeArguments(toParameterizedType,\n                toClass, typeVarAssigns);\n\n        // now to check each type argument\n        for (final TypeVariable\u003c?\u003e var : toTypeVarAssigns.keySet()) {\n            final Type toTypeArg \u003d unrollVariableAssignments(var, toTypeVarAssigns);\n            final Type fromTypeArg \u003d unrollVariableAssignments(var, fromTypeVarAssigns);\n\n            // parameters must either be absent from the subject type, within\n            // the bounds of the wildcard type, or be an exact match to the\n            // parameters of the target type.\n            if (fromTypeArg !\u003d null\n                    \u0026\u0026 !toTypeArg.equals(fromTypeArg)\n                    \u0026\u0026 !(toTypeArg instanceof WildcardType \u0026\u0026 isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 423,
    "end_line": 478,
    "comment": "/** \n * \u003cp\u003eChecks if the subject type may be implicitly cast to the target parameterized type following the Java generics rules.\u003c/p\u003e\n * @param type the subject type to be assigned to the target type\n * @param toParameterizedType the target parameterized type\n * @param typeVarAssigns a map with type variables\n * @return {@code true} if {@code type} is assignable to {@code toType}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.unrollVariableAssignments#488",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.unrollVariableAssignments(java.lang.reflect.TypeVariable\u003c?\u003e, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static Type unrollVariableAssignments(TypeVariable\u003c?\u003e var, final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns) {\n        Type result;\n        do {\n            result \u003d typeVarAssigns.get(var);\n            if (result instanceof TypeVariable\u003c?\u003e \u0026\u0026 !result.equals(var)) {\n                var \u003d (TypeVariable\u003c?\u003e) result;\n                continue;\n            }\n            break;\n        } while (true);\n        return result;\n    }",
    "begin_line": 488,
    "end_line": 499,
    "comment": "/** \n * Look up  {@code var} in {@code typeVarAssigns} \u003cem\u003etransitively\u003c/em\u003e,i.e. keep looking until the value found is \u003cem\u003enot\u003c/em\u003e a type variable.\n * @param var the type variable to look up\n * @param typeVarAssigns the map used for the look up\n * @return Type or {@code null} if some variable was not in the map\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.isAssignable#511",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.isAssignable(java.lang.reflect.Type, java.lang.reflect.GenericArrayType, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType,\n            final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns) {\n        if (type \u003d\u003d null) {\n            return true;\n        }\n\n        // only a null type can be assigned to null type which\n        // would have cause the previous to return true\n        if (toGenericArrayType \u003d\u003d null) {\n            return false;\n        }\n\n        // all types are assignable to themselves\n        if (toGenericArrayType.equals(type)) {\n            return true;\n        }\n\n        final Type toComponentType \u003d toGenericArrayType.getGenericComponentType();\n\n        if (type instanceof Class\u003c?\u003e) {\n            final Class\u003c?\u003e cls \u003d (Class\u003c?\u003e) type;\n\n            // compare the component types\n            return cls.isArray()\n                    \u0026\u0026 isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns);\n        }\n\n        if (type instanceof GenericArrayType) {\n            // compare the component types\n            return isAssignable(((GenericArrayType) type).getGenericComponentType(),\n                    toComponentType, typeVarAssigns);\n        }\n\n        if (type instanceof WildcardType) {\n            // so long as one of the upper bounds is assignable, it\u0027s good\n            for (final Type bound : getImplicitUpperBounds((WildcardType) type)) {\n                if (isAssignable(bound, toGenericArrayType)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        if (type instanceof TypeVariable\u003c?\u003e) {\n            // probably should remove the following logic and just return false.\n            // type variables cannot specify arrays as bounds.\n            for (final Type bound : getImplicitBounds((TypeVariable\u003c?\u003e) type)) {\n                if (isAssignable(bound, toGenericArrayType)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        if (type instanceof ParameterizedType) {\n            // the raw type of a parameterized type is never an array or\n            // generic array, otherwise the declaration would look like this:\n            // Collection[]\u003c ? extends String \u003e collection;\n            return false;\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }",
    "begin_line": 511,
    "end_line": 575,
    "comment": "/** \n * \u003cp\u003eChecks if the subject type may be implicitly cast to the target generic array type following the Java generics rules.\u003c/p\u003e\n * @param type the subject type to be assigned to the target type\n * @param toGenericArrayType the target generic array type\n * @param typeVarAssigns a map with type variables\n * @return {@code true} if {@code type} is assignable to{@code toGenericArrayType}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.isAssignable#587",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.isAssignable(java.lang.reflect.Type, java.lang.reflect.WildcardType, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean isAssignable(final Type type, final WildcardType toWildcardType,\n            final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns) {\n        if (type \u003d\u003d null) {\n            return true;\n        }\n\n        // only a null type can be assigned to null type which\n        // would have cause the previous to return true\n        if (toWildcardType \u003d\u003d null) {\n            return false;\n        }\n\n        // all types are assignable to themselves\n        if (toWildcardType.equals(type)) {\n            return true;\n        }\n\n        final Type[] toUpperBounds \u003d getImplicitUpperBounds(toWildcardType);\n        final Type[] toLowerBounds \u003d getImplicitLowerBounds(toWildcardType);\n\n        if (type instanceof WildcardType) {\n            final WildcardType wildcardType \u003d (WildcardType) type;\n            final Type[] upperBounds \u003d getImplicitUpperBounds(wildcardType);\n            final Type[] lowerBounds \u003d getImplicitLowerBounds(wildcardType);\n\n            for (Type toBound : toUpperBounds) {\n                // if there are assignments for unresolved type variables,\n                // now\u0027s the time to substitute them.\n                toBound \u003d substituteTypeVariables(toBound, typeVarAssigns);\n\n                // each upper bound of the subject type has to be assignable to\n                // each\n                // upper bound of the target type\n                for (final Type bound : upperBounds) {\n                    if (!isAssignable(bound, toBound, typeVarAssigns)) {\n                        return false;\n                    }\n                }\n            }\n\n            for (Type toBound : toLowerBounds) {\n                // if there are assignments for unresolved type variables,\n                // now\u0027s the time to substitute them.\n                toBound \u003d substituteTypeVariables(toBound, typeVarAssigns);\n\n                // each lower bound of the target type has to be assignable to\n                // each\n                // lower bound of the subject type\n                for (final Type bound : lowerBounds) {\n                    if (!isAssignable(toBound, bound, typeVarAssigns)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        for (final Type toBound : toUpperBounds) {\n            // if there are assignments for unresolved type variables,\n            // now\u0027s the time to substitute them.\n            if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns),\n                    typeVarAssigns)) {\n                return false;\n            }\n        }\n\n        for (final Type toBound : toLowerBounds) {\n            // if there are assignments for unresolved type variables,\n            // now\u0027s the time to substitute them.\n            if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type,\n                    typeVarAssigns)) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 587,
    "end_line": 662,
    "comment": "/** \n * \u003cp\u003eChecks if the subject type may be implicitly cast to the target wildcard type following the Java generics rules.\u003c/p\u003e\n * @param type the subject type to be assigned to the target type\n * @param toWildcardType the target wildcard type\n * @param typeVarAssigns a map with type variables\n * @return {@code true} if {@code type} is assignable to{@code toWildcardType}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.isAssignable#674",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.isAssignable(java.lang.reflect.Type, java.lang.reflect.TypeVariable\u003c?\u003e, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean isAssignable(final Type type, final TypeVariable\u003c?\u003e toTypeVariable,\n            final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns) {\n        if (type \u003d\u003d null) {\n            return true;\n        }\n\n        // only a null type can be assigned to null type which\n        // would have cause the previous to return true\n        if (toTypeVariable \u003d\u003d null) {\n            return false;\n        }\n\n        // all types are assignable to themselves\n        if (toTypeVariable.equals(type)) {\n            return true;\n        }\n\n        if (type instanceof TypeVariable\u003c?\u003e) {\n            // a type variable is assignable to another type variable, if\n            // and only if the former is the latter, extends the latter, or\n            // is otherwise a descendant of the latter.\n            final Type[] bounds \u003d getImplicitBounds((TypeVariable\u003c?\u003e) type);\n\n            for (final Type bound : bounds) {\n                if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {\n                    return true;\n                }\n            }\n        }\n\n        if (type instanceof Class\u003c?\u003e || type instanceof ParameterizedType\n                || type instanceof GenericArrayType || type instanceof WildcardType) {\n            return false;\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }",
    "begin_line": 674,
    "end_line": 710,
    "comment": "/** \n * \u003cp\u003eChecks if the subject type may be implicitly cast to the target type variable following the Java generics rules.\u003c/p\u003e\n * @param type the subject type to be assigned to the target type\n * @param toTypeVariable the target type variable\n * @param typeVarAssigns a map with type variables\n * @return {@code true} if {@code type} is assignable to{@code toTypeVariable}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.substituteTypeVariables#720",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.substituteTypeVariables(java.lang.reflect.Type, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static Type substituteTypeVariables(final Type type, final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns) {\n        if (type instanceof TypeVariable\u003c?\u003e \u0026\u0026 typeVarAssigns !\u003d null) {\n            final Type replacementType \u003d typeVarAssigns.get(type);\n\n            if (replacementType \u003d\u003d null) {\n                throw new IllegalArgumentException(\"missing assignment type for type variable \"\n                        + type);\n            }\n            return replacementType;\n        }\n        return type;\n    }",
    "begin_line": 720,
    "end_line": 731,
    "comment": "/** \n * \u003cp\u003eFind the mapping for  {@code type} in {@code typeVarAssigns}.\u003c/p\u003e\n * @param type the type to be replaced\n * @param typeVarAssigns the map with type variables\n * @return the replaced type\n * @throws IllegalArgumentException if the type cannot be substituted\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getTypeArguments#746",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getTypeArguments(java.lang.reflect.ParameterizedType)",
    "snippet": "public static Map\u003cTypeVariable\u003c?\u003e, Type\u003e getTypeArguments(final ParameterizedType type) {\n        return getTypeArguments(type, getRawType(type), null);\n    }",
    "begin_line": 746,
    "end_line": 748,
    "comment": "/** \n * \u003cp\u003eRetrieves all the type arguments for this parameterized type including owner hierarchy arguments such as {@code Outer\u003cK,V\u003e.Inner\u003cT\u003e.DeepInner\u003cE\u003e} .The arguments are returned in a {@link Map} specifying the argument type for each {@link TypeVariable}. \u003c/p\u003e\n * @param type specifies the subject parameterized type from which toharvest the parameters.\n * @return a {@code Map} of the type arguments to their respective typevariables.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getTypeArguments#782",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getTypeArguments(java.lang.reflect.Type, java.lang.Class\u003c?\u003e)",
    "snippet": "public static Map\u003cTypeVariable\u003c?\u003e, Type\u003e getTypeArguments(final Type type, final Class\u003c?\u003e toClass) {\n        return getTypeArguments(type, toClass, null);\n    }",
    "begin_line": 782,
    "end_line": 784,
    "comment": "/** \n * \u003cp\u003eGets the type arguments of a class/interface based on a subtype. For instance, this method will determine that both of the parameters for the interface  {@link Map} are {@link Object} for the subtype{@link java.util.Properties Properties} even though the subtype does notdirectly implement the  {@code Map} interface.\u003c/p\u003e\u003cp\u003eThis method returns  {@code null} if {@code type} is not assignable to{@code toClass}. It returns an empty map if none of the classes or interfaces in its inheritance hierarchy specify any type arguments.\u003c/p\u003e \u003cp\u003eA side effect of this method is that it also retrieves the type arguments for the classes and interfaces that are part of the hierarchy between  {@code type} and {@code toClass}. So with the above example, this method will also determine that the type arguments for {@link java.util.Hashtable Hashtable} are also both {@code Object}. In cases where the interface specified by  {@code toClass} is(indirectly) implemented more than once (e.g. where  {@code toClass}specifies the interface  {@link java.lang.Iterable Iterable} and{@code type} specifies a parameterized type that implements both{@link java.util.Set Set} and {@link java.util.Collection Collection}), this method will look at the inheritance hierarchy of only one of the implementations/subclasses; the first interface encountered that isn\u0027t a subinterface to one of the others in the  {@code type} to{@code toClass} hierarchy.\u003c/p\u003e\n * @param type the type from which to determine the type parameters of{@code toClass}\n * @param toClass the class whose type parameters are to be determined basedon the subtype  {@code type}\n * @return a {@code Map} of the type assignments for the type variables ineach type in the inheritance hierarchy from  {@code type} to{@code toClass} inclusive.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getTypeArguments#794",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getTypeArguments(java.lang.reflect.Type, java.lang.Class\u003c?\u003e, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static Map\u003cTypeVariable\u003c?\u003e, Type\u003e getTypeArguments(final Type type, final Class\u003c?\u003e toClass,\n            final Map\u003cTypeVariable\u003c?\u003e, Type\u003e subtypeVarAssigns) {\n        if (type instanceof Class\u003c?\u003e) {\n            return getTypeArguments((Class\u003c?\u003e) type, toClass, subtypeVarAssigns);\n        }\n\n        if (type instanceof ParameterizedType) {\n            return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns);\n        }\n\n        if (type instanceof GenericArrayType) {\n            return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass\n                    .isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n        }\n\n        // since wildcard types are not assignable to classes, should this just\n        // return null?\n        if (type instanceof WildcardType) {\n            for (final Type bound : getImplicitUpperBounds((WildcardType) type)) {\n                // find the first bound that is assignable to the target class\n                if (isAssignable(bound, toClass)) {\n                    return getTypeArguments(bound, toClass, subtypeVarAssigns);\n                }\n            }\n\n            return null;\n        }\n\n        if (type instanceof TypeVariable\u003c?\u003e) {\n            for (final Type bound : getImplicitBounds((TypeVariable\u003c?\u003e) type)) {\n                // find the first bound that is assignable to the target class\n                if (isAssignable(bound, toClass)) {\n                    return getTypeArguments(bound, toClass, subtypeVarAssigns);\n                }\n            }\n\n            return null;\n        }\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }",
    "begin_line": 794,
    "end_line": 833,
    "comment": "/** \n * \u003cp\u003eReturn a map of the type arguments of @{code type} in the context of  {@code toClass}.\u003c/p\u003e\n * @param type the type in question\n * @param toClass the class\n * @param subtypeVarAssigns a map with type variables\n * @return the {@code Map} with type arguments\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getTypeArguments#843",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getTypeArguments(java.lang.reflect.ParameterizedType, java.lang.Class\u003c?\u003e, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static Map\u003cTypeVariable\u003c?\u003e, Type\u003e getTypeArguments(\n            final ParameterizedType parameterizedType, final Class\u003c?\u003e toClass,\n            final Map\u003cTypeVariable\u003c?\u003e, Type\u003e subtypeVarAssigns) {\n        final Class\u003c?\u003e cls \u003d getRawType(parameterizedType);\n\n        // make sure they\u0027re assignable\n        if (!isAssignable(cls, toClass)) {\n            return null;\n        }\n\n        final Type ownerType \u003d parameterizedType.getOwnerType();\n        Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns;\n\n        if (ownerType instanceof ParameterizedType) {\n            // get the owner type arguments first\n            final ParameterizedType parameterizedOwnerType \u003d (ParameterizedType) ownerType;\n            typeVarAssigns \u003d getTypeArguments(parameterizedOwnerType,\n                    getRawType(parameterizedOwnerType), subtypeVarAssigns);\n        } else {\n            // no owner, prep the type variable assignments map\n            typeVarAssigns \u003d subtypeVarAssigns \u003d\u003d null ? new HashMap\u003cTypeVariable\u003c?\u003e, Type\u003e()\n                    : new HashMap\u003cTypeVariable\u003c?\u003e, Type\u003e(subtypeVarAssigns);\n        }\n\n        // get the subject parameterized type\u0027s arguments\n        final Type[] typeArgs \u003d parameterizedType.getActualTypeArguments();\n        // and get the corresponding type variables from the raw class\n        final TypeVariable\u003c?\u003e[] typeParams \u003d cls.getTypeParameters();\n\n        // map the arguments to their respective type variables\n        for (int i \u003d 0; i \u003c typeParams.length; i++) {\n            final Type typeArg \u003d typeArgs[i];\n            typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns\n                    .get(typeArg) : typeArg);\n        }\n\n        if (toClass.equals(cls)) {\n            // target class has been reached. Done.\n            return typeVarAssigns;\n        }\n\n        // walk the inheritance hierarchy until the target class is reached\n        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n    }",
    "begin_line": 843,
    "end_line": 886,
    "comment": "/** \n * \u003cp\u003eReturn a map of the type arguments of a parameterized type in the context of  {@code toClass}.\u003c/p\u003e\n * @param parameterizedType the parameterized type\n * @param toClass the class\n * @param subtypeVarAssigns a map with type variables\n * @return the {@code Map} with type arguments\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getTypeArguments#896",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getTypeArguments(java.lang.Class\u003c?\u003e, java.lang.Class\u003c?\u003e, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static Map\u003cTypeVariable\u003c?\u003e, Type\u003e getTypeArguments(Class\u003c?\u003e cls, final Class\u003c?\u003e toClass,\n            final Map\u003cTypeVariable\u003c?\u003e, Type\u003e subtypeVarAssigns) {\n        // make sure they\u0027re assignable\n        if (!isAssignable(cls, toClass)) {\n            return null;\n        }\n\n        // can\u0027t work with primitives\n        if (cls.isPrimitive()) {\n            // both classes are primitives?\n            if (toClass.isPrimitive()) {\n                // dealing with widening here. No type arguments to be\n                // harvested with these two types.\n                return new HashMap\u003cTypeVariable\u003c?\u003e, Type\u003e();\n            }\n\n            // work with wrapper the wrapper class instead of the primitive\n            cls \u003d ClassUtils.primitiveToWrapper(cls);\n        }\n\n        // create a copy of the incoming map, or an empty one if it\u0027s null\n        final HashMap\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns \u003d subtypeVarAssigns \u003d\u003d null ? new HashMap\u003cTypeVariable\u003c?\u003e, Type\u003e()\n                : new HashMap\u003cTypeVariable\u003c?\u003e, Type\u003e(subtypeVarAssigns);\n\n        // has target class been reached?\n        if (toClass.equals(cls)) {\n            return typeVarAssigns;\n        }\n\n        // walk the inheritance hierarchy until the target class is reached\n        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n    }",
    "begin_line": 896,
    "end_line": 927,
    "comment": "/** \n * \u003cp\u003eReturn a map of the type arguments of a class in the context of @{code toClass}.\u003c/p\u003e\n * @param cls the class in question\n * @param toClass the context class\n * @param subtypeVarAssigns a map with type variables\n * @return the {@code Map} with type arguments\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.determineTypeArguments#956",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.determineTypeArguments(java.lang.Class\u003c?\u003e, java.lang.reflect.ParameterizedType)",
    "snippet": "public static Map\u003cTypeVariable\u003c?\u003e, Type\u003e determineTypeArguments(final Class\u003c?\u003e cls,\n            final ParameterizedType superType) {\n        Validate.notNull(cls, \"cls is null\");\n        Validate.notNull(superType, \"superType is null\");\n\n        final Class\u003c?\u003e superClass \u003d getRawType(superType);\n\n        // compatibility check\n        if (!isAssignable(cls, superClass)) {\n            return null;\n        }\n\n        if (cls.equals(superClass)) {\n            return getTypeArguments(superType, superClass, null);\n        }\n\n        // get the next class in the inheritance hierarchy\n        final Type midType \u003d getClosestParentType(cls, superClass);\n\n        // can only be a class or a parameterized type\n        if (midType instanceof Class\u003c?\u003e) {\n            return determineTypeArguments((Class\u003c?\u003e) midType, superType);\n        }\n\n        final ParameterizedType midParameterizedType \u003d (ParameterizedType) midType;\n        final Class\u003c?\u003e midClass \u003d getRawType(midParameterizedType);\n        // get the type variables of the mid class that map to the type\n        // arguments of the super class\n        final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns \u003d determineTypeArguments(midClass, superType);\n        // map the arguments of the mid type to the class type variables\n        mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);\n\n        return typeVarAssigns;\n    }",
    "begin_line": 956,
    "end_line": 989,
    "comment": "/** \n * \u003cp\u003eTries to determine the type arguments of a class/interface based on a super parameterized type\u0027s type arguments. This method is the inverse of {@link #getTypeArguments(Type,Class)} which gets a class/interface\u0027stype arguments based on a subtype. It is far more limited in determining the type arguments for the subject class\u0027s type variables in that it can only determine those parameters that map from the subject  {@link Class}object to the supertype.\u003c/p\u003e \u003cp\u003eExample:  {@link java.util.TreeSet TreeSet} sets its parameter as the parameter for{@link java.util.NavigableSet NavigableSet}, which in turn sets the parameter of  {@link java.util.SortedSet}, which in turn sets the parameter of  {@link Set}, which in turn sets the parameter of {@link java.util.Collection}, which in turn sets the parameter of {@link java.lang.Iterable}. Since  {@code TreeSet}\u0027s parameter maps (indirectly) to  {@code Iterable}\u0027s parameter, it will be able to determine that based on the super type  {@code Iterable\u003c? extendsMap\u003cInteger, ? extends Collection\u003c?\u003e\u003e\u003e}, the parameter of {@code TreeSet} is {@code ? extends Map\u003cInteger, ? extendsCollection\u003c?\u003e\u003e}.\u003c/p\u003e\n * @param cls the class whose type parameters are to be determined, not {@code null}\n * @param superType the super type from which {@code cls}\u0027s type arguments are to be determined, not  {@code null}\n * @return a {@code Map} of the type assignments that could be determinedfor the type variables in each type in the inheritance hierarchy from {@code type} to {@code toClass} inclusive.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.mapTypeVariablesToArguments#999",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.mapTypeVariablesToArguments(java.lang.Class\u003cT\u003e, java.lang.reflect.ParameterizedType, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "private static \u003cT\u003e void mapTypeVariablesToArguments(final Class\u003cT\u003e cls,\n            final ParameterizedType parameterizedType, final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns) {\n        // capture the type variables from the owner type that have assignments\n        final Type ownerType \u003d parameterizedType.getOwnerType();\n\n        if (ownerType instanceof ParameterizedType) {\n            // recursion to make sure the owner\u0027s owner type gets processed\n            mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns);\n        }\n\n        // parameterizedType is a generic interface/class (or it\u0027s in the owner\n        // hierarchy of said interface/class) implemented/extended by the class\n        // cls. Find out which type variables of cls are type arguments of\n        // parameterizedType:\n        final Type[] typeArgs \u003d parameterizedType.getActualTypeArguments();\n\n        // of the cls\u0027s type variables that are arguments of parameterizedType,\n        // find out which ones can be determined from the super type\u0027s arguments\n        final TypeVariable\u003c?\u003e[] typeVars \u003d getRawType(parameterizedType).getTypeParameters();\n\n        // use List view of type parameters of cls so the contains() method can be used:\n        final List\u003cTypeVariable\u003cClass\u003cT\u003e\u003e\u003e typeVarList \u003d Arrays.asList(cls\n                .getTypeParameters());\n\n        for (int i \u003d 0; i \u003c typeArgs.length; i++) {\n            final TypeVariable\u003c?\u003e typeVar \u003d typeVars[i];\n            final Type typeArg \u003d typeArgs[i];\n\n            // argument of parameterizedType is a type variable of cls\n            if (typeVarList.contains(typeArg)\n            // type variable of parameterizedType has an assignment in\n                    // the super type.\n                    \u0026\u0026 typeVarAssigns.containsKey(typeVar)) {\n                // map the assignment to the cls\u0027s type variable\n                typeVarAssigns.put((TypeVariable\u003c?\u003e) typeArg, typeVarAssigns.get(typeVar));\n            }\n        }\n    }",
    "begin_line": 999,
    "end_line": 1036,
    "comment": "/** \n * \u003cp\u003ePerforms a mapping of type variables.\u003c/p\u003e\n * @param \u003c T \u003e the generic type of the class in question\n * @param cls the class in question\n * @param parameterizedType the parameterized type\n * @param typeVarAssigns the map to be filled\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getClosestParentType#1046",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getClosestParentType(java.lang.Class\u003c?\u003e, java.lang.Class\u003c?\u003e)",
    "snippet": "private static Type getClosestParentType(final Class\u003c?\u003e cls, final Class\u003c?\u003e superClass) {\n        // only look at the interfaces if the super class is also an interface\n        if (superClass.isInterface()) {\n            // get the generic interfaces of the subject class\n            final Type[] interfaceTypes \u003d cls.getGenericInterfaces();\n            // will hold the best generic interface match found\n            Type genericInterface \u003d null;\n\n            // find the interface closest to the super class\n            for (final Type midType : interfaceTypes) {\n                Class\u003c?\u003e midClass \u003d null;\n\n                if (midType instanceof ParameterizedType) {\n                    midClass \u003d getRawType((ParameterizedType) midType);\n                } else if (midType instanceof Class\u003c?\u003e) {\n                    midClass \u003d (Class\u003c?\u003e) midType;\n                } else {\n                    throw new IllegalStateException(\"Unexpected generic\"\n                            + \" interface type found: \" + midType);\n                }\n\n                // check if this interface is further up the inheritance chain\n                // than the previously found match\n                if (isAssignable(midClass, superClass)\n                        \u0026\u0026 isAssignable(genericInterface, (Type) midClass)) {\n                    genericInterface \u003d midType;\n                }\n            }\n\n            // found a match?\n            if (genericInterface !\u003d null) {\n                return genericInterface;\n            }\n        }\n\n        // none of the interfaces were descendants of the target class, so the\n        // super class has to be one, instead\n        return cls.getGenericSuperclass();\n    }",
    "begin_line": 1046,
    "end_line": 1084,
    "comment": "/** \n * \u003cp\u003eGet the closest parent type to the super class specified by  {@code superClass}.\u003c/p\u003e\n * @param cls the class in question\n * @param superClass the super class\n * @return the closes parent type\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.isInstance#1094",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.isInstance(java.lang.Object, java.lang.reflect.Type)",
    "snippet": "public static boolean isInstance(final Object value, final Type type) {\n        if (type \u003d\u003d null) {\n            return false;\n        }\n\n        return value \u003d\u003d null ? !(type instanceof Class\u003c?\u003e) || !((Class\u003c?\u003e) type).isPrimitive()\n                : isAssignable(value.getClass(), type, null);\n    }",
    "begin_line": 1094,
    "end_line": 1101,
    "comment": "/** \n * \u003cp\u003eChecks if the given value can be assigned to the target type following the Java generics rules.\u003c/p\u003e\n * @param value the value to be checked\n * @param type the target type\n * @return {@code true} if {@code value} is an instance of {@code type}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.normalizeUpperBounds#1124",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.normalizeUpperBounds(java.lang.reflect.Type[])",
    "snippet": "public static Type[] normalizeUpperBounds(final Type[] bounds) {\n        Validate.notNull(bounds, \"null value specified for bounds array\");\n        // don\u0027t bother if there\u0027s only one (or none) type\n        if (bounds.length \u003c 2) {\n            return bounds;\n        }\n\n        final Set\u003cType\u003e types \u003d new HashSet\u003cType\u003e(bounds.length);\n\n        for (final Type type1 : bounds) {\n            boolean subtypeFound \u003d false;\n\n            for (final Type type2 : bounds) {\n                if (type1 !\u003d type2 \u0026\u0026 isAssignable(type2, type1, null)) {\n                    subtypeFound \u003d true;\n                    break;\n                }\n            }\n\n            if (!subtypeFound) {\n                types.add(type1);\n            }\n        }\n\n        return types.toArray(new Type[types.size()]);\n    }",
    "begin_line": 1124,
    "end_line": 1149,
    "comment": "/** \n * \u003cp\u003eThis method strips out the redundant upper bound types in type variable types and wildcard types (or it would with wildcard types if multiple upper bounds were allowed).\u003c/p\u003e \u003cp\u003eExample, with the variable type declaration: \u003cpre\u003e\u0026lt;K extends java.util.Collection\u0026lt;String\u0026gt; \u0026amp; java.util.List\u0026lt;String\u0026gt;\u0026gt;\u003c/pre\u003e \u003cp\u003e since  {@code List} is a subinterface of {@code Collection}, this method will return the bounds as if the declaration had been: \u003c/p\u003e \u003cpre\u003e\u0026lt;K extends java.util.List\u0026lt;String\u0026gt;\u0026gt;\u003c/pre\u003e\n * @param bounds an array of types representing the upper bounds of either{@link WildcardType} or {@link TypeVariable}, not  {@code null}.\n * @return an array containing the values from {@code bounds} minus theredundant types.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getImplicitBounds#1160",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getImplicitBounds(java.lang.reflect.TypeVariable\u003c?\u003e)",
    "snippet": "public static Type[] getImplicitBounds(final TypeVariable\u003c?\u003e typeVariable) {\n        Validate.notNull(typeVariable, \"typeVariable is null\");\n        final Type[] bounds \u003d typeVariable.getBounds();\n\n        return bounds.length \u003d\u003d 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n    }",
    "begin_line": 1160,
    "end_line": 1165,
    "comment": "/** \n * \u003cp\u003eReturns an array containing the sole type of  {@link Object} if{@link TypeVariable#getBounds()} returns an empty array. Otherwise, itreturns the result of  {@link TypeVariable#getBounds()} passed into{@link #normalizeUpperBounds}.\u003c/p\u003e\n * @param typeVariable the subject type variable, not {@code null}\n * @return a non-empty array containing the bounds of the type variable.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getImplicitUpperBounds#1177",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getImplicitUpperBounds(java.lang.reflect.WildcardType)",
    "snippet": "public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {\n        Validate.notNull(wildcardType, \"wildcardType is null\");\n        final Type[] bounds \u003d wildcardType.getUpperBounds();\n\n        return bounds.length \u003d\u003d 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n    }",
    "begin_line": 1177,
    "end_line": 1182,
    "comment": "/** \n * \u003cp\u003eReturns an array containing the sole value of  {@link Object} if{@link WildcardType#getUpperBounds()} returns an empty array. Otherwise,it returns the result of  {@link WildcardType#getUpperBounds()}passed into  {@link #normalizeUpperBounds}.\u003c/p\u003e\n * @param wildcardType the subject wildcard type, not {@code null}\n * @return a non-empty array containing the upper bounds of the wildcardtype.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getImplicitLowerBounds#1193",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getImplicitLowerBounds(java.lang.reflect.WildcardType)",
    "snippet": "public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {\n        Validate.notNull(wildcardType, \"wildcardType is null\");\n        final Type[] bounds \u003d wildcardType.getLowerBounds();\n\n        return bounds.length \u003d\u003d 0 ? new Type[] { null } : bounds;\n    }",
    "begin_line": 1193,
    "end_line": 1198,
    "comment": "/** \n * \u003cp\u003eReturns an array containing a single value of  {@code null} if{@link WildcardType#getLowerBounds()} returns an empty array. Otherwise,it returns the result of  {@link WildcardType#getLowerBounds()}.\u003c/p\u003e\n * @param wildcardType the subject wildcard type, not {@code null}\n * @return a non-empty array containing the lower bounds of the wildcardtype.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.typesSatisfyVariables#1213",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.typesSatisfyVariables(java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "public static boolean typesSatisfyVariables(final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns) {\n        Validate.notNull(typeVarAssigns, \"typeVarAssigns is null\");\n        // all types must be assignable to all the bounds of the their mapped\n        // type variable.\n        for (final Map.Entry\u003cTypeVariable\u003c?\u003e, Type\u003e entry : typeVarAssigns.entrySet()) {\n            final TypeVariable\u003c?\u003e typeVar \u003d entry.getKey();\n            final Type type \u003d entry.getValue();\n\n            for (final Type bound : getImplicitBounds(typeVar)) {\n                if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns),\n                        typeVarAssigns)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
    "begin_line": 1213,
    "end_line": 1229,
    "comment": "/** \n * \u003cp\u003eDetermines whether or not specified types satisfy the bounds of their mapped type variables. When a type parameter extends another (such as {@code \u003cT, S extends T\u003e}), uses another as a type parameter (such as {@code \u003cT, S extends Comparable\u003e\u003e}), or otherwise depends on another type variable to be specified, the dependencies must be included in  {@code typeVarAssigns}.\u003c/p\u003e\n * @param typeVarAssigns specifies the potential types to be assigned to thetype variables, not  {@code null}.\n * @return whether or not the types can be assigned to their respective typevariables.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getRawType#1238",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getRawType(java.lang.reflect.ParameterizedType)",
    "snippet": "private static Class\u003c?\u003e getRawType(final ParameterizedType parameterizedType) {\n        final Type rawType \u003d parameterizedType.getRawType();\n\n        // check if raw type is a Class object\n        // not currently necessary, but since the return type is Type instead of\n        // Class, there\u0027s enough reason to believe that future versions of Java\n        // may return other Type implementations. And type-safety checking is\n        // rarely a bad idea.\n        if (!(rawType instanceof Class\u003c?\u003e)) {\n            throw new IllegalStateException(\"Wait... What!? Type of rawType: \" + rawType);\n        }\n\n        return (Class\u003c?\u003e) rawType;\n    }",
    "begin_line": 1238,
    "end_line": 1251,
    "comment": "/** \n * \u003cp\u003eTransforms the passed in type to a  {@link Class} object. Type-checking method of convenience.\u003c/p\u003e\n * @param parameterizedType the type to be converted\n * @return the corresponding {@code Class} object\n * @throws IllegalStateException if the conversion fails\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getRawType#1265",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getRawType(java.lang.reflect.Type, java.lang.reflect.Type)",
    "snippet": "public static Class\u003c?\u003e getRawType(final Type type, final Type assigningType) {\n        if (type instanceof Class\u003c?\u003e) {\n            // it is raw, no problem\n            return (Class\u003c?\u003e) type;\n        }\n\n        if (type instanceof ParameterizedType) {\n            // simple enough to get the raw type of a ParameterizedType\n            return getRawType((ParameterizedType) type);\n        }\n\n        if (type instanceof TypeVariable\u003c?\u003e) {\n            if (assigningType \u003d\u003d null) {\n                return null;\n            }\n\n            // get the entity declaring this type variable\n            final Object genericDeclaration \u003d ((TypeVariable\u003c?\u003e) type).getGenericDeclaration();\n\n            // can\u0027t get the raw type of a method- or constructor-declared type\n            // variable\n            if (!(genericDeclaration instanceof Class\u003c?\u003e)) {\n                return null;\n            }\n\n            // get the type arguments for the declaring class/interface based\n            // on the enclosing type\n            final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeVarAssigns \u003d getTypeArguments(assigningType,\n                    (Class\u003c?\u003e) genericDeclaration);\n\n            // enclosingType has to be a subclass (or subinterface) of the\n            // declaring type\n            if (typeVarAssigns \u003d\u003d null) {\n                return null;\n            }\n\n            // get the argument assigned to this type variable\n            final Type typeArgument \u003d typeVarAssigns.get(type);\n\n            if (typeArgument \u003d\u003d null) {\n                return null;\n            }\n\n            // get the argument for this type variable\n            return getRawType(typeArgument, assigningType);\n        }\n\n        if (type instanceof GenericArrayType) {\n            // get raw component type\n            final Class\u003c?\u003e rawComponentType \u003d getRawType(((GenericArrayType) type)\n                    .getGenericComponentType(), assigningType);\n\n            // create array type from raw component type and return its class\n            return Array.newInstance(rawComponentType, 0).getClass();\n        }\n\n        // (hand-waving) this is not the method you\u0027re looking for\n        if (type instanceof WildcardType) {\n            return null;\n        }\n\n        throw new IllegalArgumentException(\"unknown type: \" + type);\n    }",
    "begin_line": 1265,
    "end_line": 1327,
    "comment": "/** \n * \u003cp\u003eGet the raw type of a Java type, given its context. Primarily for use with  {@link TypeVariable}s and  {@link GenericArrayType}s, or when you do not know the runtime type of  {@code type}: if you know you have a {@link Class} instance, it is already raw; if you know you have a{@link ParameterizedType}, its raw type is only a method call away.\u003c/p\u003e\n * @param type to resolve\n * @param assigningType type to be resolved against\n * @return the resolved {@link Class} object or {@code null} ifthe type could not be resolved\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.isArrayType#1334",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.isArrayType(java.lang.reflect.Type)",
    "snippet": "public static boolean isArrayType(final Type type) {\n        return type instanceof GenericArrayType || type instanceof Class\u003c?\u003e \u0026\u0026 ((Class\u003c?\u003e) type).isArray();\n    }",
    "begin_line": 1334,
    "end_line": 1336,
    "comment": "/** \n * Learn whether the specified type denotes an array type.\n * @param type the type to be checked\n * @return {@code true} if {@code type} is an array class or a {@link GenericArrayType}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getArrayComponentType#1343",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getArrayComponentType(java.lang.reflect.Type)",
    "snippet": "public static Type getArrayComponentType(final Type type) {\n        if (type instanceof Class\u003c?\u003e) {\n            final Class\u003c?\u003e clazz \u003d (Class\u003c?\u003e) type;\n            return clazz.isArray() ? clazz.getComponentType() : null;\n        }\n        if (type instanceof GenericArrayType) {\n            return ((GenericArrayType) type).getGenericComponentType();\n        }\n        return null;\n    }",
    "begin_line": 1343,
    "end_line": 1352,
    "comment": "/** \n * Get the array component type of  {@code type}.\n * @param type the type to be checked\n * @return component type or null if type is not an array type\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.unrollVariables#1362",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.unrollVariables(java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e, java.lang.reflect.Type)",
    "snippet": "public static Type unrollVariables(Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeArguments, final Type type) {\n        if (typeArguments \u003d\u003d null) {\n            typeArguments \u003d Collections.\u003cTypeVariable\u003c?\u003e, Type\u003e emptyMap();\n        }\n        if (containsTypeVariables(type)) {\n            if (type instanceof TypeVariable\u003c?\u003e) {\n                return unrollVariables(typeArguments, typeArguments.get(type));\n            }\n            if (type instanceof ParameterizedType) {\n                final ParameterizedType p \u003d (ParameterizedType) type;\n                final Map\u003cTypeVariable\u003c?\u003e, Type\u003e parameterizedTypeArguments;\n                if (p.getOwnerType() \u003d\u003d null) {\n                    parameterizedTypeArguments \u003d typeArguments;\n                } else {\n                    parameterizedTypeArguments \u003d new HashMap\u003cTypeVariable\u003c?\u003e, Type\u003e(typeArguments);\n                    parameterizedTypeArguments.putAll(TypeUtils.getTypeArguments(p));\n                }\n                final Type[] args \u003d p.getActualTypeArguments();\n                for (int i \u003d 0; i \u003c args.length; i++) {\n                    final Type unrolled \u003d unrollVariables(parameterizedTypeArguments, args[i]);\n                    if (unrolled !\u003d null) {\n                        args[i] \u003d unrolled;\n                    }\n                }\n                return parameterizeWithOwner(p.getOwnerType(), (Class\u003c?\u003e) p.getRawType(), args);\n            }\n            if (type instanceof WildcardType) {\n                final WildcardType wild \u003d (WildcardType) type;\n                return wildcardType().withUpperBounds(unrollBounds(typeArguments, wild.getUpperBounds()))\n                    .withLowerBounds(unrollBounds(typeArguments, wild.getLowerBounds())).build();\n            }\n        }\n        return type;\n    }",
    "begin_line": 1362,
    "end_line": 1395,
    "comment": "/** \n * Get a type representing  {@code type} with variable assignments \"unrolled.\"\n * @param typeArguments as from {@link TypeUtils#getTypeArguments(Type,Class)}\n * @param type the type to unroll variable assignments for\n * @return Type\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.unrollBounds#1405",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.unrollBounds(java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e, java.lang.reflect.Type[])",
    "snippet": "private static Type[] unrollBounds(final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeArguments, final Type[] bounds) {\n        Type[] result \u003d bounds;\n        int i \u003d 0;\n        for (; i \u003c result.length; i++) {\n            final Type unrolled \u003d unrollVariables(typeArguments, result[i]);\n            if (unrolled \u003d\u003d null) {\n                result \u003d ArrayUtils.remove(result, i--);\n            } else {\n                result[i] \u003d unrolled;\n            }\n        }\n        return result;\n    }",
    "begin_line": 1405,
    "end_line": 1417,
    "comment": "/** \n * Local helper method to unroll variables in a type bounds array.\n * @param typeArguments assignments {@link Map}\n * @param bounds in which to expand variables\n * @return {@code bounds} with any variables reassigned\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.containsTypeVariables#1426",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.containsTypeVariables(java.lang.reflect.Type)",
    "snippet": "public static boolean containsTypeVariables(final Type type) {\n        if (type instanceof TypeVariable\u003c?\u003e) {\n            return true;\n        }\n        if (type instanceof Class\u003c?\u003e) {\n            return ((Class\u003c?\u003e) type).getTypeParameters().length \u003e 0;\n        }\n        if (type instanceof ParameterizedType) {\n            for (final Type arg : ((ParameterizedType) type).getActualTypeArguments()) {\n                if (containsTypeVariables(arg)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (type instanceof WildcardType) {\n            final WildcardType wild \u003d (WildcardType) type;\n            return containsTypeVariables(TypeUtils.getImplicitLowerBounds(wild)[0])\n                || containsTypeVariables(TypeUtils.getImplicitUpperBounds(wild)[0]);\n        }\n        return false;\n    }",
    "begin_line": 1426,
    "end_line": 1447,
    "comment": "/** \n * Learn, recursively, whether any of the type parameters associated with  {@code type} are bound to variables.\n * @param type the type to check for type variables\n * @return boolean\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.parameterize#1457",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.parameterize(java.lang.Class\u003c?\u003e, java.lang.reflect.Type)",
    "snippet": "public static final ParameterizedType parameterize(final Class\u003c?\u003e raw, final Type... typeArguments) {\n        return parameterizeWithOwner(null, raw, typeArguments);\n    }",
    "begin_line": 1457,
    "end_line": 1459,
    "comment": "/** \n * Create a parameterized type instance.\n * @param raw the raw class to create a parameterized type instance for\n * @param typeArguments the types used for parameterization\n * @return {@link ParameterizedType}\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.parameterize#1469",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.parameterize(java.lang.Class\u003c?\u003e, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "public static final ParameterizedType parameterize(final Class\u003c?\u003e raw,\n        final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeArgMappings) {\n        Validate.notNull(raw, \"raw class is null\");\n        Validate.notNull(typeArgMappings, \"typeArgMappings is null\");\n        return parameterizeWithOwner(null, raw, extractTypeArgumentsFrom(typeArgMappings, raw.getTypeParameters()));\n    }",
    "begin_line": 1469,
    "end_line": 1474,
    "comment": "/** \n * Create a parameterized type instance.\n * @param raw the raw class to create a parameterized type instance for\n * @param typeArgMappings the mapping used for parameterization\n * @return {@link ParameterizedType}\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.parameterizeWithOwner#1486",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.parameterizeWithOwner(java.lang.reflect.Type, java.lang.Class\u003c?\u003e, java.lang.reflect.Type)",
    "snippet": "public static final ParameterizedType parameterizeWithOwner(final Type owner, final Class\u003c?\u003e raw,\n        final Type... typeArguments) {\n        Validate.notNull(raw, \"raw class is null\");\n        final Type useOwner;\n        if (raw.getEnclosingClass() \u003d\u003d null) {\n            Validate.isTrue(owner \u003d\u003d null, \"no owner allowed for top-level %s\", raw);\n            useOwner \u003d null;\n        } else if (owner \u003d\u003d null) {\n            useOwner \u003d raw.getEnclosingClass();\n        } else {\n            Validate.isTrue(TypeUtils.isAssignable(owner, raw.getEnclosingClass()),\n                \"%s is invalid owner type for parameterized %s\", owner, raw);\n            useOwner \u003d owner;\n        }\n        Validate.noNullElements(typeArguments, \"null type argument at index %s\");\n        Validate.isTrue(raw.getTypeParameters().length \u003d\u003d typeArguments.length,\n            \"invalid number of type parameters specified: expected %d, got %d\", raw.getTypeParameters().length,\n            typeArguments.length);\n\n        return new ParameterizedTypeImpl(raw, useOwner, typeArguments);\n    }",
    "begin_line": 1486,
    "end_line": 1506,
    "comment": "/** \n * Create a parameterized type instance.\n * @param owner the owning type\n * @param raw the raw class to create a parameterized type instance for\n * @param typeArguments the types used for parameterization\n * @return {@link ParameterizedType}\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.parameterizeWithOwner#1517",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.parameterizeWithOwner(java.lang.reflect.Type, java.lang.Class\u003c?\u003e, java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e)",
    "snippet": "public static final ParameterizedType parameterizeWithOwner(final Type owner, final Class\u003c?\u003e raw,\n        final Map\u003cTypeVariable\u003c?\u003e, Type\u003e typeArgMappings) {\n        Validate.notNull(raw, \"raw class is null\");\n        Validate.notNull(typeArgMappings, \"typeArgMappings is null\");\n        return parameterizeWithOwner(owner, raw, extractTypeArgumentsFrom(typeArgMappings, raw.getTypeParameters()));\n    }",
    "begin_line": 1517,
    "end_line": 1522,
    "comment": "/** \n * Create a parameterized type instance.\n * @param owner the owning type\n * @param raw the raw class to create a parameterized type instance for\n * @param typeArgMappings the mapping used for parameterization\n * @return {@link ParameterizedType}\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.extractTypeArgumentsFrom#1530",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.extractTypeArgumentsFrom(java.util.Map\u003cjava.lang.reflect.TypeVariable\u003c?\u003e,java.lang.reflect.Type\u003e, java.lang.reflect.TypeVariable\u003c?\u003e[])",
    "snippet": "private static Type[] extractTypeArgumentsFrom(final Map\u003cTypeVariable\u003c?\u003e, Type\u003e mappings, final TypeVariable\u003c?\u003e[] variables) {\n        final Type[] result \u003d new Type[variables.length];\n        int index \u003d 0;\n        for (final TypeVariable\u003c?\u003e var : variables) {\n            Validate.isTrue(mappings.containsKey(var), \"missing argument mapping for %s\", toString(var));\n            result[index++] \u003d mappings.get(var);\n        }\n        return result;\n    }",
    "begin_line": 1530,
    "end_line": 1538,
    "comment": "/** \n * Helper method to establish the formal parameters for a parameterized type.\n * @param mappings map containing the assignements\n * @param variables expected map keys\n * @return array of map values corresponding to specified keys\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.wildcardType#1545",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.wildcardType()",
    "snippet": "public static WildcardTypeBuilder wildcardType() {\n        return new WildcardTypeBuilder();\n    }",
    "begin_line": 1545,
    "end_line": 1547,
    "comment": "/** \n * Get a  {@link WildcardTypeBuilder}.\n * @return {@link WildcardTypeBuilder}\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.genericArrayType#1557",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.genericArrayType(java.lang.reflect.Type)",
    "snippet": "public static GenericArrayType genericArrayType(final Type componentType) {\n        return new GenericArrayTypeImpl(Validate.notNull(componentType, \"componentType is null\"));\n    }",
    "begin_line": 1557,
    "end_line": 1559,
    "comment": "/** \n * Create a generic array type instance.\n * @param componentType the type of the elements of the array. For example the component type of {@code boolean[]}is  {@code boolean}\n * @return {@link GenericArrayType}\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.equals#1570",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.equals(java.lang.reflect.Type, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings( \"deprecation\" ) equals(final Type t1, final Type t2) {\n        if (ObjectUtils.equals(t1, t2)) {\n            return true;\n        }\n        if (t1 instanceof ParameterizedType) {\n            return equals((ParameterizedType) t1, t2);\n        }\n        if (t1 instanceof GenericArrayType) {\n            return equals((GenericArrayType) t1, t2);\n        }\n        if (t1 instanceof WildcardType) {\n            return equals((WildcardType) t1, t2);\n        }\n        return false;\n    }",
    "begin_line": 1570,
    "end_line": 1584,
    "comment": "/** \n * Check equality of types.\n * @param t1 the first type\n * @param t2 the second type\n * @return boolean\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.equals#1593",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.equals(java.lang.reflect.ParameterizedType, java.lang.reflect.Type)",
    "snippet": "private static boolean equals(final ParameterizedType p, final Type t) {\n        if (t instanceof ParameterizedType) {\n            final ParameterizedType other \u003d (ParameterizedType) t;\n            if (equals(p.getRawType(), other.getRawType()) \u0026\u0026 equals(p.getOwnerType(), other.getOwnerType())) {\n                return equals(p.getActualTypeArguments(), other.getActualTypeArguments());\n            }\n        }\n        return false;\n    }",
    "begin_line": 1593,
    "end_line": 1601,
    "comment": "/** \n * Learn whether  {@code t} equals {@code p}.\n * @param p LHS\n * @param t RHS\n * @return boolean\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.equals#1610",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.equals(java.lang.reflect.GenericArrayType, java.lang.reflect.Type)",
    "snippet": "private static boolean equals(final GenericArrayType a, final Type t) {\n        return t instanceof GenericArrayType\n            \u0026\u0026 equals(a.getGenericComponentType(), ((GenericArrayType) t).getGenericComponentType());\n    }",
    "begin_line": 1610,
    "end_line": 1613,
    "comment": "/** \n * Learn whether  {@code t} equals {@code a}.\n * @param a LHS\n * @param t RHS\n * @return boolean\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.equals#1622",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.equals(java.lang.reflect.WildcardType, java.lang.reflect.Type)",
    "snippet": "private static boolean equals(final WildcardType w, final Type t) {\n        if (t instanceof WildcardType) {\n            final WildcardType other \u003d (WildcardType) t;\n            return equals(getImplicitLowerBounds(w), getImplicitLowerBounds(other))\n                \u0026\u0026 equals(getImplicitUpperBounds(w), getImplicitUpperBounds(other));\n        }\n        return false;\n    }",
    "begin_line": 1622,
    "end_line": 1629,
    "comment": "/** \n * Learn whether  {@code t} equals {@code w}.\n * @param w LHS\n * @param t RHS\n * @return boolean\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.equals#1638",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.equals(java.lang.reflect.Type[], java.lang.reflect.Type[])",
    "snippet": "private static boolean equals(final Type[] t1, final Type[] t2) {\n        if (t1.length \u003d\u003d t2.length) {\n            for (int i \u003d 0; i \u003c t1.length; i++) {\n                if (!equals(t1[i], t2[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }",
    "begin_line": 1638,
    "end_line": 1648,
    "comment": "/** \n * Learn whether  {@code t1} equals {@code t2}.\n * @param t1 LHS\n * @param t2 RHS\n * @return boolean\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.toString#1657",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.toString(java.lang.reflect.Type)",
    "snippet": "public static String toString(final Type type) {\n        Validate.notNull(type);\n        if (type instanceof Class\u003c?\u003e) {\n            return classToString((Class\u003c?\u003e) type);\n        }\n        if (type instanceof ParameterizedType) {\n            return parameterizedTypeToString((ParameterizedType) type);\n        }\n        if (type instanceof WildcardType) {\n            return wildcardTypeToString((WildcardType) type);\n        }\n        if (type instanceof TypeVariable\u003c?\u003e) {\n            return typeVariableToString((TypeVariable\u003c?\u003e) type);\n        }\n        if (type instanceof GenericArrayType) {\n            return genericArrayTypeToString((GenericArrayType) type);\n        }\n        throw new IllegalArgumentException(ObjectUtils.identityToString(type));\n    }",
    "begin_line": 1657,
    "end_line": 1675,
    "comment": "/** \n * Present a given type as a Java-esque String.\n * @param type the type to create a String representation for, not {@code null}\n * @return String\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.toLongString#1684",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.toLongString(java.lang.reflect.TypeVariable\u003c?\u003e)",
    "snippet": "public static String toLongString(final TypeVariable\u003c?\u003e var) {\n        Validate.notNull(var, \"var is null\");\n        final StringBuilder buf \u003d new StringBuilder();\n        final GenericDeclaration d \u003d ((TypeVariable\u003c?\u003e) var).getGenericDeclaration();\n        if (d instanceof Class\u003c?\u003e) {\n            Class\u003c?\u003e c \u003d (Class\u003c?\u003e) d;\n            while (true) {\n                if (c.getEnclosingClass() \u003d\u003d null) {\n                    buf.insert(0, c.getName());\n                    break;\n                }\n                buf.insert(0, c.getSimpleName()).insert(0, \u0027.\u0027);\n                c \u003d c.getEnclosingClass();\n            }\n        } else if (d instanceof Type) {// not possible as of now\n            buf.append(toString((Type) d));\n        } else {\n            buf.append(d);\n        }\n        return buf.append(\u0027:\u0027).append(typeVariableToString(var)).toString();\n    }",
    "begin_line": 1684,
    "end_line": 1704,
    "comment": "/** \n * Format a  {@link TypeVariable} including its {@link GenericDeclaration}.\n * @param var the type variable to create a String representation for, not {@code null}\n * @return String\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.wrap#1714",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.wrap(java.lang.reflect.Type)",
    "snippet": "public static \u003cT\u003e Typed\u003cT\u003e wrap(final Type type) {\n        return new Typed\u003cT\u003e() {\n            @Override\n            public Type getType() {\n                return type;\n            }\n        };\n    }",
    "begin_line": 1714,
    "end_line": 1721,
    "comment": "/** \n * Wrap the specified  {@link Type} in a {@link Typed} wrapper.\n * @param \u003c T \u003e inferred generic type\n * @param type to wrap\n * @return Typed\u0026lt;T\u0026gt;\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.getType#1717",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.getType()",
    "snippet": "@Override\n            public Type getType() {\n                return type;\n            }",
    "begin_line": 1717,
    "end_line": 1719,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.wrap#1731",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.wrap(java.lang.Class\u003cT\u003e)",
    "snippet": "public static \u003cT\u003e Typed\u003cT\u003e wrap(final Class\u003cT\u003e type) {\n        return TypeUtils.\u003cT\u003e wrap((Type) type);\n    }",
    "begin_line": 1731,
    "end_line": 1733,
    "comment": "/** \n * Wrap the specified  {@link Class} in a {@link Typed} wrapper.\n * @param \u003c T \u003e generic type\n * @param type to wrap\n * @return Typed\u0026lt;T\u0026gt;\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.classToString#1741",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.classToString(java.lang.Class\u003c?\u003e)",
    "snippet": "private static String classToString(final Class\u003c?\u003e c) {\n        final StringBuilder buf \u003d new StringBuilder();\n\n        if (c.getEnclosingClass() !\u003d null) {\n            buf.append(classToString(c.getEnclosingClass())).append(\u0027.\u0027).append(c.getSimpleName());\n        } else {\n            buf.append(c.getName());\n        }\n        if (c.getTypeParameters().length \u003e 0) {\n            buf.append(\u0027\u003c\u0027);\n            appendAllTo(buf, \", \", c.getTypeParameters());\n            buf.append(\u0027\u003e\u0027);\n        }\n        return buf.toString();\n    }",
    "begin_line": 1741,
    "end_line": 1755,
    "comment": "/** \n * Format a  {@link Class} as a {@link String}.\n * @param c {@code Class} to format\n * @return String\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.typeVariableToString#1763",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.typeVariableToString(java.lang.reflect.TypeVariable\u003c?\u003e)",
    "snippet": "private static String typeVariableToString(final TypeVariable\u003c?\u003e v) {\n        final StringBuilder buf \u003d new StringBuilder(v.getName());\n        final Type[] bounds \u003d v.getBounds();\n        if (bounds.length \u003e 0 \u0026\u0026 !(bounds.length \u003d\u003d 1 \u0026\u0026 Object.class.equals(bounds[0]))) {\n            buf.append(\" extends \");\n            appendAllTo(buf, \" \u0026 \", v.getBounds());\n        }\n        return buf.toString();\n    }",
    "begin_line": 1763,
    "end_line": 1771,
    "comment": "/** \n * Format a  {@link TypeVariable} as a {@link String}.\n * @param v {@code TypeVariable} to format\n * @return String\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.parameterizedTypeToString#1779",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.parameterizedTypeToString(java.lang.reflect.ParameterizedType)",
    "snippet": "private static String parameterizedTypeToString(final ParameterizedType p) {\n        final StringBuilder buf \u003d new StringBuilder();\n\n        final Type useOwner \u003d p.getOwnerType();\n        final Class\u003c?\u003e raw \u003d (Class\u003c?\u003e) p.getRawType();\n        final Type[] typeArguments \u003d p.getActualTypeArguments();\n        if (useOwner \u003d\u003d null) {\n            buf.append(raw.getName());\n        } else {\n            if (useOwner instanceof Class\u003c?\u003e) {\n                buf.append(((Class\u003c?\u003e) useOwner).getName());\n            } else {\n                buf.append(useOwner.toString());\n            }\n            buf.append(\u0027.\u0027).append(raw.getSimpleName());\n        }\n\n        appendAllTo(buf.append(\u0027\u003c\u0027), \", \", typeArguments).append(\u0027\u003e\u0027);\n        return buf.toString();\n    }",
    "begin_line": 1779,
    "end_line": 1798,
    "comment": "/** \n * Format a  {@link ParameterizedType} as a {@link String}.\n * @param p {@code ParameterizedType} to format\n * @return String\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.wildcardTypeToString#1806",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.wildcardTypeToString(java.lang.reflect.WildcardType)",
    "snippet": "private static String wildcardTypeToString(final WildcardType w) {\n        final StringBuilder buf \u003d new StringBuilder().append(\u0027?\u0027);\n        final Type[] lowerBounds \u003d w.getLowerBounds();\n        final Type[] upperBounds \u003d w.getUpperBounds();\n        if (lowerBounds.length \u003e 1 || lowerBounds.length \u003d\u003d 1 \u0026\u0026 lowerBounds[0] !\u003d null) {\n            appendAllTo(buf.append(\" super \"), \" \u0026 \", lowerBounds);\n        } else if (upperBounds.length \u003e 1 || upperBounds.length \u003d\u003d 1 \u0026\u0026 !Object.class.equals(upperBounds[0])) {\n            appendAllTo(buf.append(\" extends \"), \" \u0026 \", upperBounds);\n        }\n        return buf.toString();\n    }",
    "begin_line": 1806,
    "end_line": 1816,
    "comment": "/** \n * Format a  {@link WildcardType} as a {@link String}.\n * @param w {@code WildcardType} to format\n * @return String\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.genericArrayTypeToString#1824",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.genericArrayTypeToString(java.lang.reflect.GenericArrayType)",
    "snippet": "private static String genericArrayTypeToString(final GenericArrayType g) {\n        return String.format(\"%s[]\", toString(g.getGenericComponentType()));\n    }",
    "begin_line": 1824,
    "end_line": 1826,
    "comment": "/** \n * Format a  {@link GenericArrayType} as a {@link String}.\n * @param g {@code GenericArrayType} to format\n * @return String\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "WildcardTypeImpl.appendAllTo#1836",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/reflect/TypeUtils.java",
    "class_name": "org.apache.commons.lang3.reflect.TypeUtils",
    "signature": "org.apache.commons.lang3.reflect.TypeUtils.appendAllTo(java.lang.StringBuilder, java.lang.String, java.lang.reflect.Type)",
    "snippet": "private static StringBuilder appendAllTo(final StringBuilder buf, final String sep, final Type... types) {\n        Validate.notEmpty(Validate.noNullElements(types));\n        if (types.length \u003e 0) {\n            buf.append(toString(types[0]));\n            for (int i \u003d 1; i \u003c types.length; i++) {\n                buf.append(sep).append(toString(types[i]));\n            }\n        }\n        return buf;\n    }",
    "begin_line": 1836,
    "end_line": 1845,
    "comment": "/** \n * Append  {@code types} to @{code buf} with separator {@code sep}.\n * @param buf destination\n * @param sep separator\n * @param types to append\n * @return {@code buf}\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]