[
  {
    "name": "StringUtils.StringUtils#183",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.StringUtils()",
    "snippet": "public StringUtils() {\n        super();\n    }",
    "begin_line": 183,
    "end_line": 185,
    "comment": "/** \n * \u003cp\u003e {@code StringUtils} instances should NOT be constructed instandard programming. Instead, the class should be used as {@code StringUtils.trim(\" foo \");}.\u003c/p\u003e \u003cp\u003eThis constructor is public to permit tools that require a JavaBean instance to operate.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isEmpty#208",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isEmpty(java.lang.CharSequence)",
    "snippet": "public static boolean isEmpty(final CharSequence cs) {\n        return cs \u003d\u003d null || cs.length() \u003d\u003d 0;\n    }",
    "begin_line": 208,
    "end_line": 210,
    "comment": "/** \n * \u003cp\u003eChecks if a CharSequence is empty (\"\") or null.\u003c/p\u003e \u003cpre\u003e StringUtils.isEmpty(null)      \u003d true StringUtils.isEmpty(\"\")        \u003d true StringUtils.isEmpty(\" \")       \u003d false StringUtils.isEmpty(\"bob\")     \u003d false StringUtils.isEmpty(\"  bob  \") \u003d false \u003c/pre\u003e \u003cp\u003eNOTE: This method changed in Lang version 2.0. It no longer trims the CharSequence. That functionality is available in isBlank().\u003c/p\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if the CharSequence is empty or null\n * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNotEmpty#227",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNotEmpty(java.lang.CharSequence)",
    "snippet": "public static boolean isNotEmpty(final CharSequence cs) {\n        return !isEmpty(cs);\n    }",
    "begin_line": 227,
    "end_line": 229,
    "comment": "/** \n * \u003cp\u003eChecks if a CharSequence is not empty (\"\") and not null.\u003c/p\u003e \u003cpre\u003e StringUtils.isNotEmpty(null)      \u003d false StringUtils.isNotEmpty(\"\")        \u003d false StringUtils.isNotEmpty(\" \")       \u003d true StringUtils.isNotEmpty(\"bob\")     \u003d true StringUtils.isNotEmpty(\"  bob  \") \u003d true \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if the CharSequence is not empty and not null\n * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAnyEmpty#248",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAnyEmpty(java.lang.CharSequence)",
    "snippet": "public static boolean isAnyEmpty(final CharSequence... css) {\n      if (ArrayUtils.isEmpty(css)) {\n        return true;\n      }\n      for (final CharSequence cs : css){\n        if (isEmpty(cs)) {\n          return true;\n        }\n      }\n      return false;\n    }",
    "begin_line": 248,
    "end_line": 258,
    "comment": "/** \n * \u003cp\u003eChecks if any one of the CharSequences are empty (\"\") or null.\u003c/p\u003e \u003cpre\u003e StringUtils.isAnyEmpty(null)             \u003d true StringUtils.isAnyEmpty(null, \"foo\")      \u003d true StringUtils.isAnyEmpty(\"\", \"bar\")        \u003d true StringUtils.isAnyEmpty(\"bob\", \"\")        \u003d true StringUtils.isAnyEmpty(\"  bob  \", null)  \u003d true StringUtils.isAnyEmpty(\" \", \"bar\")       \u003d false StringUtils.isAnyEmpty(\"foo\", \"bar\")     \u003d false \u003c/pre\u003e\n * @param css  the CharSequences to check, may be null or empty\n * @return {@code true} if any of the CharSequences are empty or null\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNoneEmpty#277",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNoneEmpty(java.lang.CharSequence)",
    "snippet": "public static boolean isNoneEmpty(final CharSequence... css) {\n      return !isAnyEmpty(css);\n    }",
    "begin_line": 277,
    "end_line": 279,
    "comment": "/** \n * \u003cp\u003eChecks if none of the CharSequences are empty (\"\") or null.\u003c/p\u003e \u003cpre\u003e StringUtils.isNoneEmpty(null)             \u003d false StringUtils.isNoneEmpty(null, \"foo\")      \u003d false StringUtils.isNoneEmpty(\"\", \"bar\")        \u003d false StringUtils.isNoneEmpty(\"bob\", \"\")        \u003d false StringUtils.isNoneEmpty(\"  bob  \", null)  \u003d false StringUtils.isNoneEmpty(\" \", \"bar\")       \u003d true StringUtils.isNoneEmpty(\"foo\", \"bar\")     \u003d true \u003c/pre\u003e\n * @param css  the CharSequences to check, may be null or empty\n * @return {@code true} if none of the CharSequences are empty or null\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isBlank#296",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isBlank(java.lang.CharSequence)",
    "snippet": "public static boolean isBlank(final CharSequence cs) {\n        int strLen;\n        if (cs \u003d\u003d null || (strLen \u003d cs.length()) \u003d\u003d 0) {\n            return true;\n        }\n        for (int i \u003d 0; i \u003c strLen; i++) {\n            if (Character.isWhitespace(cs.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 296,
    "end_line": 307,
    "comment": "/** \n * \u003cp\u003eChecks if a CharSequence is whitespace, empty (\"\") or null.\u003c/p\u003e \u003cpre\u003e StringUtils.isBlank(null)      \u003d true StringUtils.isBlank(\"\")        \u003d true StringUtils.isBlank(\" \")       \u003d true StringUtils.isBlank(\"bob\")     \u003d false StringUtils.isBlank(\"  bob  \") \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if the CharSequence is null, empty or whitespace\n * @since 2.0\n * @since 3.0 Changed signature from isBlank(String) to isBlank(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNotBlank#326",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNotBlank(java.lang.CharSequence)",
    "snippet": "public static boolean isNotBlank(final CharSequence cs) {\n        return !isBlank(cs);\n    }",
    "begin_line": 326,
    "end_line": 328,
    "comment": "/** \n * \u003cp\u003eChecks if a CharSequence is not empty (\"\"), not null and not whitespace only.\u003c/p\u003e \u003cpre\u003e StringUtils.isNotBlank(null)      \u003d false StringUtils.isNotBlank(\"\")        \u003d false StringUtils.isNotBlank(\" \")       \u003d false StringUtils.isNotBlank(\"bob\")     \u003d true StringUtils.isNotBlank(\"  bob  \") \u003d true \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if the CharSequence isnot empty and not null and not whitespace\n * @since 2.0\n * @since 3.0 Changed signature from isNotBlank(String) to isNotBlank(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAnyBlank#348",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAnyBlank(java.lang.CharSequence)",
    "snippet": "public static boolean isAnyBlank(final CharSequence... css) {\n      if (ArrayUtils.isEmpty(css)) {\n        return true;\n      }\n      for (final CharSequence cs : css){\n        if (isBlank(cs)) {\n          return true;\n        }\n      }\n      return false;\n    }",
    "begin_line": 348,
    "end_line": 358,
    "comment": "/** \n * \u003cp\u003eChecks if any one of the CharSequences are blank (\"\") or null and not whitespace only..\u003c/p\u003e \u003cpre\u003e StringUtils.isAnyBlank(null)             \u003d true StringUtils.isAnyBlank(null, \"foo\")      \u003d true StringUtils.isAnyBlank(null, null)       \u003d true StringUtils.isAnyBlank(\"\", \"bar\")        \u003d true StringUtils.isAnyBlank(\"bob\", \"\")        \u003d true StringUtils.isAnyBlank(\"  bob  \", null)  \u003d true StringUtils.isAnyBlank(\" \", \"bar\")       \u003d true StringUtils.isAnyBlank(\"foo\", \"bar\")     \u003d false \u003c/pre\u003e\n * @param css  the CharSequences to check, may be null or empty\n * @return {@code true} if any of the CharSequences are blank or null or whitespace only\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNoneBlank#378",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNoneBlank(java.lang.CharSequence)",
    "snippet": "public static boolean isNoneBlank(final CharSequence... css) {\n      return !isAnyBlank(css);\n    }",
    "begin_line": 378,
    "end_line": 380,
    "comment": "/** \n * \u003cp\u003eChecks if none of the CharSequences are blank (\"\") or null and whitespace only..\u003c/p\u003e \u003cpre\u003e StringUtils.isNoneBlank(null)             \u003d false StringUtils.isNoneBlank(null, \"foo\")      \u003d false StringUtils.isNoneBlank(null, null)       \u003d false StringUtils.isNoneBlank(\"\", \"bar\")        \u003d false StringUtils.isNoneBlank(\"bob\", \"\")        \u003d false StringUtils.isNoneBlank(\"  bob  \", null)  \u003d false StringUtils.isNoneBlank(\" \", \"bar\")       \u003d false StringUtils.isNoneBlank(\"foo\", \"bar\")     \u003d true \u003c/pre\u003e\n * @param css  the CharSequences to check, may be null or empty\n * @return {@code true} if none of the CharSequences are blank or null or whitespace only\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.trim#407",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.trim(java.lang.String)",
    "snippet": "public static String trim(final String str) {\n        return str \u003d\u003d null ? null : str.trim();\n    }",
    "begin_line": 407,
    "end_line": 409,
    "comment": "/** \n * \u003cp\u003eRemoves control characters (char \u0026lt;\u003d 32) from both ends of this String, handling  {@code null} by returning{@code null}.\u003c/p\u003e \u003cp\u003eThe String is trimmed using  {@link String#trim()}. Trim removes start and end characters \u0026lt;\u003d 32. To strip whitespace use  {@link #strip(String)}.\u003c/p\u003e \u003cp\u003eTo trim your choice of characters, use the {@link #strip(String,String)} methods.\u003c/p\u003e\u003cpre\u003e StringUtils.trim(null)          \u003d null StringUtils.trim(\"\")            \u003d \"\" StringUtils.trim(\"     \")       \u003d \"\" StringUtils.trim(\"abc\")         \u003d \"abc\" StringUtils.trim(\"    abc    \") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to be trimmed, may be null\n * @return the trimmed string, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.trimToNull#433",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.trimToNull(java.lang.String)",
    "snippet": "public static String trimToNull(final String str) {\n        final String ts \u003d trim(str);\n        return isEmpty(ts) ? null : ts;\n    }",
    "begin_line": 433,
    "end_line": 436,
    "comment": "/** \n * \u003cp\u003eRemoves control characters (char \u0026lt;\u003d 32) from both ends of this String returning  {@code null} if the String isempty (\"\") after the trim or if it is  {@code null}. \u003cp\u003eThe String is trimmed using  {@link String#trim()}. Trim removes start and end characters \u0026lt;\u003d 32. To strip whitespace use  {@link #stripToNull(String)}.\u003c/p\u003e \u003cpre\u003e StringUtils.trimToNull(null)          \u003d null StringUtils.trimToNull(\"\")            \u003d null StringUtils.trimToNull(\"     \")       \u003d null StringUtils.trimToNull(\"abc\")         \u003d \"abc\" StringUtils.trimToNull(\"    abc    \") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to be trimmed, may be null\n * @return the trimmed String,{@code null} if only chars \u0026lt;\u003d 32, empty or null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.trimToEmpty#459",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.trimToEmpty(java.lang.String)",
    "snippet": "public static String trimToEmpty(final String str) {\n        return str \u003d\u003d null ? EMPTY : str.trim();\n    }",
    "begin_line": 459,
    "end_line": 461,
    "comment": "/** \n * \u003cp\u003eRemoves control characters (char \u0026lt;\u003d 32) from both ends of this String returning an empty String (\"\") if the String is empty (\"\") after the trim or if it is  {@code null}. \u003cp\u003eThe String is trimmed using  {@link String#trim()}. Trim removes start and end characters \u0026lt;\u003d 32. To strip whitespace use  {@link #stripToEmpty(String)}.\u003c/p\u003e \u003cpre\u003e StringUtils.trimToEmpty(null)          \u003d \"\" StringUtils.trimToEmpty(\"\")            \u003d \"\" StringUtils.trimToEmpty(\"     \")       \u003d \"\" StringUtils.trimToEmpty(\"abc\")         \u003d \"abc\" StringUtils.trimToEmpty(\"    abc    \") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to be trimmed, may be null\n * @return the trimmed String, or an empty String if {@code null} input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.strip#487",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.strip(java.lang.String)",
    "snippet": "public static String strip(final String str) {\n        return strip(str, null);\n    }",
    "begin_line": 487,
    "end_line": 489,
    "comment": "/** \n * \u003cp\u003eStrips whitespace from the start and end of a String.\u003c/p\u003e \u003cp\u003eThis is similar to  {@link #trim(String)} but removes whitespace.Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.strip(null)     \u003d null StringUtils.strip(\"\")       \u003d \"\" StringUtils.strip(\"   \")    \u003d \"\" StringUtils.strip(\"abc\")    \u003d \"abc\" StringUtils.strip(\"  abc\")  \u003d \"abc\" StringUtils.strip(\"abc  \")  \u003d \"abc\" StringUtils.strip(\" abc \")  \u003d \"abc\" StringUtils.strip(\" ab c \") \u003d \"ab c\" \u003c/pre\u003e\n * @param str  the String to remove whitespace from, may be null\n * @return the stripped String, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripToNull#514",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripToNull(java.lang.String)",
    "snippet": "public static String stripToNull(String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        str \u003d strip(str, null);\n        return str.isEmpty() ? null : str;\n    }",
    "begin_line": 514,
    "end_line": 520,
    "comment": "/** \n * \u003cp\u003eStrips whitespace from the start and end of a String  returning {@code null} if the String is empty (\"\") after the strip.\u003c/p\u003e\u003cp\u003eThis is similar to  {@link #trimToNull(String)} but removes whitespace.Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripToNull(null)     \u003d null StringUtils.stripToNull(\"\")       \u003d null StringUtils.stripToNull(\"   \")    \u003d null StringUtils.stripToNull(\"abc\")    \u003d \"abc\" StringUtils.stripToNull(\"  abc\")  \u003d \"abc\" StringUtils.stripToNull(\"abc  \")  \u003d \"abc\" StringUtils.stripToNull(\" abc \")  \u003d \"abc\" StringUtils.stripToNull(\" ab c \") \u003d \"ab c\" \u003c/pre\u003e\n * @param str  the String to be stripped, may be null\n * @return the stripped String,{@code null} if whitespace, empty or null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripToEmpty#544",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripToEmpty(java.lang.String)",
    "snippet": "public static String stripToEmpty(final String str) {\n        return str \u003d\u003d null ? EMPTY : strip(str, null);\n    }",
    "begin_line": 544,
    "end_line": 546,
    "comment": "/** \n * \u003cp\u003eStrips whitespace from the start and end of a String  returning an empty String if  {@code null} input.\u003c/p\u003e\u003cp\u003eThis is similar to  {@link #trimToEmpty(String)} but removes whitespace.Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripToEmpty(null)     \u003d \"\" StringUtils.stripToEmpty(\"\")       \u003d \"\" StringUtils.stripToEmpty(\"   \")    \u003d \"\" StringUtils.stripToEmpty(\"abc\")    \u003d \"abc\" StringUtils.stripToEmpty(\"  abc\")  \u003d \"abc\" StringUtils.stripToEmpty(\"abc  \")  \u003d \"abc\" StringUtils.stripToEmpty(\" abc \")  \u003d \"abc\" StringUtils.stripToEmpty(\" ab c \") \u003d \"ab c\" \u003c/pre\u003e\n * @param str  the String to be stripped, may be null\n * @return the trimmed String, or an empty String if {@code null} input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.strip#574",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.strip(java.lang.String, java.lang.String)",
    "snippet": "public static String strip(String str, final String stripChars) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        str \u003d stripStart(str, stripChars);\n        return stripEnd(str, stripChars);\n    }",
    "begin_line": 574,
    "end_line": 580,
    "comment": "/** \n * \u003cp\u003eStrips any of a set of characters from the start and end of a String. This is similar to  {@link String#trim()} but allows the charactersto be stripped to be controlled.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. An empty string (\"\") input returns the empty string.\u003c/p\u003e \u003cp\u003eIf the stripChars String is  {@code null}, whitespace is stripped as defined by  {@link Character#isWhitespace(char)}. Alternatively use  {@link #strip(String)}.\u003c/p\u003e \u003cpre\u003e StringUtils.strip(null, *)          \u003d null StringUtils.strip(\"\", *)            \u003d \"\" StringUtils.strip(\"abc\", null)      \u003d \"abc\" StringUtils.strip(\"  abc\", null)    \u003d \"abc\" StringUtils.strip(\"abc  \", null)    \u003d \"abc\" StringUtils.strip(\" abc \", null)    \u003d \"abc\" StringUtils.strip(\"  abcyx\", \"xyz\") \u003d \"  abc\" \u003c/pre\u003e\n * @param str  the String to remove characters from, may be null\n * @param stripChars  the characters to remove, null treated as whitespace\n * @return the stripped String, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripStart#606",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripStart(java.lang.String, java.lang.String)",
    "snippet": "public static String stripStart(final String str, final String stripChars) {\n        int strLen;\n        if (str \u003d\u003d null || (strLen \u003d str.length()) \u003d\u003d 0) {\n            return str;\n        }\n        int start \u003d 0;\n        if (stripChars \u003d\u003d null) {\n            while (start !\u003d strLen \u0026\u0026 Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.isEmpty()) {\n            return str;\n        } else {\n            while (start !\u003d strLen \u0026\u0026 stripChars.indexOf(str.charAt(start)) !\u003d INDEX_NOT_FOUND) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }",
    "begin_line": 606,
    "end_line": 624,
    "comment": "/** \n * \u003cp\u003eStrips any of a set of characters from the start of a String.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. An empty string (\"\") input returns the empty string.\u003c/p\u003e \u003cp\u003eIf the stripChars String is  {@code null}, whitespace is stripped as defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripStart(null, *)          \u003d null StringUtils.stripStart(\"\", *)            \u003d \"\" StringUtils.stripStart(\"abc\", \"\")        \u003d \"abc\" StringUtils.stripStart(\"abc\", null)      \u003d \"abc\" StringUtils.stripStart(\"  abc\", null)    \u003d \"abc\" StringUtils.stripStart(\"abc  \", null)    \u003d \"abc  \" StringUtils.stripStart(\" abc \", null)    \u003d \"abc \" StringUtils.stripStart(\"yxabc  \", \"xyz\") \u003d \"abc  \" \u003c/pre\u003e\n * @param str  the String to remove characters from, may be null\n * @param stripChars  the characters to remove, null treated as whitespace\n * @return the stripped String, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripEnd#651",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripEnd(java.lang.String, java.lang.String)",
    "snippet": "public static String stripEnd(final String str, final String stripChars) {\n        int end;\n        if (str \u003d\u003d null || (end \u003d str.length()) \u003d\u003d 0) {\n            return str;\n        }\n\n        if (stripChars \u003d\u003d null) {\n            while (end !\u003d 0 \u0026\u0026 Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.isEmpty()) {\n            return str;\n        } else {\n            while (end !\u003d 0 \u0026\u0026 stripChars.indexOf(str.charAt(end - 1)) !\u003d INDEX_NOT_FOUND) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }",
    "begin_line": 651,
    "end_line": 669,
    "comment": "/** \n * \u003cp\u003eStrips any of a set of characters from the end of a String.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. An empty string (\"\") input returns the empty string.\u003c/p\u003e \u003cp\u003eIf the stripChars String is  {@code null}, whitespace is stripped as defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripEnd(null, *)          \u003d null StringUtils.stripEnd(\"\", *)            \u003d \"\" StringUtils.stripEnd(\"abc\", \"\")        \u003d \"abc\" StringUtils.stripEnd(\"abc\", null)      \u003d \"abc\" StringUtils.stripEnd(\"  abc\", null)    \u003d \"  abc\" StringUtils.stripEnd(\"abc  \", null)    \u003d \"abc\" StringUtils.stripEnd(\" abc \", null)    \u003d \" abc\" StringUtils.stripEnd(\"  abcyx\", \"xyz\") \u003d \"  abc\" StringUtils.stripEnd(\"120.00\", \".0\")   \u003d \"12\" \u003c/pre\u003e\n * @param str  the String to remove characters from, may be null\n * @param stripChars  the set of characters to remove, null treated as whitespace\n * @return the stripped String, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripAll#692",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripAll(java.lang.String)",
    "snippet": "public static String[] stripAll(final String... strs) {\n        return stripAll(strs, null);\n    }",
    "begin_line": 692,
    "end_line": 694,
    "comment": "/** \n * \u003cp\u003eStrips whitespace from the start and end of every String in an array. Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eA new array is returned each time, except for length zero. A  {@code null} array will return {@code null}. An empty array will return itself. A  {@code null} array entry will be ignored.\u003c/p\u003e\u003cpre\u003e StringUtils.stripAll(null)             \u003d null StringUtils.stripAll([])               \u003d [] StringUtils.stripAll([\"abc\", \"  abc\"]) \u003d [\"abc\", \"abc\"] StringUtils.stripAll([\"abc  \", null])  \u003d [\"abc\", null] \u003c/pre\u003e\n * @param strs  the array to remove whitespace from, may be null\n * @return the stripped Strings, {@code null} if null array input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripAll#721",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripAll(java.lang.String[], java.lang.String)",
    "snippet": "public static String[] stripAll(final String[] strs, final String stripChars) {\n        int strsLen;\n        if (strs \u003d\u003d null || (strsLen \u003d strs.length) \u003d\u003d 0) {\n            return strs;\n        }\n        final String[] newArr \u003d new String[strsLen];\n        for (int i \u003d 0; i \u003c strsLen; i++) {\n            newArr[i] \u003d strip(strs[i], stripChars);\n        }\n        return newArr;\n    }",
    "begin_line": 721,
    "end_line": 731,
    "comment": "/** \n * \u003cp\u003eStrips any of a set of characters from the start and end of every String in an array.\u003c/p\u003e \u003cp\u003eWhitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eA new array is returned each time, except for length zero. A  {@code null} array will return {@code null}. An empty array will return itself. A  {@code null} array entry will be ignored.A  {@code null} stripChars will strip whitespace as defined by{@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.stripAll(null, *)                \u003d null StringUtils.stripAll([], *)                  \u003d [] StringUtils.stripAll([\"abc\", \"  abc\"], null) \u003d [\"abc\", \"abc\"] StringUtils.stripAll([\"abc  \", null], null)  \u003d [\"abc\", null] StringUtils.stripAll([\"abc  \", null], \"yz\")  \u003d [\"abc  \", null] StringUtils.stripAll([\"yabcz\", null], \"yz\")  \u003d [\"abc\", null] \u003c/pre\u003e\n * @param strs  the array to remove characters from, may be null\n * @param stripChars  the characters to remove, null treated as whitespace\n * @return the stripped Strings, {@code null} if null array input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.stripAccents#751",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.stripAccents(java.lang.String)",
    "snippet": " stripAccents(final String input) {\n        if(input \u003d\u003d null) {\n            return null;\n        }\n        final Pattern pattern \u003d Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");//$NON-NLS-1$\n        final String decomposed \u003d Normalizer.normalize(input, Normalizer.Form.NFD);\n        // Note that this doesn\u0027t correctly remove ligatures...\n        return pattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n    }",
    "begin_line": 751,
    "end_line": 759,
    "comment": "/** \n * \u003cp\u003eRemoves diacritics (~\u003d accents) from a string. The case will not be altered.\u003c/p\u003e \u003cp\u003eFor instance, \u0027\u0026agrave;\u0027 will be replaced by \u0027a\u0027.\u003c/p\u003e \u003cp\u003eNote that ligatures will be left as is.\u003c/p\u003e \u003cpre\u003e StringUtils.stripAccents(null)                \u003d null StringUtils.stripAccents(\"\")                  \u003d \"\" StringUtils.stripAccents(\"control\")           \u003d \"control\" StringUtils.stripAccents(\"\u0026eacute;clair\")     \u003d \"eclair\" \u003c/pre\u003e\n * @param input String to be stripped\n * @return input text with diacritics removed\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.equals#784",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.equals(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 \u003d\u003d cs2) {\n            return true;\n        }\n        if (cs1 \u003d\u003d null || cs2 \u003d\u003d null) {\n            return false;\n        }\n        if (cs1.length() !\u003d cs2.length()) {\n            return false;\n        }\n        if (cs1 instanceof String \u0026\u0026 cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n    }",
    "begin_line": 784,
    "end_line": 798,
    "comment": "/** \n * \u003cp\u003eCompares two CharSequences, returning  {@code true} if they representequal sequences of characters.\u003c/p\u003e \u003cp\u003e {@code null}s are handled without exceptions. Two  {@code null}references are considered to be equal. The comparison is case sensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.equals(null, null)   \u003d true StringUtils.equals(null, \"abc\")  \u003d false StringUtils.equals(\"abc\", null)  \u003d false StringUtils.equals(\"abc\", \"abc\") \u003d true StringUtils.equals(\"abc\", \"ABC\") \u003d false \u003c/pre\u003e\n * @see Object#equals(Object)\n * @param cs1  the first CharSequence, may be {@code null}\n * @param cs2  the second CharSequence, may be {@code null}\n * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.equalsIgnoreCase#821",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.equalsIgnoreCase(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {\n        if (str1 \u003d\u003d null || str2 \u003d\u003d null) {\n            return str1 \u003d\u003d str2;\n        } else if (str1 \u003d\u003d str2) {\n            return true;\n        } else if (str1.length() !\u003d str2.length()) {\n            return false;\n        } else {\n            return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());\n        }\n    }",
    "begin_line": 821,
    "end_line": 831,
    "comment": "/** \n * \u003cp\u003eCompares two CharSequences, returning  {@code true} if they representequal sequences of characters, ignoring case.\u003c/p\u003e \u003cp\u003e {@code null}s are handled without exceptions. Two  {@code null}references are considered equal. Comparison is case insensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.equalsIgnoreCase(null, null)   \u003d true StringUtils.equalsIgnoreCase(null, \"abc\")  \u003d false StringUtils.equalsIgnoreCase(\"abc\", null)  \u003d false StringUtils.equalsIgnoreCase(\"abc\", \"abc\") \u003d true StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") \u003d true \u003c/pre\u003e\n * @param str1  the first CharSequence, may be null\n * @param str2  the second CharSequence, may be null\n * @return {@code true} if the CharSequence are equal, case insensitive, orboth  {@code null}\n * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.compare#867",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.compare(java.lang.String, java.lang.String)",
    "snippet": "public static int compare(final String str1, final String str2) {\n        return compare(str1, str2, true);\n    }",
    "begin_line": 867,
    "end_line": 869,
    "comment": "/** \n * \u003cp\u003eCompare two Strings lexicographically, as per  {@link String#compareTo(String)}, returning :\u003c/p\u003e \u003cul\u003e \u003cli\u003e {@code int \u003d 0}, if  {@code str1} is equal to {@code str2} (or both {@code null})\u003c/li\u003e \u003cli\u003e {@code int \u003c 0}, if  {@code str1} is less than {@code str2}\u003c/li\u003e \u003cli\u003e {@code int \u003e 0}, if  {@code str1} is greater than {@code str2}\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eThis is a  {@code null} safe version of :\u003c/p\u003e\u003cblockquote\u003e\u003cpre\u003estr1.compareTo(str2)\u003c/pre\u003e\u003c/blockquote\u003e \u003cp\u003e {@code null} value is considered less than non-{@code null} value.Two  {@code null} references are considered equal.\u003c/p\u003e\u003cpre\u003e StringUtils.compare(null, null)   \u003d 0 StringUtils.compare(null , \"a\")   \u0026lt; 0 StringUtils.compare(\"a\", null)    \u0026gt; 0 StringUtils.compare(\"abc\", \"abc\") \u003d 0 StringUtils.compare(\"a\", \"b\")     \u0026lt; 0 StringUtils.compare(\"b\", \"a\")     \u0026gt; 0 StringUtils.compare(\"a\", \"B\")     \u0026gt; 0 StringUtils.compare(\"ab\", \"abc\")  \u0026lt; 0 \u003c/pre\u003e\n * @see #compare(String,String,boolean)\n * @see String#compareTo(String)\n * @param str1  the String to compare from\n * @param str2  the String to compare to\n * @return \u0026lt; 0, 0, \u0026gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2}\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.compare#905",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.compare(java.lang.String, java.lang.String, boolean)",
    "snippet": "public static int compare(final String str1, final String str2, final boolean nullIsLess) {\n        if (str1 \u003d\u003d str2) {\n            return 0;\n        }\n        if (str1 \u003d\u003d null) {\n            return nullIsLess ? -1 : 1;\n        }\n        if (str2 \u003d\u003d null) {\n            return nullIsLess ? 1 : - 1;\n        }\n        return str1.compareTo(str2);\n    }",
    "begin_line": 905,
    "end_line": 916,
    "comment": "/** \n * \u003cp\u003eCompare two Strings lexicographically, as per  {@link String#compareTo(String)}, returning :\u003c/p\u003e \u003cul\u003e \u003cli\u003e {@code int \u003d 0}, if  {@code str1} is equal to {@code str2} (or both {@code null})\u003c/li\u003e \u003cli\u003e {@code int \u003c 0}, if  {@code str1} is less than {@code str2}\u003c/li\u003e \u003cli\u003e {@code int \u003e 0}, if  {@code str1} is greater than {@code str2}\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eThis is a  {@code null} safe version of :\u003c/p\u003e\u003cblockquote\u003e\u003cpre\u003estr1.compareTo(str2)\u003c/pre\u003e\u003c/blockquote\u003e \u003cp\u003e {@code null} inputs are handled according to the {@code nullIsLess} parameter.Two  {@code null} references are considered equal.\u003c/p\u003e\u003cpre\u003e StringUtils.compare(null, null, *)     \u003d 0 StringUtils.compare(null , \"a\", true)  \u0026lt; 0 StringUtils.compare(null , \"a\", false) \u0026gt; 0 StringUtils.compare(\"a\", null, true)   \u0026gt; 0 StringUtils.compare(\"a\", null, false)  \u0026lt; 0 StringUtils.compare(\"abc\", \"abc\", *)   \u003d 0 StringUtils.compare(\"a\", \"b\", *)       \u0026lt; 0 StringUtils.compare(\"b\", \"a\", *)       \u0026gt; 0 StringUtils.compare(\"a\", \"B\", *)       \u0026gt; 0 StringUtils.compare(\"ab\", \"abc\", *)    \u0026lt; 0 \u003c/pre\u003e\n * @see String#compareTo(String)\n * @param str1  the String to compare from\n * @param str2  the String to compare to\n * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value\n * @return \u0026lt; 0, 0, \u0026gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2}\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.compareIgnoreCase#955",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.compareIgnoreCase(java.lang.String, java.lang.String)",
    "snippet": "public static int compareIgnoreCase(final String str1, final String str2) {\n        return compareIgnoreCase(str1, str2, true);\n    }",
    "begin_line": 955,
    "end_line": 957,
    "comment": "/** \n * \u003cp\u003eCompare two Strings lexicographically, ignoring case differences, as per  {@link String#compareToIgnoreCase(String)}, returning :\u003c/p\u003e \u003cul\u003e \u003cli\u003e {@code int \u003d 0}, if  {@code str1} is equal to {@code str2} (or both {@code null})\u003c/li\u003e \u003cli\u003e {@code int \u003c 0}, if  {@code str1} is less than {@code str2}\u003c/li\u003e \u003cli\u003e {@code int \u003e 0}, if  {@code str1} is greater than {@code str2}\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eThis is a  {@code null} safe version of :\u003c/p\u003e\u003cblockquote\u003e\u003cpre\u003estr1.compareToIgnoreCase(str2)\u003c/pre\u003e\u003c/blockquote\u003e \u003cp\u003e {@code null} value is considered less than non-{@code null} value.Two  {@code null} references are considered equal.Comparison is case insensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.compareIgnoreCase(null, null)   \u003d 0 StringUtils.compareIgnoreCase(null , \"a\")   \u0026lt; 0 StringUtils.compareIgnoreCase(\"a\", null)    \u0026gt; 0 StringUtils.compareIgnoreCase(\"abc\", \"abc\") \u003d 0 StringUtils.compareIgnoreCase(\"abc\", \"ABC\") \u003d 0 StringUtils.compareIgnoreCase(\"a\", \"b\")     \u0026lt; 0 StringUtils.compareIgnoreCase(\"b\", \"a\")     \u0026gt; 0 StringUtils.compareIgnoreCase(\"a\", \"B\")     \u0026lt; 0 StringUtils.compareIgnoreCase(\"A\", \"b\")     \u0026lt; 0 StringUtils.compareIgnoreCase(\"ab\", \"ABC\")  \u0026lt; 0 \u003c/pre\u003e\n * @see #compareIgnoreCase(String,String,boolean)\n * @see String#compareToIgnoreCase(String)\n * @param str1  the String to compare from\n * @param str2  the String to compare to\n * @return \u0026lt; 0, 0, \u0026gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2}, ignoring case differences.\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.compareIgnoreCase#998",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.compareIgnoreCase(java.lang.String, java.lang.String, boolean)",
    "snippet": "public static int compareIgnoreCase(final String str1, final String str2, final boolean nullIsLess) {\n        if (str1 \u003d\u003d str2) {\n            return 0;\n        }\n        if (str1 \u003d\u003d null) {\n            return nullIsLess ? -1 : 1;\n        }\n        if (str2 \u003d\u003d null) {\n            return nullIsLess ? 1 : - 1;\n        }\n        return str1.compareToIgnoreCase(str2);\n    }",
    "begin_line": 998,
    "end_line": 1009,
    "comment": "/** \n * \u003cp\u003eCompare two Strings lexicographically, ignoring case differences, as per  {@link String#compareToIgnoreCase(String)}, returning :\u003c/p\u003e \u003cul\u003e \u003cli\u003e {@code int \u003d 0}, if  {@code str1} is equal to {@code str2} (or both {@code null})\u003c/li\u003e \u003cli\u003e {@code int \u003c 0}, if  {@code str1} is less than {@code str2}\u003c/li\u003e \u003cli\u003e {@code int \u003e 0}, if  {@code str1} is greater than {@code str2}\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eThis is a  {@code null} safe version of :\u003c/p\u003e\u003cblockquote\u003e\u003cpre\u003estr1.compareToIgnoreCase(str2)\u003c/pre\u003e\u003c/blockquote\u003e \u003cp\u003e {@code null} inputs are handled according to the {@code nullIsLess} parameter.Two  {@code null} references are considered equal.Comparison is case insensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.compareIgnoreCase(null, null, *)     \u003d 0 StringUtils.compareIgnoreCase(null , \"a\", true)  \u0026lt; 0 StringUtils.compareIgnoreCase(null , \"a\", false) \u0026gt; 0 StringUtils.compareIgnoreCase(\"a\", null, true)   \u0026gt; 0 StringUtils.compareIgnoreCase(\"a\", null, false)  \u0026lt; 0 StringUtils.compareIgnoreCase(\"abc\", \"abc\", *)   \u003d 0 StringUtils.compareIgnoreCase(\"abc\", \"ABC\", *)   \u003d 0 StringUtils.compareIgnoreCase(\"a\", \"b\", *)       \u0026lt; 0 StringUtils.compareIgnoreCase(\"b\", \"a\", *)       \u0026gt; 0 StringUtils.compareIgnoreCase(\"a\", \"B\", *)       \u0026lt; 0 StringUtils.compareIgnoreCase(\"A\", \"b\", *)       \u0026lt; 0 StringUtils.compareIgnoreCase(\"ab\", \"abc\", *)    \u0026lt; 0 \u003c/pre\u003e\n * @see String#compareToIgnoreCase(String)\n * @param str1  the String to compare from\n * @param str2  the String to compare to\n * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value\n * @return \u0026lt; 0, 0, \u0026gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2}, ignoring case differences.\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOf#1033",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOf(java.lang.CharSequence, int)",
    "snippet": "public static int indexOf(final CharSequence seq, final int searchChar) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchChar, 0);\n    }",
    "begin_line": 1033,
    "end_line": 1038,
    "comment": "/** \n * \u003cp\u003eFinds the first index within a CharSequence, handling  {@code null}. This method uses  {@link String#indexOf(int,int)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} or empty (\"\") CharSequence will return {@code INDEX_NOT_FOUND (-1)}.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOf(null, *)         \u003d -1 StringUtils.indexOf(\"\", *)           \u003d -1 StringUtils.indexOf(\"aabaabaa\", \u0027a\u0027) \u003d 0 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027) \u003d 2 \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchChar  the character to find\n * @return the first index of the search character,-1 if no match or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from indexOf(String, int) to indexOf(CharSequence, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOf#1066",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOf(java.lang.CharSequence, int, int)",
    "snippet": "public static int indexOf(final CharSequence seq, final int searchChar, final int startPos) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchChar, startPos);\n    }",
    "begin_line": 1066,
    "end_line": 1071,
    "comment": "/** \n * \u003cp\u003eFinds the first index within a CharSequence from a start position, handling  {@code null}. This method uses  {@link String#indexOf(int,int)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} or empty (\"\") CharSequence will return {@code (INDEX_NOT_FOUND) -1}. A negative start position is treated as zero. A start position greater than the string length returns  {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOf(null, *, *)          \u003d -1 StringUtils.indexOf(\"\", *, *)            \u003d -1 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027, 0)  \u003d 2 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027, 3)  \u003d 5 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027, 9)  \u003d -1 StringUtils.indexOf(\"aabaabaa\", \u0027b\u0027, -1) \u003d 2 \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchChar  the character to find\n * @param startPos  the start position, negative treated as zero\n * @return the first index of the search character (always \u0026ge; startPos),-1 if no match or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from indexOf(String, int, int) to indexOf(CharSequence, int, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOf#1097",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOf(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int indexOf(final CharSequence seq, final CharSequence searchSeq) {\n        if (seq \u003d\u003d null || searchSeq \u003d\u003d null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchSeq, 0);\n    }",
    "begin_line": 1097,
    "end_line": 1102,
    "comment": "/** \n * \u003cp\u003eFinds the first index within a CharSequence, handling  {@code null}. This method uses  {@link String#indexOf(String,int)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} CharSequence will return {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOf(null, *)          \u003d -1 StringUtils.indexOf(*, null)          \u003d -1 StringUtils.indexOf(\"\", \"\")           \u003d 0 StringUtils.indexOf(\"\", *)            \u003d -1 (except when * \u003d \"\") StringUtils.indexOf(\"aabaabaa\", \"a\")  \u003d 0 StringUtils.indexOf(\"aabaabaa\", \"b\")  \u003d 2 StringUtils.indexOf(\"aabaabaa\", \"ab\") \u003d 1 StringUtils.indexOf(\"aabaabaa\", \"\")   \u003d 0 \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchSeq  the CharSequence to find, may be null\n * @return the first index of the search CharSequence,-1 if no match or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOf#1137",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOf(java.lang.CharSequence, java.lang.CharSequence, int)",
    "snippet": "public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {\n        if (seq \u003d\u003d null || searchSeq \u003d\u003d null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.indexOf(seq, searchSeq, startPos);\n    }",
    "begin_line": 1137,
    "end_line": 1142,
    "comment": "/** \n * \u003cp\u003eFinds the first index within a CharSequence, handling  {@code null}. This method uses  {@link String#indexOf(String,int)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A negative start position is treated as zero. An empty (\"\") search CharSequence always matches. A start position greater than the string length only matches an empty search CharSequence.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOf(null, *, *)          \u003d -1 StringUtils.indexOf(*, null, *)          \u003d -1 StringUtils.indexOf(\"\", \"\", 0)           \u003d 0 StringUtils.indexOf(\"\", *, 0)            \u003d -1 (except when * \u003d \"\") StringUtils.indexOf(\"aabaabaa\", \"a\", 0)  \u003d 0 StringUtils.indexOf(\"aabaabaa\", \"b\", 0)  \u003d 2 StringUtils.indexOf(\"aabaabaa\", \"ab\", 0) \u003d 1 StringUtils.indexOf(\"aabaabaa\", \"b\", 3)  \u003d 5 StringUtils.indexOf(\"aabaabaa\", \"b\", 9)  \u003d -1 StringUtils.indexOf(\"aabaabaa\", \"b\", -1) \u003d 2 StringUtils.indexOf(\"aabaabaa\", \"\", 2)   \u003d 2 StringUtils.indexOf(\"abc\", \"\", 9)        \u003d 3 \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchSeq  the CharSequence to find, may be null\n * @param startPos  the start position, negative treated as zero\n * @return the first index of the search CharSequence (always \u0026ge; startPos),-1 if no match or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from indexOf(String, String, int) to indexOf(CharSequence, CharSequence, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.ordinalIndexOf#1178",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.ordinalIndexOf(java.lang.CharSequence, java.lang.CharSequence, int)",
    "snippet": "public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, false);\n    }",
    "begin_line": 1178,
    "end_line": 1180,
    "comment": "/** \n * \u003cp\u003eFinds the n-th index within a CharSequence, handling  {@code null}. This method uses  {@link String#indexOf(String)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} CharSequence will return {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.ordinalIndexOf(null, *, *)          \u003d -1 StringUtils.ordinalIndexOf(*, null, *)          \u003d -1 StringUtils.ordinalIndexOf(\"\", \"\", *)           \u003d 0 StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1)  \u003d 0 StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2)  \u003d 1 StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1)  \u003d 2 StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2)  \u003d 5 StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1) \u003d 1 StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2) \u003d 4 StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1)   \u003d 0 StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2)   \u003d 0 \u003c/pre\u003e \u003cp\u003eNote that \u0027head(CharSequence str, int n)\u0027 may be implemented as: \u003c/p\u003e \u003cpre\u003e str.substring(0, lastOrdinalIndexOf(str, \"\\n\", n)) \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @param ordinal  the n-th {@code searchStr} to find\n * @return the n-th index of the search CharSequence,{@code -1} ({@code INDEX_NOT_FOUND}) if no match or  {@code null} string input\n * @since 2.1\n * @since 3.0 Changed signature from ordinalIndexOf(String, String, int) to ordinalIndexOf(CharSequence, CharSequence, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.ordinalIndexOf#1196",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.ordinalIndexOf(java.lang.CharSequence, java.lang.CharSequence, int, boolean)",
    "snippet": " ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null || ordinal \u003c\u003d 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() \u003d\u003d 0) {\n            return lastIndex ? str.length() : 0;\n        }\n        int found \u003d 0;\n        int index \u003d lastIndex ? str.length() : INDEX_NOT_FOUND;\n        do {\n            if (lastIndex) {\n                index \u003d CharSequenceUtils.lastIndexOf(str, searchStr, index - searchStr.length());\n            } else {\n                index \u003d CharSequenceUtils.indexOf(str, searchStr, index + searchStr.length());\n            }\n            if (index \u003c 0) {\n                return index;\n            }\n            found++;\n        } while (found \u003c ordinal);\n        return index;\n    }",
    "begin_line": 1196,
    "end_line": 1217,
    "comment": "/** \n * \u003cp\u003eFinds the n-th index within a String, handling  {@code null}. This method uses  {@link String#indexOf(String)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} CharSequence will return {@code -1}.\u003c/p\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @param ordinal  the n-th {@code searchStr} to find\n * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()\n * @return the n-th index of the search CharSequence,{@code -1} ({@code INDEX_NOT_FOUND}) if no match or  {@code null} string input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfIgnoreCase#1244",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfIgnoreCase(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) {\n        return indexOfIgnoreCase(str, searchStr, 0);\n    }",
    "begin_line": 1244,
    "end_line": 1246,
    "comment": "/** \n * \u003cp\u003eCase in-sensitive find of the first index within a CharSequence.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A negative start position is treated as zero. An empty (\"\") search CharSequence always matches. A start position greater than the string length only matches an empty search CharSequence.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfIgnoreCase(null, *)          \u003d -1 StringUtils.indexOfIgnoreCase(*, null)          \u003d -1 StringUtils.indexOfIgnoreCase(\"\", \"\")           \u003d 0 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"a\")  \u003d 0 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"b\")  \u003d 2 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"ab\") \u003d 1 \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @return the first index of the search CharSequence,-1 if no match or  {@code null} string input\n * @since 2.5\n * @since 3.0 Changed signature from indexOfIgnoreCase(String, String) to indexOfIgnoreCase(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfIgnoreCase#1280",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfIgnoreCase(java.lang.CharSequence, java.lang.CharSequence, int)",
    "snippet": "public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos \u003c 0) {\n            startPos \u003d 0;\n        }\n        final int endLimit \u003d str.length() - searchStr.length() + 1;\n        if (startPos \u003e endLimit) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() \u003d\u003d 0) {\n            return startPos;\n        }\n        for (int i \u003d startPos; i \u003c endLimit; i++) {\n            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }",
    "begin_line": 1280,
    "end_line": 1300,
    "comment": "/** \n * \u003cp\u003eCase in-sensitive find of the first index within a CharSequence from the specified position.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A negative start position is treated as zero. An empty (\"\") search CharSequence always matches. A start position greater than the string length only matches an empty search CharSequence.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfIgnoreCase(null, *, *)          \u003d -1 StringUtils.indexOfIgnoreCase(*, null, *)          \u003d -1 StringUtils.indexOfIgnoreCase(\"\", \"\", 0)           \u003d 0 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  \u003d 0 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  \u003d 2 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"AB\", 0) \u003d 1 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 3)  \u003d 5 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  \u003d -1 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", -1) \u003d 2 StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"\", 2)   \u003d 2 StringUtils.indexOfIgnoreCase(\"abc\", \"\", 9)        \u003d 3 \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @param startPos  the start position, negative treated as zero\n * @return the first index of the search CharSequence (always \u0026ge; startPos),-1 if no match or  {@code null} string input\n * @since 2.5\n * @since 3.0 Changed signature from indexOfIgnoreCase(String, String, int) to indexOfIgnoreCase(CharSequence, CharSequence, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOf#1324",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOf(java.lang.CharSequence, int)",
    "snippet": "public static int lastIndexOf(final CharSequence seq, final int searchChar) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());\n    }",
    "begin_line": 1324,
    "end_line": 1329,
    "comment": "/** \n * \u003cp\u003eFinds the last index within a CharSequence, handling  {@code null}. This method uses  {@link String#lastIndexOf(int)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} or empty (\"\") CharSequence will return {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOf(null, *)         \u003d -1 StringUtils.lastIndexOf(\"\", *)           \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \u0027a\u0027) \u003d 7 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027) \u003d 5 \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchChar  the character to find\n * @return the last index of the search character,-1 if no match or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOf#1362",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOf(java.lang.CharSequence, int, int)",
    "snippet": "public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) {\n        if (isEmpty(seq)) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);\n    }",
    "begin_line": 1362,
    "end_line": 1367,
    "comment": "/** \n * \u003cp\u003eFinds the last index within a CharSequence from a start position, handling  {@code null}. This method uses  {@link String#lastIndexOf(int,int)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} or empty (\"\") CharSequence will return {@code -1}. A negative start position returns  {@code -1}. A start position greater than the string length searches the whole string. The search starts at the startPos and works backwards; matches starting after the start position are ignored. \u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOf(null, *, *)          \u003d -1 StringUtils.lastIndexOf(\"\", *,  *)           \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, 8)  \u003d 5 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, 4)  \u003d 2 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, 0)  \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, 9)  \u003d 5 StringUtils.lastIndexOf(\"aabaabaa\", \u0027b\u0027, -1) \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \u0027a\u0027, 0)  \u003d 0 \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchChar  the character to find\n * @param startPos  the start position\n * @return the last index of the search character (always \u0026le; startPos),-1 if no match or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOf#1392",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOf(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq) {\n        if (seq \u003d\u003d null || searchSeq \u003d\u003d null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchSeq, seq.length());\n    }",
    "begin_line": 1392,
    "end_line": 1397,
    "comment": "/** \n * \u003cp\u003eFinds the last index within a CharSequence, handling  {@code null}. This method uses  {@link String#lastIndexOf(String)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} CharSequence will return {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOf(null, *)          \u003d -1 StringUtils.lastIndexOf(*, null)          \u003d -1 StringUtils.lastIndexOf(\"\", \"\")           \u003d 0 StringUtils.lastIndexOf(\"aabaabaa\", \"a\")  \u003d 7 StringUtils.lastIndexOf(\"aabaabaa\", \"b\")  \u003d 5 StringUtils.lastIndexOf(\"aabaabaa\", \"ab\") \u003d 4 StringUtils.lastIndexOf(\"aabaabaa\", \"\")   \u003d 8 \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchSeq  the CharSequence to find, may be null\n * @return the last index of the search String,-1 if no match or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from lastIndexOf(String, String) to lastIndexOf(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastOrdinalIndexOf#1433",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastOrdinalIndexOf(java.lang.CharSequence, java.lang.CharSequence, int)",
    "snippet": "public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {\n        return ordinalIndexOf(str, searchStr, ordinal, true);\n    }",
    "begin_line": 1433,
    "end_line": 1435,
    "comment": "/** \n * \u003cp\u003eFinds the n-th last index within a String, handling  {@code null}. This method uses  {@link String#lastIndexOf(String)}.\u003c/p\u003e \u003cp\u003eA  {@code null} String will return {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.lastOrdinalIndexOf(null, *, *)          \u003d -1 StringUtils.lastOrdinalIndexOf(*, null, *)          \u003d -1 StringUtils.lastOrdinalIndexOf(\"\", \"\", *)           \u003d 0 StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"a\", 1)  \u003d 7 StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"a\", 2)  \u003d 6 StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"b\", 1)  \u003d 5 StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"b\", 2)  \u003d 2 StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"ab\", 1) \u003d 4 StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"ab\", 2) \u003d 1 StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"\", 1)   \u003d 8 StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"\", 2)   \u003d 8 \u003c/pre\u003e \u003cp\u003eNote that \u0027tail(CharSequence str, int n)\u0027 may be implemented as: \u003c/p\u003e \u003cpre\u003e str.substring(lastOrdinalIndexOf(str, \"\\n\", n) + 1) \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @param ordinal  the n-th last {@code searchStr} to find\n * @return the n-th last index of the search CharSequence,{@code -1} ({@code INDEX_NOT_FOUND}) if no match or  {@code null} string input\n * @since 2.5\n * @since 3.0 Changed signature from lastOrdinalIndexOf(String, String, int) to lastOrdinalIndexOf(CharSequence, CharSequence, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOf#1473",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOf(java.lang.CharSequence, java.lang.CharSequence, int)",
    "snippet": "public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {\n        if (seq \u003d\u003d null || searchSeq \u003d\u003d null) {\n            return INDEX_NOT_FOUND;\n        }\n        return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);\n    }",
    "begin_line": 1473,
    "end_line": 1478,
    "comment": "/** \n * \u003cp\u003eFinds the last index within a CharSequence, handling  {@code null}. This method uses  {@link String#lastIndexOf(String,int)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A negative start position returns  {@code -1}. An empty (\"\") search CharSequence always matches unless the start position is negative. A start position greater than the string length searches the whole string. The search starts at the startPos and works backwards; matches starting after the start position are ignored. \u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOf(null, *, *)          \u003d -1 StringUtils.lastIndexOf(*, null, *)          \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 8)  \u003d 7 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 8)  \u003d 5 StringUtils.lastIndexOf(\"aabaabaa\", \"ab\", 8) \u003d 4 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 9)  \u003d 5 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1) \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0)  \u003d 0 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 1)  \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 2)  \u003d 2 StringUtils.lastIndexOf(\"aabaabaa\", \"ba\", 2)  \u003d -1 StringUtils.lastIndexOf(\"aabaabaa\", \"ba\", 2)  \u003d 2 \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchSeq  the CharSequence to find, may be null\n * @param startPos  the start position, negative treated as zero\n * @return the last index of the search CharSequence (always \u0026le; startPos),-1 if no match or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from lastIndexOf(String, String, int) to lastIndexOf(CharSequence, CharSequence, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOfIgnoreCase#1503",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOfIgnoreCase(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return INDEX_NOT_FOUND;\n        }\n        return lastIndexOfIgnoreCase(str, searchStr, str.length());\n    }",
    "begin_line": 1503,
    "end_line": 1508,
    "comment": "/** \n * \u003cp\u003eCase in-sensitive find of the last index within a CharSequence.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A negative start position returns  {@code -1}. An empty (\"\") search CharSequence always matches unless the start position is negative. A start position greater than the string length searches the whole string.\u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOfIgnoreCase(null, *)          \u003d -1 StringUtils.lastIndexOfIgnoreCase(*, null)          \u003d -1 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\")  \u003d 7 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\")  \u003d 5 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"AB\") \u003d 4 \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @return the first index of the search CharSequence,-1 if no match or  {@code null} string input\n * @since 2.5\n * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String) to lastIndexOfIgnoreCase(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOfIgnoreCase#1542",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOfIgnoreCase(java.lang.CharSequence, java.lang.CharSequence, int)",
    "snippet": "public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startPos \u003e str.length() - searchStr.length()) {\n            startPos \u003d str.length() - searchStr.length();\n        }\n        if (startPos \u003c 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() \u003d\u003d 0) {\n            return startPos;\n        }\n\n        for (int i \u003d startPos; i \u003e\u003d 0; i--) {\n            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }",
    "begin_line": 1542,
    "end_line": 1562,
    "comment": "/** \n * \u003cp\u003eCase in-sensitive find of the last index within a CharSequence from the specified position.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A negative start position returns  {@code -1}. An empty (\"\") search CharSequence always matches unless the start position is negative. A start position greater than the string length searches the whole string. The search starts at the startPos and works backwards; matches starting after the start position are ignored. \u003c/p\u003e \u003cpre\u003e StringUtils.lastIndexOfIgnoreCase(null, *, *)          \u003d -1 StringUtils.lastIndexOfIgnoreCase(*, null, *)          \u003d -1 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 8)  \u003d 7 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 8)  \u003d 5 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"AB\", 8) \u003d 4 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  \u003d 5 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", -1) \u003d -1 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  \u003d 0 StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  \u003d -1 \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @param startPos  the start position\n * @return the last index of the search CharSequence (always \u0026le; startPos),-1 if no match or  {@code null} input\n * @since 2.5\n * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String, int) to lastIndexOfIgnoreCase(CharSequence, CharSequence, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.contains#1586",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.contains(java.lang.CharSequence, int)",
    "snippet": "public static boolean contains(final CharSequence seq, final int searchChar) {\n        if (isEmpty(seq)) {\n            return false;\n        }\n        return CharSequenceUtils.indexOf(seq, searchChar, 0) \u003e\u003d 0;\n    }",
    "begin_line": 1586,
    "end_line": 1591,
    "comment": "/** \n * \u003cp\u003eChecks if CharSequence contains a search character, handling  {@code null}. This method uses  {@link String#indexOf(int)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} or empty (\"\") CharSequence will return {@code false}.\u003c/p\u003e \u003cpre\u003e StringUtils.contains(null, *)    \u003d false StringUtils.contains(\"\", *)      \u003d false StringUtils.contains(\"abc\", \u0027a\u0027) \u003d true StringUtils.contains(\"abc\", \u0027z\u0027) \u003d false \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchChar  the character to find\n * @return true if the CharSequence contains the search character,false if not or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.contains#1615",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.contains(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {\n        if (seq \u003d\u003d null || searchSeq \u003d\u003d null) {\n            return false;\n        }\n        return CharSequenceUtils.indexOf(seq, searchSeq, 0) \u003e\u003d 0;\n    }",
    "begin_line": 1615,
    "end_line": 1620,
    "comment": "/** \n * \u003cp\u003eChecks if CharSequence contains a search CharSequence, handling  {@code null}. This method uses  {@link String#indexOf(String)} if possible.\u003c/p\u003e\u003cp\u003eA  {@code null} CharSequence will return {@code false}.\u003c/p\u003e \u003cpre\u003e StringUtils.contains(null, *)     \u003d false StringUtils.contains(*, null)     \u003d false StringUtils.contains(\"\", \"\")      \u003d true StringUtils.contains(\"abc\", \"\")   \u003d true StringUtils.contains(\"abc\", \"a\")  \u003d true StringUtils.contains(\"abc\", \"z\")  \u003d false \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchSeq  the CharSequence to find, may be null\n * @return true if the CharSequence contains the search CharSequence,false if not or  {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from contains(String, String) to contains(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsIgnoreCase#1646",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsIgnoreCase(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {\n        if (str \u003d\u003d null || searchStr \u003d\u003d null) {\n            return false;\n        }\n        final int len \u003d searchStr.length();\n        final int max \u003d str.length() - len;\n        for (int i \u003d 0; i \u003c\u003d max; i++) {\n            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "begin_line": 1646,
    "end_line": 1658,
    "comment": "/** \n * \u003cp\u003eChecks if CharSequence contains a search CharSequence irrespective of case, handling  {@code null}. Case-insensitivity is defined as by {@link String#equalsIgnoreCase(String)}. \u003cp\u003eA  {@code null} CharSequence will return {@code false}.\u003c/p\u003e \u003cpre\u003e StringUtils.contains(null, *) \u003d false StringUtils.contains(*, null) \u003d false StringUtils.contains(\"\", \"\") \u003d true StringUtils.contains(\"abc\", \"\") \u003d true StringUtils.contains(\"abc\", \"a\") \u003d true StringUtils.contains(\"abc\", \"z\") \u003d false StringUtils.contains(\"abc\", \"A\") \u003d true StringUtils.contains(\"abc\", \"Z\") \u003d false \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @return true if the CharSequence contains the search CharSequence irrespective ofcase or false if not or  {@code null} string input\n * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsWhitespace#1669",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsWhitespace(java.lang.CharSequence)",
    "snippet": " containsWhitespace(final CharSequence seq) {\n        if (isEmpty(seq)) {\n            return false;\n        }\n        final int strLen \u003d seq.length();\n        for (int i \u003d 0; i \u003c strLen; i++) {\n            if (Character.isWhitespace(seq.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "begin_line": 1669,
    "end_line": 1680,
    "comment": "/** \n * Check whether the given CharSequence contains any whitespace characters.\n * @param seq the CharSequence to check (may be {@code null})\n * @return {@code true} if the CharSequence is not empty andcontains at least 1 whitespace character\n * @see java.lang.Character#isWhitespace\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAny#1707",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAny(java.lang.CharSequence, char)",
    "snippet": "public static int indexOfAny(final CharSequence cs, final char... searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        final int csLen \u003d cs.length();\n        final int csLast \u003d csLen - 1;\n        final int searchLen \u003d searchChars.length;\n        final int searchLast \u003d searchLen - 1;\n        for (int i \u003d 0; i \u003c csLen; i++) {\n            final char ch \u003d cs.charAt(i);\n            for (int j \u003d 0; j \u003c searchLen; j++) {\n                if (searchChars[j] \u003d\u003d ch) {\n                    if (i \u003c csLast \u0026\u0026 j \u003c searchLast \u0026\u0026 Character.isHighSurrogate(ch)) {\n                        // ch is a supplementary character\n                        if (searchChars[j + 1] \u003d\u003d cs.charAt(i + 1)) {\n                            return i;\n                        }\n                    } else {\n                        return i;\n                    }\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }",
    "begin_line": 1707,
    "end_line": 1731,
    "comment": "/** \n * \u003cp\u003eSearch a CharSequence to find the first index of any character in the given set of characters.\u003c/p\u003e \u003cp\u003eA  {@code null} String will return {@code -1}. A  {@code null} or zero length search array will return {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfAny(null, *)                \u003d -1 StringUtils.indexOfAny(\"\", *)                  \u003d -1 StringUtils.indexOfAny(*, null)                \u003d -1 StringUtils.indexOfAny(*, [])                  \u003d -1 StringUtils.indexOfAny(\"zzabyycdxx\",[\u0027z\u0027,\u0027a\u0027]) \u003d 0 StringUtils.indexOfAny(\"zzabyycdxx\",[\u0027b\u0027,\u0027y\u0027]) \u003d 3 StringUtils.indexOfAny(\"aba\", [\u0027z\u0027])           \u003d -1 \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAny#1756",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAny(java.lang.CharSequence, java.lang.String)",
    "snippet": "public static int indexOfAny(final CharSequence cs, final String searchChars) {\n        if (isEmpty(cs) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        return indexOfAny(cs, searchChars.toCharArray());\n    }",
    "begin_line": 1756,
    "end_line": 1761,
    "comment": "/** \n * \u003cp\u003eSearch a CharSequence to find the first index of any character in the given set of characters.\u003c/p\u003e \u003cp\u003eA  {@code null} String will return {@code -1}. A  {@code null} search string will return {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfAny(null, *)            \u003d -1 StringUtils.indexOfAny(\"\", *)              \u003d -1 StringUtils.indexOfAny(*, null)            \u003d -1 StringUtils.indexOfAny(*, \"\")              \u003d -1 StringUtils.indexOfAny(\"zzabyycdxx\", \"za\") \u003d 0 StringUtils.indexOfAny(\"zzabyycdxx\", \"by\") \u003d 3 StringUtils.indexOfAny(\"aba\",\"z\")          \u003d -1 \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsAny#1790",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsAny(java.lang.CharSequence, char)",
    "snippet": "public static boolean containsAny(final CharSequence cs, final char... searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return false;\n        }\n        final int csLength \u003d cs.length();\n        final int searchLength \u003d searchChars.length;\n        final int csLast \u003d csLength - 1;\n        final int searchLast \u003d searchLength - 1;\n        for (int i \u003d 0; i \u003c csLength; i++) {\n            final char ch \u003d cs.charAt(i);\n            for (int j \u003d 0; j \u003c searchLength; j++) {\n                if (searchChars[j] \u003d\u003d ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j \u003d\u003d searchLast) {\n                            // missing low surrogate, fine, like String.indexOf(String)\n                            return true;\n                        }\n                        if (i \u003c csLast \u0026\u0026 searchChars[j + 1] \u003d\u003d cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        // ch is in the Basic Multilingual Plane\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }",
    "begin_line": 1790,
    "end_line": 1818,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains any character in the given set of characters.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code false}. A  {@code null} or zero length search array will return {@code false}.\u003c/p\u003e \u003cpre\u003e StringUtils.containsAny(null, *)                \u003d false StringUtils.containsAny(\"\", *)                  \u003d false StringUtils.containsAny(*, null)                \u003d false StringUtils.containsAny(*, [])                  \u003d false StringUtils.containsAny(\"zzabyycdxx\",[\u0027z\u0027,\u0027a\u0027]) \u003d true StringUtils.containsAny(\"zzabyycdxx\",[\u0027b\u0027,\u0027y\u0027]) \u003d true StringUtils.containsAny(\"zzabyycdxx\",[\u0027z\u0027,\u0027y\u0027]) \u003d true StringUtils.containsAny(\"aba\", [\u0027z\u0027])           \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the {@code true} if any of the chars are found,{@code false} if no match or null input\n * @since 2.4\n * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsAny#1849",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsAny(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {\n        if (searchChars \u003d\u003d null) {\n            return false;\n        }\n        return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));\n    }",
    "begin_line": 1849,
    "end_line": 1854,
    "comment": "/** \n * \u003cp\u003e Checks if the CharSequence contains any character in the given set of characters. \u003c/p\u003e \u003cp\u003e A  {@code null} CharSequence will return {@code false}. A  {@code null} search CharSequence will return{@code false}. \u003c/p\u003e \u003cpre\u003e StringUtils.containsAny(null, *)            \u003d false StringUtils.containsAny(\"\", *)              \u003d false StringUtils.containsAny(*, null)            \u003d false StringUtils.containsAny(*, \"\")              \u003d false StringUtils.containsAny(\"zzabyycdxx\", \"za\") \u003d true StringUtils.containsAny(\"zzabyycdxx\", \"by\") \u003d true StringUtils.containsAny(\"zzabyycdxx\", \"zy\") \u003d true StringUtils.containsAny(\"aba\",\"z\")          \u003d false \u003c/pre\u003e\n * @param cs the CharSequence to check, may be null\n * @param searchChars the chars to search for, may be null\n * @return the {@code true} if any of the chars are found, {@code false} if no match or null input\n * @since 2.4\n * @since 3.0 Changed signature from containsAny(String, String) to containsAny(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsAny#1880",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsAny(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean containsAny(CharSequence cs, CharSequence... searchCharSequences) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchCharSequences)) {\n            return false;\n        }\n        for (CharSequence searchCharSequence : searchCharSequences) {\n            if (contains(cs, searchCharSequence)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "begin_line": 1880,
    "end_line": 1890,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains any of the CharSequences in the given array.\u003c/p\u003e \u003cp\u003e A  {@code null} CharSequence will return {@code false}. A  {@code null} or zerolength search array will return  {@code false}. \u003c/p\u003e \u003cpre\u003e StringUtils.containsAny(null, *)            \u003d false StringUtils.containsAny(\"\", *)              \u003d false StringUtils.containsAny(*, null)            \u003d false StringUtils.containsAny(*, [])              \u003d false StringUtils.containsAny(\"abcd\", \"ab\", null) \u003d false StringUtils.containsAny(\"abcd\", \"ab\", \"cd\") \u003d true StringUtils.containsAny(\"abc\", \"d\", \"abc\")  \u003d true \u003c/pre\u003e\n * @param cs The CharSequence to check, may be null\n * @param searchCharSequences The array of CharSequences to search for, may be null\n * @return {@code true} if any of the search CharSequences are found, {@code false} otherwise\n * @since 3.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAnyBut#1918",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAnyBut(java.lang.CharSequence, char)",
    "snippet": "public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) {\n        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        final int csLen \u003d cs.length();\n        final int csLast \u003d csLen - 1;\n        final int searchLen \u003d searchChars.length;\n        final int searchLast \u003d searchLen - 1;\n        outer:\n        for (int i \u003d 0; i \u003c csLen; i++) {\n            final char ch \u003d cs.charAt(i);\n            for (int j \u003d 0; j \u003c searchLen; j++) {\n                if (searchChars[j] \u003d\u003d ch) {\n                    if (i \u003c csLast \u0026\u0026 j \u003c searchLast \u0026\u0026 Character.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] \u003d\u003d cs.charAt(i + 1)) {\n                            continue outer;\n                        }\n                    } else {\n                        continue outer;\n                    }\n                }\n            }\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }",
    "begin_line": 1918,
    "end_line": 1943,
    "comment": "/** \n * \u003cp\u003eSearches a CharSequence to find the first index of any character not in the given set of characters.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A  {@code null} or zero length search array will return {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfAnyBut(null, *)                              \u003d -1 StringUtils.indexOfAnyBut(\"\", *)                                \u003d -1 StringUtils.indexOfAnyBut(*, null)                              \u003d -1 StringUtils.indexOfAnyBut(*, [])                                \u003d -1 StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {\u0027z\u0027, \u0027a\u0027} ) \u003d 3 StringUtils.indexOfAnyBut(\"aba\", new char[] {\u0027z\u0027} )             \u003d 0 StringUtils.indexOfAnyBut(\"aba\", new char[] {\u0027a\u0027, \u0027b\u0027} )        \u003d -1 \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAnyBut#1968",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAnyBut(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {\n        if (isEmpty(seq) || isEmpty(searchChars)) {\n            return INDEX_NOT_FOUND;\n        }\n        final int strLen \u003d seq.length();\n        for (int i \u003d 0; i \u003c strLen; i++) {\n            final char ch \u003d seq.charAt(i);\n            final boolean chFound \u003d CharSequenceUtils.indexOf(searchChars, ch, 0) \u003e\u003d 0;\n            if (i + 1 \u003c strLen \u0026\u0026 Character.isHighSurrogate(ch)) {\n                final char ch2 \u003d seq.charAt(i + 1);\n                if (chFound \u0026\u0026 CharSequenceUtils.indexOf(searchChars, ch2, 0) \u003c 0) {\n                    return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }",
    "begin_line": 1968,
    "end_line": 1988,
    "comment": "/** \n * \u003cp\u003eSearch a CharSequence to find the first index of any character not in the given set of characters.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A  {@code null} or empty search string will return {@code -1}.\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfAnyBut(null, *)            \u003d -1 StringUtils.indexOfAnyBut(\"\", *)              \u003d -1 StringUtils.indexOfAnyBut(*, null)            \u003d -1 StringUtils.indexOfAnyBut(*, \"\")              \u003d -1 StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") \u003d 3 StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   \u003d -1 StringUtils.indexOfAnyBut(\"aba\",\"ab\")         \u003d -1 \u003c/pre\u003e\n * @param seq  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsOnly#2014",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsOnly(java.lang.CharSequence, char)",
    "snippet": "public static boolean containsOnly(final CharSequence cs, final char... valid) {\n        // All these pre-checks are to maintain API with an older version\n        if (valid \u003d\u003d null || cs \u003d\u003d null) {\n            return false;\n        }\n        if (cs.length() \u003d\u003d 0) {\n            return true;\n        }\n        if (valid.length \u003d\u003d 0) {\n            return false;\n        }\n        return indexOfAnyBut(cs, valid) \u003d\u003d INDEX_NOT_FOUND;\n    }",
    "begin_line": 2014,
    "end_line": 2026,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only certain characters.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code false}. A  {@code null} valid character array will return {@code false}. An empty CharSequence (length()\u003d0) always returns  {@code true}.\u003c/p\u003e \u003cpre\u003e StringUtils.containsOnly(null, *)       \u003d false StringUtils.containsOnly(*, null)       \u003d false StringUtils.containsOnly(\"\", *)         \u003d true StringUtils.containsOnly(\"ab\", \u0027\u0027)      \u003d false StringUtils.containsOnly(\"abab\", \u0027abc\u0027) \u003d true StringUtils.containsOnly(\"ab1\", \u0027abc\u0027)  \u003d false StringUtils.containsOnly(\"abz\", \u0027abc\u0027)  \u003d false \u003c/pre\u003e\n * @param cs  the String to check, may be null\n * @param valid  an array of valid chars, may be null\n * @return true if it only contains valid chars and is non-null\n * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsOnly#2051",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsOnly(java.lang.CharSequence, java.lang.String)",
    "snippet": "public static boolean containsOnly(final CharSequence cs, final String validChars) {\n        if (cs \u003d\u003d null || validChars \u003d\u003d null) {\n            return false;\n        }\n        return containsOnly(cs, validChars.toCharArray());\n    }",
    "begin_line": 2051,
    "end_line": 2056,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only certain characters.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code false}. A  {@code null} valid character String will return {@code false}. An empty String (length()\u003d0) always returns  {@code true}.\u003c/p\u003e \u003cpre\u003e StringUtils.containsOnly(null, *)       \u003d false StringUtils.containsOnly(*, null)       \u003d false StringUtils.containsOnly(\"\", *)         \u003d true StringUtils.containsOnly(\"ab\", \"\")      \u003d false StringUtils.containsOnly(\"abab\", \"abc\") \u003d true StringUtils.containsOnly(\"ab1\", \"abc\")  \u003d false StringUtils.containsOnly(\"abz\", \"abc\")  \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @param validChars  a String of valid chars, may be null\n * @return true if it only contains valid chars and is non-null\n * @since 2.0\n * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsNone#2083",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsNone(java.lang.CharSequence, char)",
    "snippet": "public static boolean containsNone(final CharSequence cs, final char... searchChars) {\n        if (cs \u003d\u003d null || searchChars \u003d\u003d null) {\n            return true;\n        }\n        final int csLen \u003d cs.length();\n        final int csLast \u003d csLen - 1;\n        final int searchLen \u003d searchChars.length;\n        final int searchLast \u003d searchLen - 1;\n        for (int i \u003d 0; i \u003c csLen; i++) {\n            final char ch \u003d cs.charAt(i);\n            for (int j \u003d 0; j \u003c searchLen; j++) {\n                if (searchChars[j] \u003d\u003d ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j \u003d\u003d searchLast) {\n                            // missing low surrogate, fine, like String.indexOf(String)\n                            return false;\n                        }\n                        if (i \u003c csLast \u0026\u0026 searchChars[j + 1] \u003d\u003d cs.charAt(i + 1)) {\n                            return false;\n                        }\n                    } else {\n                        // ch is in the Basic Multilingual Plane\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }",
    "begin_line": 2083,
    "end_line": 2111,
    "comment": "/** \n * \u003cp\u003eChecks that the CharSequence does not contain certain characters.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code true}. A  {@code null} invalid character array will return {@code true}. An empty CharSequence (length()\u003d0) always returns true.\u003c/p\u003e \u003cpre\u003e StringUtils.containsNone(null, *)       \u003d true StringUtils.containsNone(*, null)       \u003d true StringUtils.containsNone(\"\", *)         \u003d true StringUtils.containsNone(\"ab\", \u0027\u0027)      \u003d true StringUtils.containsNone(\"abab\", \u0027xyz\u0027) \u003d true StringUtils.containsNone(\"ab1\", \u0027xyz\u0027)  \u003d true StringUtils.containsNone(\"abz\", \u0027xyz\u0027)  \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  an array of invalid chars, may be null\n * @return true if it contains none of the invalid chars, or is null\n * @since 2.0\n * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.containsNone#2136",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsNone(java.lang.CharSequence, java.lang.String)",
    "snippet": "public static boolean containsNone(final CharSequence cs, final String invalidChars) {\n        if (cs \u003d\u003d null || invalidChars \u003d\u003d null) {\n            return true;\n        }\n        return containsNone(cs, invalidChars.toCharArray());\n    }",
    "begin_line": 2136,
    "end_line": 2141,
    "comment": "/** \n * \u003cp\u003eChecks that the CharSequence does not contain certain characters.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code true}. A  {@code null} invalid character array will return {@code true}. An empty String (\"\") always returns true.\u003c/p\u003e \u003cpre\u003e StringUtils.containsNone(null, *)       \u003d true StringUtils.containsNone(*, null)       \u003d true StringUtils.containsNone(\"\", *)         \u003d true StringUtils.containsNone(\"ab\", \"\")      \u003d true StringUtils.containsNone(\"abab\", \"xyz\") \u003d true StringUtils.containsNone(\"ab1\", \"xyz\")  \u003d true StringUtils.containsNone(\"abz\", \"xyz\")  \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @param invalidChars  a String of invalid chars, may be null\n * @return true if it contains none of the invalid chars, or is null\n * @since 2.0\n * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfAny#2172",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfAny(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {\n        if (str \u003d\u003d null || searchStrs \u003d\u003d null) {\n            return INDEX_NOT_FOUND;\n        }\n        final int sz \u003d searchStrs.length;\n\n        // String\u0027s can\u0027t have a MAX_VALUEth index.\n        int ret \u003d Integer.MAX_VALUE;\n\n        int tmp \u003d 0;\n        for (int i \u003d 0; i \u003c sz; i++) {\n            final CharSequence search \u003d searchStrs[i];\n            if (search \u003d\u003d null) {\n                continue;\n            }\n            tmp \u003d CharSequenceUtils.indexOf(str, search, 0);\n            if (tmp \u003d\u003d INDEX_NOT_FOUND) {\n                continue;\n            }\n\n            if (tmp \u003c ret) {\n                ret \u003d tmp;\n            }\n        }\n\n        return ret \u003d\u003d Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;\n    }",
    "begin_line": 2172,
    "end_line": 2198,
    "comment": "/** \n * \u003cp\u003eFind the first index of any of a set of potential substrings.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A  {@code null} or zero length search array will return {@code -1}. A  {@code null} search array entry will be ignored, but a searcharray containing \"\" will return  {@code 0} if {@code str} is notnull. This method uses  {@link String#indexOf(String)} if possible.\u003c/p\u003e\u003cpre\u003e StringUtils.indexOfAny(null, *)                     \u003d -1 StringUtils.indexOfAny(*, null)                     \u003d -1 StringUtils.indexOfAny(*, [])                       \u003d -1 StringUtils.indexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"])   \u003d 2 StringUtils.indexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"])   \u003d 2 StringUtils.indexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"])   \u003d -1 StringUtils.indexOfAny(\"zzabyycdxx\", [\"zab\",\"aby\"]) \u003d 1 StringUtils.indexOfAny(\"zzabyycdxx\", [\"\"])          \u003d 0 StringUtils.indexOfAny(\"\", [\"\"])                    \u003d 0 StringUtils.indexOfAny(\"\", [\"a\"])                   \u003d -1 \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStrs  the CharSequences to search for, may be null\n * @return the first index of any of the searchStrs in str, -1 if no match\n * @since 3.0 Changed signature from indexOfAny(String, String[]) to indexOfAny(CharSequence, CharSequence...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lastIndexOfAny#2226",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lastIndexOfAny(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {\n        if (str \u003d\u003d null || searchStrs \u003d\u003d null) {\n            return INDEX_NOT_FOUND;\n        }\n        final int sz \u003d searchStrs.length;\n        int ret \u003d INDEX_NOT_FOUND;\n        int tmp \u003d 0;\n        for (int i \u003d 0; i \u003c sz; i++) {\n            final CharSequence search \u003d searchStrs[i];\n            if (search \u003d\u003d null) {\n                continue;\n            }\n            tmp \u003d CharSequenceUtils.lastIndexOf(str, search, str.length());\n            if (tmp \u003e ret) {\n                ret \u003d tmp;\n            }\n        }\n        return ret;\n    }",
    "begin_line": 2226,
    "end_line": 2244,
    "comment": "/** \n * \u003cp\u003eFind the latest index of any of a set of potential substrings.\u003c/p\u003e \u003cp\u003eA  {@code null} CharSequence will return {@code -1}. A  {@code null} search array will return {@code -1}. A  {@code null} or zero length search array entry will be ignored,but a search array containing \"\" will return the length of  {@code str}if  {@code str} is not null. This method uses {@link String#indexOf(String)} if possible\u003c/p\u003e\u003cpre\u003e StringUtils.lastIndexOfAny(null, *)                   \u003d -1 StringUtils.lastIndexOfAny(*, null)                   \u003d -1 StringUtils.lastIndexOfAny(*, [])                     \u003d -1 StringUtils.lastIndexOfAny(*, [null])                 \u003d -1 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"]) \u003d 6 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"]) \u003d 6 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) \u003d -1 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) \u003d -1 StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   \u003d 10 \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param searchStrs  the CharSequences to search for, may be null\n * @return the last index of any of the CharSequences, -1 if no match\n * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substring#2272",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substring(java.lang.String, int)",
    "snippet": "public static String substring(final String str, int start) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n\n        // handle negatives, which means last n characters\n        if (start \u003c 0) {\n            start \u003d str.length() + start; // remember start is negative\n        }\n\n        if (start \u003c 0) {\n            start \u003d 0;\n        }\n        if (start \u003e str.length()) {\n            return EMPTY;\n        }\n\n        return str.substring(start);\n    }",
    "begin_line": 2272,
    "end_line": 2290,
    "comment": "/** \n * \u003cp\u003eGets a substring from the specified String avoiding exceptions.\u003c/p\u003e \u003cp\u003eA negative start position can be used to start  {@code n}characters from the end of the String.\u003c/p\u003e \u003cp\u003eA  {@code null} String will return {@code null}. An empty (\"\") String will return \"\".\u003c/p\u003e \u003cpre\u003e StringUtils.substring(null, *)   \u003d null StringUtils.substring(\"\", *)     \u003d \"\" StringUtils.substring(\"abc\", 0)  \u003d \"abc\" StringUtils.substring(\"abc\", 2)  \u003d \"c\" StringUtils.substring(\"abc\", 4)  \u003d \"\" StringUtils.substring(\"abc\", -2) \u003d \"bc\" StringUtils.substring(\"abc\", -4) \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get the substring from, may be null\n * @param start  the position to start from, negative meanscount back from the end of the String by this many characters\n * @return substring from start position, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substring#2327",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substring(java.lang.String, int, int)",
    "snippet": "public static String substring(final String str, int start, int end) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n\n        // handle negatives\n        if (end \u003c 0) {\n            end \u003d str.length() + end; // remember end is negative\n        }\n        if (start \u003c 0) {\n            start \u003d str.length() + start; // remember start is negative\n        }\n\n        // check length next\n        if (end \u003e str.length()) {\n            end \u003d str.length();\n        }\n\n        // if start is greater than end, return \"\"\n        if (start \u003e end) {\n            return EMPTY;\n        }\n\n        if (start \u003c 0) {\n            start \u003d 0;\n        }\n        if (end \u003c 0) {\n            end \u003d 0;\n        }\n\n        return str.substring(start, end);\n    }",
    "begin_line": 2327,
    "end_line": 2358,
    "comment": "/** \n * \u003cp\u003eGets a substring from the specified String avoiding exceptions.\u003c/p\u003e \u003cp\u003eA negative start position can be used to start/end  {@code n}characters from the end of the String.\u003c/p\u003e \u003cp\u003eThe returned substring starts with the character in the  {@code start}position and ends before the  {@code end} position. All position counting iszero-based -- i.e., to start at the beginning of the string use {@code start \u003d 0}. Negative start and end positions can be used to specify offsets relative to the end of the String.\u003c/p\u003e \u003cp\u003eIf  {@code start} is not strictly to the left of {@code end}, \"\" is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substring(null, *, *)    \u003d null StringUtils.substring(\"\", * ,  *)    \u003d \"\"; StringUtils.substring(\"abc\", 0, 2)   \u003d \"ab\" StringUtils.substring(\"abc\", 2, 0)   \u003d \"\" StringUtils.substring(\"abc\", 2, 4)   \u003d \"c\" StringUtils.substring(\"abc\", 4, 6)   \u003d \"\" StringUtils.substring(\"abc\", 2, 2)   \u003d \"\" StringUtils.substring(\"abc\", -2, -1) \u003d \"b\" StringUtils.substring(\"abc\", -4, 2)  \u003d \"ab\" \u003c/pre\u003e\n * @param str  the String to get the substring from, may be null\n * @param start  the position to start from, negative meanscount back from the end of the String by this many characters\n * @param end  the position to end at (exclusive), negative meanscount back from the end of the String by this many characters\n * @return substring from start position to end position,{@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.left#2382",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.left(java.lang.String, int)",
    "snippet": "public static String left(final String str, final int len) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (len \u003c 0) {\n            return EMPTY;\n        }\n        if (str.length() \u003c\u003d len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }",
    "begin_line": 2382,
    "end_line": 2393,
    "comment": "/** \n * \u003cp\u003eGets the leftmost  {@code len} characters of a String.\u003c/p\u003e\u003cp\u003eIf  {@code len} characters are not available, or theString is  {@code null}, the String will be returned without an exception. An empty String is returned if len is negative.\u003c/p\u003e \u003cpre\u003e StringUtils.left(null, *)    \u003d null StringUtils.left(*, -ve)     \u003d \"\" StringUtils.left(\"\", *)      \u003d \"\" StringUtils.left(\"abc\", 0)   \u003d \"\" StringUtils.left(\"abc\", 2)   \u003d \"ab\" StringUtils.left(\"abc\", 4)   \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get the leftmost characters from, may be null\n * @param len  the length of the required String\n * @return the leftmost characters, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.right#2415",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.right(java.lang.String, int)",
    "snippet": "public static String right(final String str, final int len) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (len \u003c 0) {\n            return EMPTY;\n        }\n        if (str.length() \u003c\u003d len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }",
    "begin_line": 2415,
    "end_line": 2426,
    "comment": "/** \n * \u003cp\u003eGets the rightmost  {@code len} characters of a String.\u003c/p\u003e\u003cp\u003eIf  {@code len} characters are not available, or the Stringis  {@code null}, the String will be returned without an an exception. An empty String is returned if len is negative.\u003c/p\u003e \u003cpre\u003e StringUtils.right(null, *)    \u003d null StringUtils.right(*, -ve)     \u003d \"\" StringUtils.right(\"\", *)      \u003d \"\" StringUtils.right(\"abc\", 0)   \u003d \"\" StringUtils.right(\"abc\", 2)   \u003d \"bc\" StringUtils.right(\"abc\", 4)   \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get the rightmost characters from, may be null\n * @param len  the length of the required String\n * @return the rightmost characters, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.mid#2453",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.mid(java.lang.String, int, int)",
    "snippet": "public static String mid(final String str, int pos, final int len) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (len \u003c 0 || pos \u003e str.length()) {\n            return EMPTY;\n        }\n        if (pos \u003c 0) {\n            pos \u003d 0;\n        }\n        if (str.length() \u003c\u003d pos + len) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }",
    "begin_line": 2453,
    "end_line": 2467,
    "comment": "/** \n * \u003cp\u003eGets  {@code len} characters from the middle of a String.\u003c/p\u003e\u003cp\u003eIf  {@code len} characters are not available, the remainderof the String will be returned without an exception. If the String is  {@code null},  {@code null} will be returned.An empty String is returned if len is negative or exceeds the length of  {@code str}.\u003c/p\u003e \u003cpre\u003e StringUtils.mid(null, *, *)    \u003d null StringUtils.mid(*, *, -ve)     \u003d \"\" StringUtils.mid(\"\", 0, *)      \u003d \"\" StringUtils.mid(\"abc\", 0, 2)   \u003d \"ab\" StringUtils.mid(\"abc\", 0, 4)   \u003d \"abc\" StringUtils.mid(\"abc\", 2, 4)   \u003d \"c\" StringUtils.mid(\"abc\", 4, 2)   \u003d \"\" StringUtils.mid(\"abc\", -2, 2)  \u003d \"ab\" \u003c/pre\u003e\n * @param str  the String to get the characters from, may be null\n * @param pos  the position to start from, negative treated as zero\n * @param len  the length of the required String\n * @return the middle characters, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringBefore#2498",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringBefore(java.lang.String, java.lang.String)",
    "snippet": "public static String substringBefore(final String str, final String separator) {\n        if (isEmpty(str) || separator \u003d\u003d null) {\n            return str;\n        }\n        if (separator.isEmpty()) {\n            return EMPTY;\n        }\n        final int pos \u003d str.indexOf(separator);\n        if (pos \u003d\u003d INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }",
    "begin_line": 2498,
    "end_line": 2510,
    "comment": "/** \n * \u003cp\u003eGets the substring before the first occurrence of a separator. The separator is not returned.\u003c/p\u003e \u003cp\u003eA  {@code null} string input will return {@code null}. An empty (\"\") string input will return the empty string. A  {@code null} separator will return the input string.\u003c/p\u003e\u003cp\u003eIf nothing is found, the string input is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substringBefore(null, *)      \u003d null StringUtils.substringBefore(\"\", *)        \u003d \"\" StringUtils.substringBefore(\"abc\", \"a\")   \u003d \"\" StringUtils.substringBefore(\"abcba\", \"b\") \u003d \"a\" StringUtils.substringBefore(\"abc\", \"c\")   \u003d \"ab\" StringUtils.substringBefore(\"abc\", \"d\")   \u003d \"abc\" StringUtils.substringBefore(\"abc\", \"\")    \u003d \"\" StringUtils.substringBefore(\"abc\", null)  \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring before the first occurrence of the separator,{@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringAfter#2540",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringAfter(java.lang.String, java.lang.String)",
    "snippet": "public static String substringAfter(final String str, final String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (separator \u003d\u003d null) {\n            return EMPTY;\n        }\n        final int pos \u003d str.indexOf(separator);\n        if (pos \u003d\u003d INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }",
    "begin_line": 2540,
    "end_line": 2552,
    "comment": "/** \n * \u003cp\u003eGets the substring after the first occurrence of a separator. The separator is not returned.\u003c/p\u003e \u003cp\u003eA  {@code null} string input will return {@code null}. An empty (\"\") string input will return the empty string. A  {@code null} separator will return the empty string if theinput string is not  {@code null}.\u003c/p\u003e \u003cp\u003eIf nothing is found, the empty string is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substringAfter(null, *)      \u003d null StringUtils.substringAfter(\"\", *)        \u003d \"\" StringUtils.substringAfter(*, null)      \u003d \"\" StringUtils.substringAfter(\"abc\", \"a\")   \u003d \"bc\" StringUtils.substringAfter(\"abcba\", \"b\") \u003d \"cba\" StringUtils.substringAfter(\"abc\", \"c\")   \u003d \"\" StringUtils.substringAfter(\"abc\", \"d\")   \u003d \"\" StringUtils.substringAfter(\"abc\", \"\")    \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring after the first occurrence of the separator,{@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringBeforeLast#2581",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringBeforeLast(java.lang.String, java.lang.String)",
    "snippet": "public static String substringBeforeLast(final String str, final String separator) {\n        if (isEmpty(str) || isEmpty(separator)) {\n            return str;\n        }\n        final int pos \u003d str.lastIndexOf(separator);\n        if (pos \u003d\u003d INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }",
    "begin_line": 2581,
    "end_line": 2590,
    "comment": "/** \n * \u003cp\u003eGets the substring before the last occurrence of a separator. The separator is not returned.\u003c/p\u003e \u003cp\u003eA  {@code null} string input will return {@code null}. An empty (\"\") string input will return the empty string. An empty or  {@code null} separator will return the input string.\u003c/p\u003e\u003cp\u003eIf nothing is found, the string input is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substringBeforeLast(null, *)      \u003d null StringUtils.substringBeforeLast(\"\", *)        \u003d \"\" StringUtils.substringBeforeLast(\"abcba\", \"b\") \u003d \"abc\" StringUtils.substringBeforeLast(\"abc\", \"c\")   \u003d \"ab\" StringUtils.substringBeforeLast(\"a\", \"a\")     \u003d \"\" StringUtils.substringBeforeLast(\"a\", \"z\")     \u003d \"a\" StringUtils.substringBeforeLast(\"a\", null)    \u003d \"a\" StringUtils.substringBeforeLast(\"a\", \"\")      \u003d \"a\" \u003c/pre\u003e\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring before the last occurrence of the separator,{@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringAfterLast#2621",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringAfterLast(java.lang.String, java.lang.String)",
    "snippet": "public static String substringAfterLast(final String str, final String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (isEmpty(separator)) {\n            return EMPTY;\n        }\n        final int pos \u003d str.lastIndexOf(separator);\n        if (pos \u003d\u003d INDEX_NOT_FOUND || pos \u003d\u003d str.length() - separator.length()) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }",
    "begin_line": 2621,
    "end_line": 2633,
    "comment": "/** \n * \u003cp\u003eGets the substring after the last occurrence of a separator. The separator is not returned.\u003c/p\u003e \u003cp\u003eA  {@code null} string input will return {@code null}. An empty (\"\") string input will return the empty string. An empty or  {@code null} separator will return the empty string ifthe input string is not  {@code null}.\u003c/p\u003e \u003cp\u003eIf nothing is found, the empty string is returned.\u003c/p\u003e \u003cpre\u003e StringUtils.substringAfterLast(null, *)      \u003d null StringUtils.substringAfterLast(\"\", *)        \u003d \"\" StringUtils.substringAfterLast(*, \"\")        \u003d \"\" StringUtils.substringAfterLast(*, null)      \u003d \"\" StringUtils.substringAfterLast(\"abc\", \"a\")   \u003d \"bc\" StringUtils.substringAfterLast(\"abcba\", \"b\") \u003d \"a\" StringUtils.substringAfterLast(\"abc\", \"c\")   \u003d \"\" StringUtils.substringAfterLast(\"a\", \"a\")     \u003d \"\" StringUtils.substringAfterLast(\"a\", \"z\")     \u003d \"\" \u003c/pre\u003e\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring after the last occurrence of the separator,{@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringBetween#2658",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringBetween(java.lang.String, java.lang.String)",
    "snippet": "public static String substringBetween(final String str, final String tag) {\n        return substringBetween(str, tag, tag);\n    }",
    "begin_line": 2658,
    "end_line": 2660,
    "comment": "/** \n * \u003cp\u003eGets the String that is nested in between two instances of the same String.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} tag returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.substringBetween(null, *)            \u003d null StringUtils.substringBetween(\"\", \"\")             \u003d \"\" StringUtils.substringBetween(\"\", \"tag\")          \u003d null StringUtils.substringBetween(\"tagabctag\", null)  \u003d null StringUtils.substringBetween(\"tagabctag\", \"\")    \u003d \"\" StringUtils.substringBetween(\"tagabctag\", \"tag\") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String containing the substring, may be null\n * @param tag  the String before and after the substring, may be null\n * @return the substring, {@code null} if no match\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringBetween#2689",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringBetween(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String substringBetween(final String str, final String open, final String close) {\n        if (str \u003d\u003d null || open \u003d\u003d null || close \u003d\u003d null) {\n            return null;\n        }\n        final int start \u003d str.indexOf(open);\n        if (start !\u003d INDEX_NOT_FOUND) {\n            final int end \u003d str.indexOf(close, start + open.length());\n            if (end !\u003d INDEX_NOT_FOUND) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }",
    "begin_line": 2689,
    "end_line": 2701,
    "comment": "/** \n * \u003cp\u003eGets the String that is nested in between two Strings. Only the first match is returned.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} open/close returns {@code null} (no match).An empty (\"\") open and close returns an empty string.\u003c/p\u003e \u003cpre\u003e StringUtils.substringBetween(\"wx[b]yz\", \"[\", \"]\") \u003d \"b\" StringUtils.substringBetween(null, *, *)          \u003d null StringUtils.substringBetween(*, null, *)          \u003d null StringUtils.substringBetween(*, *, null)          \u003d null StringUtils.substringBetween(\"\", \"\", \"\")          \u003d \"\" StringUtils.substringBetween(\"\", \"\", \"]\")         \u003d null StringUtils.substringBetween(\"\", \"[\", \"]\")        \u003d null StringUtils.substringBetween(\"yabcz\", \"\", \"\")     \u003d \"\" StringUtils.substringBetween(\"yabcz\", \"y\", \"z\")   \u003d \"abc\" StringUtils.substringBetween(\"yabczyabcz\", \"y\", \"z\")   \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String containing the substring, may be null\n * @param open  the String before the substring, may be null\n * @param close  the String after the substring, may be null\n * @return the substring, {@code null} if no match\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.substringsBetween#2725",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.substringsBetween(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String[] substringsBetween(final String str, final String open, final String close) {\n        if (str \u003d\u003d null || isEmpty(open) || isEmpty(close)) {\n            return null;\n        }\n        final int strLen \u003d str.length();\n        if (strLen \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final int closeLen \u003d close.length();\n        final int openLen \u003d open.length();\n        final List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n        int pos \u003d 0;\n        while (pos \u003c strLen - closeLen) {\n            int start \u003d str.indexOf(open, pos);\n            if (start \u003c 0) {\n                break;\n            }\n            start +\u003d openLen;\n            final int end \u003d str.indexOf(close, start);\n            if (end \u003c 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos \u003d end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        }\n        return list.toArray(new String [list.size()]);\n    }",
    "begin_line": 2725,
    "end_line": 2754,
    "comment": "/** \n * \u003cp\u003eSearches a String for substrings delimited by a start and end tag, returning all matching substrings in an array.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} open/close returns {@code null} (no match).An empty (\"\") open/close returns  {@code null} (no match).\u003c/p\u003e\u003cpre\u003e StringUtils.substringsBetween(\"[a][b][c]\", \"[\", \"]\") \u003d [\"a\",\"b\",\"c\"] StringUtils.substringsBetween(null, *, *)            \u003d null StringUtils.substringsBetween(*, null, *)            \u003d null StringUtils.substringsBetween(*, *, null)            \u003d null StringUtils.substringsBetween(\"\", \"[\", \"]\")          \u003d [] \u003c/pre\u003e\n * @param str  the String containing the substrings, null returns null, empty returns empty\n * @param open  the String identifying the start of the substring, empty returns null\n * @param close  the String identifying the end of the substring, empty returns null\n * @return a String Array of substrings, or {@code null} if no match\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.split#2783",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.split(java.lang.String)",
    "snippet": "public static String[] split(final String str) {\n        return split(str, null, -1);\n    }",
    "begin_line": 2783,
    "end_line": 2785,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, using whitespace as the separator. Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as one separator. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.split(null)       \u003d null StringUtils.split(\"\")         \u003d [] StringUtils.split(\"abc def\")  \u003d [\"abc\", \"def\"] StringUtils.split(\"abc  def\") \u003d [\"abc\", \"def\"] StringUtils.split(\" abc \")    \u003d [\"abc\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @return an array of parsed Strings, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.split#2811",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.split(java.lang.String, char)",
    "snippet": "public static String[] split(final String str, final char separatorChar) {\n        return splitWorker(str, separatorChar, false);\n    }",
    "begin_line": 2811,
    "end_line": 2813,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator specified. This is an alternative to using StringTokenizer.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as one separator. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.split(null, *)         \u003d null StringUtils.split(\"\", *)           \u003d [] StringUtils.split(\"a.b.c\", \u0027.\u0027)    \u003d [\"a\", \"b\", \"c\"] StringUtils.split(\"a..b.c\", \u0027.\u0027)   \u003d [\"a\", \"b\", \"c\"] StringUtils.split(\"a:b:c\", \u0027.\u0027)    \u003d [\"a:b:c\"] StringUtils.split(\"a b c\", \u0027 \u0027)    \u003d [\"a\", \"b\", \"c\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separatorChar  the character used as the delimiter\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.split#2840",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.split(java.lang.String, java.lang.String)",
    "snippet": "public static String[] split(final String str, final String separatorChars) {\n        return splitWorker(str, separatorChars, -1, false);\n    }",
    "begin_line": 2840,
    "end_line": 2842,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separators specified. This is an alternative to using StringTokenizer.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as one separator. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} separatorChars splits on whitespace.\u003c/p\u003e\u003cpre\u003e StringUtils.split(null, *)         \u003d null StringUtils.split(\"\", *)           \u003d [] StringUtils.split(\"abc def\", null) \u003d [\"abc\", \"def\"] StringUtils.split(\"abc def\", \" \")  \u003d [\"abc\", \"def\"] StringUtils.split(\"abc  def\", \" \") \u003d [\"abc\", \"def\"] StringUtils.split(\"ab:cd:ef\", \":\") \u003d [\"ab\", \"cd\", \"ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separatorChars  the characters used as the delimiters,{@code null} splits on whitespace\n * @return an array of parsed Strings, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.split#2874",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.split(java.lang.String, java.lang.String, int)",
    "snippet": "public static String[] split(final String str, final String separatorChars, final int max) {\n        return splitWorker(str, separatorChars, max, false);\n    }",
    "begin_line": 2874,
    "end_line": 2876,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array with a maximum length, separators specified.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as one separator.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} separatorChars splits on whitespace.\u003c/p\u003e\u003cp\u003eIf more than  {@code max} delimited substrings are found, the lastreturned string includes all characters after the first  {@code max - 1}returned strings (including separator characters).\u003c/p\u003e \u003cpre\u003e StringUtils.split(null, *, *)            \u003d null StringUtils.split(\"\", *, *)              \u003d [] StringUtils.split(\"ab cd ef\", null, 0)   \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.split(\"ab   cd ef\", null, 0) \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.split(\"ab:cd:ef\", \":\", 0)    \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.split(\"ab:cd:ef\", \":\", 2)    \u003d [\"ab\", \"cd:ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separatorChars  the characters used as the delimiters,{@code null} splits on whitespace\n * @param max  the maximum number of elements to include in thearray. A zero or negative value implies no limit\n * @return an array of parsed Strings, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparator#2901",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparator(java.lang.String, java.lang.String)",
    "snippet": "public static String[] splitByWholeSeparator(final String str, final String separator) {\n        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n    }",
    "begin_line": 2901,
    "end_line": 2903,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator string specified.\u003c/p\u003e \u003cp\u003eThe separator(s) will not be included in the returned String array. Adjacent separators are treated as one separator.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} separator splits on whitespace.\u003c/p\u003e\u003cpre\u003e StringUtils.splitByWholeSeparator(null, *)               \u003d null StringUtils.splitByWholeSeparator(\"\", *)                 \u003d [] StringUtils.splitByWholeSeparator(\"ab de fg\", null)      \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparator(\"ab   de fg\", null)    \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\")       \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\") \u003d [\"ab\", \"cd\", \"ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separator  String containing the String to be used as a delimiter,{@code null} splits on whitespace\n * @return an array of parsed Strings, {@code null} if null String was input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparator#2932",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparator(java.lang.String, java.lang.String, int)",
    "snippet": "public static String[] splitByWholeSeparator( final String str, final String separator, final int max ) {\n        return splitByWholeSeparatorWorker(str, separator, max, false);\n    }",
    "begin_line": 2932,
    "end_line": 2934,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator string specified. Returns a maximum of  {@code max} substrings.\u003c/p\u003e\u003cp\u003eThe separator(s) will not be included in the returned String array. Adjacent separators are treated as one separator.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} separator splits on whitespace.\u003c/p\u003e\u003cpre\u003e StringUtils.splitByWholeSeparator(null, *, *)               \u003d null StringUtils.splitByWholeSeparator(\"\", *, *)                 \u003d [] StringUtils.splitByWholeSeparator(\"ab de fg\", null, 0)      \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparator(\"ab   de fg\", null, 0)    \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\", 2)       \u003d [\"ab\", \"cd:ef\"] StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 5) \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 2) \u003d [\"ab\", \"cd-!-ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separator  String containing the String to be used as a delimiter,{@code null} splits on whitespace\n * @param max  the maximum number of elements to include in the returnedarray. A zero or negative value implies no limit.\n * @return an array of parsed Strings, {@code null} if null String was input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparatorPreserveAllTokens#2961",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparatorPreserveAllTokens(java.lang.String, java.lang.String)",
    "snippet": "public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator) {\n        return splitByWholeSeparatorWorker(str, separator, -1, true);\n    }",
    "begin_line": 2961,
    "end_line": 2963,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator string specified. \u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} separator splits on whitespace.\u003c/p\u003e\u003cpre\u003e StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               \u003d null StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *)                 \u003d [] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null)      \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null)    \u003d [\"ab\", \"\", \"\", \"de\", \"fg\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\")       \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\") \u003d [\"ab\", \"cd\", \"ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separator  String containing the String to be used as a delimiter,{@code null} splits on whitespace\n * @return an array of parsed Strings, {@code null} if null String was input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparatorPreserveAllTokens#2994",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparatorPreserveAllTokens(java.lang.String, java.lang.String, int)",
    "snippet": "public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {\n        return splitByWholeSeparatorWorker(str, separator, max, true);\n    }",
    "begin_line": 2994,
    "end_line": 2996,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator string specified. Returns a maximum of  {@code max} substrings.\u003c/p\u003e\u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} separator splits on whitespace.\u003c/p\u003e\u003cpre\u003e StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               \u003d null StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *, *)                 \u003d [] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null, 0)      \u003d [\"ab\", \"de\", \"fg\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null, 0)    \u003d [\"ab\", \"\", \"\", \"de\", \"fg\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\", 2)       \u003d [\"ab\", \"cd:ef\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 5) \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 2) \u003d [\"ab\", \"cd-!-ef\"] \u003c/pre\u003e\n * @param str  the String to parse, may be null\n * @param separator  String containing the String to be used as a delimiter,{@code null} splits on whitespace\n * @param max  the maximum number of elements to include in the returnedarray. A zero or negative value implies no limit.\n * @return an array of parsed Strings, {@code null} if null String was input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByWholeSeparatorWorker#3012",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByWholeSeparatorWorker(java.lang.String, java.lang.String, int, boolean)",
    "snippet": "private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n\n        final int len \u003d str.length();\n\n        if (len \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n        if (separator \u003d\u003d null || EMPTY.equals(separator)) {\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength \u003d separator.length();\n\n        final ArrayList\u003cString\u003e substrings \u003d new ArrayList\u003cString\u003e();\n        int numberOfSubstrings \u003d 0;\n        int beg \u003d 0;\n        int end \u003d 0;\n        while (end \u003c len) {\n            end \u003d str.indexOf(separator, beg);\n\n            if (end \u003e -1) {\n                if (end \u003e beg) {\n                    numberOfSubstrings +\u003d 1;\n\n                    if (numberOfSubstrings \u003d\u003d max) {\n                        end \u003d len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position \u0027end\u0027.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg \u003d end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg \u003d end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings +\u003d 1;\n                        if (numberOfSubstrings \u003d\u003d max) {\n                            end \u003d len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg \u003d end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from \u0027beg\u0027 to the end of the String.\n                substrings.add(str.substring(beg));\n                end \u003d len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
    "begin_line": 3012,
    "end_line": 3076,
    "comment": "/** \n * Performs the logic for the  {@code splitByWholeSeparatorPreserveAllTokens} methods.\n * @param str  the String to parse, may be {@code null}\n * @param separator  String containing the String to be used as a delimiter,{@code null} splits on whitespace\n * @param max  the maximum number of elements to include in the returnedarray. A zero or negative value implies no limit.\n * @param preserveAllTokens if {@code true}, adjacent separators are treated as empty token separators; if  {@code false}, adjacent separators are treated as one separator.\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitPreserveAllTokens#3103",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitPreserveAllTokens(java.lang.String)",
    "snippet": "public static String[] splitPreserveAllTokens(final String str) {\n        return splitWorker(str, null, -1, true);\n    }",
    "begin_line": 3103,
    "end_line": 3105,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, using whitespace as the separator, preserving all tokens, including empty tokens created by adjacent separators. This is an alternative to using StringTokenizer. Whitespace is defined by  {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.splitPreserveAllTokens(null)       \u003d null StringUtils.splitPreserveAllTokens(\"\")         \u003d [] StringUtils.splitPreserveAllTokens(\"abc def\")  \u003d [\"abc\", \"def\"] StringUtils.splitPreserveAllTokens(\"abc  def\") \u003d [\"abc\", \"\", \"def\"] StringUtils.splitPreserveAllTokens(\" abc \")    \u003d [\"\", \"abc\", \"\"] \u003c/pre\u003e\n * @param str  the String to parse, may be {@code null}\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitPreserveAllTokens#3139",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitPreserveAllTokens(java.lang.String, char)",
    "snippet": "public static String[] splitPreserveAllTokens(final String str, final char separatorChar) {\n        return splitWorker(str, separatorChar, true);\n    }",
    "begin_line": 3139,
    "end_line": 3141,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separator specified, preserving all tokens, including empty tokens created by adjacent separators. This is an alternative to using StringTokenizer.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.splitPreserveAllTokens(null, *)         \u003d null StringUtils.splitPreserveAllTokens(\"\", *)           \u003d [] StringUtils.splitPreserveAllTokens(\"a.b.c\", \u0027.\u0027)    \u003d [\"a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"a..b.c\", \u0027.\u0027)   \u003d [\"a\", \"\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"a:b:c\", \u0027.\u0027)    \u003d [\"a:b:c\"] StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) \u003d [\"a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"a b c\", \u0027 \u0027)    \u003d [\"a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"a b c \", \u0027 \u0027)   \u003d [\"a\", \"b\", \"c\", \"\"] StringUtils.splitPreserveAllTokens(\"a b c  \", \u0027 \u0027)   \u003d [\"a\", \"b\", \"c\", \"\", \"\"] StringUtils.splitPreserveAllTokens(\" a b c\", \u0027 \u0027)   \u003d [\"\", a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\"  a b c\", \u0027 \u0027)  \u003d [\"\", \"\", a\", \"b\", \"c\"] StringUtils.splitPreserveAllTokens(\" a b c \", \u0027 \u0027)  \u003d [\"\", a\", \"b\", \"c\", \"\"] \u003c/pre\u003e\n * @param str  the String to parse, may be {@code null}\n * @param separatorChar  the character used as the delimiter,{@code null} splits on whitespace\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitWorker#3155",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitWorker(java.lang.String, char, boolean)",
    "snippet": "private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        final int len \u003d str.length();\n        if (len \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n        int i \u003d 0, start \u003d 0;\n        boolean match \u003d false;\n        boolean lastMatch \u003d false;\n        while (i \u003c len) {\n            if (str.charAt(i) \u003d\u003d separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match \u003d false;\n                    lastMatch \u003d true;\n                }\n                start \u003d ++i;\n                continue;\n            }\n            lastMatch \u003d false;\n            match \u003d true;\n            i++;\n        }\n        if (match || preserveAllTokens \u0026\u0026 lastMatch) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }",
    "begin_line": 3155,
    "end_line": 3187,
    "comment": "/** \n * Performs the logic for the  {@code split} and{@code splitPreserveAllTokens} methods that do not return amaximum array length.\n * @param str  the String to parse, may be {@code null}\n * @param separatorChar the separate character\n * @param preserveAllTokens if {@code true}, adjacent separators are treated as empty token separators; if  {@code false}, adjacent separators are treated as one separator.\n * @return an array of parsed Strings, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitPreserveAllTokens#3222",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitPreserveAllTokens(java.lang.String, java.lang.String)",
    "snippet": "public static String[] splitPreserveAllTokens(final String str, final String separatorChars) {\n        return splitWorker(str, separatorChars, -1, true);\n    }",
    "begin_line": 3222,
    "end_line": 3224,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array, separators specified, preserving all tokens, including empty tokens created by adjacent separators. This is an alternative to using StringTokenizer.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} separatorChars splits on whitespace.\u003c/p\u003e\u003cpre\u003e StringUtils.splitPreserveAllTokens(null, *)           \u003d null StringUtils.splitPreserveAllTokens(\"\", *)             \u003d [] StringUtils.splitPreserveAllTokens(\"abc def\", null)   \u003d [\"abc\", \"def\"] StringUtils.splitPreserveAllTokens(\"abc def\", \" \")    \u003d [\"abc\", \"def\"] StringUtils.splitPreserveAllTokens(\"abc  def\", \" \")   \u003d [\"abc\", \"\", def\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\")   \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef:\", \":\")  \u003d [\"ab\", \"cd\", \"ef\", \"\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef::\", \":\") \u003d [\"ab\", \"cd\", \"ef\", \"\", \"\"] StringUtils.splitPreserveAllTokens(\"ab::cd:ef\", \":\")  \u003d [\"ab\", \"\", cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\":cd:ef\", \":\")     \u003d [\"\", cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"::cd:ef\", \":\")    \u003d [\"\", \"\", cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\":cd:ef:\", \":\")    \u003d [\"\", cd\", \"ef\", \"\"] \u003c/pre\u003e\n * @param str  the String to parse, may be {@code null}\n * @param separatorChars  the characters used as the delimiters,{@code null} splits on whitespace\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitPreserveAllTokens#3262",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitPreserveAllTokens(java.lang.String, java.lang.String, int)",
    "snippet": "public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {\n        return splitWorker(str, separatorChars, max, true);\n    }",
    "begin_line": 3262,
    "end_line": 3264,
    "comment": "/** \n * \u003cp\u003eSplits the provided text into an array with a maximum length, separators specified, preserving all tokens, including empty tokens created by adjacent separators.\u003c/p\u003e \u003cp\u003eThe separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. Adjacent separators are treated as one separator.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}. A  {@code null} separatorChars splits on whitespace.\u003c/p\u003e\u003cp\u003eIf more than  {@code max} delimited substrings are found, the lastreturned string includes all characters after the first  {@code max - 1}returned strings (including separator characters).\u003c/p\u003e \u003cpre\u003e StringUtils.splitPreserveAllTokens(null, *, *)            \u003d null StringUtils.splitPreserveAllTokens(\"\", *, *)              \u003d [] StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    \u003d [\"ab\", \"cd\", \"ef\"] StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    \u003d [\"ab\", \"cd:ef\"] StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) \u003d [\"ab\", \"  de fg\"] StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) \u003d [\"ab\", \"\", \" de fg\"] StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) \u003d [\"ab\", \"\", \"\", \"de fg\"] \u003c/pre\u003e\n * @param str  the String to parse, may be {@code null}\n * @param separatorChars  the characters used as the delimiters,{@code null} splits on whitespace\n * @param max  the maximum number of elements to include in thearray. A zero or negative value implies no limit\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitWorker#3280",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitWorker(java.lang.String, java.lang.String, int, boolean)",
    "snippet": "private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        final int len \u003d str.length();\n        if (len \u003d\u003d 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n        int sizePlus1 \u003d 1;\n        int i \u003d 0, start \u003d 0;\n        boolean match \u003d false;\n        boolean lastMatch \u003d false;\n        if (separatorChars \u003d\u003d null) {\n            // Null separator means use whitespace\n            while (i \u003c len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch \u003d true;\n                        if (sizePlus1++ \u003d\u003d max) {\n                            i \u003d len;\n                            lastMatch \u003d false;\n                        }\n                        list.add(str.substring(start, i));\n                        match \u003d false;\n                    }\n                    start \u003d ++i;\n                    continue;\n                }\n                lastMatch \u003d false;\n                match \u003d true;\n                i++;\n            }\n        } else if (separatorChars.length() \u003d\u003d 1) {\n            // Optimise 1 character case\n            final char sep \u003d separatorChars.charAt(0);\n            while (i \u003c len) {\n                if (str.charAt(i) \u003d\u003d sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch \u003d true;\n                        if (sizePlus1++ \u003d\u003d max) {\n                            i \u003d len;\n                            lastMatch \u003d false;\n                        }\n                        list.add(str.substring(start, i));\n                        match \u003d false;\n                    }\n                    start \u003d ++i;\n                    continue;\n                }\n                lastMatch \u003d false;\n                match \u003d true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i \u003c len) {\n                if (separatorChars.indexOf(str.charAt(i)) \u003e\u003d 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch \u003d true;\n                        if (sizePlus1++ \u003d\u003d max) {\n                            i \u003d len;\n                            lastMatch \u003d false;\n                        }\n                        list.add(str.substring(start, i));\n                        match \u003d false;\n                    }\n                    start \u003d ++i;\n                    continue;\n                }\n                lastMatch \u003d false;\n                match \u003d true;\n                i++;\n            }\n        }\n        if (match || preserveAllTokens \u0026\u0026 lastMatch) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }",
    "begin_line": 3280,
    "end_line": 3363,
    "comment": "/** \n * Performs the logic for the  {@code split} and{@code splitPreserveAllTokens} methods that return a maximum arraylength.\n * @param str  the String to parse, may be {@code null}\n * @param separatorChars the separate character\n * @param max  the maximum number of elements to include in thearray. A zero or negative value implies no limit.\n * @param preserveAllTokens if {@code true}, adjacent separators are treated as empty token separators; if  {@code false}, adjacent separators are treated as one separator.\n * @return an array of parsed Strings, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByCharacterType#3384",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByCharacterType(java.lang.String)",
    "snippet": "public static String[] splitByCharacterType(final String str) {\n        return splitByCharacterType(str, false);\n    }",
    "begin_line": 3384,
    "end_line": 3386,
    "comment": "/** \n * \u003cp\u003eSplits a String by Character type as returned by {@code java.lang.Character.getType(char)}. Groups of contiguous characters of the same type are returned as complete tokens. \u003cpre\u003e StringUtils.splitByCharacterType(null)         \u003d null StringUtils.splitByCharacterType(\"\")           \u003d [] StringUtils.splitByCharacterType(\"ab de fg\")   \u003d [\"ab\", \" \", \"de\", \" \", \"fg\"] StringUtils.splitByCharacterType(\"ab   de fg\") \u003d [\"ab\", \"   \", \"de\", \" \", \"fg\"] StringUtils.splitByCharacterType(\"ab:cd:ef\")   \u003d [\"ab\", \":\", \"cd\", \":\", \"ef\"] StringUtils.splitByCharacterType(\"number5\")    \u003d [\"number\", \"5\"] StringUtils.splitByCharacterType(\"fooBar\")     \u003d [\"foo\", \"B\", \"ar\"] StringUtils.splitByCharacterType(\"foo200Bar\")  \u003d [\"foo\", \"200\", \"B\", \"ar\"] StringUtils.splitByCharacterType(\"ASFRules\")   \u003d [\"ASFR\", \"ules\"] \u003c/pre\u003e\n * @param str the String to split, may be {@code null}\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByCharacterTypeCamelCase#3412",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByCharacterTypeCamelCase(java.lang.String)",
    "snippet": "public static String[] splitByCharacterTypeCamelCase(final String str) {\n        return splitByCharacterType(str, true);\n    }",
    "begin_line": 3412,
    "end_line": 3414,
    "comment": "/** \n * \u003cp\u003eSplits a String by Character type as returned by {@code java.lang.Character.getType(char)}. Groups of contiguous characters of the same type are returned as complete tokens, with the following exception: the character of type {@code Character.UPPERCASE_LETTER}, if any, immediately preceding a token of type  {@code Character.LOWERCASE_LETTER}will belong to the following token rather than to the preceding, if any, {@code Character.UPPERCASE_LETTER} token.\u003cpre\u003e StringUtils.splitByCharacterTypeCamelCase(null)         \u003d null StringUtils.splitByCharacterTypeCamelCase(\"\")           \u003d [] StringUtils.splitByCharacterTypeCamelCase(\"ab de fg\")   \u003d [\"ab\", \" \", \"de\", \" \", \"fg\"] StringUtils.splitByCharacterTypeCamelCase(\"ab   de fg\") \u003d [\"ab\", \"   \", \"de\", \" \", \"fg\"] StringUtils.splitByCharacterTypeCamelCase(\"ab:cd:ef\")   \u003d [\"ab\", \":\", \"cd\", \":\", \"ef\"] StringUtils.splitByCharacterTypeCamelCase(\"number5\")    \u003d [\"number\", \"5\"] StringUtils.splitByCharacterTypeCamelCase(\"fooBar\")     \u003d [\"foo\", \"Bar\"] StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\")  \u003d [\"foo\", \"200\", \"Bar\"] StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\")   \u003d [\"ASF\", \"Rules\"] \u003c/pre\u003e\n * @param str the String to split, may be {@code null}\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.splitByCharacterType#3430",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.splitByCharacterType(java.lang.String, boolean)",
    "snippet": "private static String[] splitByCharacterType(final String str, final boolean camelCase) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final char[] c \u003d str.toCharArray();\n        final List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n        int tokenStart \u003d 0;\n        int currentType \u003d Character.getType(c[tokenStart]);\n        for (int pos \u003d tokenStart + 1; pos \u003c c.length; pos++) {\n            final int type \u003d Character.getType(c[pos]);\n            if (type \u003d\u003d currentType) {\n                continue;\n            }\n            if (camelCase \u0026\u0026 type \u003d\u003d Character.LOWERCASE_LETTER \u0026\u0026 currentType \u003d\u003d Character.UPPERCASE_LETTER) {\n                final int newTokenStart \u003d pos - 1;\n                if (newTokenStart !\u003d tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart \u003d newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart \u003d pos;\n            }\n            currentType \u003d type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }",
    "begin_line": 3430,
    "end_line": 3460,
    "comment": "/** \n * \u003cp\u003eSplits a String by Character type as returned by {@code java.lang.Character.getType(char)}. Groups of contiguous characters of the same type are returned as complete tokens, with the following exception: if  {@code camelCase} is {@code true}, the character of type  {@code Character.UPPERCASE_LETTER}, if any, immediately preceding a token of type  {@code Character.LOWERCASE_LETTER}will belong to the following token rather than to the preceding, if any, {@code Character.UPPERCASE_LETTER} token.\n * @param str the String to split, may be {@code null}\n * @param camelCase whether to use so-called \"camel-case\" for letter types\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3486",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(T)",
    "snippet": "public static \u003cT\u003e String join(final T... elements) {\n        return join(elements, null);\n    }",
    "begin_line": 3486,
    "end_line": 3488,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo separator is added to the joined String. Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null)            \u003d null StringUtils.join([])              \u003d \"\" StringUtils.join([null])          \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"]) \u003d \"abc\" StringUtils.join([null, \"\", \"a\"]) \u003d \"a\" \u003c/pre\u003e\n * @param \u003c T \u003e the specific type of values to join together\n * @param elements  the values to join together, may be null\n * @return the joined String, {@code null} if null array input\n * @since 2.0\n * @since 3.0 Changed signature to use varargs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3512",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Object[], char)",
    "snippet": "public static String join(final Object[] array, final char separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 3512,
    "end_line": 3517,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"], \u0027;\u0027)  \u003d \"a;b;c\" StringUtils.join([\"a\", \"b\", \"c\"], null) \u003d \"abc\" StringUtils.join([null, \"\", \"a\"], \u0027;\u0027)  \u003d \";;a\" \u003c/pre\u003e\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use\n * @return the joined String, {@code null} if null array input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3544",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(long[], char)",
    "snippet": "public static String join(final long[] array, final char separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 3544,
    "end_line": 3549,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3576",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(int[], char)",
    "snippet": "public static String join(final int[] array, final char separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 3576,
    "end_line": 3581,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3608",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(short[], char)",
    "snippet": "public static String join(final short[] array, final char separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 3608,
    "end_line": 3613,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3640",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(byte[], char)",
    "snippet": "public static String join(final byte[] array, final char separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 3640,
    "end_line": 3645,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3672",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(char[], char)",
    "snippet": "public static String join(final char[] array, final char separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 3672,
    "end_line": 3677,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3704",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(float[], char)",
    "snippet": "public static String join(final float[] array, final char separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 3704,
    "end_line": 3709,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3736",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(double[], char)",
    "snippet": "public static String join(final double[] array, final char separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 3736,
    "end_line": 3741,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3770",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Object[], char, int, int)",
    "snippet": "public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        final int noOfItems \u003d endIndex - startIndex;\n        if (noOfItems \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final StringBuilder buf \u003d new StringBuilder(noOfItems * 16);\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] !\u003d null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }",
    "begin_line": 3770,
    "end_line": 3788,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"], \u0027;\u0027)  \u003d \"a;b;c\" StringUtils.join([\"a\", \"b\", \"c\"], null) \u003d \"abc\" StringUtils.join([null, \"\", \"a\"], \u0027;\u0027)  \u003d \";;a\" \u003c/pre\u003e\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use\n * @param startIndex the first index to start joining from.  It isan error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It isan error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3821",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(long[], char, int, int)",
    "snippet": "public static String join(final long[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        final int noOfItems \u003d endIndex - startIndex;\n        if (noOfItems \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final StringBuilder buf \u003d new StringBuilder(noOfItems * 16);\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            buf.append(array[i]);\n        }\n        return buf.toString();\n    }",
    "begin_line": 3821,
    "end_line": 3837,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @param startIndex the first index to start joining from. It is an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3870",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(int[], char, int, int)",
    "snippet": "public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        final int noOfItems \u003d endIndex - startIndex;\n        if (noOfItems \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final StringBuilder buf \u003d new StringBuilder(noOfItems * 16);\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            buf.append(array[i]);\n        }\n        return buf.toString();\n    }",
    "begin_line": 3870,
    "end_line": 3886,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @param startIndex the first index to start joining from. It is an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3919",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(byte[], char, int, int)",
    "snippet": "public static String join(final byte[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        final int noOfItems \u003d endIndex - startIndex;\n        if (noOfItems \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final StringBuilder buf \u003d new StringBuilder(noOfItems * 16);\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            buf.append(array[i]);\n        }\n        return buf.toString();\n    }",
    "begin_line": 3919,
    "end_line": 3935,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @param startIndex the first index to start joining from. It is an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#3968",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(short[], char, int, int)",
    "snippet": "public static String join(final short[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        final int noOfItems \u003d endIndex - startIndex;\n        if (noOfItems \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final StringBuilder buf \u003d new StringBuilder(noOfItems * 16);\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            buf.append(array[i]);\n        }\n        return buf.toString();\n    }",
    "begin_line": 3968,
    "end_line": 3984,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @param startIndex the first index to start joining from. It is an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#4017",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(char[], char, int, int)",
    "snippet": "public static String join(final char[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        final int noOfItems \u003d endIndex - startIndex;\n        if (noOfItems \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final StringBuilder buf \u003d new StringBuilder(noOfItems * 16);\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            buf.append(array[i]);\n        }\n        return buf.toString();\n    }",
    "begin_line": 4017,
    "end_line": 4033,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @param startIndex the first index to start joining from. It is an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#4066",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(double[], char, int, int)",
    "snippet": "public static String join(final double[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        final int noOfItems \u003d endIndex - startIndex;\n        if (noOfItems \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final StringBuilder buf \u003d new StringBuilder(noOfItems * 16);\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            buf.append(array[i]);\n        }\n        return buf.toString();\n    }",
    "begin_line": 4066,
    "end_line": 4082,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @param startIndex the first index to start joining from. It is an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#4115",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(float[], char, int, int)",
    "snippet": "public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        final int noOfItems \u003d endIndex - startIndex;\n        if (noOfItems \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final StringBuilder buf \u003d new StringBuilder(noOfItems * 16);\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            buf.append(array[i]);\n        }\n        return buf.toString();\n    }",
    "begin_line": 4115,
    "end_line": 4131,
    "comment": "/** \n * \u003cp\u003e Joins the elements of the provided array into a single String containing the provided list of elements. \u003c/p\u003e \u003cp\u003e No delimiter is added before or after the list. Null objects or empty strings within the array are represented by empty strings. \u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)               \u003d null StringUtils.join([], *)                 \u003d \"\" StringUtils.join([null], *)             \u003d \"\" StringUtils.join([1, 2, 3], \u0027;\u0027)  \u003d \"1;2;3\" StringUtils.join([1, 2, 3], null) \u003d \"123\" \u003c/pre\u003e\n * @param array the array of values to join together, may be null\n * @param separator the separator character to use\n * @param startIndex the first index to start joining from. It is an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#4157",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Object[], java.lang.String)",
    "snippet": "public static String join(final Object[] array, final String separator) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }",
    "begin_line": 4157,
    "end_line": 4162,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. A  {@code null} separator is the same as an empty String (\"\").Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *)                \u003d null StringUtils.join([], *)                  \u003d \"\" StringUtils.join([null], *)              \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  \u003d \"a--b--c\" StringUtils.join([\"a\", \"b\", \"c\"], null)  \u003d \"abc\" StringUtils.join([\"a\", \"b\", \"c\"], \"\")    \u003d \"abc\" StringUtils.join([null, \"\", \"a\"], \u0027,\u0027)   \u003d \",,a\" \u003c/pre\u003e\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @return the joined String, {@code null} if null array input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#4199",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Object[], java.lang.String, int, int)",
    "snippet": "public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {\n        if (array \u003d\u003d null) {\n            return null;\n        }\n        if (separator \u003d\u003d null) {\n            separator \u003d EMPTY;\n        }\n\n        // endIndex - startIndex \u003e 0:   Len \u003d NofStrings *(len(firstString) + len(separator))\n        //           (Assuming that all Strings are roughly equally long)\n        final int noOfItems \u003d endIndex - startIndex;\n        if (noOfItems \u003c\u003d 0) {\n            return EMPTY;\n        }\n\n        final StringBuilder buf \u003d new StringBuilder(noOfItems * 16);\n\n        for (int i \u003d startIndex; i \u003c endIndex; i++) {\n            if (i \u003e startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] !\u003d null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }",
    "begin_line": 4199,
    "end_line": 4225,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided array into a single String containing the provided list of elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. A  {@code null} separator is the same as an empty String (\"\").Null objects or empty strings within the array are represented by empty strings.\u003c/p\u003e \u003cpre\u003e StringUtils.join(null, *, *, *)                \u003d null StringUtils.join([], *, *, *)                  \u003d \"\" StringUtils.join([null], *, *, *)              \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"], \"--\", 0, 3)  \u003d \"a--b--c\" StringUtils.join([\"a\", \"b\", \"c\"], \"--\", 1, 3)  \u003d \"b--c\" StringUtils.join([\"a\", \"b\", \"c\"], \"--\", 2, 3)  \u003d \"c\" StringUtils.join([\"a\", \"b\", \"c\"], \"--\", 2, 2)  \u003d \"\" StringUtils.join([\"a\", \"b\", \"c\"], null, 0, 3)  \u003d \"abc\" StringUtils.join([\"a\", \"b\", \"c\"], \"\", 0, 3)    \u003d \"abc\" StringUtils.join([null, \"\", \"a\"], \u0027,\u0027, 0, 3)   \u003d \",,a\" \u003c/pre\u003e\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @param startIndex the first index to start joining from.\n * @param endIndex the index to stop joining from (exclusive).\n * @return the joined String, {@code null} if null array input; or the empty stringif  {@code endIndex - startIndex \u003c\u003d 0}. The number of joined entries is given by {@code endIndex - startIndex}\n * @throws ArrayIndexOutOfBoundsException ife\u003cbr\u003e{@code startIndex \u003c 0} or \u003cbr\u003e{@code startIndex \u003e\u003d array.length()} or \u003cbr\u003e{@code endIndex \u003c 0} or \u003cbr\u003e{@code endIndex \u003e array.length()}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#4241",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.util.Iterator\u003c?\u003e, char)",
    "snippet": "public static String join(final Iterator\u003c?\u003e iterator, final char separator) {\n\n        // handle null, zero and one elements before building a buffer\n        if (iterator \u003d\u003d null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        final Object first \u003d iterator.next();\n        if (!iterator.hasNext()) {\n            @SuppressWarnings( \"deprecation\" ) // ObjectUtils.toString(Object) has been deprecated in 3.2\n            final\n            String result \u003d ObjectUtils.toString(first);\n            return result;\n        }\n\n        // two or more elements\n        final StringBuilder buf \u003d new StringBuilder(256); // Java default is 16, probably too small\n        if (first !\u003d null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            final Object obj \u003d iterator.next();\n            if (obj !\u003d null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }",
    "begin_line": 4241,
    "end_line": 4273,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided  {@code Iterator} intoa single String containing the provided elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. Null objects or empty strings within the iteration are represented by empty strings.\u003c/p\u003e \u003cp\u003eSee the examples here:  {@link #join(Object[],char)}. \u003c/p\u003e\n * @param iterator  the {@code Iterator} of values to join together, may be null\n * @param separator  the separator character to use\n * @return the joined String, {@code null} if null iterator input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#4288",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.util.Iterator\u003c?\u003e, java.lang.String)",
    "snippet": "public static String join(final Iterator\u003c?\u003e iterator, final String separator) {\n\n        // handle null, zero and one elements before building a buffer\n        if (iterator \u003d\u003d null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        final Object first \u003d iterator.next();\n        if (!iterator.hasNext()) {\n            @SuppressWarnings( \"deprecation\" ) // ObjectUtils.toString(Object) has been deprecated in 3.2\n            final String result \u003d ObjectUtils.toString(first);\n            return result;\n        }\n\n        // two or more elements\n        final StringBuilder buf \u003d new StringBuilder(256); // Java default is 16, probably too small\n        if (first !\u003d null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator !\u003d null) {\n                buf.append(separator);\n            }\n            final Object obj \u003d iterator.next();\n            if (obj !\u003d null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }",
    "begin_line": 4288,
    "end_line": 4320,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided  {@code Iterator} intoa single String containing the provided elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. A  {@code null} separator is the same as an empty String (\"\").\u003c/p\u003e\u003cp\u003eSee the examples here:  {@link #join(Object[],String)}. \u003c/p\u003e\n * @param iterator  the {@code Iterator} of values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @return the joined String, {@code null} if null iterator input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#4336",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Iterable\u003c?\u003e, char)",
    "snippet": "public static String join(final Iterable\u003c?\u003e iterable, final char separator) {\n        if (iterable \u003d\u003d null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }",
    "begin_line": 4336,
    "end_line": 4341,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided  {@code Iterable} intoa single String containing the provided elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. Null objects or empty strings within the iteration are represented by empty strings.\u003c/p\u003e \u003cp\u003eSee the examples here:  {@link #join(Object[],char)}. \u003c/p\u003e\n * @param iterable  the {@code Iterable} providing the values to join together, may be null\n * @param separator  the separator character to use\n * @return the joined String, {@code null} if null iterator input\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.join#4357",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.join(java.lang.Iterable\u003c?\u003e, java.lang.String)",
    "snippet": "public static String join(final Iterable\u003c?\u003e iterable, final String separator) {\n        if (iterable \u003d\u003d null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }",
    "begin_line": 4357,
    "end_line": 4362,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided  {@code Iterable} intoa single String containing the provided elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. A  {@code null} separator is the same as an empty String (\"\").\u003c/p\u003e\u003cp\u003eSee the examples here:  {@link #join(Object[],String)}. \u003c/p\u003e\n * @param iterable  the {@code Iterable} providing the values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @return the joined String, {@code null} if null iterator input\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.joinWith#4383",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.joinWith(java.lang.String, java.lang.Object)",
    "snippet": "public static String joinWith(final String separator, final Object... objects) {\n        if (objects \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Object varargs must not be null\");\n        }\n\n        final String sanitizedSeparator \u003d defaultString(separator, StringUtils.EMPTY);\n\n        final StringBuilder result \u003d new StringBuilder();\n\n        final Iterator\u003cObject\u003e iterator \u003d Arrays.asList(objects).iterator();\n        while (iterator.hasNext()) {\n            @SuppressWarnings(\"deprecation\") // o.k. to use as long as we do not require java 7 or greater\n            final String value \u003d ObjectUtils.toString(iterator.next());\n            result.append(value);\n\n            if (iterator.hasNext()) {\n                result.append(sanitizedSeparator);\n            }\n        }\n\n        return result.toString();\n    }",
    "begin_line": 4383,
    "end_line": 4404,
    "comment": "/** \n * \u003cp\u003eJoins the elements of the provided varargs into a single String containing the provided elements.\u003c/p\u003e \u003cp\u003eNo delimiter is added before or after the list. {@code null} elements and separator are treated as empty Strings (\"\").\u003c/p\u003e\u003cpre\u003e StringUtils.joinWith(\",\", {\"a\", \"b\"})        \u003d \"a,b\" StringUtils.joinWith(\",\", {\"a\", \"b\",\"\"})     \u003d \"a,b,\" StringUtils.joinWith(\",\", {\"a\", null, \"b\"})  \u003d \"a,,b\" StringUtils.joinWith(null, {\"a\", \"b\"})       \u003d \"ab\" \u003c/pre\u003e\n * @param separator the separator character to use, null treated as \"\"\n * @param objects the varargs providing the values to join together. {@code null} elements are treated as \"\"\n * @return the joined String.\n * @throws java.lang.IllegalArgumentException if a null varargs is provided\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.deleteWhitespace#4422",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.deleteWhitespace(java.lang.String)",
    "snippet": "public static String deleteWhitespace(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int sz \u003d str.length();\n        final char[] chs \u003d new char[sz];\n        int count \u003d 0;\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] \u003d str.charAt(i);\n            }\n        }\n        if (count \u003d\u003d sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
    "begin_line": 4422,
    "end_line": 4438,
    "comment": "/** \n * \u003cp\u003eDeletes all whitespaces from a String as defined by {@link Character#isWhitespace(char)}.\u003c/p\u003e \u003cpre\u003e StringUtils.deleteWhitespace(null)         \u003d null StringUtils.deleteWhitespace(\"\")           \u003d \"\" StringUtils.deleteWhitespace(\"abc\")        \u003d \"abc\" StringUtils.deleteWhitespace(\"   ab  c  \") \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to delete whitespace from, may be null\n * @return the String without whitespaces, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.removeStart#4466",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.removeStart(java.lang.String, java.lang.String)",
    "snippet": "public static String removeStart(final String str, final String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)){\n            return str.substring(remove.length());\n        }\n        return str;\n    }",
    "begin_line": 4466,
    "end_line": 4474,
    "comment": "/** \n * \u003cp\u003eRemoves a substring only if it is at the beginning of a source string, otherwise returns the source string.\u003c/p\u003e \u003cp\u003eA  {@code null} source string will return {@code null}. An empty (\"\") source string will return the empty string. A  {@code null} search string will return the source string.\u003c/p\u003e\u003cpre\u003e StringUtils.removeStart(null, *)      \u003d null StringUtils.removeStart(\"\", *)        \u003d \"\" StringUtils.removeStart(*, null)      \u003d  StringUtils.removeStart(\"www.domain.com\", \"www.\")   \u003d \"domain.com\" StringUtils.removeStart(\"domain.com\", \"www.\")       \u003d \"domain.com\" StringUtils.removeStart(\"www.domain.com\", \"domain\") \u003d \"www.domain.com\" StringUtils.removeStart(\"abc\", \"\")    \u003d \"abc\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for and remove, may be null\n * @return the substring with the string removed if found,{@code null} if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.removeStartIgnoreCase#4501",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.removeStartIgnoreCase(java.lang.String, java.lang.String)",
    "snippet": "public static String removeStartIgnoreCase(final String str, final String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }",
    "begin_line": 4501,
    "end_line": 4509,
    "comment": "/** \n * \u003cp\u003eCase insensitive removal of a substring if it is at the beginning of a source string, otherwise returns the source string.\u003c/p\u003e \u003cp\u003eA  {@code null} source string will return {@code null}. An empty (\"\") source string will return the empty string. A  {@code null} search string will return the source string.\u003c/p\u003e\u003cpre\u003e StringUtils.removeStartIgnoreCase(null, *)      \u003d null StringUtils.removeStartIgnoreCase(\"\", *)        \u003d \"\" StringUtils.removeStartIgnoreCase(*, null)      \u003d  StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"www.\")   \u003d \"domain.com\" StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"WWW.\")   \u003d \"domain.com\" StringUtils.removeStartIgnoreCase(\"domain.com\", \"www.\")       \u003d \"domain.com\" StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"domain\") \u003d \"www.domain.com\" StringUtils.removeStartIgnoreCase(\"abc\", \"\")    \u003d \"abc\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for (case insensitive) and remove, may be null\n * @return the substring with the string removed if found,{@code null} if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.removeEnd#4535",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.removeEnd(java.lang.String, java.lang.String)",
    "snippet": "public static String removeEnd(final String str, final String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }",
    "begin_line": 4535,
    "end_line": 4543,
    "comment": "/** \n * \u003cp\u003eRemoves a substring only if it is at the end of a source string, otherwise returns the source string.\u003c/p\u003e \u003cp\u003eA  {@code null} source string will return {@code null}. An empty (\"\") source string will return the empty string. A  {@code null} search string will return the source string.\u003c/p\u003e\u003cpre\u003e StringUtils.removeEnd(null, *)      \u003d null StringUtils.removeEnd(\"\", *)        \u003d \"\" StringUtils.removeEnd(*, null)      \u003d  StringUtils.removeEnd(\"www.domain.com\", \".com.\")  \u003d \"www.domain.com\" StringUtils.removeEnd(\"www.domain.com\", \".com\")   \u003d \"www.domain\" StringUtils.removeEnd(\"www.domain.com\", \"domain\") \u003d \"www.domain.com\" StringUtils.removeEnd(\"abc\", \"\")    \u003d \"abc\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for and remove, may be null\n * @return the substring with the string removed if found,{@code null} if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.removeEndIgnoreCase#4571",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.removeEndIgnoreCase(java.lang.String, java.lang.String)",
    "snippet": "public static String removeEndIgnoreCase(final String str, final String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }",
    "begin_line": 4571,
    "end_line": 4579,
    "comment": "/** \n * \u003cp\u003eCase insensitive removal of a substring if it is at the end of a source string, otherwise returns the source string.\u003c/p\u003e \u003cp\u003eA  {@code null} source string will return {@code null}. An empty (\"\") source string will return the empty string. A  {@code null} search string will return the source string.\u003c/p\u003e\u003cpre\u003e StringUtils.removeEndIgnoreCase(null, *)      \u003d null StringUtils.removeEndIgnoreCase(\"\", *)        \u003d \"\" StringUtils.removeEndIgnoreCase(*, null)      \u003d  StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".com.\")  \u003d \"www.domain.com\" StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".com\")   \u003d \"www.domain\" StringUtils.removeEndIgnoreCase(\"www.domain.com\", \"domain\") \u003d \"www.domain.com\" StringUtils.removeEndIgnoreCase(\"abc\", \"\")    \u003d \"abc\" StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".COM\") \u003d \"www.domain\") StringUtils.removeEndIgnoreCase(\"www.domain.COM\", \".com\") \u003d \"www.domain\") \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for (case insensitive) and remove, may be null\n * @return the substring with the string removed if found,{@code null} if null String input\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.remove#4604",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.remove(java.lang.String, java.lang.String)",
    "snippet": "public static String remove(final String str, final String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        return replace(str, remove, EMPTY, -1);\n    }",
    "begin_line": 4604,
    "end_line": 4609,
    "comment": "/** \n * \u003cp\u003eRemoves all occurrences of a substring from within the source string.\u003c/p\u003e \u003cp\u003eA  {@code null} source string will return {@code null}. An empty (\"\") source string will return the empty string. A  {@code null} remove string will return the source string.An empty (\"\") remove string will return the source string.\u003c/p\u003e \u003cpre\u003e StringUtils.remove(null, *)        \u003d null StringUtils.remove(\"\", *)          \u003d \"\" StringUtils.remove(*, null)        \u003d  StringUtils.remove(*, \"\")          \u003d  StringUtils.remove(\"queued\", \"ue\") \u003d \"qd\" StringUtils.remove(\"queued\", \"zz\") \u003d \"queued\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the String to search for and remove, may be null\n * @return the substring with the string removed if found,{@code null} if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.remove#4630",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.remove(java.lang.String, char)",
    "snippet": "public static String remove(final String str, final char remove) {\n        if (isEmpty(str) || str.indexOf(remove) \u003d\u003d INDEX_NOT_FOUND) {\n            return str;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int pos \u003d 0;\n        for (int i \u003d 0; i \u003c chars.length; i++) {\n            if (chars[i] !\u003d remove) {\n                chars[pos++] \u003d chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }",
    "begin_line": 4630,
    "end_line": 4642,
    "comment": "/** \n * \u003cp\u003eRemoves all occurrences of a character from within the source string.\u003c/p\u003e \u003cp\u003eA  {@code null} source string will return {@code null}. An empty (\"\") source string will return the empty string.\u003c/p\u003e \u003cpre\u003e StringUtils.remove(null, *)       \u003d null StringUtils.remove(\"\", *)         \u003d \"\" StringUtils.remove(\"queued\", \u0027u\u0027) \u003d \"qeed\" StringUtils.remove(\"queued\", \u0027z\u0027) \u003d \"queued\" \u003c/pre\u003e\n * @param str  the source String to search, may be null\n * @param remove  the char to search for and remove, may be null\n * @return the substring with the char removed if found,{@code null} if null String input\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceOnce#4669",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceOnce(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String replaceOnce(final String text, final String searchString, final String replacement) {\n        return replace(text, searchString, replacement, 1);\n    }",
    "begin_line": 4669,
    "end_line": 4671,
    "comment": "/** \n * \u003cp\u003eReplaces a String with another String inside a larger String, once.\u003c/p\u003e \u003cp\u003eA  {@code null} reference passed to this method is a no-op.\u003c/p\u003e\u003cpre\u003e StringUtils.replaceOnce(null, *, *)        \u003d null StringUtils.replaceOnce(\"\", *, *)          \u003d \"\" StringUtils.replaceOnce(\"any\", null, *)    \u003d \"any\" StringUtils.replaceOnce(\"any\", *, null)    \u003d \"any\" StringUtils.replaceOnce(\"any\", \"\", *)      \u003d \"any\" StringUtils.replaceOnce(\"aba\", \"a\", null)  \u003d \"aba\" StringUtils.replaceOnce(\"aba\", \"a\", \"\")    \u003d \"ba\" StringUtils.replaceOnce(\"aba\", \"a\", \"z\")   \u003d \"zba\" \u003c/pre\u003e\n * @see #replace(String text,String searchString,String replacement,int max)\n * @param text  text to search and replace in, may be null\n * @param searchString  the String to search for, may be null\n * @param replacement  the String to replace with, may be null\n * @return the text with any replacements processed,{@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replacePattern#4693",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replacePattern(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String replacePattern(final String source, final String regex, final String replacement) {\n        return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);\n    }",
    "begin_line": 4693,
    "end_line": 4695,
    "comment": "/** \n * Replaces each substring of the source String that matches the given regular expression with the given replacement using the  {@link Pattern#DOTALL} option. DOTALL is also know as single-line mode in Perl. This callis also equivalent to: \u003cul\u003e \u003cli\u003e {@code source.replaceAll(\u0026quot;(?s)\u0026quot; + regex, replacement)}\u003c/li\u003e \u003cli\u003e {@code Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement)}\u003c/li\u003e \u003c/ul\u003e\n * @param source the source string\n * @param regex the regular expression to which this string is to be matched\n * @param replacement the string to be substituted for each match\n * @return The resulting {@code String}\n * @see String#replaceAll(String,String)\n * @see Pattern#DOTALL\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.removePattern#4709",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.removePattern(java.lang.String, java.lang.String)",
    "snippet": "public static String removePattern(final String source, final String regex) {\n        return replacePattern(source, regex, StringUtils.EMPTY);\n    }",
    "begin_line": 4709,
    "end_line": 4711,
    "comment": "/** \n * Removes each substring of the source String that matches the given regular expression using the DOTALL option.\n * @param source the source string\n * @param regex the regular expression to which this string is to be matched\n * @return The resulting {@code String}\n * @see String#replaceAll(String,String)\n * @see Pattern#DOTALL\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceAll#4759",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceAll(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String replaceAll(final String text, final String regex, final String replacement) {\n        if (text \u003d\u003d null || regex \u003d\u003d null|| replacement \u003d\u003d null ) {\n            return text;\n        }\n        return text.replaceAll(regex, replacement);\n    }",
    "begin_line": 4759,
    "end_line": 4764,
    "comment": "/** \n * \u003cp\u003eReplaces each substring of the text String that matches the given regular expression with the given replacement.\u003c/p\u003e This method is a  {@code null} safe equivalent to:\u003cul\u003e \u003cli\u003e {@code text.replaceAll(regex, replacement)}\u003c/li\u003e \u003cli\u003e {@code Pattern.compile(regex).matcher(text).replaceAll(replacement)}\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eA  {@code null} reference passed to this method is a no-op.\u003c/p\u003e\u003cp\u003eUnlike in the  {@link #replacePattern(String,String,String)} method, the {@link Pattern#DOTALL} optionis NOT automatically added. To use the DOTALL option prepend \u003ccode\u003e\"(?s)\"\u003c/code\u003e to the regex. DOTALL is also know as single-line mode in Perl.\u003c/p\u003e \u003cpre\u003e StringUtils.replaceAll(null, *, *)       \u003d null StringUtils.replaceAll(\"any\", null, *)   \u003d \"any\" StringUtils.replaceAll(\"any\", *, null)   \u003d \"any\" StringUtils.replaceAll(\"\", \"\", \"zzz\")    \u003d \"zzz\" StringUtils.replaceAll(\"\", \".*\", \"zzz\")  \u003d \"zzz\" StringUtils.replaceAll(\"\", \".+\", \"zzz\")  \u003d \"\" StringUtils.replaceAll(\"\u003c__\u003e\\n\u003c__\u003e\", \"\u003c.*\u003e\", \"z\")      \u003d \"z\\nz\" StringUtils.replaceAll(\"\u003c__\u003e\\n\u003c__\u003e\", \"(?s)\u003c.*\u003e\", \"z\")  \u003d \"z\" StringUtils.replaceAll(\"ABCabc123\", \"[a-z]\", \"_\")       \u003d \"ABC___123\" StringUtils.replaceAll(\"ABCabc123\", \"[^A-Z0-9]+\", \"_\")  \u003d \"ABC_123\" StringUtils.replaceAll(\"ABCabc123\", \"[^A-Z0-9]+\", \"\")   \u003d \"ABC123\" StringUtils.replaceAll(\"Lorem ipsum  dolor   sit\", \"( +)([a-z]+)\", \"_$2\")  \u003d \"Lorem_ipsum_dolor_sit\" \u003c/pre\u003e\n * @param text  text to search and replace in, may be null\n * @param regex  the regular expression to which this string is to be matched\n * @param replacement  the string to be substituted for each match\n * @return  the text with any replacements processed,{@code null} if null String input\n * @throws java.util.regex.PatternSyntaxException if the regular expression\u0027s syntax is invalid\n * @see String#replaceAll(String,String)\n * @see java.util.regex.Pattern\n * @see java.util.regex.Pattern#DOTALL\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceFirst#4811",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceFirst(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String replaceFirst(final String text, final String regex, final String replacement) {\n        if (text \u003d\u003d null || regex \u003d\u003d null|| replacement \u003d\u003d null ) {\n            return text;\n        }\n        return text.replaceFirst(regex, replacement);\n    }",
    "begin_line": 4811,
    "end_line": 4816,
    "comment": "/** \n * \u003cp\u003eReplaces the first substring of the text string that matches the given regular expression with the given replacement.\u003c/p\u003e This method is a  {@code null} safe equivalent to:\u003cul\u003e \u003cli\u003e {@code text.replaceFirst(regex, replacement)}\u003c/li\u003e \u003cli\u003e {@code Pattern.compile(regex).matcher(text).replaceFirst(replacement)}\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eA  {@code null} reference passed to this method is a no-op.\u003c/p\u003e\u003cp\u003eThe  {@link Pattern#DOTALL} option is NOT automatically added.To use the DOTALL option prepend \u003ccode\u003e\"(?s)\"\u003c/code\u003e to the regex. DOTALL is also know as single-line mode in Perl.\u003c/p\u003e \u003cpre\u003e StringUtils.replaceFirst(null, *, *)       \u003d null StringUtils.replaceFirst(\"any\", null, *)   \u003d \"any\" StringUtils.replaceFirst(\"any\", *, null)   \u003d \"any\" StringUtils.replaceFirst(\"\", \"\", \"zzz\")    \u003d \"zzz\" StringUtils.replaceFirst(\"\", \".*\", \"zzz\")  \u003d \"zzz\" StringUtils.replaceFirst(\"\", \".+\", \"zzz\")  \u003d \"\" StringUtils.replaceFirst(\"\u003c__\u003e\\n\u003c__\u003e\", \"\u003c.*\u003e\", \"z\")      \u003d \"z\\n\u003c__\u003e\" StringUtils.replaceFirst(\"\u003c__\u003e\\n\u003c__\u003e\", \"(?s)\u003c.*\u003e\", \"z\")  \u003d \"z\" StringUtils.replaceFirst(\"ABCabc123\", \"[a-z]\", \"_\")          \u003d \"ABC_bc123\" StringUtils.replaceFirst(\"ABCabc123abc\", \"[^A-Z0-9]+\", \"_\")  \u003d \"ABC_123abc\" StringUtils.replaceFirst(\"ABCabc123abc\", \"[^A-Z0-9]+\", \"\")   \u003d \"ABC123abc\" StringUtils.replaceFirst(\"Lorem ipsum  dolor   sit\", \"( +)([a-z]+)\", \"_$2\")  \u003d \"Lorem_ipsum  dolor   sit\" \u003c/pre\u003e\n * @param text  text to search and replace in, may be null\n * @param regex  the regular expression to which this string is to be matched\n * @param replacement  the string to be substituted for the first match\n * @return  the text with the first replacement processed,{@code null} if null String input\n * @throws java.util.regex.PatternSyntaxException if the regular expression\u0027s syntax is invalid\n * @see String#replaceFirst(String,String)\n * @see java.util.regex.Pattern\n * @see java.util.regex.Pattern#DOTALL\n * @since 3.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replace#4841",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replace(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String replace(final String text, final String searchString, final String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }",
    "begin_line": 4841,
    "end_line": 4843,
    "comment": "/** \n * \u003cp\u003eReplaces all occurrences of a String within another String.\u003c/p\u003e \u003cp\u003eA  {@code null} reference passed to this method is a no-op.\u003c/p\u003e\u003cpre\u003e StringUtils.replace(null, *, *)        \u003d null StringUtils.replace(\"\", *, *)          \u003d \"\" StringUtils.replace(\"any\", null, *)    \u003d \"any\" StringUtils.replace(\"any\", *, null)    \u003d \"any\" StringUtils.replace(\"any\", \"\", *)      \u003d \"any\" StringUtils.replace(\"aba\", \"a\", null)  \u003d \"aba\" StringUtils.replace(\"aba\", \"a\", \"\")    \u003d \"b\" StringUtils.replace(\"aba\", \"a\", \"z\")   \u003d \"zbz\" \u003c/pre\u003e\n * @see #replace(String text,String searchString,String replacement,int max)\n * @param text  text to search and replace in, may be null\n * @param searchString  the String to search for, may be null\n * @param replacement  the String to replace it with, may be null\n * @return the text with any replacements processed,{@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replace#4873",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replace(java.lang.String, java.lang.String, java.lang.String, int)",
    "snippet": "public static String replace(final String text, final String searchString, final String replacement, int max) {\n        if (isEmpty(text) || isEmpty(searchString) || replacement \u003d\u003d null || max \u003d\u003d 0) {\n            return text;\n        }\n        int start \u003d 0;\n        int end \u003d text.indexOf(searchString, start);\n        if (end \u003d\u003d INDEX_NOT_FOUND) {\n            return text;\n        }\n        final int replLength \u003d searchString.length();\n        int increase \u003d replacement.length() - replLength;\n        increase \u003d increase \u003c 0 ? 0 : increase;\n        increase *\u003d max \u003c 0 ? 16 : max \u003e 64 ? 64 : max;\n        final StringBuilder buf \u003d new StringBuilder(text.length() + increase);\n        while (end !\u003d INDEX_NOT_FOUND) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start \u003d end + replLength;\n            if (--max \u003d\u003d 0) {\n                break;\n            }\n            end \u003d text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }",
    "begin_line": 4873,
    "end_line": 4897,
    "comment": "/** \n * \u003cp\u003eReplaces a String with another String inside a larger String, for the first  {@code max} values of the search String.\u003c/p\u003e\u003cp\u003eA  {@code null} reference passed to this method is a no-op.\u003c/p\u003e\u003cpre\u003e StringUtils.replace(null, *, *, *)         \u003d null StringUtils.replace(\"\", *, *, *)           \u003d \"\" StringUtils.replace(\"any\", null, *, *)     \u003d \"any\" StringUtils.replace(\"any\", *, null, *)     \u003d \"any\" StringUtils.replace(\"any\", \"\", *, *)       \u003d \"any\" StringUtils.replace(\"any\", *, *, 0)        \u003d \"any\" StringUtils.replace(\"abaa\", \"a\", null, -1) \u003d \"abaa\" StringUtils.replace(\"abaa\", \"a\", \"\", -1)   \u003d \"b\" StringUtils.replace(\"abaa\", \"a\", \"z\", 0)   \u003d \"abaa\" StringUtils.replace(\"abaa\", \"a\", \"z\", 1)   \u003d \"zbaa\" StringUtils.replace(\"abaa\", \"a\", \"z\", 2)   \u003d \"zbza\" StringUtils.replace(\"abaa\", \"a\", \"z\", -1)  \u003d \"zbzz\" \u003c/pre\u003e\n * @param text  text to search and replace in, may be null\n * @param searchString  the String to search for, may be null\n * @param replacement  the String to replace it with, may be null\n * @param max  maximum number of values to replace, or {@code -1} if no maximum\n * @return the text with any replacements processed,{@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceEach#4938",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceEach(java.lang.String, java.lang.String[], java.lang.String[])",
    "snippet": "public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) {\n        return replaceEach(text, searchList, replacementList, false, 0);\n    }",
    "begin_line": 4938,
    "end_line": 4940,
    "comment": "/** \n * \u003cp\u003e Replaces all occurrences of Strings within another String. \u003c/p\u003e \u003cp\u003e A  {@code null} reference passed to this method is a no-op, or ifany \"search string\" or \"string to replace\" is null, that replace will be ignored. This will not repeat. For repeating replaces, call the overloaded method. \u003c/p\u003e \u003cpre\u003e StringUtils.replaceEach(null, *, *)        \u003d null StringUtils.replaceEach(\"\", *, *)          \u003d \"\" StringUtils.replaceEach(\"aba\", null, null) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[0], null) \u003d \"aba\" StringUtils.replaceEach(\"aba\", null, new String[0]) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null)  \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"})  \u003d \"b\" StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"})  \u003d \"aba\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"})  \u003d \"wcte\" (example of how it does not repeat) StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"})  \u003d \"dcte\" \u003c/pre\u003e\n * @param text text to search and replace in, no-op if null\n * @param searchList the Strings to search for, no-op if null\n * @param replacementList the Strings to replace them with, no-op if null\n * @return the text with any replacements processed, {@code null} ifnull String input\n * @throws IllegalArgumentException if the lengths of the arrays are not the same (null is ok, and/or size 0)\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceEachRepeatedly#4984",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceEachRepeatedly(java.lang.String, java.lang.String[], java.lang.String[])",
    "snippet": "public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {\n        // timeToLive should be 0 if not used or nothing to replace, else it\u0027s\n        // the length of the replace array\n        final int timeToLive \u003d searchList \u003d\u003d null ? 0 : searchList.length;\n        return replaceEach(text, searchList, replacementList, true, timeToLive);\n    }",
    "begin_line": 4984,
    "end_line": 4989,
    "comment": "/** \n * \u003cp\u003e Replaces all occurrences of Strings within another String. \u003c/p\u003e \u003cp\u003e A  {@code null} reference passed to this method is a no-op, or ifany \"search string\" or \"string to replace\" is null, that replace will be ignored. \u003c/p\u003e \u003cpre\u003e StringUtils.replaceEachRepeatedly(null, *, *) \u003d null StringUtils.replaceEachRepeatedly(\"\", *, *) \u003d \"\" StringUtils.replaceEachRepeatedly(\"aba\", null, null) \u003d \"aba\" StringUtils.replaceEachRepeatedly(\"aba\", new String[0], null) \u003d \"aba\" StringUtils.replaceEachRepeatedly(\"aba\", null, new String[0]) \u003d \"aba\" StringUtils.replaceEachRepeatedly(\"aba\", new String[]{\"a\"}, null) \u003d \"aba\" StringUtils.replaceEachRepeatedly(\"aba\", new String[]{\"a\"}, new String[]{\"\"}) \u003d \"b\" StringUtils.replaceEachRepeatedly(\"aba\", new String[]{null}, new String[]{\"a\"}) \u003d \"aba\" StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}) \u003d \"wcte\" (example of how it repeats) StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}) \u003d \"tcte\" StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}) \u003d IllegalStateException \u003c/pre\u003e\n * @param text text to search and replace in, no-op if null\n * @param searchList the Strings to search for, no-op if null\n * @param replacementList the Strings to replace them with, no-op if null\n * @return the text with any replacements processed, {@code null} ifnull String input\n * @throws IllegalStateException if the search is repeating and there is an endless loop due to outputs of one being inputs to another\n * @throws IllegalArgumentException if the lengths of the arrays are not the same (null is ok, and/or size 0)\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceEach#5041",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceEach(java.lang.String, java.lang.String[], java.lang.String[], boolean, int)",
    "snippet": "private static String replaceEach(\n            final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text \u003d\u003d null || text.isEmpty() || searchList \u003d\u003d null ||\n                searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n            return text;\n        }\n\n        // if recursing, this shouldn\u0027t be less than 0\n        if (timeToLive \u003c 0) {\n            throw new IllegalStateException(\"Aborting to protect against StackOverflowError - \" +\n                                            \"output of one loop is the input of another\");\n        }\n\n        final int searchLength \u003d searchList.length;\n        final int replacementLength \u003d replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength !\u003d replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        final boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex \u003d -1;\n        int replaceIndex \u003d -1;\n        int tempIndex \u003d -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i \u003d 0; i \u003c searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null ||\n                    searchList[i].isEmpty() || replacementList[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex \u003d\u003d -1) {\n            return text;\n        }\n\n        int start \u003d 0;\n\n        // get a good guess on the size of the result buffer so it doesn\u0027t have to double if it goes over a bit\n        int increase \u003d 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i \u003d 0; i \u003c searchList.length; i++) {\n            if (searchList[i] \u003d\u003d null || replacementList[i] \u003d\u003d null) {\n                continue;\n            }\n            final int greater \u003d replacementList[i].length() - searchList[i].length();\n            if (greater \u003e 0) {\n                increase +\u003d 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase \u003d Math.min(increase, text.length() / 5);\n\n        final StringBuilder buf \u003d new StringBuilder(text.length() + increase);\n\n        while (textIndex !\u003d -1) {\n\n            for (int i \u003d start; i \u003c textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start \u003d textIndex + searchList[replaceIndex].length();\n\n            textIndex \u003d -1;\n            replaceIndex \u003d -1;\n            tempIndex \u003d -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i \u003d 0; i \u003c searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null ||\n                        searchList[i].isEmpty() || replacementList[i] \u003d\u003d null) {\n                    continue;\n                }\n                tempIndex \u003d text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex \u003d\u003d -1) {\n                    noMoreMatchesForReplIndex[i] \u003d true;\n                } else {\n                    if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                        textIndex \u003d tempIndex;\n                        replaceIndex \u003d i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        final int textLength \u003d text.length();\n        for (int i \u003d start; i \u003c textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        final String result \u003d buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }",
    "begin_line": 5041,
    "end_line": 5167,
    "comment": "/** \n * \u003cp\u003e Replace all occurrences of Strings within another String. This is a private recursive helper method for  {@link #replaceEachRepeatedly(String,String[],String[])} and{@link #replaceEach(String,String[],String[])}\u003c/p\u003e \u003cp\u003e A  {@code null} reference passed to this method is a no-op, or ifany \"search string\" or \"string to replace\" is null, that replace will be ignored. \u003c/p\u003e \u003cpre\u003e StringUtils.replaceEach(null, *, *, *, *) \u003d null StringUtils.replaceEach(\"\", *, *, *, *) \u003d \"\" StringUtils.replaceEach(\"aba\", null, null, *, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[0], null, *, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", null, new String[0], *, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *, *) \u003d \"aba\" StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *, \u003e\u003d0) \u003d \"b\" StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *, \u003e\u003d0) \u003d \"aba\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *, \u003e\u003d0) \u003d \"wcte\" (example of how it repeats) StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false, \u003e\u003d0) \u003d \"dcte\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true, \u003e\u003d2) \u003d \"tcte\" StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *, *) \u003d IllegalStateException \u003c/pre\u003e\n * @param text text to search and replace in, no-op if null\n * @param searchList the Strings to search for, no-op if null\n * @param replacementList the Strings to replace them with, no-op if null\n * @param repeat if true, then replace repeatedlyuntil there are no more possible replacements or timeToLive \u003c 0\n * @param timeToLive if less than 0 then there is a circular reference and endless loop\n * @return the text with any replacements processed, {@code null} ifnull String input\n * @throws IllegalStateException if the search is repeating and there is an endless loop due to outputs of one being inputs to another\n * @throws IllegalArgumentException if the lengths of the arrays are not the same (null is ok, and/or size 0)\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceChars#5191",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceChars(java.lang.String, char, char)",
    "snippet": "public static String replaceChars(final String str, final char searchChar, final char replaceChar) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }",
    "begin_line": 5191,
    "end_line": 5196,
    "comment": "/** \n * \u003cp\u003eReplaces all occurrences of a character in a String with another. This is a null-safe version of  {@link String#replace(char,char)}.\u003c/p\u003e \u003cp\u003eA  {@code null} string input returns {@code null}. An empty (\"\") string input returns an empty string.\u003c/p\u003e \u003cpre\u003e StringUtils.replaceChars(null, *, *)        \u003d null StringUtils.replaceChars(\"\", *, *)          \u003d \"\" StringUtils.replaceChars(\"abcba\", \u0027b\u0027, \u0027y\u0027) \u003d \"aycya\" StringUtils.replaceChars(\"abcba\", \u0027z\u0027, \u0027y\u0027) \u003d \"abcba\" \u003c/pre\u003e\n * @param str  String to replace characters in, may be null\n * @param searchChar  the character to search for, may be null\n * @param replaceChar  the character to replace, may be null\n * @return modified String, {@code null} if null string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.replaceChars#5234",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.replaceChars(java.lang.String, java.lang.String, java.lang.String)",
    "snippet": "public static String replaceChars(final String str, final String searchChars, String replaceChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars \u003d\u003d null) {\n            replaceChars \u003d EMPTY;\n        }\n        boolean modified \u003d false;\n        final int replaceCharsLength \u003d replaceChars.length();\n        final int strLength \u003d str.length();\n        final StringBuilder buf \u003d new StringBuilder(strLength);\n        for (int i \u003d 0; i \u003c strLength; i++) {\n            final char ch \u003d str.charAt(i);\n            final int index \u003d searchChars.indexOf(ch);\n            if (index \u003e\u003d 0) {\n                modified \u003d true;\n                if (index \u003c replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }",
    "begin_line": 5234,
    "end_line": 5261,
    "comment": "/** \n * \u003cp\u003eReplaces multiple characters in a String in one go. This method can also be used to delete characters.\u003c/p\u003e \u003cp\u003eFor example:\u003cbr\u003e \u003ccode\u003ereplaceChars(\u0026quot;hello\u0026quot;, \u0026quot;ho\u0026quot;, \u0026quot;jy\u0026quot;) \u003d jelly\u003c/code\u003e.\u003c/p\u003e \u003cp\u003eA  {@code null} string input returns {@code null}. An empty (\"\") string input returns an empty string. A null or empty set of search characters returns the input string.\u003c/p\u003e \u003cp\u003eThe length of the search characters should normally equal the length of the replace characters. If the search characters is longer, then the extra search characters are deleted. If the search characters is shorter, then the extra replace characters are ignored.\u003c/p\u003e \u003cpre\u003e StringUtils.replaceChars(null, *, *)           \u003d null StringUtils.replaceChars(\"\", *, *)             \u003d \"\" StringUtils.replaceChars(\"abc\", null, *)       \u003d \"abc\" StringUtils.replaceChars(\"abc\", \"\", *)         \u003d \"abc\" StringUtils.replaceChars(\"abc\", \"b\", null)     \u003d \"ac\" StringUtils.replaceChars(\"abc\", \"b\", \"\")       \u003d \"ac\" StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\")  \u003d \"ayzya\" StringUtils.replaceChars(\"abcba\", \"bc\", \"y\")   \u003d \"ayya\" StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\") \u003d \"ayzya\" \u003c/pre\u003e\n * @param str  String to replace characters in, may be null\n * @param searchChars  a set of characters to search for, may be null\n * @param replaceChars  a set of characters to replace, may be null\n * @return modified String, {@code null} if null string input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.overlay#5294",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.overlay(java.lang.String, java.lang.String, int, int)",
    "snippet": "public static String overlay(final String str, String overlay, int start, int end) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (overlay \u003d\u003d null) {\n            overlay \u003d EMPTY;\n        }\n        final int len \u003d str.length();\n        if (start \u003c 0) {\n            start \u003d 0;\n        }\n        if (start \u003e len) {\n            start \u003d len;\n        }\n        if (end \u003c 0) {\n            end \u003d 0;\n        }\n        if (end \u003e len) {\n            end \u003d len;\n        }\n        if (start \u003e end) {\n            final int temp \u003d start;\n            start \u003d end;\n            end \u003d temp;\n        }\n        return new StringBuilder(len + start - end + overlay.length() + 1)\n            .append(str.substring(0, start))\n            .append(overlay)\n            .append(str.substring(end))\n            .toString();\n    }",
    "begin_line": 5294,
    "end_line": 5324,
    "comment": "/** \n * \u003cp\u003eOverlays part of a String with another String.\u003c/p\u003e \u003cp\u003eA  {@code null} string input returns {@code null}. A negative index is treated as zero. An index greater than the string length is treated as the string length. The start index is always the smaller of the two indices.\u003c/p\u003e \u003cpre\u003e StringUtils.overlay(null, *, *, *)            \u003d null StringUtils.overlay(\"\", \"abc\", 0, 0)          \u003d \"abc\" StringUtils.overlay(\"abcdef\", null, 2, 4)     \u003d \"abef\" StringUtils.overlay(\"abcdef\", \"\", 2, 4)       \u003d \"abef\" StringUtils.overlay(\"abcdef\", \"\", 4, 2)       \u003d \"abef\" StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4)   \u003d \"abzzzzef\" StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2)   \u003d \"abzzzzef\" StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4)  \u003d \"zzzzef\" StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 8)   \u003d \"abzzzz\" StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -3) \u003d \"zzzzabcdef\" StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10)  \u003d \"abcdefzzzz\" \u003c/pre\u003e\n * @param str  the String to do overlaying in, may be null\n * @param overlay  the String to overlay, may be null\n * @param start  the position to start overlaying at\n * @param end  the position to stop overlaying before\n * @return overlayed String, {@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.chomp#5353",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.chomp(java.lang.String)",
    "snippet": "public static String chomp(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n\n        if (str.length() \u003d\u003d 1) {\n            final char ch \u003d str.charAt(0);\n            if (ch \u003d\u003d CharUtils.CR || ch \u003d\u003d CharUtils.LF) {\n                return EMPTY;\n            }\n            return str;\n        }\n\n        int lastIdx \u003d str.length() - 1;\n        final char last \u003d str.charAt(lastIdx);\n\n        if (last \u003d\u003d CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) \u003d\u003d CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last !\u003d CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }",
    "begin_line": 5353,
    "end_line": 5377,
    "comment": "/** \n * \u003cp\u003eRemoves one newline from end of a String if it\u0027s there, otherwise leave it alone.  A newline is \u0026quot; {@code \\n}\u0026quot;, \u0026quot; {@code \\r}\u0026quot;, or \u0026quot; {@code \\r\\n}\u0026quot;.\u003c/p\u003e \u003cp\u003eNOTE: This method changed in 2.0. It now more closely matches Perl chomp.\u003c/p\u003e \u003cpre\u003e StringUtils.chomp(null)          \u003d null StringUtils.chomp(\"\")            \u003d \"\" StringUtils.chomp(\"abc \\r\")      \u003d \"abc \" StringUtils.chomp(\"abc\\n\")       \u003d \"abc\" StringUtils.chomp(\"abc\\r\\n\")     \u003d \"abc\" StringUtils.chomp(\"abc\\r\\n\\r\\n\") \u003d \"abc\\r\\n\" StringUtils.chomp(\"abc\\n\\r\")     \u003d \"abc\\n\" StringUtils.chomp(\"abc\\n\\rabc\")  \u003d \"abc\\n\\rabc\" StringUtils.chomp(\"\\r\")          \u003d \"\" StringUtils.chomp(\"\\n\")          \u003d \"\" StringUtils.chomp(\"\\r\\n\")        \u003d \"\" \u003c/pre\u003e\n * @param str  the String to chomp a newline from, may be null\n * @return String without newline, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.chomp#5407",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.chomp(java.lang.String, java.lang.String)",
    "snippet": "@Deprecated\n    public static String chomp(final String str, final String separator) {\n        return removeEnd(str,separator);\n    }",
    "begin_line": 5407,
    "end_line": 5409,
    "comment": "/** \n * \u003cp\u003eRemoves  {@code separator} from the end of{@code str} if it\u0027s there, otherwise leave it alone.\u003c/p\u003e\u003cp\u003eNOTE: This method changed in version 2.0. It now more closely matches Perl chomp. For the previous behavior, use  {@link #substringBeforeLast(String,String)}. This method uses  {@link String#endsWith(String)}.\u003c/p\u003e \u003cpre\u003e StringUtils.chomp(null, *)         \u003d null StringUtils.chomp(\"\", *)           \u003d \"\" StringUtils.chomp(\"foobar\", \"bar\") \u003d \"foo\" StringUtils.chomp(\"foobar\", \"baz\") \u003d \"foobar\" StringUtils.chomp(\"foo\", \"foo\")    \u003d \"\" StringUtils.chomp(\"foo \", \"foo\")   \u003d \"foo \" StringUtils.chomp(\" foo\", \"foo\")   \u003d \" \" StringUtils.chomp(\"foo\", \"foooo\")  \u003d \"foo\" StringUtils.chomp(\"foo\", \"\")       \u003d \"foo\" StringUtils.chomp(\"foo\", null)     \u003d \"foo\" \u003c/pre\u003e\n * @param str  the String to chomp from, may be null\n * @param separator  separator String, may be null\n * @return String without trailing separator, {@code null} if null String input\n * @deprecated This feature will be removed in Lang 4.0, use {@link StringUtils#removeEnd(String,String)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.chop#5436",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.chop(java.lang.String)",
    "snippet": "public static String chop(final String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        final int strLen \u003d str.length();\n        if (strLen \u003c 2) {\n            return EMPTY;\n        }\n        final int lastIdx \u003d strLen - 1;\n        final String ret \u003d str.substring(0, lastIdx);\n        final char last \u003d str.charAt(lastIdx);\n        if (last \u003d\u003d CharUtils.LF \u0026\u0026 ret.charAt(lastIdx - 1) \u003d\u003d CharUtils.CR) {\n            return ret.substring(0, lastIdx - 1);\n        }\n        return ret;\n    }",
    "begin_line": 5436,
    "end_line": 5451,
    "comment": "/** \n * \u003cp\u003eRemove the last character from a String.\u003c/p\u003e \u003cp\u003eIf the String ends in  {@code \\r\\n}, then remove both of them.\u003c/p\u003e \u003cpre\u003e StringUtils.chop(null)          \u003d null StringUtils.chop(\"\")            \u003d \"\" StringUtils.chop(\"abc \\r\")      \u003d \"abc \" StringUtils.chop(\"abc\\n\")       \u003d \"abc\" StringUtils.chop(\"abc\\r\\n\")     \u003d \"abc\" StringUtils.chop(\"abc\")         \u003d \"ab\" StringUtils.chop(\"abc\\nabc\")    \u003d \"abc\\nab\" StringUtils.chop(\"a\")           \u003d \"\" StringUtils.chop(\"\\r\")          \u003d \"\" StringUtils.chop(\"\\n\")          \u003d \"\" StringUtils.chop(\"\\r\\n\")        \u003d \"\" \u003c/pre\u003e\n * @param str  the String to chop last character from, may be null\n * @return String without last character, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.repeat#5476",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.repeat(java.lang.String, int)",
    "snippet": "public static String repeat(final String str, final int repeat) {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (repeat \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final int inputLength \u003d str.length();\n        if (repeat \u003d\u003d 1 || inputLength \u003d\u003d 0) {\n            return str;\n        }\n        if (inputLength \u003d\u003d 1 \u0026\u0026 repeat \u003c\u003d PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength \u003d inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 \u003d str.charAt(0);\n                final char ch1 \u003d str.charAt(1);\n                final char[] output2 \u003d new char[outputLength];\n                for (int i \u003d repeat * 2 - 2; i \u003e\u003d 0; i--, i--) {\n                    output2[i] \u003d ch0;\n                    output2[i + 1] \u003d ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf \u003d new StringBuilder(outputLength);\n                for (int i \u003d 0; i \u003c repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
    "begin_line": 5476,
    "end_line": 5513,
    "comment": "/** \n * \u003cp\u003eRepeat a String  {@code repeat} times to form anew String.\u003c/p\u003e \u003cpre\u003e StringUtils.repeat(null, 2) \u003d null StringUtils.repeat(\"\", 0)   \u003d \"\" StringUtils.repeat(\"\", 2)   \u003d \"\" StringUtils.repeat(\"a\", 3)  \u003d \"aaa\" StringUtils.repeat(\"ab\", 2) \u003d \"abab\" StringUtils.repeat(\"a\", -2) \u003d \"\" \u003c/pre\u003e\n * @param str  the String to repeat, may be null\n * @param repeat  number of times to repeat str, negative treated as zero\n * @return a new String consisting of the original String repeated,{@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.repeat#5535",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.repeat(java.lang.String, java.lang.String, int)",
    "snippet": "public static String repeat(final String str, final String separator, final int repeat) {\n        if(str \u003d\u003d null || separator \u003d\u003d null) {\n            return repeat(str, repeat);\n        }\n        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n        final String result \u003d repeat(str + separator, repeat);\n        return removeEnd(result, separator);\n    }",
    "begin_line": 5535,
    "end_line": 5542,
    "comment": "/** \n * \u003cp\u003eRepeat a String  {@code repeat} times to form anew String, with a String separator injected each time. \u003c/p\u003e \u003cpre\u003e StringUtils.repeat(null, null, 2) \u003d null StringUtils.repeat(null, \"x\", 2)  \u003d null StringUtils.repeat(\"\", null, 0)   \u003d \"\" StringUtils.repeat(\"\", \"\", 2)     \u003d \"\" StringUtils.repeat(\"\", \"x\", 3)    \u003d \"xxx\" StringUtils.repeat(\"?\", \", \", 3)  \u003d \"?, ?, ?\" \u003c/pre\u003e\n * @param str        the String to repeat, may be null\n * @param separator  the String to inject, may be null\n * @param repeat     number of times to repeat str, negative treated as zero\n * @return a new String consisting of the original String repeated,{@code null} if null String input\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.repeat#5566",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.repeat(char, int)",
    "snippet": "public static String repeat(final char ch, final int repeat) {\n        if (repeat \u003c\u003d 0) {\n            return EMPTY;\n        }\n        final char[] buf \u003d new char[repeat];\n        for (int i \u003d repeat - 1; i \u003e\u003d 0; i--) {\n            buf[i] \u003d ch;\n        }\n        return new String(buf);\n    }",
    "begin_line": 5566,
    "end_line": 5575,
    "comment": "/** \n * \u003cp\u003eReturns padding using the specified delimiter repeated to a given length.\u003c/p\u003e \u003cpre\u003e StringUtils.repeat(\u0027e\u0027, 0)  \u003d \"\" StringUtils.repeat(\u0027e\u0027, 3)  \u003d \"eee\" StringUtils.repeat(\u0027e\u0027, -2) \u003d \"\" \u003c/pre\u003e \u003cp\u003eNote: this method doesn\u0027t not support padding with \u003ca href\u003d\"http://www.unicode.org/glossary/#supplementary_character\"\u003eUnicode Supplementary Characters\u003c/a\u003e as they require a pair of  {@code char}s to be represented. If you are needing to support full I18N of your applications consider using  {@link #repeat(String,int)} instead.\u003c/p\u003e\n * @param ch  character to repeat\n * @param repeat  number of times to repeat char, negative treated as zero\n * @return String with repeated character\n * @see #repeat(String,int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.rightPad#5596",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.rightPad(java.lang.String, int)",
    "snippet": "public static String rightPad(final String str, final int size) {\n        return rightPad(str, size, \u0027 \u0027);\n    }",
    "begin_line": 5596,
    "end_line": 5598,
    "comment": "/** \n * \u003cp\u003eRight pad a String with spaces (\u0027 \u0027).\u003c/p\u003e \u003cp\u003eThe String is padded to the size of  {@code size}.\u003c/p\u003e \u003cpre\u003e StringUtils.rightPad(null, *)   \u003d null StringUtils.rightPad(\"\", 3)     \u003d \"   \" StringUtils.rightPad(\"bat\", 3)  \u003d \"bat\" StringUtils.rightPad(\"bat\", 5)  \u003d \"bat  \" StringUtils.rightPad(\"bat\", 1)  \u003d \"bat\" StringUtils.rightPad(\"bat\", -1) \u003d \"bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @return right padded String or original String if no padding is necessary,{@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.rightPad#5621",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.rightPad(java.lang.String, int, char)",
    "snippet": "public static String rightPad(final String str, final int size, final char padChar) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        final int pads \u003d size - str.length();\n        if (pads \u003c\u003d 0) {\n            return str; // returns original String when possible\n        }\n        if (pads \u003e PAD_LIMIT) {\n            return rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(repeat(padChar, pads));\n    }",
    "begin_line": 5621,
    "end_line": 5633,
    "comment": "/** \n * \u003cp\u003eRight pad a String with a specified character.\u003c/p\u003e \u003cp\u003eThe String is padded to the size of  {@code size}.\u003c/p\u003e \u003cpre\u003e StringUtils.rightPad(null, *, *)     \u003d null StringUtils.rightPad(\"\", 3, \u0027z\u0027)     \u003d \"zzz\" StringUtils.rightPad(\"bat\", 3, \u0027z\u0027)  \u003d \"bat\" StringUtils.rightPad(\"bat\", 5, \u0027z\u0027)  \u003d \"batzz\" StringUtils.rightPad(\"bat\", 1, \u0027z\u0027)  \u003d \"bat\" StringUtils.rightPad(\"bat\", -1, \u0027z\u0027) \u003d \"bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padChar  the character to pad with\n * @return right padded String or original String if no padding is necessary,{@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.rightPad#5658",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.rightPad(java.lang.String, int, java.lang.String)",
    "snippet": "public static String rightPad(final String str, final int size, String padStr) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr \u003d SPACE;\n        }\n        final int padLen \u003d padStr.length();\n        final int strLen \u003d str.length();\n        final int pads \u003d size - strLen;\n        if (pads \u003c\u003d 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen \u003d\u003d 1 \u0026\u0026 pads \u003c\u003d PAD_LIMIT) {\n            return rightPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads \u003d\u003d padLen) {\n            return str.concat(padStr);\n        } else if (pads \u003c padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            final char[] padding \u003d new char[pads];\n            final char[] padChars \u003d padStr.toCharArray();\n            for (int i \u003d 0; i \u003c pads; i++) {\n                padding[i] \u003d padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }",
    "begin_line": 5658,
    "end_line": 5687,
    "comment": "/** \n * \u003cp\u003eRight pad a String with a specified String.\u003c/p\u003e \u003cp\u003eThe String is padded to the size of  {@code size}.\u003c/p\u003e \u003cpre\u003e StringUtils.rightPad(null, *, *)      \u003d null StringUtils.rightPad(\"\", 3, \"z\")      \u003d \"zzz\" StringUtils.rightPad(\"bat\", 3, \"yz\")  \u003d \"bat\" StringUtils.rightPad(\"bat\", 5, \"yz\")  \u003d \"batyz\" StringUtils.rightPad(\"bat\", 8, \"yz\")  \u003d \"batyzyzy\" StringUtils.rightPad(\"bat\", 1, \"yz\")  \u003d \"bat\" StringUtils.rightPad(\"bat\", -1, \"yz\") \u003d \"bat\" StringUtils.rightPad(\"bat\", 5, null)  \u003d \"bat  \" StringUtils.rightPad(\"bat\", 5, \"\")    \u003d \"bat  \" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padStr  the String to pad with, null or empty treated as single space\n * @return right padded String or original String if no padding is necessary,{@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.leftPad#5708",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.leftPad(java.lang.String, int)",
    "snippet": "public static String leftPad(final String str, final int size) {\n        return leftPad(str, size, \u0027 \u0027);\n    }",
    "begin_line": 5708,
    "end_line": 5710,
    "comment": "/** \n * \u003cp\u003eLeft pad a String with spaces (\u0027 \u0027).\u003c/p\u003e \u003cp\u003eThe String is padded to the size of  {@code size}.\u003c/p\u003e \u003cpre\u003e StringUtils.leftPad(null, *)   \u003d null StringUtils.leftPad(\"\", 3)     \u003d \"   \" StringUtils.leftPad(\"bat\", 3)  \u003d \"bat\" StringUtils.leftPad(\"bat\", 5)  \u003d \"  bat\" StringUtils.leftPad(\"bat\", 1)  \u003d \"bat\" StringUtils.leftPad(\"bat\", -1) \u003d \"bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @return left padded String or original String if no padding is necessary,{@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.leftPad#5733",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.leftPad(java.lang.String, int, char)",
    "snippet": "public static String leftPad(final String str, final int size, final char padChar) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        final int pads \u003d size - str.length();\n        if (pads \u003c\u003d 0) {\n            return str; // returns original String when possible\n        }\n        if (pads \u003e PAD_LIMIT) {\n            return leftPad(str, size, String.valueOf(padChar));\n        }\n        return repeat(padChar, pads).concat(str);\n    }",
    "begin_line": 5733,
    "end_line": 5745,
    "comment": "/** \n * \u003cp\u003eLeft pad a String with a specified character.\u003c/p\u003e \u003cp\u003ePad to a size of  {@code size}.\u003c/p\u003e \u003cpre\u003e StringUtils.leftPad(null, *, *)     \u003d null StringUtils.leftPad(\"\", 3, \u0027z\u0027)     \u003d \"zzz\" StringUtils.leftPad(\"bat\", 3, \u0027z\u0027)  \u003d \"bat\" StringUtils.leftPad(\"bat\", 5, \u0027z\u0027)  \u003d \"zzbat\" StringUtils.leftPad(\"bat\", 1, \u0027z\u0027)  \u003d \"bat\" StringUtils.leftPad(\"bat\", -1, \u0027z\u0027) \u003d \"bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padChar  the character to pad with\n * @return left padded String or original String if no padding is necessary,{@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.leftPad#5770",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.leftPad(java.lang.String, int, java.lang.String)",
    "snippet": "public static String leftPad(final String str, final int size, String padStr) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr \u003d SPACE;\n        }\n        final int padLen \u003d padStr.length();\n        final int strLen \u003d str.length();\n        final int pads \u003d size - strLen;\n        if (pads \u003c\u003d 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen \u003d\u003d 1 \u0026\u0026 pads \u003c\u003d PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads \u003d\u003d padLen) {\n            return padStr.concat(str);\n        } else if (pads \u003c padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            final char[] padding \u003d new char[pads];\n            final char[] padChars \u003d padStr.toCharArray();\n            for (int i \u003d 0; i \u003c pads; i++) {\n                padding[i] \u003d padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }",
    "begin_line": 5770,
    "end_line": 5799,
    "comment": "/** \n * \u003cp\u003eLeft pad a String with a specified String.\u003c/p\u003e \u003cp\u003ePad to a size of  {@code size}.\u003c/p\u003e \u003cpre\u003e StringUtils.leftPad(null, *, *)      \u003d null StringUtils.leftPad(\"\", 3, \"z\")      \u003d \"zzz\" StringUtils.leftPad(\"bat\", 3, \"yz\")  \u003d \"bat\" StringUtils.leftPad(\"bat\", 5, \"yz\")  \u003d \"yzbat\" StringUtils.leftPad(\"bat\", 8, \"yz\")  \u003d \"yzyzybat\" StringUtils.leftPad(\"bat\", 1, \"yz\")  \u003d \"bat\" StringUtils.leftPad(\"bat\", -1, \"yz\") \u003d \"bat\" StringUtils.leftPad(\"bat\", 5, null)  \u003d \"  bat\" StringUtils.leftPad(\"bat\", 5, \"\")    \u003d \"  bat\" \u003c/pre\u003e\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padStr  the String to pad with, null or empty treated as single space\n * @return left padded String or original String if no padding is necessary,{@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.length#5812",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.length(java.lang.CharSequence)",
    "snippet": "public static int length(final CharSequence cs) {\n        return cs \u003d\u003d null ? 0 : cs.length();\n    }",
    "begin_line": 5812,
    "end_line": 5814,
    "comment": "/** \n * Gets a CharSequence length or  {@code 0} if the CharSequence is{@code null}.\n * @param cs a CharSequence or  {@code null}\n * @return CharSequence length or {@code 0} if the CharSequence is{@code null}.\n * @since 2.4\n * @since 3.0 Changed signature from length(String) to length(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.center#5841",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.center(java.lang.String, int)",
    "snippet": "public static String center(final String str, final int size) {\n        return center(str, size, \u0027 \u0027);\n    }",
    "begin_line": 5841,
    "end_line": 5843,
    "comment": "/** \n * \u003cp\u003eCenters a String in a larger String of size  {@code size}using the space character (\u0027 \u0027).\u003c/p\u003e \u003cp\u003eIf the size is less than the String length, the String is returned. A  {@code null} String returns {@code null}. A negative size is treated as zero.\u003c/p\u003e \u003cp\u003eEquivalent to  {@code center(str, size, \" \")}.\u003c/p\u003e \u003cpre\u003e StringUtils.center(null, *)   \u003d null StringUtils.center(\"\", 4)     \u003d \"    \" StringUtils.center(\"ab\", -1)  \u003d \"ab\" StringUtils.center(\"ab\", 4)   \u003d \" ab \" StringUtils.center(\"abcd\", 2) \u003d \"abcd\" StringUtils.center(\"a\", 4)    \u003d \" a  \" \u003c/pre\u003e\n * @param str  the String to center, may be null\n * @param size  the int size of new String, negative treated as zero\n * @return centered String, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.center#5869",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.center(java.lang.String, int, char)",
    "snippet": "public static String center(String str, final int size, final char padChar) {\n        if (str \u003d\u003d null || size \u003c\u003d 0) {\n            return str;\n        }\n        final int strLen \u003d str.length();\n        final int pads \u003d size - strLen;\n        if (pads \u003c\u003d 0) {\n            return str;\n        }\n        str \u003d leftPad(str, strLen + pads / 2, padChar);\n        str \u003d rightPad(str, size, padChar);\n        return str;\n    }",
    "begin_line": 5869,
    "end_line": 5881,
    "comment": "/** \n * \u003cp\u003eCenters a String in a larger String of size  {@code size}. Uses a supplied character as the value to pad the String with.\u003c/p\u003e \u003cp\u003eIf the size is less than the String length, the String is returned. A  {@code null} String returns {@code null}. A negative size is treated as zero.\u003c/p\u003e \u003cpre\u003e StringUtils.center(null, *, *)     \u003d null StringUtils.center(\"\", 4, \u0027 \u0027)     \u003d \"    \" StringUtils.center(\"ab\", -1, \u0027 \u0027)  \u003d \"ab\" StringUtils.center(\"ab\", 4, \u0027 \u0027)   \u003d \" ab \" StringUtils.center(\"abcd\", 2, \u0027 \u0027) \u003d \"abcd\" StringUtils.center(\"a\", 4, \u0027 \u0027)    \u003d \" a  \" StringUtils.center(\"a\", 4, \u0027y\u0027)    \u003d \"yayy\" \u003c/pre\u003e\n * @param str  the String to center, may be null\n * @param size  the int size of new String, negative treated as zero\n * @param padChar  the character to pad the new String with\n * @return centered String, {@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.center#5909",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.center(java.lang.String, int, java.lang.String)",
    "snippet": "public static String center(String str, final int size, String padStr) {\n        if (str \u003d\u003d null || size \u003c\u003d 0) {\n            return str;\n        }\n        if (isEmpty(padStr)) {\n            padStr \u003d SPACE;\n        }\n        final int strLen \u003d str.length();\n        final int pads \u003d size - strLen;\n        if (pads \u003c\u003d 0) {\n            return str;\n        }\n        str \u003d leftPad(str, strLen + pads / 2, padStr);\n        str \u003d rightPad(str, size, padStr);\n        return str;\n    }",
    "begin_line": 5909,
    "end_line": 5924,
    "comment": "/** \n * \u003cp\u003eCenters a String in a larger String of size  {@code size}. Uses a supplied String as the value to pad the String with.\u003c/p\u003e \u003cp\u003eIf the size is less than the String length, the String is returned. A  {@code null} String returns {@code null}. A negative size is treated as zero.\u003c/p\u003e \u003cpre\u003e StringUtils.center(null, *, *)     \u003d null StringUtils.center(\"\", 4, \" \")     \u003d \"    \" StringUtils.center(\"ab\", -1, \" \")  \u003d \"ab\" StringUtils.center(\"ab\", 4, \" \")   \u003d \" ab \" StringUtils.center(\"abcd\", 2, \" \") \u003d \"abcd\" StringUtils.center(\"a\", 4, \" \")    \u003d \" a  \" StringUtils.center(\"a\", 4, \"yz\")   \u003d \"yayz\" StringUtils.center(\"abc\", 7, null) \u003d \"  abc  \" StringUtils.center(\"abc\", 7, \"\")   \u003d \"  abc  \" \u003c/pre\u003e\n * @param str  the String to center, may be null\n * @param size  the int size of new String, negative treated as zero\n * @param padStr  the String to pad the new String with, must not be null or empty\n * @return centered String, {@code null} if null String input\n * @throws IllegalArgumentException if padStr is {@code null} or empty\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.upperCase#5947",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.upperCase(java.lang.String)",
    "snippet": "public static String upperCase(final String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }",
    "begin_line": 5947,
    "end_line": 5952,
    "comment": "/** \n * \u003cp\u003eConverts a String to upper case as per  {@link String#toUpperCase()}.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.upperCase(null)  \u003d null StringUtils.upperCase(\"\")    \u003d \"\" StringUtils.upperCase(\"aBc\") \u003d \"ABC\" \u003c/pre\u003e \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e As described in the documentation for  {@link String#toUpperCase()}, the result of this method is affected by the current locale. For platform-independent case transformations, the method  {@link #lowerCase(String,Locale)}should be used with a specific locale (e.g.  {@link Locale#ENGLISH}).\u003c/p\u003e\n * @param str  the String to upper case, may be null\n * @return the upper cased String, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.upperCase#5970",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.upperCase(java.lang.String, java.util.Locale)",
    "snippet": "public static String upperCase(final String str, final Locale locale) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }",
    "begin_line": 5970,
    "end_line": 5975,
    "comment": "/** \n * \u003cp\u003eConverts a String to upper case as per  {@link String#toUpperCase(Locale)}.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.upperCase(null, Locale.ENGLISH)  \u003d null StringUtils.upperCase(\"\", Locale.ENGLISH)    \u003d \"\" StringUtils.upperCase(\"aBc\", Locale.ENGLISH) \u003d \"ABC\" \u003c/pre\u003e\n * @param str  the String to upper case, may be null\n * @param locale  the locale that defines the case transformation rules, must not be null\n * @return the upper cased String, {@code null} if null String input\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lowerCase#5996",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lowerCase(java.lang.String)",
    "snippet": "public static String lowerCase(final String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }",
    "begin_line": 5996,
    "end_line": 6001,
    "comment": "/** \n * \u003cp\u003eConverts a String to lower case as per  {@link String#toLowerCase()}.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.lowerCase(null)  \u003d null StringUtils.lowerCase(\"\")    \u003d \"\" StringUtils.lowerCase(\"aBc\") \u003d \"abc\" \u003c/pre\u003e \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e As described in the documentation for  {@link String#toLowerCase()}, the result of this method is affected by the current locale. For platform-independent case transformations, the method  {@link #lowerCase(String,Locale)}should be used with a specific locale (e.g.  {@link Locale#ENGLISH}).\u003c/p\u003e\n * @param str  the String to lower case, may be null\n * @return the lower cased String, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.lowerCase#6019",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.lowerCase(java.lang.String, java.util.Locale)",
    "snippet": "public static String lowerCase(final String str, final Locale locale) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }",
    "begin_line": 6019,
    "end_line": 6024,
    "comment": "/** \n * \u003cp\u003eConverts a String to lower case as per  {@link String#toLowerCase(Locale)}.\u003c/p\u003e \u003cp\u003eA  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.lowerCase(null, Locale.ENGLISH)  \u003d null StringUtils.lowerCase(\"\", Locale.ENGLISH)    \u003d \"\" StringUtils.lowerCase(\"aBc\", Locale.ENGLISH) \u003d \"abc\" \u003c/pre\u003e\n * @param str  the String to lower case, may be null\n * @param locale  the locale that defines the case transformation rules, must not be null\n * @return the lower cased String, {@code null} if null String input\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.capitalize#6047",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.capitalize(java.lang.String)",
    "snippet": "public static String capitalize(final String str) {\n        int strLen;\n        if (str \u003d\u003d null || (strLen \u003d str.length()) \u003d\u003d 0) {\n            return str;\n        }\n\n        final char firstChar \u003d str.charAt(0);\n        final char newChar \u003d Character.toTitleCase(firstChar);\n        if (firstChar \u003d\u003d newChar) {\n            // already capitalized\n            return str;\n        }\n\n        char[] newChars \u003d new char[strLen];\n        newChars[0] \u003d newChar;\n        str.getChars(1,strLen, newChars, 1);\n        return String.valueOf(newChars);\n    }",
    "begin_line": 6047,
    "end_line": 6064,
    "comment": "/** \n * \u003cp\u003eCapitalizes a String changing the first character to title case as per  {@link Character#toTitleCase(char)}. No other characters are changed.\u003c/p\u003e \u003cp\u003eFor a word based algorithm, see  {@link org.apache.commons.lang3.text.WordUtils#capitalize(String)}. A  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.capitalize(null)  \u003d null StringUtils.capitalize(\"\")    \u003d \"\" StringUtils.capitalize(\"cat\") \u003d \"Cat\" StringUtils.capitalize(\"cAt\") \u003d \"CAt\" StringUtils.capitalize(\"\u0027cat\u0027\") \u003d \"\u0027cat\u0027\" \u003c/pre\u003e\n * @param str the String to capitalize, may be null\n * @return the capitalized String, {@code null} if null String input\n * @see org.apache.commons.lang3.text.WordUtils#capitalize(String)\n * @see #uncapitalize(String)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.uncapitalize#6087",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.uncapitalize(java.lang.String)",
    "snippet": "public static String uncapitalize(final String str) {\n        int strLen;\n        if (str \u003d\u003d null || (strLen \u003d str.length()) \u003d\u003d 0) {\n            return str;\n        }\n\n        final char firstChar \u003d str.charAt(0);\n        final char newChar \u003d Character.toLowerCase(firstChar);\n        if (firstChar \u003d\u003d newChar) {\n            // already uncapitalized\n            return str;\n        }\n\n        char[] newChars \u003d new char[strLen];\n        newChars[0] \u003d newChar;\n        str.getChars(1,strLen, newChars, 1);\n        return String.valueOf(newChars);\n    }",
    "begin_line": 6087,
    "end_line": 6104,
    "comment": "/** \n * \u003cp\u003eUncapitalizes a String, changing the first character to lower case as per  {@link Character#toLowerCase(char)}. No other characters are changed.\u003c/p\u003e \u003cp\u003eFor a word based algorithm, see  {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}. A  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.uncapitalize(null)  \u003d null StringUtils.uncapitalize(\"\")    \u003d \"\" StringUtils.uncapitalize(\"cat\") \u003d \"cat\" StringUtils.uncapitalize(\"Cat\") \u003d \"cat\" StringUtils.uncapitalize(\"CAT\") \u003d \"cAT\" \u003c/pre\u003e\n * @param str the String to uncapitalize, may be null\n * @return the uncapitalized String, {@code null} if null String input\n * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)\n * @see #capitalize(String)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.swapCase#6133",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.swapCase(java.lang.String)",
    "snippet": "public static String swapCase(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n\n        final char[] buffer \u003d str.toCharArray();\n\n        for (int i \u003d 0; i \u003c buffer.length; i++) {\n            final char ch \u003d buffer[i];\n            if (Character.isUpperCase(ch)) {\n                buffer[i] \u003d Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                buffer[i] \u003d Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                buffer[i] \u003d Character.toUpperCase(ch);\n            }\n        }\n        return new String(buffer);\n    }",
    "begin_line": 6133,
    "end_line": 6151,
    "comment": "/** \n * \u003cp\u003eSwaps the case of a String changing upper and title case to lower case, and lower case to upper case.\u003c/p\u003e \u003cul\u003e \u003cli\u003eUpper case character converts to Lower case\u003c/li\u003e \u003cli\u003eTitle case character converts to Lower case\u003c/li\u003e \u003cli\u003eLower case character converts to Upper case\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eFor a word based algorithm, see  {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}. A  {@code null} input String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.swapCase(null)                 \u003d null StringUtils.swapCase(\"\")                   \u003d \"\" StringUtils.swapCase(\"The dog has a BONE\") \u003d \"tHE DOG HAS A bone\" \u003c/pre\u003e \u003cp\u003eNOTE: This method changed in Lang version 2.0. It no longer performs a word based algorithm. If you only use ASCII, you will notice no change. That functionality is available in org.apache.commons.lang3.text.WordUtils.\u003c/p\u003e\n * @param str  the String to swap case, may be null\n * @return the changed String, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.countMatches#6175",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.countMatches(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int countMatches(final CharSequence str, final CharSequence sub) {\n        if (isEmpty(str) || isEmpty(sub)) {\n            return 0;\n        }\n        int count \u003d 0;\n        int idx \u003d 0;\n        while ((idx \u003d CharSequenceUtils.indexOf(str, sub, idx)) !\u003d INDEX_NOT_FOUND) {\n            count++;\n            idx +\u003d sub.length();\n        }\n        return count;\n    }",
    "begin_line": 6175,
    "end_line": 6186,
    "comment": "/** \n * \u003cp\u003eCounts how many times the substring appears in the larger string.\u003c/p\u003e \u003cp\u003eA  {@code null} or empty (\"\") String input returns {@code 0}.\u003c/p\u003e \u003cpre\u003e StringUtils.countMatches(null, *)       \u003d 0 StringUtils.countMatches(\"\", *)         \u003d 0 StringUtils.countMatches(\"abba\", null)  \u003d 0 StringUtils.countMatches(\"abba\", \"\")    \u003d 0 StringUtils.countMatches(\"abba\", \"a\")   \u003d 2 StringUtils.countMatches(\"abba\", \"ab\")  \u003d 1 StringUtils.countMatches(\"abba\", \"xxx\") \u003d 0 \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param sub  the substring to count, may be null\n * @return the number of occurrences, 0 if either CharSequence is {@code null}\n * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.countMatches#6207",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.countMatches(java.lang.CharSequence, char)",
    "snippet": "public static int countMatches(final CharSequence str, final char ch) {\n        if (isEmpty(str)) {\n            return 0;\n        }\n        int count \u003d 0;\n        // We could also call str.toCharArray() for faster look ups but that would generate more garbage.\n        for (int i \u003d 0; i \u003c str.length(); i++) {\n            if (ch \u003d\u003d str.charAt(i)) {\n                count++;\n            }\n        }\n        return count;\n    }",
    "begin_line": 6207,
    "end_line": 6219,
    "comment": "/** \n * \u003cp\u003eCounts how many times the char appears in the given string.\u003c/p\u003e \u003cp\u003eA  {@code null} or empty (\"\") String input returns {@code 0}.\u003c/p\u003e \u003cpre\u003e StringUtils.countMatches(null, *)       \u003d 0 StringUtils.countMatches(\"\", *)         \u003d 0 StringUtils.countMatches(\"abba\", 0)  \u003d 0 StringUtils.countMatches(\"abba\", \u0027a\u0027)   \u003d 2 StringUtils.countMatches(\"abba\", \u0027b\u0027)  \u003d 2 StringUtils.countMatches(\"abba\", \u0027x\u0027) \u003d 0 \u003c/pre\u003e\n * @param str  the CharSequence to check, may be null\n * @param ch  the char to count\n * @return the number of occurrences, 0 if the CharSequence is {@code null}\n * @since 3.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAlpha#6243",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAlpha(java.lang.CharSequence)",
    "snippet": "public static boolean isAlpha(final CharSequence cs) {\n        if (isEmpty(cs)) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isLetter(cs.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6243,
    "end_line": 6254,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only Unicode letters.\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}. An empty CharSequence (length()\u003d0) will return  {@code false}.\u003c/p\u003e \u003cpre\u003e StringUtils.isAlpha(null)   \u003d false StringUtils.isAlpha(\"\")     \u003d false StringUtils.isAlpha(\"  \")   \u003d false StringUtils.isAlpha(\"abc\")  \u003d true StringUtils.isAlpha(\"ab2c\") \u003d false StringUtils.isAlpha(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains letters, and is non-null\n * @since 3.0 Changed signature from isAlpha(String) to isAlpha(CharSequence)\n * @since 3.0 Changed \"\" to return false and not true\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAlphaSpace#6278",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAlphaSpace(java.lang.CharSequence)",
    "snippet": "public static boolean isAlphaSpace(final CharSequence cs) {\n        if (cs \u003d\u003d null) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isLetter(cs.charAt(i)) \u003d\u003d false \u0026\u0026 cs.charAt(i) !\u003d \u0027 \u0027) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6278,
    "end_line": 6289,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only Unicode letters and space (\u0027 \u0027).\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}An empty CharSequence (length()\u003d0) will return  {@code true}.\u003c/p\u003e \u003cpre\u003e StringUtils.isAlphaSpace(null)   \u003d false StringUtils.isAlphaSpace(\"\")     \u003d true StringUtils.isAlphaSpace(\"  \")   \u003d true StringUtils.isAlphaSpace(\"abc\")  \u003d true StringUtils.isAlphaSpace(\"ab c\") \u003d true StringUtils.isAlphaSpace(\"ab2c\") \u003d false StringUtils.isAlphaSpace(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains letters and space,and is non-null\n * @since 3.0 Changed signature from isAlphaSpace(String) to isAlphaSpace(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAlphanumeric#6313",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAlphanumeric(java.lang.CharSequence)",
    "snippet": "public static boolean isAlphanumeric(final CharSequence cs) {\n        if (isEmpty(cs)) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isLetterOrDigit(cs.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6313,
    "end_line": 6324,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only Unicode letters or digits.\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}. An empty CharSequence (length()\u003d0) will return  {@code false}.\u003c/p\u003e \u003cpre\u003e StringUtils.isAlphanumeric(null)   \u003d false StringUtils.isAlphanumeric(\"\")     \u003d false StringUtils.isAlphanumeric(\"  \")   \u003d false StringUtils.isAlphanumeric(\"abc\")  \u003d true StringUtils.isAlphanumeric(\"ab c\") \u003d false StringUtils.isAlphanumeric(\"ab2c\") \u003d true StringUtils.isAlphanumeric(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains letters or digits,and is non-null\n * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)\n * @since 3.0 Changed \"\" to return false and not true\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAlphanumericSpace#6348",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAlphanumericSpace(java.lang.CharSequence)",
    "snippet": "public static boolean isAlphanumericSpace(final CharSequence cs) {\n        if (cs \u003d\u003d null) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isLetterOrDigit(cs.charAt(i)) \u003d\u003d false \u0026\u0026 cs.charAt(i) !\u003d \u0027 \u0027) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6348,
    "end_line": 6359,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only Unicode letters, digits or space ( {@code \u0027 \u0027}).\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}. An empty CharSequence (length()\u003d0) will return  {@code true}.\u003c/p\u003e \u003cpre\u003e StringUtils.isAlphanumericSpace(null)   \u003d false StringUtils.isAlphanumericSpace(\"\")     \u003d true StringUtils.isAlphanumericSpace(\"  \")   \u003d true StringUtils.isAlphanumericSpace(\"abc\")  \u003d true StringUtils.isAlphanumericSpace(\"ab c\") \u003d true StringUtils.isAlphanumericSpace(\"ab2c\") \u003d true StringUtils.isAlphanumericSpace(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains letters, digits or space,and is non-null\n * @since 3.0 Changed signature from isAlphanumericSpace(String) to isAlphanumericSpace(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAsciiPrintable#6387",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAsciiPrintable(java.lang.CharSequence)",
    "snippet": "public static boolean isAsciiPrintable(final CharSequence cs) {\n        if (cs \u003d\u003d null) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (CharUtils.isAsciiPrintable(cs.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6387,
    "end_line": 6398,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only ASCII printable characters.\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}. An empty CharSequence (length()\u003d0) will return  {@code true}.\u003c/p\u003e \u003cpre\u003e StringUtils.isAsciiPrintable(null)     \u003d false StringUtils.isAsciiPrintable(\"\")       \u003d true StringUtils.isAsciiPrintable(\" \")      \u003d true StringUtils.isAsciiPrintable(\"Ceki\")   \u003d true StringUtils.isAsciiPrintable(\"ab2c\")   \u003d true StringUtils.isAsciiPrintable(\"!ab-c~\") \u003d true StringUtils.isAsciiPrintable(\"\\u0020\") \u003d true StringUtils.isAsciiPrintable(\"\\u0021\") \u003d true StringUtils.isAsciiPrintable(\"\\u007e\") \u003d true StringUtils.isAsciiPrintable(\"\\u007f\") \u003d false StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") \u003d false \u003c/pre\u003e\n * @param cs the CharSequence to check, may be null\n * @return {@code true} if every character is in the range32 thru 126\n * @since 2.1\n * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNumeric#6431",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNumeric(java.lang.CharSequence)",
    "snippet": "public static boolean isNumeric(final CharSequence cs) {\n        if (isEmpty(cs)) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (!Character.isDigit(cs.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6431,
    "end_line": 6442,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only Unicode digits. A decimal point is not a Unicode digit and returns false.\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}. An empty CharSequence (length()\u003d0) will return  {@code false}.\u003c/p\u003e \u003cp\u003eNote that the method does not allow for a leading sign, either positive or negative. Also, if a String passes the numeric test, it may still generate a NumberFormatException when parsed by Integer.parseInt or Long.parseLong, e.g. if the value is outside the range for int or long respectively.\u003c/p\u003e \u003cpre\u003e StringUtils.isNumeric(null)   \u003d false StringUtils.isNumeric(\"\")     \u003d false StringUtils.isNumeric(\"  \")   \u003d false StringUtils.isNumeric(\"123\")  \u003d true StringUtils.isNumeric(\"\\u0967\\u0968\\u0969\")  \u003d true StringUtils.isNumeric(\"12 3\") \u003d false StringUtils.isNumeric(\"ab2c\") \u003d false StringUtils.isNumeric(\"12-3\") \u003d false StringUtils.isNumeric(\"12.3\") \u003d false StringUtils.isNumeric(\"-123\") \u003d false StringUtils.isNumeric(\"+123\") \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains digits, and is non-null\n * @since 3.0 Changed signature from isNumeric(String) to isNumeric(CharSequence)\n * @since 3.0 Changed \"\" to return false and not true\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isNumericSpace#6470",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isNumericSpace(java.lang.CharSequence)",
    "snippet": "public static boolean isNumericSpace(final CharSequence cs) {\n        if (cs \u003d\u003d null) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isDigit(cs.charAt(i)) \u003d\u003d false \u0026\u0026 cs.charAt(i) !\u003d \u0027 \u0027) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6470,
    "end_line": 6481,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only Unicode digits or space ( {@code \u0027 \u0027}). A decimal point is not a Unicode digit and returns false.\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}. An empty CharSequence (length()\u003d0) will return  {@code true}.\u003c/p\u003e \u003cpre\u003e StringUtils.isNumericSpace(null)   \u003d false StringUtils.isNumericSpace(\"\")     \u003d true StringUtils.isNumericSpace(\"  \")   \u003d true StringUtils.isNumericSpace(\"123\")  \u003d true StringUtils.isNumericSpace(\"12 3\") \u003d true StringUtils.isNumeric(\"\\u0967\\u0968\\u0969\")  \u003d true StringUtils.isNumeric(\"\\u0967\\u0968 \\u0969\")  \u003d true StringUtils.isNumericSpace(\"ab2c\") \u003d false StringUtils.isNumericSpace(\"12-3\") \u003d false StringUtils.isNumericSpace(\"12.3\") \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains digits or space,and is non-null\n * @since 3.0 Changed signature from isNumericSpace(String) to isNumericSpace(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isWhitespace#6503",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isWhitespace(java.lang.CharSequence)",
    "snippet": "public static boolean isWhitespace(final CharSequence cs) {\n        if (cs \u003d\u003d null) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isWhitespace(cs.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6503,
    "end_line": 6514,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only whitespace.\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}. An empty CharSequence (length()\u003d0) will return  {@code true}.\u003c/p\u003e \u003cpre\u003e StringUtils.isWhitespace(null)   \u003d false StringUtils.isWhitespace(\"\")     \u003d true StringUtils.isWhitespace(\"  \")   \u003d true StringUtils.isWhitespace(\"abc\")  \u003d false StringUtils.isWhitespace(\"ab2c\") \u003d false StringUtils.isWhitespace(\"ab-c\") \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains whitespace, and is non-null\n * @since 2.0\n * @since 3.0 Changed signature from isWhitespace(String) to isWhitespace(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAllLowerCase#6538",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAllLowerCase(java.lang.CharSequence)",
    "snippet": "public static boolean isAllLowerCase(final CharSequence cs) {\n        if (cs \u003d\u003d null || isEmpty(cs)) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isLowerCase(cs.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6538,
    "end_line": 6549,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only lowercase characters.\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}. An empty CharSequence (length()\u003d0) will return  {@code false}.\u003c/p\u003e \u003cpre\u003e StringUtils.isAllLowerCase(null)   \u003d false StringUtils.isAllLowerCase(\"\")     \u003d false StringUtils.isAllLowerCase(\"  \")   \u003d false StringUtils.isAllLowerCase(\"abc\")  \u003d true StringUtils.isAllLowerCase(\"abC\")  \u003d false StringUtils.isAllLowerCase(\"ab c\") \u003d false StringUtils.isAllLowerCase(\"ab1c\") \u003d false StringUtils.isAllLowerCase(\"ab/c\") \u003d false \u003c/pre\u003e\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains lowercase characters, and is non-null\n * @since 2.5\n * @since 3.0 Changed signature from isAllLowerCase(String) to isAllLowerCase(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.isAllUpperCase#6573",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.isAllUpperCase(java.lang.CharSequence)",
    "snippet": "public static boolean isAllUpperCase(final CharSequence cs) {\n        if (cs \u003d\u003d null || isEmpty(cs)) {\n            return false;\n        }\n        final int sz \u003d cs.length();\n        for (int i \u003d 0; i \u003c sz; i++) {\n            if (Character.isUpperCase(cs.charAt(i)) \u003d\u003d false) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 6573,
    "end_line": 6584,
    "comment": "/** \n * \u003cp\u003eChecks if the CharSequence contains only uppercase characters.\u003c/p\u003e \u003cp\u003e {@code null} will return {@code false}. An empty String (length()\u003d0) will return  {@code false}.\u003c/p\u003e \u003cpre\u003e StringUtils.isAllUpperCase(null)   \u003d false StringUtils.isAllUpperCase(\"\")     \u003d false StringUtils.isAllUpperCase(\"  \")   \u003d false StringUtils.isAllUpperCase(\"ABC\")  \u003d true StringUtils.isAllUpperCase(\"aBC\")  \u003d false StringUtils.isAllUpperCase(\"A C\")  \u003d false StringUtils.isAllUpperCase(\"A1C\")  \u003d false StringUtils.isAllUpperCase(\"A/C\")  \u003d false \u003c/pre\u003e\n * @param cs the CharSequence to check, may be null\n * @return {@code true} if only contains uppercase characters, and is non-null\n * @since 2.5\n * @since 3.0 Changed signature from isAllUpperCase(String) to isAllUpperCase(CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.defaultString#6604",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.defaultString(java.lang.String)",
    "snippet": "public static String defaultString(final String str) {\n        return str \u003d\u003d null ? EMPTY : str;\n    }",
    "begin_line": 6604,
    "end_line": 6606,
    "comment": "/** \n * \u003cp\u003eReturns either the passed in String, or if the String is  {@code null}, an empty String (\"\").\u003c/p\u003e \u003cpre\u003e StringUtils.defaultString(null)  \u003d \"\" StringUtils.defaultString(\"\")    \u003d \"\" StringUtils.defaultString(\"bat\") \u003d \"bat\" \u003c/pre\u003e\n * @see ObjectUtils#toString(Object)\n * @see String#valueOf(Object)\n * @param str  the String to check, may be null\n * @return the passed in String, or the empty String if itwas  {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.defaultString#6625",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.defaultString(java.lang.String, java.lang.String)",
    "snippet": "public static String defaultString(final String str, final String defaultStr) {\n        return str \u003d\u003d null ? defaultStr : str;\n    }",
    "begin_line": 6625,
    "end_line": 6627,
    "comment": "/** \n * \u003cp\u003eReturns either the passed in String, or if the String is {@code null}, the value of  {@code defaultStr}.\u003c/p\u003e \u003cpre\u003e StringUtils.defaultString(null, \"NULL\")  \u003d \"NULL\" StringUtils.defaultString(\"\", \"NULL\")    \u003d \"\" StringUtils.defaultString(\"bat\", \"NULL\") \u003d \"bat\" \u003c/pre\u003e\n * @see ObjectUtils#toString(Object,String)\n * @see String#valueOf(Object)\n * @param str  the String to check, may be null\n * @param defaultStr  the default String to returnif the input is  {@code null}, may be null\n * @return the passed in String, or the default if it was {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.defaultIfBlank#6647",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.defaultIfBlank(T, T)",
    "snippet": "public static \u003cT extends CharSequence\u003e T defaultIfBlank(final T str, final T defaultStr) {\n        return isBlank(str) ? defaultStr : str;\n    }",
    "begin_line": 6647,
    "end_line": 6649,
    "comment": "/** \n * \u003cp\u003eReturns either the passed in CharSequence, or if the CharSequence is whitespace, empty (\"\") or  {@code null}, the value of  {@code defaultStr}.\u003c/p\u003e \u003cpre\u003e StringUtils.defaultIfBlank(null, \"NULL\")  \u003d \"NULL\" StringUtils.defaultIfBlank(\"\", \"NULL\")    \u003d \"NULL\" StringUtils.defaultIfBlank(\" \", \"NULL\")   \u003d \"NULL\" StringUtils.defaultIfBlank(\"bat\", \"NULL\") \u003d \"bat\" StringUtils.defaultIfBlank(\"\", null)      \u003d null \u003c/pre\u003e\n * @param \u003c T \u003e the specific kind of CharSequence\n * @param str the CharSequence to check, may be null\n * @param defaultStr  the default CharSequence to returnif the input is whitespace, empty (\"\") or  {@code null}, may be null\n * @return the passed in CharSequence, or the default\n * @see StringUtils#defaultString(String,String)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.defaultIfEmpty#6669",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.defaultIfEmpty(T, T)",
    "snippet": "public static \u003cT extends CharSequence\u003e T defaultIfEmpty(final T str, final T defaultStr) {\n        return isEmpty(str) ? defaultStr : str;\n    }",
    "begin_line": 6669,
    "end_line": 6671,
    "comment": "/** \n * \u003cp\u003eReturns either the passed in CharSequence, or if the CharSequence is empty or  {@code null}, the value of  {@code defaultStr}.\u003c/p\u003e \u003cpre\u003e StringUtils.defaultIfEmpty(null, \"NULL\")  \u003d \"NULL\" StringUtils.defaultIfEmpty(\"\", \"NULL\")    \u003d \"NULL\" StringUtils.defaultIfEmpty(\" \", \"NULL\")   \u003d \" \" StringUtils.defaultIfEmpty(\"bat\", \"NULL\") \u003d \"bat\" StringUtils.defaultIfEmpty(\"\", null)      \u003d null \u003c/pre\u003e\n * @param \u003c T \u003e the specific kind of CharSequence\n * @param str  the CharSequence to check, may be null\n * @param defaultStr  the default CharSequence to returnif the input is empty (\"\") or  {@code null}, may be null\n * @return the passed in CharSequence, or the default\n * @see StringUtils#defaultString(String,String)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.rotate#6700",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.rotate(java.lang.String, int)",
    "snippet": "public static String rotate(String str, int shift) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n\n        final int strLen \u003d str.length();\n        if (shift \u003d\u003d 0 || strLen \u003d\u003d 0 || shift % strLen \u003d\u003d 0) {\n            return str;\n        }\n\n        final StringBuilder builder \u003d new StringBuilder(strLen);\n        final int offset \u003d - (shift % strLen);\n        builder.append(substring(str, offset));\n        builder.append(substring(str, 0, offset));\n        return builder.toString();\n    }",
    "begin_line": 6700,
    "end_line": 6715,
    "comment": "/** \n * \u003cp\u003eRotate (circular shift) a String of  {@code shift} characters.\u003c/p\u003e\u003cul\u003e \u003cli\u003eIf  {@code shift \u003e 0}, right circular shift (ex : ABCDEF \u003d\u0026gt; FABCDE)\u003c/li\u003e \u003cli\u003eIf  {@code shift \u003c 0}, left circular shift (ex : ABCDEF \u003d\u0026gt; BCDEFA)\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e StringUtils.rotate(null, *)        \u003d null StringUtils.rotate(\"\", *)          \u003d \"\" StringUtils.rotate(\"abcdefg\", 0)   \u003d \"abcdefg\" StringUtils.rotate(\"abcdefg\", 2)   \u003d \"fgabcde\" StringUtils.rotate(\"abcdefg\", -2)  \u003d \"cdefgab\" StringUtils.rotate(\"abcdefg\", 7)   \u003d \"abcdefg\" StringUtils.rotate(\"abcdefg\", -7)  \u003d \"abcdefg\" StringUtils.rotate(\"abcdefg\", 9)   \u003d \"fgabcde\" StringUtils.rotate(\"abcdefg\", -9)  \u003d \"cdefgab\" \u003c/pre\u003e\n * @param str  the String to rotate, may be null\n * @param shift  number of time to shift (positive : right shift, negative : left shift)\n * @return the rotated String,or the original String if  {@code shift \u003d\u003d 0}, or  {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.reverse#6733",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.reverse(java.lang.String)",
    "snippet": "public static String reverse(final String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }",
    "begin_line": 6733,
    "end_line": 6738,
    "comment": "/** \n * \u003cp\u003eReverses a String as per  {@link StringBuilder#reverse()}.\u003c/p\u003e \u003cp\u003eA  {@code null} String returns {@code null}.\u003c/p\u003e \u003cpre\u003e StringUtils.reverse(null)  \u003d null StringUtils.reverse(\"\")    \u003d \"\" StringUtils.reverse(\"bat\") \u003d \"tab\" \u003c/pre\u003e\n * @param str  the String to reverse, may be null\n * @return the reversed String, {@code null} if null String input\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.reverseDelimited#6759",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.reverseDelimited(java.lang.String, char)",
    "snippet": "public static String reverseDelimited(final String str, final char separatorChar) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        // could implement manually, but simple way is to reuse other,\n        // probably slower, methods.\n        final String[] strs \u003d split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }",
    "begin_line": 6759,
    "end_line": 6768,
    "comment": "/** \n * \u003cp\u003eReverses a String that is delimited by a specific character.\u003c/p\u003e \u003cp\u003eThe Strings between the delimiters are not reversed. Thus java.lang.String becomes String.lang.java (if the delimiter is  {@code \u0027.\u0027}).\u003c/p\u003e \u003cpre\u003e StringUtils.reverseDelimited(null, *)      \u003d null StringUtils.reverseDelimited(\"\", *)        \u003d \"\" StringUtils.reverseDelimited(\"a.b.c\", \u0027x\u0027) \u003d \"a.b.c\" StringUtils.reverseDelimited(\"a.b.c\", \".\") \u003d \"c.b.a\" \u003c/pre\u003e\n * @param str  the String to reverse, may be null\n * @param separatorChar  the separator character to use\n * @return the reversed String, {@code null} if null String input\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.abbreviate#6803",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.abbreviate(java.lang.String, int)",
    "snippet": "public static String abbreviate(final String str, final int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }",
    "begin_line": 6803,
    "end_line": 6805,
    "comment": "/** \n * \u003cp\u003eAbbreviates a String using ellipses. This will turn \"Now is the time for all good men\" into \"Now is the time for...\"\u003c/p\u003e \u003cp\u003eSpecifically:\u003c/p\u003e \u003cul\u003e \u003cli\u003eIf the number of characters in  {@code str} is less than or equal to {@code maxWidth}, return  {@code str}.\u003c/li\u003e \u003cli\u003eElse abbreviate it to  {@code (substring(str, 0, max-3) + \"...\")}.\u003c/li\u003e \u003cli\u003eIf  {@code maxWidth} is less than {@code 4}, throw an {@code IllegalArgumentException}.\u003c/li\u003e \u003cli\u003eIn no case will it return a String of length greater than {@code maxWidth}.\u003c/li\u003e \u003c/ul\u003e \u003cpre\u003e StringUtils.abbreviate(null, *)      \u003d null StringUtils.abbreviate(\"\", 4)        \u003d \"\" StringUtils.abbreviate(\"abcdefg\", 6) \u003d \"abc...\" StringUtils.abbreviate(\"abcdefg\", 7) \u003d \"abcdefg\" StringUtils.abbreviate(\"abcdefg\", 8) \u003d \"abcdefg\" StringUtils.abbreviate(\"abcdefg\", 4) \u003d \"a...\" StringUtils.abbreviate(\"abcdefg\", 3) \u003d IllegalArgumentException \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param maxWidth  maximum length of result String, must be at least 4\n * @return abbreviated String, {@code null} if null String input\n * @throws IllegalArgumentException if the width is too small\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.abbreviate#6842",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.abbreviate(java.lang.String, int, int)",
    "snippet": "public static String abbreviate(final String str, int offset, final int maxWidth) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (maxWidth \u003c 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() \u003c\u003d maxWidth) {\n            return str;\n        }\n        if (offset \u003e str.length()) {\n            offset \u003d str.length();\n        }\n        if (str.length() - offset \u003c maxWidth - 3) {\n            offset \u003d str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker \u003d \"...\";\n        if (offset \u003c\u003d 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth \u003c 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if (offset + maxWidth - 3 \u003c str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    }",
    "begin_line": 6842,
    "end_line": 6869,
    "comment": "/** \n * \u003cp\u003eAbbreviates a String using ellipses. This will turn \"Now is the time for all good men\" into \"...is the time for...\"\u003c/p\u003e \u003cp\u003eWorks like  {@code abbreviate(String, int)}, but allows you to specify a \"left edge\" offset.  Note that this left edge is not necessarily going to be the leftmost character in the result, or the first character following the ellipses, but it will appear somewhere in the result. \u003cp\u003eIn no case will it return a String of length greater than {@code maxWidth}.\u003c/p\u003e \u003cpre\u003e StringUtils.abbreviate(null, *, *)                \u003d null StringUtils.abbreviate(\"\", 0, 4)                  \u003d \"\" StringUtils.abbreviate(\"abcdefghijklmno\", -1, 10) \u003d \"abcdefg...\" StringUtils.abbreviate(\"abcdefghijklmno\", 0, 10)  \u003d \"abcdefg...\" StringUtils.abbreviate(\"abcdefghijklmno\", 1, 10)  \u003d \"abcdefg...\" StringUtils.abbreviate(\"abcdefghijklmno\", 4, 10)  \u003d \"abcdefg...\" StringUtils.abbreviate(\"abcdefghijklmno\", 5, 10)  \u003d \"...fghi...\" StringUtils.abbreviate(\"abcdefghijklmno\", 6, 10)  \u003d \"...ghij...\" StringUtils.abbreviate(\"abcdefghijklmno\", 8, 10)  \u003d \"...ijklmno\" StringUtils.abbreviate(\"abcdefghijklmno\", 10, 10) \u003d \"...ijklmno\" StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10) \u003d \"...ijklmno\" StringUtils.abbreviate(\"abcdefghij\", 0, 3)        \u003d IllegalArgumentException StringUtils.abbreviate(\"abcdefghij\", 5, 6)        \u003d IllegalArgumentException \u003c/pre\u003e\n * @param str  the String to check, may be null\n * @param offset  left edge of source String\n * @param maxWidth  maximum length of result String, must be at least 4\n * @return abbreviated String, {@code null} if null String input\n * @throws IllegalArgumentException if the width is too small\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.abbreviateMiddle#6900",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.abbreviateMiddle(java.lang.String, java.lang.String, int)",
    "snippet": "public static String abbreviateMiddle(final String str, final String middle, final int length) {\n        if (isEmpty(str) || isEmpty(middle)) {\n            return str;\n        }\n\n        if (length \u003e\u003d str.length() || length \u003c middle.length()+2) {\n            return str;\n        }\n\n        final int targetSting \u003d length-middle.length();\n        final int startOffset \u003d targetSting/2+targetSting%2;\n        final int endOffset \u003d str.length()-targetSting/2;\n\n        final StringBuilder builder \u003d new StringBuilder(length);\n        builder.append(str.substring(0,startOffset));\n        builder.append(middle);\n        builder.append(str.substring(endOffset));\n\n        return builder.toString();\n    }",
    "begin_line": 6900,
    "end_line": 6919,
    "comment": "/** \n * \u003cp\u003eAbbreviates a String to the length passed, replacing the middle characters with the supplied replacement String.\u003c/p\u003e \u003cp\u003eThis abbreviation only occurs if the following criteria is met:\u003c/p\u003e \u003cul\u003e \u003cli\u003eNeither the String for abbreviation nor the replacement String are null or empty \u003c/li\u003e \u003cli\u003eThe length to truncate to is less than the length of the supplied String\u003c/li\u003e \u003cli\u003eThe length to truncate to is greater than 0\u003c/li\u003e \u003cli\u003eThe abbreviated String will have enough room for the length supplied replacement String and the first and last characters of the supplied String for abbreviation\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eOtherwise, the returned String will be the same as the supplied String for abbreviation. \u003c/p\u003e \u003cpre\u003e StringUtils.abbreviateMiddle(null, null, 0)      \u003d null StringUtils.abbreviateMiddle(\"abc\", null, 0)      \u003d \"abc\" StringUtils.abbreviateMiddle(\"abc\", \".\", 0)      \u003d \"abc\" StringUtils.abbreviateMiddle(\"abc\", \".\", 3)      \u003d \"abc\" StringUtils.abbreviateMiddle(\"abcdef\", \".\", 4)     \u003d \"ab.f\" \u003c/pre\u003e\n * @param str  the String to abbreviate, may be null\n * @param middle the String to replace the middle characters with, may be null\n * @param length the length to abbreviate {@code str} to.\n * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.difference#6951",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.difference(java.lang.String, java.lang.String)",
    "snippet": "public static String difference(final String str1, final String str2) {\n        if (str1 \u003d\u003d null) {\n            return str2;\n        }\n        if (str2 \u003d\u003d null) {\n            return str1;\n        }\n        final int at \u003d indexOfDifference(str1, str2);\n        if (at \u003d\u003d INDEX_NOT_FOUND) {\n            return EMPTY;\n        }\n        return str2.substring(at);\n    }",
    "begin_line": 6951,
    "end_line": 6963,
    "comment": "/** \n * \u003cp\u003eCompares two Strings, and returns the portion where they differ. More precisely, return the remainder of the second String, starting from where it\u0027s different from the first. This means that the difference between \"abc\" and \"ab\" is the empty String and not \"c\". \u003c/p\u003e \u003cp\u003eFor example, {@code difference(\"i am a machine\", \"i am a robot\") -\u003e \"robot\"}.\u003c/p\u003e \u003cpre\u003e StringUtils.difference(null, null) \u003d null StringUtils.difference(\"\", \"\") \u003d \"\" StringUtils.difference(\"\", \"abc\") \u003d \"abc\" StringUtils.difference(\"abc\", \"\") \u003d \"\" StringUtils.difference(\"abc\", \"abc\") \u003d \"\" StringUtils.difference(\"abc\", \"ab\") \u003d \"\" StringUtils.difference(\"ab\", \"abxyz\") \u003d \"xyz\" StringUtils.difference(\"abcde\", \"abxyz\") \u003d \"xyz\" StringUtils.difference(\"abcde\", \"xyz\") \u003d \"xyz\" \u003c/pre\u003e\n * @param str1  the first String, may be null\n * @param str2  the second String, may be null\n * @return the portion of str2 where it differs from str1; returns theempty String if they are equal\n * @see #indexOfDifference(CharSequence,CharSequence)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfDifference#6990",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfDifference(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 \u003d\u003d cs2) {\n            return INDEX_NOT_FOUND;\n        }\n        if (cs1 \u003d\u003d null || cs2 \u003d\u003d null) {\n            return 0;\n        }\n        int i;\n        for (i \u003d 0; i \u003c cs1.length() \u0026\u0026 i \u003c cs2.length(); ++i) {\n            if (cs1.charAt(i) !\u003d cs2.charAt(i)) {\n                break;\n            }\n        }\n        if (i \u003c cs2.length() || i \u003c cs1.length()) {\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }",
    "begin_line": 6990,
    "end_line": 7007,
    "comment": "/** \n * \u003cp\u003eCompares two CharSequences, and returns the index at which the CharSequences begin to differ.\u003c/p\u003e \u003cp\u003eFor example, {@code indexOfDifference(\"i am a machine\", \"i am a robot\") -\u003e 7}\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfDifference(null, null) \u003d -1 StringUtils.indexOfDifference(\"\", \"\") \u003d -1 StringUtils.indexOfDifference(\"\", \"abc\") \u003d 0 StringUtils.indexOfDifference(\"abc\", \"\") \u003d 0 StringUtils.indexOfDifference(\"abc\", \"abc\") \u003d -1 StringUtils.indexOfDifference(\"ab\", \"abxyz\") \u003d 2 StringUtils.indexOfDifference(\"abcde\", \"abxyz\") \u003d 2 StringUtils.indexOfDifference(\"abcde\", \"xyz\") \u003d 0 \u003c/pre\u003e\n * @param cs1  the first CharSequence, may be null\n * @param cs2  the second CharSequence, may be null\n * @return the index where cs1 and cs2 begin to differ; -1 if they are equal\n * @since 2.0\n * @since 3.0 Changed signature from indexOfDifference(String, String) toindexOfDifference(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.indexOfDifference#7041",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.indexOfDifference(java.lang.CharSequence)",
    "snippet": "public static int indexOfDifference(final CharSequence... css) {\n        if (css \u003d\u003d null || css.length \u003c\u003d 1) {\n            return INDEX_NOT_FOUND;\n        }\n        boolean anyStringNull \u003d false;\n        boolean allStringsNull \u003d true;\n        final int arrayLen \u003d css.length;\n        int shortestStrLen \u003d Integer.MAX_VALUE;\n        int longestStrLen \u003d 0;\n\n        // find the min and max string lengths; this avoids checking to make\n        // sure we are not exceeding the length of the string each time through\n        // the bottom loop.\n        for (int i \u003d 0; i \u003c arrayLen; i++) {\n            if (css[i] \u003d\u003d null) {\n                anyStringNull \u003d true;\n                shortestStrLen \u003d 0;\n            } else {\n                allStringsNull \u003d false;\n                shortestStrLen \u003d Math.min(css[i].length(), shortestStrLen);\n                longestStrLen \u003d Math.max(css[i].length(), longestStrLen);\n            }\n        }\n\n        // handle lists containing all nulls or all empty strings\n        if (allStringsNull || longestStrLen \u003d\u003d 0 \u0026\u0026 !anyStringNull) {\n            return INDEX_NOT_FOUND;\n        }\n\n        // handle lists containing some nulls or some empty strings\n        if (shortestStrLen \u003d\u003d 0) {\n            return 0;\n        }\n\n        // find the position with the first difference across all strings\n        int firstDiff \u003d -1;\n        for (int stringPos \u003d 0; stringPos \u003c shortestStrLen; stringPos++) {\n            final char comparisonChar \u003d css[0].charAt(stringPos);\n            for (int arrayPos \u003d 1; arrayPos \u003c arrayLen; arrayPos++) {\n                if (css[arrayPos].charAt(stringPos) !\u003d comparisonChar) {\n                    firstDiff \u003d stringPos;\n                    break;\n                }\n            }\n            if (firstDiff !\u003d -1) {\n                break;\n            }\n        }\n\n        if (firstDiff \u003d\u003d -1 \u0026\u0026 shortestStrLen !\u003d longestStrLen) {\n            // we compared all of the characters up to the length of the\n            // shortest string and didn\u0027t find a match, but the string lengths\n            // vary, so return the length of the shortest string.\n            return shortestStrLen;\n        }\n        return firstDiff;\n    }",
    "begin_line": 7041,
    "end_line": 7097,
    "comment": "/** \n * \u003cp\u003eCompares all CharSequences in an array and returns the index at which the CharSequences begin to differ.\u003c/p\u003e \u003cp\u003eFor example, \u003ccode\u003eindexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) -\u0026gt; 7\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e StringUtils.indexOfDifference(null) \u003d -1 StringUtils.indexOfDifference(new String[] {}) \u003d -1 StringUtils.indexOfDifference(new String[] {\"abc\"}) \u003d -1 StringUtils.indexOfDifference(new String[] {null, null}) \u003d -1 StringUtils.indexOfDifference(new String[] {\"\", \"\"}) \u003d -1 StringUtils.indexOfDifference(new String[] {\"\", null}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"abc\", null, null}) \u003d 0 StringUtils.indexOfDifference(new String[] {null, null, \"abc\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"\", \"abc\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"abc\", \"\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"abc\", \"abc\"}) \u003d -1 StringUtils.indexOfDifference(new String[] {\"abc\", \"a\"}) \u003d 1 StringUtils.indexOfDifference(new String[] {\"ab\", \"abxyz\"}) \u003d 2 StringUtils.indexOfDifference(new String[] {\"abcde\", \"abxyz\"}) \u003d 2 StringUtils.indexOfDifference(new String[] {\"abcde\", \"xyz\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"xyz\", \"abcde\"}) \u003d 0 StringUtils.indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) \u003d 7 \u003c/pre\u003e\n * @param css  array of CharSequences, entries may be null\n * @return the index where the strings begin to differ; -1 if they are all equal\n * @since 2.4\n * @since 3.0 Changed signature from indexOfDifference(String...) to indexOfDifference(CharSequence...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.getCommonPrefix#7132",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.getCommonPrefix(java.lang.String)",
    "snippet": "public static String getCommonPrefix(final String... strs) {\n        if (strs \u003d\u003d null || strs.length \u003d\u003d 0) {\n            return EMPTY;\n        }\n        final int smallestIndexOfDiff \u003d indexOfDifference(strs);\n        if (smallestIndexOfDiff \u003d\u003d INDEX_NOT_FOUND) {\n            // all strings were identical\n            if (strs[0] \u003d\u003d null) {\n                return EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff \u003d\u003d 0) {\n            // there were no common initial characters\n            return EMPTY;\n        } else {\n            // we found a common initial character sequence\n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }",
    "begin_line": 7132,
    "end_line": 7150,
    "comment": "/** \n * \u003cp\u003eCompares all Strings in an array and returns the initial sequence of characters that is common to all of them.\u003c/p\u003e \u003cp\u003eFor example, \u003ccode\u003egetCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) -\u0026gt; \"i am a \"\u003c/code\u003e\u003c/p\u003e \u003cpre\u003e StringUtils.getCommonPrefix(null) \u003d \"\" StringUtils.getCommonPrefix(new String[] {}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"abc\"}) \u003d \"abc\" StringUtils.getCommonPrefix(new String[] {null, null}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"\", \"\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"\", null}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"abc\", null, null}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {null, null, \"abc\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"\", \"abc\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"abc\", \"\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"abc\", \"abc\"}) \u003d \"abc\" StringUtils.getCommonPrefix(new String[] {\"abc\", \"a\"}) \u003d \"a\" StringUtils.getCommonPrefix(new String[] {\"ab\", \"abxyz\"}) \u003d \"ab\" StringUtils.getCommonPrefix(new String[] {\"abcde\", \"abxyz\"}) \u003d \"ab\" StringUtils.getCommonPrefix(new String[] {\"abcde\", \"xyz\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"xyz\", \"abcde\"}) \u003d \"\" StringUtils.getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) \u003d \"i am a \" \u003c/pre\u003e\n * @param strs  array of String objects, entries may be null\n * @return the initial sequence of characters that are common to all Stringsin the array; empty String if the array is null, the elements are all null or if there is no common prefix.\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.getLevenshteinDistance#7190",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.getLevenshteinDistance(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n        if (s \u003d\u003d null || t \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        /*\n           The difference between this impl. and the previous is that, rather\n           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,\n           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,\n           is the \u0027current working\u0027 distance array that maintains the newest distance cost\n           counts as we iterate through the characters of String s.  Each time we increment\n           the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n           allows us to retain the previous cost counts as required by the algorithm (taking\n           the minimum of the cost count to the left, up one, and diagonally up and to the left\n           of the current cost count being calculated).  (Note that the arrays aren\u0027t really\n           copied anymore, just switched...this is clearly much better than cloning an array\n           or doing a System.arraycopy() each time  through the outer loop.)\n\n           Effectively, the difference between the two implementations is this one does not\n           cause an out of memory condition when calculating the LD over two very large strings.\n         */\n\n        int n \u003d s.length(); // length of s\n        int m \u003d t.length(); // length of t\n\n        if (n \u003d\u003d 0) {\n            return m;\n        } else if (m \u003d\u003d 0) {\n            return n;\n        }\n\n        if (n \u003e m) {\n            // swap the input strings to consume less memory\n            final CharSequence tmp \u003d s;\n            s \u003d t;\n            t \u003d tmp;\n            n \u003d m;\n            m \u003d t.length();\n        }\n\n        int p[] \u003d new int[n + 1]; //\u0027previous\u0027 cost array, horizontally\n        int d[] \u003d new int[n + 1]; // cost array, horizontally\n        int _d[]; //placeholder to assist in swapping p and d\n\n        // indexes into strings s and t\n        int i; // iterates through s\n        int j; // iterates through t\n\n        char t_j; // jth character of t\n\n        int cost; // cost\n\n        for (i \u003d 0; i \u003c\u003d n; i++) {\n            p[i] \u003d i;\n        }\n\n        for (j \u003d 1; j \u003c\u003d m; j++) {\n            t_j \u003d t.charAt(j - 1);\n            d[0] \u003d j;\n\n            for (i \u003d 1; i \u003c\u003d n; i++) {\n                cost \u003d s.charAt(i - 1) \u003d\u003d t_j ? 0 : 1;\n                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n                d[i] \u003d Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);\n            }\n\n            // copy current distance counts to \u0027previous row\u0027 distance counts\n            _d \u003d p;\n            p \u003d d;\n            d \u003d _d;\n        }\n\n        // our last action in the above loop was to switch d and p, so p now\n        // actually has the most recent cost counts\n        return p[n];\n    }",
    "begin_line": 7190,
    "end_line": 7265,
    "comment": "/** \n * \u003cp\u003eFind the Levenshtein distance between two Strings.\u003c/p\u003e \u003cp\u003eThis is the number of changes needed to change one String into another, where each change is a single character modification (deletion, insertion or substitution).\u003c/p\u003e \u003cp\u003eThe previous implementation of the Levenshtein distance algorithm was from \u003ca href\u003d\"http://www.merriampark.com/ld.htm\"\u003ehttp://www.merriampark.com/ld.htm\u003c/a\u003e\u003c/p\u003e \u003cp\u003eChas Emerick has written an implementation in Java, which avoids an OutOfMemoryError which can occur when my Java implementation is used with very large strings.\u003cbr\u003e This implementation of the Levenshtein distance algorithm is from \u003ca href\u003d\"http://www.merriampark.com/ldjava.htm\"\u003ehttp://www.merriampark.com/ldjava.htm\u003c/a\u003e\u003c/p\u003e \u003cpre\u003e StringUtils.getLevenshteinDistance(null, *)             \u003d IllegalArgumentException StringUtils.getLevenshteinDistance(*, null)             \u003d IllegalArgumentException StringUtils.getLevenshteinDistance(\"\",\"\")               \u003d 0 StringUtils.getLevenshteinDistance(\"\",\"a\")              \u003d 1 StringUtils.getLevenshteinDistance(\"aaapppp\", \"\")       \u003d 7 StringUtils.getLevenshteinDistance(\"frog\", \"fog\")       \u003d 1 StringUtils.getLevenshteinDistance(\"fly\", \"ant\")        \u003d 3 StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") \u003d 7 StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") \u003d 7 StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") \u003d 8 StringUtils.getLevenshteinDistance(\"hello\", \"hallo\")    \u003d 1 \u003c/pre\u003e\n * @param s  the first String, must not be null\n * @param t  the second String, must not be null\n * @return result distance\n * @throws IllegalArgumentException if either String input {@code null}\n * @since 3.0 Changed signature from getLevenshteinDistance(String, String) togetLevenshteinDistance(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.getLevenshteinDistance#7299",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.getLevenshteinDistance(java.lang.CharSequence, java.lang.CharSequence, int)",
    "snippet": "public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {\n        if (s \u003d\u003d null || t \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n        if (threshold \u003c 0) {\n            throw new IllegalArgumentException(\"Threshold must not be negative\");\n        }\n\n        /*\n        This implementation only computes the distance if it\u0027s less than or equal to the\n        threshold value, returning -1 if it\u0027s greater.  The advantage is performance: unbounded\n        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only\n        computing a diagonal stripe of width 2k + 1 of the cost table.\n        It is also possible to use this to compute the unbounded Levenshtein distance by starting\n        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where\n        d is the distance.\n\n        One subtlety comes from needing to ignore entries on the border of our stripe\n        eg.\n        p[] \u003d |#|#|#|*\n        d[] \u003d  *|#|#|#|\n        We must ignore the entry to the left of the leftmost member\n        We must ignore the entry above the rightmost member\n\n        Another subtlety comes from our stripe running off the matrix if the strings aren\u0027t\n        of the same size.  Since string s is always swapped to be the shorter of the two,\n        the stripe will always run off to the upper right instead of the lower left of the matrix.\n\n        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.\n        In this case we\u0027re going to walk a stripe of length 3.  The matrix would look like so:\n\n           1 2 3 4 5\n        1 |#|#| | | |\n        2 |#|#|#| | |\n        3 | |#|#|#| |\n        4 | | |#|#|#|\n        5 | | | |#|#|\n        6 | | | | |#|\n        7 | | | | | |\n\n        Note how the stripe leads off the table as there is no possible way to turn a string of length 5\n        into one of length 7 in edit distance of 1.\n\n        Additionally, this implementation decreases memory usage by using two\n        single-dimensional arrays and swapping them back and forth instead of allocating\n        an entire n by m matrix.  This requires a few minor changes, such as immediately returning\n        when it\u0027s detected that the stripe has run off the matrix and initially filling the arrays with\n        large values so that entries we don\u0027t compute are ignored.\n\n        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.\n         */\n\n        int n \u003d s.length(); // length of s\n        int m \u003d t.length(); // length of t\n\n        // if one string is empty, the edit distance is necessarily the length of the other\n        if (n \u003d\u003d 0) {\n            return m \u003c\u003d threshold ? m : -1;\n        } else if (m \u003d\u003d 0) {\n            return n \u003c\u003d threshold ? n : -1;\n        }\n\n        if (n \u003e m) {\n            // swap the two strings to consume less memory\n            final CharSequence tmp \u003d s;\n            s \u003d t;\n            t \u003d tmp;\n            n \u003d m;\n            m \u003d t.length();\n        }\n\n        int p[] \u003d new int[n + 1]; // \u0027previous\u0027 cost array, horizontally\n        int d[] \u003d new int[n + 1]; // cost array, horizontally\n        int _d[]; // placeholder to assist in swapping p and d\n\n        // fill in starting table values\n        final int boundary \u003d Math.min(n, threshold) + 1;\n        for (int i \u003d 0; i \u003c boundary; i++) {\n            p[i] \u003d i;\n        }\n        // these fills ensure that the value above the rightmost entry of our\n        // stripe will be ignored in following loop iterations\n        Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n        Arrays.fill(d, Integer.MAX_VALUE);\n\n        // iterates through t\n        for (int j \u003d 1; j \u003c\u003d m; j++) {\n            final char t_j \u003d t.charAt(j - 1); // jth character of t\n            d[0] \u003d j;\n\n            // compute stripe indices, constrain to array size\n            final int min \u003d Math.max(1, j - threshold);\n            final int max \u003d j \u003e Integer.MAX_VALUE - threshold ? n : Math.min(n, j + threshold);\n\n            // the stripe may lead off of the table if s and t are of different sizes\n            if (min \u003e max) {\n                return -1;\n            }\n\n            // ignore entry left of leftmost\n            if (min \u003e 1) {\n                d[min - 1] \u003d Integer.MAX_VALUE;\n            }\n\n            // iterates through [min, max] in s\n            for (int i \u003d min; i \u003c\u003d max; i++) {\n                if (s.charAt(i - 1) \u003d\u003d t_j) {\n                    // diagonally left and up\n                    d[i] \u003d p[i - 1];\n                } else {\n                    // 1 + minimum of cell to the left, to the top, diagonally left and up\n                    d[i] \u003d 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n                }\n            }\n\n            // copy current distance counts to \u0027previous row\u0027 distance counts\n            _d \u003d p;\n            p \u003d d;\n            d \u003d _d;\n        }\n\n        // if p[n] is greater than the threshold, there\u0027s no guarantee on it being the correct\n        // distance\n        if (p[n] \u003c\u003d threshold) {\n            return p[n];\n        }\n        return -1;\n    }",
    "begin_line": 7299,
    "end_line": 7426,
    "comment": "/** \n * \u003cp\u003eFind the Levenshtein distance between two Strings if it\u0027s less than or equal to a given threshold.\u003c/p\u003e \u003cp\u003eThis is the number of changes needed to change one String into another, where each change is a single character modification (deletion, insertion or substitution).\u003c/p\u003e \u003cp\u003eThis implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield and Chas Emerick\u0027s implementation of the Levenshtein distance algorithm from \u003ca href\u003d\"http://www.merriampark.com/ld.htm\"\u003ehttp://www.merriampark.com/ld.htm\u003c/a\u003e\u003c/p\u003e \u003cpre\u003e StringUtils.getLevenshteinDistance(null, *, *)             \u003d IllegalArgumentException StringUtils.getLevenshteinDistance(*, null, *)             \u003d IllegalArgumentException StringUtils.getLevenshteinDistance(*, *, -1)               \u003d IllegalArgumentException StringUtils.getLevenshteinDistance(\"\",\"\", 0)               \u003d 0 StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 8)       \u003d 7 StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 7)       \u003d 7 StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 6))      \u003d -1 StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\", 7) \u003d 7 StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\", 6) \u003d -1 StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\", 7) \u003d 7 StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\", 6) \u003d -1 \u003c/pre\u003e\n * @param s  the first String, must not be null\n * @param t  the second String, must not be null\n * @param threshold the target threshold, must not be negative\n * @return result distance, or {@code -1} if the distance would be greater than the threshold\n * @throws IllegalArgumentException if either String input {@code null} or negative threshold\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.getJaroWinklerDistance#7460",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.getJaroWinklerDistance(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static double getJaroWinklerDistance(final CharSequence first, final CharSequence second) {\n        final double DEFAULT_SCALING_FACTOR \u003d 0.1;\n\n        if (first \u003d\u003d null || second \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        final double jaro \u003d score(first,second);\n        final int cl \u003d commonPrefixLength(first, second);\n        final double matchScore \u003d Math.round((jaro + (DEFAULT_SCALING_FACTOR * cl * (1.0 - jaro))) *100.0)/100.0;\n\n        return  matchScore;\n    }",
    "begin_line": 7460,
    "end_line": 7472,
    "comment": "/** \n * \u003cp\u003eFind the Jaro Winkler Distance which indicates the similarity score between two Strings.\u003c/p\u003e \u003cp\u003eThe Jaro measure is the weighted sum of percentage of matched characters from each file and transposed characters.  Winkler increased this measure for matching initial characters.\u003c/p\u003e \u003cp\u003eThis implementation is based on the Jaro Winkler similarity algorithm from \u003ca href\u003d\"http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\"\u003ehttp://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\u003c/a\u003e.\u003c/p\u003e \u003cpre\u003e StringUtils.getJaroWinklerDistance(null, null)          \u003d IllegalArgumentException StringUtils.getJaroWinklerDistance(\"\",\"\")               \u003d 0.0 StringUtils.getJaroWinklerDistance(\"\",\"a\")              \u003d 0.0 StringUtils.getJaroWinklerDistance(\"aaapppp\", \"\")       \u003d 0.0 StringUtils.getJaroWinklerDistance(\"frog\", \"fog\")       \u003d 0.93 StringUtils.getJaroWinklerDistance(\"fly\", \"ant\")        \u003d 0.0 StringUtils.getJaroWinklerDistance(\"elephant\", \"hippo\") \u003d 0.44 StringUtils.getJaroWinklerDistance(\"hippo\", \"elephant\") \u003d 0.44 StringUtils.getJaroWinklerDistance(\"hippo\", \"zzzzzzzz\") \u003d 0.0 StringUtils.getJaroWinklerDistance(\"hello\", \"hallo\")    \u003d 0.88 StringUtils.getJaroWinklerDistance(\"ABC Corporation\", \"ABC Corp\") \u003d 0.91 StringUtils.getJaroWinklerDistance(\"D N H Enterprises Inc\", \"D \u0026amp; H Enterprises, Inc.\") \u003d 0.93 StringUtils.getJaroWinklerDistance(\"My Gym Children\u0027s Fitness Center\", \"My Gym. Childrens Fitness\") \u003d 0.94 StringUtils.getJaroWinklerDistance(\"PENNSYLVANIA\", \"PENNCISYLVNIA\")    \u003d 0.9 \u003c/pre\u003e\n * @param first the first String, must not be null\n * @param second the second String, must not be null\n * @return result distance\n * @throws IllegalArgumentException if either String input {@code null}\n * @since 3.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.score#7480",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.score(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "private static double score(final CharSequence first, final CharSequence second) {\n        String shorter;\n        String longer;\n\n        // Determine which String is longer.\n        if (first.length() \u003e second.length()) {\n            longer \u003d first.toString().toLowerCase();\n            shorter \u003d second.toString().toLowerCase();\n        } else {\n            longer \u003d second.toString().toLowerCase();\n            shorter \u003d first.toString().toLowerCase();\n        }\n\n        // Calculate the half length() distance of the shorter String.\n        final int halflength \u003d shorter.length() / 2 + 1;\n\n        // Find the set of matching characters between the shorter and longer strings. Note that\n        // the set of matching characters may be different depending on the order of the strings.\n        final String m1 \u003d getSetOfMatchingCharacterWithin(shorter, longer, halflength);\n        final String m2 \u003d getSetOfMatchingCharacterWithin(longer, shorter, halflength);\n\n        // If one or both of the sets of common characters is empty, then\n        // there is no similarity between the two strings.\n        if (m1.length() \u003d\u003d 0 || m2.length() \u003d\u003d 0) {\n            return 0.0;\n        }\n\n        // If the set of common characters is not the same size, then\n        // there is no similarity between the two strings, either.\n        if (m1.length() !\u003d m2.length()) {\n            return 0.0;\n        }\n\n        // Calculate the number of transposition between the two sets\n        // of common characters.\n        final int transpositions \u003d transpositions(m1, m2);\n\n        // Calculate the distance.\n        final double dist \u003d\n                (m1.length() / ((double)shorter.length()) +\n                        m2.length() / ((double)longer.length()) +\n                        (m1.length() - transpositions) / ((double)m1.length())) / 3.0;\n        return dist;\n    }",
    "begin_line": 7480,
    "end_line": 7523,
    "comment": "/** \n * This method returns the Jaro-Winkler score for string matching.\n * @param first the first string to be matched\n * @param second the second string to be machted\n * @return matching score without scaling factor impact\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.getFuzzyDistance#7551",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.getFuzzyDistance(java.lang.CharSequence, java.lang.CharSequence, java.util.Locale)",
    "snippet": "public static int getFuzzyDistance(final CharSequence term, final CharSequence query, final Locale locale) {\n        if (term \u003d\u003d null || query \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        } else if (locale \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Locale must not be null\");\n        }\n\n        // fuzzy logic is case insensitive. We normalize the Strings to lower\n        // case right from the start. Turning characters to lower case\n        // via Character.toLowerCase(char) is unfortunately insufficient\n        // as it does not accept a locale.\n        final String termLowerCase \u003d term.toString().toLowerCase(locale);\n        final String queryLowerCase \u003d query.toString().toLowerCase(locale);\n\n        // the resulting score\n        int score \u003d 0;\n\n        // the position in the term which will be scanned next for potential\n        // query character matches\n        int termIndex \u003d 0;\n\n        // index of the previously matched character in the term\n        int previousMatchingCharacterIndex \u003d Integer.MIN_VALUE;\n\n        for (int queryIndex \u003d 0; queryIndex \u003c queryLowerCase.length(); queryIndex++) {\n            final char queryChar \u003d queryLowerCase.charAt(queryIndex);\n\n            boolean termCharacterMatchFound \u003d false;\n            for (; termIndex \u003c termLowerCase.length() \u0026\u0026 !termCharacterMatchFound; termIndex++) {\n                final char termChar \u003d termLowerCase.charAt(termIndex);\n\n                if (queryChar \u003d\u003d termChar) {\n                    // simple character matches result in one point\n                    score++;\n\n                    // subsequent character matches further improve\n                    // the score.\n                    if (previousMatchingCharacterIndex + 1 \u003d\u003d termIndex) {\n                        score +\u003d 2;\n                    }\n\n                    previousMatchingCharacterIndex \u003d termIndex;\n\n                    // we can leave the nested loop. Every character in the\n                    // query can match at most one character in the term.\n                    termCharacterMatchFound \u003d true;\n                }\n            }\n        }\n\n        return score;\n    }",
    "begin_line": 7551,
    "end_line": 7602,
    "comment": "/** \n * \u003cp\u003eFind the Fuzzy Distance which indicates the similarity score between two Strings.\u003c/p\u003e \u003cp\u003eThis string matching algorithm is similar to the algorithms of editors such as Sublime Text, TextMate, Atom and others. One point is given for every matched character. Subsequent matches yield two bonus points. A higher score indicates a higher similarity.\u003c/p\u003e \u003cpre\u003e StringUtils.getFuzzyDistance(null, null, null)                                    \u003d IllegalArgumentException StringUtils.getFuzzyDistance(\"\", \"\", Locale.ENGLISH)                              \u003d 0 StringUtils.getFuzzyDistance(\"Workshop\", \"b\", Locale.ENGLISH)                     \u003d 0 StringUtils.getFuzzyDistance(\"Room\", \"o\", Locale.ENGLISH)                         \u003d 1 StringUtils.getFuzzyDistance(\"Workshop\", \"w\", Locale.ENGLISH)                     \u003d 1 StringUtils.getFuzzyDistance(\"Workshop\", \"ws\", Locale.ENGLISH)                    \u003d 2 StringUtils.getFuzzyDistance(\"Workshop\", \"wo\", Locale.ENGLISH)                    \u003d 4 StringUtils.getFuzzyDistance(\"Apache Software Foundation\", \"asf\", Locale.ENGLISH) \u003d 3 \u003c/pre\u003e\n * @param term a full term that should be matched against, must not be null\n * @param query the query that will be matched against a term, must not be null\n * @param locale This string matching logic is case insensitive. A locale is necessary to normalizeboth Strings to lower case.\n * @return result score\n * @throws IllegalArgumentException if either String input {@code null} or Locale input {@code null}\n * @since 3.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.getSetOfMatchingCharacterWithin#7615",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.getSetOfMatchingCharacterWithin(java.lang.CharSequence, java.lang.CharSequence, int)",
    "snippet": "private static String getSetOfMatchingCharacterWithin(final CharSequence first, final CharSequence second, final int limit) {\n        final StringBuilder common \u003d new StringBuilder();\n        final StringBuilder copy \u003d new StringBuilder(second);\n\n        for (int i \u003d 0; i \u003c first.length(); i++) {\n            final char ch \u003d first.charAt(i);\n            boolean found \u003d false;\n\n            // See if the character is within the limit positions away from the original position of that character.\n            for (int j \u003d Math.max(0, i - limit); !found \u0026\u0026 j \u003c Math.min(i + limit, second.length()); j++) {\n                if (copy.charAt(j) \u003d\u003d ch) {\n                    found \u003d true;\n                    common.append(ch);\n                    copy.setCharAt(j,\u0027*\u0027);\n                }\n            }\n        }\n        return common.toString();\n    }",
    "begin_line": 7615,
    "end_line": 7633,
    "comment": "/** \n * Gets a set of matching characters between two strings. \u003cp\u003e\u003cTwo characters from the first string and the second string are considered matching if the character\u0027s respective positions are no farther than the limit value.\u003c/p\u003e\n * @param first The first string.\n * @param second The second string.\n * @param limit The maximum distance to consider.\n * @return A string contain the set of common characters.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.transpositions#7641",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.transpositions(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "private static int transpositions(final CharSequence first, final CharSequence second) {\n        int transpositions \u003d 0;\n        for (int i \u003d 0; i \u003c first.length(); i++) {\n            if (first.charAt(i) !\u003d second.charAt(i)) {\n                transpositions++;\n            }\n        }\n        return transpositions / 2;\n    }",
    "begin_line": 7641,
    "end_line": 7649,
    "comment": "/** \n * Calculates the number of transposition between two strings.\n * @param first The first string.\n * @param second The second string.\n * @return The number of transposition between the two strings.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.commonPrefixLength#7658",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.commonPrefixLength(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "private static int commonPrefixLength(final CharSequence first, final CharSequence second) {\n        final int result \u003d getCommonPrefix(first.toString(), second.toString()).length();\n\n        // Limit the result to 4.\n        return result \u003e 4 ? 4 : result;\n    }",
    "begin_line": 7658,
    "end_line": 7663,
    "comment": "/** \n * Calculates the number of characters from the beginning of the strings that match exactly one-to-one,  up to a maximum of four (4) characters.\n * @param first The first string.\n * @param second The second string.\n * @return A number between 0 and 4.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.startsWith#7690",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.startsWith(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean startsWith(final CharSequence str, final CharSequence prefix) {\n        return startsWith(str, prefix, false);\n    }",
    "begin_line": 7690,
    "end_line": 7692,
    "comment": "/** \n * \u003cp\u003eCheck if a CharSequence starts with a specified prefix.\u003c/p\u003e \u003cp\u003e {@code null}s are handled without exceptions. Two  {@code null}references are considered to be equal. The comparison is case sensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.startsWith(null, null)      \u003d true StringUtils.startsWith(null, \"abc\")     \u003d false StringUtils.startsWith(\"abcdef\", null)  \u003d false StringUtils.startsWith(\"abcdef\", \"abc\") \u003d true StringUtils.startsWith(\"ABCDEF\", \"abc\") \u003d false \u003c/pre\u003e\n * @see java.lang.String#startsWith(String)\n * @param str  the CharSequence to check, may be null\n * @param prefix the prefix to find, may be null\n * @return {@code true} if the CharSequence starts with the prefix, case sensitive, orboth  {@code null}\n * @since 2.4\n * @since 3.0 Changed signature from startsWith(String, String) to startsWith(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.startsWithIgnoreCase#7716",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.startsWithIgnoreCase(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {\n        return startsWith(str, prefix, true);\n    }",
    "begin_line": 7716,
    "end_line": 7718,
    "comment": "/** \n * \u003cp\u003eCase insensitive check if a CharSequence starts with a specified prefix.\u003c/p\u003e \u003cp\u003e {@code null}s are handled without exceptions. Two  {@code null}references are considered to be equal. The comparison is case insensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.startsWithIgnoreCase(null, null)      \u003d true StringUtils.startsWithIgnoreCase(null, \"abc\")     \u003d false StringUtils.startsWithIgnoreCase(\"abcdef\", null)  \u003d false StringUtils.startsWithIgnoreCase(\"abcdef\", \"abc\") \u003d true StringUtils.startsWithIgnoreCase(\"ABCDEF\", \"abc\") \u003d true \u003c/pre\u003e\n * @see java.lang.String#startsWith(String)\n * @param str  the CharSequence to check, may be null\n * @param prefix the prefix to find, may be null\n * @return {@code true} if the CharSequence starts with the prefix, case insensitive, orboth  {@code null}\n * @since 2.4\n * @since 3.0 Changed signature from startsWithIgnoreCase(String, String) to startsWithIgnoreCase(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.startsWith#7731",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.startsWith(java.lang.CharSequence, java.lang.CharSequence, boolean)",
    "snippet": "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {\n        if (str \u003d\u003d null || prefix \u003d\u003d null) {\n            return str \u003d\u003d null \u0026\u0026 prefix \u003d\u003d null;\n        }\n        if (prefix.length() \u003e str.length()) {\n            return false;\n        }\n        return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n    }",
    "begin_line": 7731,
    "end_line": 7739,
    "comment": "/** \n * \u003cp\u003eCheck if a CharSequence starts with a specified prefix (optionally case insensitive).\u003c/p\u003e\n * @see java.lang.String#startsWith(String)\n * @param str  the CharSequence to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase indicates whether the compare should ignore case(case insensitive) or not.\n * @return {@code true} if the CharSequence starts with the prefix orboth  {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.startsWithAny#7760",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.startsWithAny(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (final CharSequence searchString : searchStrings) {\n            if (startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "begin_line": 7760,
    "end_line": 7770,
    "comment": "/** \n * \u003cp\u003eCheck if a CharSequence starts with any of an array of specified strings.\u003c/p\u003e \u003cpre\u003e StringUtils.startsWithAny(null, null)      \u003d false StringUtils.startsWithAny(null, new String[] {\"abc\"})  \u003d false StringUtils.startsWithAny(\"abcxyz\", null)     \u003d false StringUtils.startsWithAny(\"abcxyz\", new String[] {\"\"}) \u003d false StringUtils.startsWithAny(\"abcxyz\", new String[] {\"abc\"}) \u003d true StringUtils.startsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) \u003d true \u003c/pre\u003e\n * @param string  the CharSequence to check, may be null\n * @param searchStrings the CharSequences to find, may be null or empty\n * @return {@code true} if the CharSequence starts with any of the the prefixes, case insensitive, orboth  {@code null}\n * @since 2.5\n * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.endsWith#7798",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.endsWith(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean endsWith(final CharSequence str, final CharSequence suffix) {\n        return endsWith(str, suffix, false);\n    }",
    "begin_line": 7798,
    "end_line": 7800,
    "comment": "/** \n * \u003cp\u003eCheck if a CharSequence ends with a specified suffix.\u003c/p\u003e \u003cp\u003e {@code null}s are handled without exceptions. Two  {@code null}references are considered to be equal. The comparison is case sensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.endsWith(null, null)      \u003d true StringUtils.endsWith(null, \"def\")     \u003d false StringUtils.endsWith(\"abcdef\", null)  \u003d false StringUtils.endsWith(\"abcdef\", \"def\") \u003d true StringUtils.endsWith(\"ABCDEF\", \"def\") \u003d false StringUtils.endsWith(\"ABCDEF\", \"cde\") \u003d false \u003c/pre\u003e\n * @see java.lang.String#endsWith(String)\n * @param str  the CharSequence to check, may be null\n * @param suffix the suffix to find, may be null\n * @return {@code true} if the CharSequence ends with the suffix, case sensitive, orboth  {@code null}\n * @since 2.4\n * @since 3.0 Changed signature from endsWith(String, String) to endsWith(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.endsWithIgnoreCase#7825",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.endsWithIgnoreCase(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {\n        return endsWith(str, suffix, true);\n    }",
    "begin_line": 7825,
    "end_line": 7827,
    "comment": "/** \n * \u003cp\u003eCase insensitive check if a CharSequence ends with a specified suffix.\u003c/p\u003e \u003cp\u003e {@code null}s are handled without exceptions. Two  {@code null}references are considered to be equal. The comparison is case insensitive.\u003c/p\u003e \u003cpre\u003e StringUtils.endsWithIgnoreCase(null, null)      \u003d true StringUtils.endsWithIgnoreCase(null, \"def\")     \u003d false StringUtils.endsWithIgnoreCase(\"abcdef\", null)  \u003d false StringUtils.endsWithIgnoreCase(\"abcdef\", \"def\") \u003d true StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"def\") \u003d true StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"cde\") \u003d false \u003c/pre\u003e\n * @see java.lang.String#endsWith(String)\n * @param str  the CharSequence to check, may be null\n * @param suffix the suffix to find, may be null\n * @return {@code true} if the CharSequence ends with the suffix, case insensitive, orboth  {@code null}\n * @since 2.4\n * @since 3.0 Changed signature from endsWithIgnoreCase(String, String) to endsWithIgnoreCase(CharSequence, CharSequence)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.endsWith#7840",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.endsWith(java.lang.CharSequence, java.lang.CharSequence, boolean)",
    "snippet": "private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {\n        if (str \u003d\u003d null || suffix \u003d\u003d null) {\n            return str \u003d\u003d null \u0026\u0026 suffix \u003d\u003d null;\n        }\n        if (suffix.length() \u003e str.length()) {\n            return false;\n        }\n        final int strOffset \u003d str.length() - suffix.length();\n        return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n    }",
    "begin_line": 7840,
    "end_line": 7849,
    "comment": "/** \n * \u003cp\u003eCheck if a CharSequence ends with a specified suffix (optionally case insensitive).\u003c/p\u003e\n * @see java.lang.String#endsWith(String)\n * @param str  the CharSequence to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase indicates whether the compare should ignore case(case insensitive) or not.\n * @return {@code true} if the CharSequence starts with the prefix orboth  {@code null}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.normalizeSpace#7892",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.normalizeSpace(java.lang.String)",
    "snippet": "public static String normalizeSpace(final String str) {\n        // LANG-1020: Improved performance significantly by normalizing manually instead of using regex\n        // See https://github.com/librucha/commons-lang-normalizespaces-benchmark for performance test\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int size \u003d str.length();\n        final char[] newChars \u003d new char[size];\n        int count \u003d 0;\n        int whitespacesCount \u003d 0;\n        boolean startWhitespaces \u003d true;\n        for (int i \u003d 0; i \u003c size; i++) {\n            char actualChar \u003d str.charAt(i);\n            boolean isWhitespace \u003d Character.isWhitespace(actualChar);\n            if (!isWhitespace) {\n                startWhitespaces \u003d false;\n                newChars[count++] \u003d (actualChar \u003d\u003d 160 ? 32 : actualChar);\n                whitespacesCount \u003d 0;\n            } else {\n                if (whitespacesCount \u003d\u003d 0 \u0026\u0026 !startWhitespaces) {\n                    newChars[count++] \u003d SPACE.charAt(0);\n                }\n                whitespacesCount++;\n            }\n        }\n        if (startWhitespaces) {\n            return EMPTY;\n        }\n        return new String(newChars, 0, count - (whitespacesCount \u003e 0 ? 1 : 0));\n    }",
    "begin_line": 7892,
    "end_line": 7921,
    "comment": "/** \n * \u003cp\u003e Similar to \u003ca href\u003d\"http://www.w3.org/TR/xpath/#function-normalize-space\"\u003ehttp://www.w3.org/TR/xpath/#function-normalize -space\u003c/a\u003e \u003c/p\u003e \u003cp\u003e The function returns the argument string with whitespace normalized by using \u003ccode\u003e {@link #trim(String)}\u003c/code\u003e to remove leading and trailing whitespace and then replacing sequences of whitespace characters by a single space. \u003c/p\u003e In XML Whitespace characters are the same as those allowed by the \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#NT-S\"\u003eS\u003c/a\u003e production, which is S ::\u003d (#x20 | #x9 | #xD | #xA)+ \u003cp\u003e Java\u0027s regexp pattern \\s defines whitespace as [ \\t\\n\\x0B\\f\\r] \u003cp\u003eFor reference:\u003c/p\u003e \u003cul\u003e \u003cli\u003e\\x0B \u003d vertical tab\u003c/li\u003e \u003cli\u003e\\f \u003d #xC \u003d form feed\u003c/li\u003e \u003cli\u003e#x20 \u003d space\u003c/li\u003e \u003cli\u003e#x9 \u003d \\t\u003c/li\u003e \u003cli\u003e#xA \u003d \\n\u003c/li\u003e \u003cli\u003e#xD \u003d \\r\u003c/li\u003e \u003c/ul\u003e \u003cp\u003e The difference is that Java\u0027s whitespace includes vertical tab and form feed, which this functional will also normalize. Additionally \u003ccode\u003e {@link #trim(String)}\u003c/code\u003e removes control characters (char \u0026lt;\u003d 32) from both ends of this String. \u003c/p\u003e\n * @see Pattern\n * @see #trim(String)\n * @see \u003ca\n     *      href\u003d\"http://www.w3.org/TR/xpath/#function-normalize-space\"\u003ehttp://www.w3.org/TR/xpath/#function-normalize-space\u003c/a\u003e\n * @param str the source String to normalize whitespaces from, may be null\n * @return the modified string with whitespace normalized, {@code null} if null String input\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.endsWithAny#7941",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.endsWithAny(java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (final CharSequence searchString : searchStrings) {\n            if (endsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "begin_line": 7941,
    "end_line": 7951,
    "comment": "/** \n * \u003cp\u003eCheck if a CharSequence ends with any of an array of specified strings.\u003c/p\u003e \u003cpre\u003e StringUtils.endsWithAny(null, null)      \u003d false StringUtils.endsWithAny(null, new String[] {\"abc\"})  \u003d false StringUtils.endsWithAny(\"abcxyz\", null)     \u003d false StringUtils.endsWithAny(\"abcxyz\", new String[] {\"\"}) \u003d true StringUtils.endsWithAny(\"abcxyz\", new String[] {\"xyz\"}) \u003d true StringUtils.endsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) \u003d true \u003c/pre\u003e\n * @param string  the CharSequence to check, may be null\n * @param searchStrings the CharSequences to find, may be null or empty\n * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, orboth  {@code null}\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.appendIfMissing#7964",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.appendIfMissing(java.lang.String, java.lang.CharSequence, boolean, java.lang.CharSequence)",
    "snippet": "private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) {\n        if (str \u003d\u003d null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) {\n            return str;\n        }\n        if (suffixes !\u003d null \u0026\u0026 suffixes.length \u003e 0) {\n            for (final CharSequence s : suffixes) {\n                if (endsWith(str, s, ignoreCase)) {\n                    return str;\n                }\n            }\n        }\n        return str + suffix.toString();\n    }",
    "begin_line": 7964,
    "end_line": 7976,
    "comment": "/** \n * Appends the suffix to the end of the string if the string does not already end in the suffix.\n * @param str The string.\n * @param suffix The suffix to append to the end of the string.\n * @param ignoreCase Indicates whether the compare should ignore case.\n * @param suffixes Additional suffixes that are valid terminators (optional).\n * @return A new String if suffix was appened, the same string otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.appendIfMissing#8012",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.appendIfMissing(java.lang.String, java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {\n        return appendIfMissing(str, suffix, false, suffixes);\n    }",
    "begin_line": 8012,
    "end_line": 8014,
    "comment": "/** \n * Appends the suffix to the end of the string if the string does not already end with any the suffixes. \u003cpre\u003e StringUtils.appendIfMissing(null, null) \u003d null StringUtils.appendIfMissing(\"abc\", null) \u003d \"abc\" StringUtils.appendIfMissing(\"\", \"xyz\") \u003d \"xyz\" StringUtils.appendIfMissing(\"abc\", \"xyz\") \u003d \"abcxyz\" StringUtils.appendIfMissing(\"abcxyz\", \"xyz\") \u003d \"abcxyz\" StringUtils.appendIfMissing(\"abcXYZ\", \"xyz\") \u003d \"abcXYZxyz\" \u003c/pre\u003e \u003cp\u003eWith additional suffixes,\u003c/p\u003e \u003cpre\u003e StringUtils.appendIfMissing(null, null, null) \u003d null StringUtils.appendIfMissing(\"abc\", null, null) \u003d \"abc\" StringUtils.appendIfMissing(\"\", \"xyz\", null) \u003d \"xyz\" StringUtils.appendIfMissing(\"abc\", \"xyz\", new CharSequence[]{null}) \u003d \"abcxyz\" StringUtils.appendIfMissing(\"abc\", \"xyz\", \"\") \u003d \"abc\" StringUtils.appendIfMissing(\"abc\", \"xyz\", \"mno\") \u003d \"abcxyz\" StringUtils.appendIfMissing(\"abcxyz\", \"xyz\", \"mno\") \u003d \"abcxyz\" StringUtils.appendIfMissing(\"abcmno\", \"xyz\", \"mno\") \u003d \"abcmno\" StringUtils.appendIfMissing(\"abcXYZ\", \"xyz\", \"mno\") \u003d \"abcXYZxyz\" StringUtils.appendIfMissing(\"abcMNO\", \"xyz\", \"mno\") \u003d \"abcMNOxyz\" \u003c/pre\u003e\n * @param str The string.\n * @param suffix The suffix to append to the end of the string.\n * @param suffixes Additional suffixes that are valid terminators.\n * @return A new String if suffix was appened, the same string otherwise.\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.appendIfMissingIgnoreCase#8050",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.appendIfMissingIgnoreCase(java.lang.String, java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {\n        return appendIfMissing(str, suffix, true, suffixes);\n    }",
    "begin_line": 8050,
    "end_line": 8052,
    "comment": "/** \n * Appends the suffix to the end of the string if the string does not already end, case insensitive, with any of the suffixes. \u003cpre\u003e StringUtils.appendIfMissingIgnoreCase(null, null) \u003d null StringUtils.appendIfMissingIgnoreCase(\"abc\", null) \u003d \"abc\" StringUtils.appendIfMissingIgnoreCase(\"\", \"xyz\") \u003d \"xyz\" StringUtils.appendIfMissingIgnoreCase(\"abc\", \"xyz\") \u003d \"abcxyz\" StringUtils.appendIfMissingIgnoreCase(\"abcxyz\", \"xyz\") \u003d \"abcxyz\" StringUtils.appendIfMissingIgnoreCase(\"abcXYZ\", \"xyz\") \u003d \"abcXYZ\" \u003c/pre\u003e \u003cp\u003eWith additional suffixes,\u003c/p\u003e \u003cpre\u003e StringUtils.appendIfMissingIgnoreCase(null, null, null) \u003d null StringUtils.appendIfMissingIgnoreCase(\"abc\", null, null) \u003d \"abc\" StringUtils.appendIfMissingIgnoreCase(\"\", \"xyz\", null) \u003d \"xyz\" StringUtils.appendIfMissingIgnoreCase(\"abc\", \"xyz\", new CharSequence[]{null}) \u003d \"abcxyz\" StringUtils.appendIfMissingIgnoreCase(\"abc\", \"xyz\", \"\") \u003d \"abc\" StringUtils.appendIfMissingIgnoreCase(\"abc\", \"xyz\", \"mno\") \u003d \"axyz\" StringUtils.appendIfMissingIgnoreCase(\"abcxyz\", \"xyz\", \"mno\") \u003d \"abcxyz\" StringUtils.appendIfMissingIgnoreCase(\"abcmno\", \"xyz\", \"mno\") \u003d \"abcmno\" StringUtils.appendIfMissingIgnoreCase(\"abcXYZ\", \"xyz\", \"mno\") \u003d \"abcXYZ\" StringUtils.appendIfMissingIgnoreCase(\"abcMNO\", \"xyz\", \"mno\") \u003d \"abcMNO\" \u003c/pre\u003e\n * @param str The string.\n * @param suffix The suffix to append to the end of the string.\n * @param suffixes Additional suffixes that are valid terminators.\n * @return A new String if suffix was appened, the same string otherwise.\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.prependIfMissing#8065",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.prependIfMissing(java.lang.String, java.lang.CharSequence, boolean, java.lang.CharSequence)",
    "snippet": "private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) {\n        if (str \u003d\u003d null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) {\n            return str;\n        }\n        if (prefixes !\u003d null \u0026\u0026 prefixes.length \u003e 0) {\n            for (final CharSequence p : prefixes) {\n                if (startsWith(str, p, ignoreCase)) {\n                    return str;\n                }\n            }\n        }\n        return prefix.toString() + str;\n    }",
    "begin_line": 8065,
    "end_line": 8077,
    "comment": "/** \n * Prepends the prefix to the start of the string if the string does not already start with any of the prefixes.\n * @param str The string.\n * @param prefix The prefix to prepend to the start of the string.\n * @param ignoreCase Indicates whether the compare should ignore case.\n * @param prefixes Additional prefixes that are valid (optional).\n * @return A new String if prefix was prepended, the same string otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.prependIfMissing#8113",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.prependIfMissing(java.lang.String, java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {\n        return prependIfMissing(str, prefix, false, prefixes);\n    }",
    "begin_line": 8113,
    "end_line": 8115,
    "comment": "/** \n * Prepends the prefix to the start of the string if the string does not already start with any of the prefixes. \u003cpre\u003e StringUtils.prependIfMissing(null, null) \u003d null StringUtils.prependIfMissing(\"abc\", null) \u003d \"abc\" StringUtils.prependIfMissing(\"\", \"xyz\") \u003d \"xyz\" StringUtils.prependIfMissing(\"abc\", \"xyz\") \u003d \"xyzabc\" StringUtils.prependIfMissing(\"xyzabc\", \"xyz\") \u003d \"xyzabc\" StringUtils.prependIfMissing(\"XYZabc\", \"xyz\") \u003d \"xyzXYZabc\" \u003c/pre\u003e \u003cp\u003eWith additional prefixes,\u003c/p\u003e \u003cpre\u003e StringUtils.prependIfMissing(null, null, null) \u003d null StringUtils.prependIfMissing(\"abc\", null, null) \u003d \"abc\" StringUtils.prependIfMissing(\"\", \"xyz\", null) \u003d \"xyz\" StringUtils.prependIfMissing(\"abc\", \"xyz\", new CharSequence[]{null}) \u003d \"xyzabc\" StringUtils.prependIfMissing(\"abc\", \"xyz\", \"\") \u003d \"abc\" StringUtils.prependIfMissing(\"abc\", \"xyz\", \"mno\") \u003d \"xyzabc\" StringUtils.prependIfMissing(\"xyzabc\", \"xyz\", \"mno\") \u003d \"xyzabc\" StringUtils.prependIfMissing(\"mnoabc\", \"xyz\", \"mno\") \u003d \"mnoabc\" StringUtils.prependIfMissing(\"XYZabc\", \"xyz\", \"mno\") \u003d \"xyzXYZabc\" StringUtils.prependIfMissing(\"MNOabc\", \"xyz\", \"mno\") \u003d \"xyzMNOabc\" \u003c/pre\u003e\n * @param str The string.\n * @param prefix The prefix to prepend to the start of the string.\n * @param prefixes Additional prefixes that are valid.\n * @return A new String if prefix was prepended, the same string otherwise.\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.prependIfMissingIgnoreCase#8151",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.prependIfMissingIgnoreCase(java.lang.String, java.lang.CharSequence, java.lang.CharSequence)",
    "snippet": "public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {\n        return prependIfMissing(str, prefix, true, prefixes);\n    }",
    "begin_line": 8151,
    "end_line": 8153,
    "comment": "/** \n * Prepends the prefix to the start of the string if the string does not already start, case insensitive, with any of the prefixes. \u003cpre\u003e StringUtils.prependIfMissingIgnoreCase(null, null) \u003d null StringUtils.prependIfMissingIgnoreCase(\"abc\", null) \u003d \"abc\" StringUtils.prependIfMissingIgnoreCase(\"\", \"xyz\") \u003d \"xyz\" StringUtils.prependIfMissingIgnoreCase(\"abc\", \"xyz\") \u003d \"xyzabc\" StringUtils.prependIfMissingIgnoreCase(\"xyzabc\", \"xyz\") \u003d \"xyzabc\" StringUtils.prependIfMissingIgnoreCase(\"XYZabc\", \"xyz\") \u003d \"XYZabc\" \u003c/pre\u003e \u003cp\u003eWith additional prefixes,\u003c/p\u003e \u003cpre\u003e StringUtils.prependIfMissingIgnoreCase(null, null, null) \u003d null StringUtils.prependIfMissingIgnoreCase(\"abc\", null, null) \u003d \"abc\" StringUtils.prependIfMissingIgnoreCase(\"\", \"xyz\", null) \u003d \"xyz\" StringUtils.prependIfMissingIgnoreCase(\"abc\", \"xyz\", new CharSequence[]{null}) \u003d \"xyzabc\" StringUtils.prependIfMissingIgnoreCase(\"abc\", \"xyz\", \"\") \u003d \"abc\" StringUtils.prependIfMissingIgnoreCase(\"abc\", \"xyz\", \"mno\") \u003d \"xyzabc\" StringUtils.prependIfMissingIgnoreCase(\"xyzabc\", \"xyz\", \"mno\") \u003d \"xyzabc\" StringUtils.prependIfMissingIgnoreCase(\"mnoabc\", \"xyz\", \"mno\") \u003d \"mnoabc\" StringUtils.prependIfMissingIgnoreCase(\"XYZabc\", \"xyz\", \"mno\") \u003d \"XYZabc\" StringUtils.prependIfMissingIgnoreCase(\"MNOabc\", \"xyz\", \"mno\") \u003d \"MNOabc\" \u003c/pre\u003e\n * @param str The string.\n * @param prefix The prefix to prepend to the start of the string.\n * @param prefixes Additional prefixes that are valid (optional).\n * @return A new String if prefix was prepended, the same string otherwise.\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.toString#8171",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.toString(byte[], java.lang.String)",
    "snippet": "@Deprecated\n    public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {\n        return charsetName !\u003d null ? new String(bytes, charsetName) : new String(bytes, Charset.defaultCharset());\n    }",
    "begin_line": 8171,
    "end_line": 8173,
    "comment": "/** \n * Converts a \u003ccode\u003ebyte[]\u003c/code\u003e to a String using the specified character encoding.\n * @param bytes the byte array to read from\n * @param charsetName the encoding to use, if null then use the platform default\n * @return a new String\n * @throws UnsupportedEncodingException If the named charset is not supported\n * @throws NullPointerException if the input is null\n * @deprecated use {@link StringUtils#toEncodedString(byte[],Charset)} instead of String constants in your code\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.toEncodedString#8188",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.toEncodedString(byte[], java.nio.charset.Charset)",
    "snippet": "public static String toEncodedString(final byte[] bytes, final Charset charset) {\n        return new String(bytes, charset !\u003d null ? charset : Charset.defaultCharset());\n    }",
    "begin_line": 8188,
    "end_line": 8190,
    "comment": "/** \n * Converts a \u003ccode\u003ebyte[]\u003c/code\u003e to a String using the specified character encoding.\n * @param bytes the byte array to read from\n * @param charset the encoding to use, if null then use the platform default\n * @return a new String\n * @throws NullPointerException if  {@code bytes} is null\n * @since 3.2\n * @since 3.3 No longer throws {@link UnsupportedEncodingException}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.wrap#8213",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.wrap(java.lang.String, char)",
    "snippet": "public static String wrap(final String str, final char wrapWith) {\n\n        if (isEmpty(str) || wrapWith \u003d\u003d \u0027\\0\u0027) {\n            return str;\n        }\n\n        return wrapWith + str + wrapWith;\n    }",
    "begin_line": 8213,
    "end_line": 8220,
    "comment": "/** \n * \u003cp\u003e Wraps a string with a char. \u003c/p\u003e \u003cpre\u003e StringUtils.wrap(null, *)        \u003d null StringUtils.wrap(\"\", *)          \u003d \"\" StringUtils.wrap(\"ab\", \u0027\\0\u0027)     \u003d \"ab\" StringUtils.wrap(\"ab\", \u0027x\u0027)      \u003d \"xabx\" StringUtils.wrap(\"ab\", \u0027\\\u0027\u0027)     \u003d \"\u0027ab\u0027\" StringUtils.wrap(\"\\\"ab\\\"\", \u0027\\\"\u0027) \u003d \"\\\"\\\"ab\\\"\\\"\" \u003c/pre\u003e\n * @param str the string to be wrapped, may be  {@code null}\n * @param wrapWith the char that will wrap  {@code str}\n * @return the wrapped string, or {@code null} if {@code str\u003d\u003dnull}\n * @since 3.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringUtils.wrap#8251",
    "is_bug": true,
    "src_path": "org/apache/commons/lang3/StringUtils.java",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.wrap(java.lang.String, java.lang.String)",
    "snippet": "public static String wrap(final String str, final String wrapWith) {\n\n        if (isEmpty(str) || isEmpty(wrapWith)) {\n            return str;\n        }\n\n        return wrapWith.concat(str).concat(wrapWith);\n    }",
    "begin_line": 8251,
    "end_line": 8258,
    "comment": "/** \n * \u003cp\u003e Wraps a String with another String. \u003c/p\u003e \u003cp\u003e A  {@code null} input String returns {@code null}. \u003c/p\u003e \u003cpre\u003e StringUtils.wrap(null, *)         \u003d null StringUtils.wrap(\"\", *)           \u003d \"\" StringUtils.wrap(\"ab\", null)      \u003d \"ab\" StringUtils.wrap(\"ab\", \"x\")       \u003d \"xabx\" StringUtils.wrap(\"ab\", \"\\\"\")      \u003d \"\\\"ab\\\"\" StringUtils.wrap(\"\\\"ab\\\"\", \"\\\"\")  \u003d \"\\\"\\\"ab\\\"\\\"\" StringUtils.wrap(\"ab\", \"\u0027\")       \u003d \"\u0027ab\u0027\" StringUtils.wrap(\"\u0027abcd\u0027\", \"\u0027\")   \u003d \"\u0027\u0027abcd\u0027\u0027\" StringUtils.wrap(\"\\\"abcd\\\"\", \"\u0027\") \u003d \"\u0027\\\"abcd\\\"\u0027\" StringUtils.wrap(\"\u0027abcd\u0027\", \"\\\"\")  \u003d \"\\\"\u0027abcd\u0027\\\"\" \u003c/pre\u003e\n * @param str the String to be wrapper, may be null\n * @param wrapWith the String that will wrap str\n * @return wrapped String, {@code null} if null String input\n * @since 3.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]