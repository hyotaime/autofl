[
  {
    "name": "IOUtils.buffer#190",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.InputStream)",
    "snippet": "public static BufferedInputStream buffer(final InputStream inputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);\n    }",
    "begin_line": 190,
    "end_line": 196,
    "comment": "/** \n * Returns the given InputStream if it is already a  {@link BufferedInputStream}, otherwise creates a BufferedInputStream from the given InputStream.\n * @param inputStream the InputStream to wrap or return (not null)\n * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#208",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.InputStream, int)",
    "snippet": "public static BufferedInputStream buffer(final InputStream inputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream, size);\n    }",
    "begin_line": 208,
    "end_line": 214,
    "comment": "/** \n * Returns the given InputStream if it is already a  {@link BufferedInputStream}, otherwise creates a BufferedInputStream from the given InputStream.\n * @param inputStream the InputStream to wrap or return (not null)\n * @param size the buffer size, if a new BufferedInputStream is created.\n * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#225",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.OutputStream)",
    "snippet": "public static BufferedOutputStream buffer(final OutputStream outputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream);\n    }",
    "begin_line": 225,
    "end_line": 231,
    "comment": "/** \n * Returns the given OutputStream if it is already a  {@link BufferedOutputStream}, otherwise creates a BufferedOutputStream from the given OutputStream.\n * @param outputStream the OutputStream to wrap or return (not null)\n * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#243",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.OutputStream, int)",
    "snippet": "public static BufferedOutputStream buffer(final OutputStream outputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream, size);\n    }",
    "begin_line": 243,
    "end_line": 249,
    "comment": "/** \n * Returns the given OutputStream if it is already a  {@link BufferedOutputStream}, otherwise creates a BufferedOutputStream from the given OutputStream.\n * @param outputStream the OutputStream to wrap or return (not null)\n * @param size the buffer size, if a new BufferedOutputStream is created.\n * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#260",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Reader)",
    "snippet": "public static BufferedReader buffer(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }",
    "begin_line": 260,
    "end_line": 262,
    "comment": "/** \n * Returns the given reader if it is already a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#274",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Reader, int)",
    "snippet": "public static BufferedReader buffer(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }",
    "begin_line": 274,
    "end_line": 276,
    "comment": "/** \n * Returns the given reader if it is already a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @param size the buffer size, if a new BufferedReader is created.\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#287",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Writer)",
    "snippet": "public static BufferedWriter buffer(final Writer writer) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer);\n    }",
    "begin_line": 287,
    "end_line": 289,
    "comment": "/** \n * Returns the given Writer if it is already a  {@link BufferedWriter}, otherwise creates a BufferedWriter from the given Writer.\n * @param writer the Writer to wrap or return (not null)\n * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.buffer#301",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.buffer(java.io.Writer, int)",
    "snippet": "public static BufferedWriter buffer(final Writer writer, final int size) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer, size);\n    }",
    "begin_line": 301,
    "end_line": 303,
    "comment": "/** \n * Returns the given Writer if it is already a  {@link BufferedWriter}, otherwise creates a BufferedWriter from the given Writer.\n * @param writer the Writer to wrap or return (not null)\n * @param size the buffer size, if a new BufferedWriter is created.\n * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n * @throws NullPointerException if the input parameter is null\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#312",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.io.Closeable)",
    "snippet": "public static void close(final Closeable closeable) throws IOException {\n        if (closeable !\u003d null) {\n            closeable.close();\n        }\n    }",
    "begin_line": 312,
    "end_line": 316,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation.\n * @param closeable The resource to close, may be null.\n * @throws IOException if an I/O error occurs.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#325",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.io.Closeable)",
    "snippet": "public static void close(final Closeable... closeables) throws IOException {\n        if (closeables !\u003d null) {\n            for (final Closeable closeable : closeables) {\n                close(closeable);\n            }\n        }\n    }",
    "begin_line": 325,
    "end_line": 331,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation.\n * @param closeables The resource(s) to close, may be null.\n * @throws IOException if an I/O error occurs.\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#341",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.io.Closeable, org.apache.commons.io.function.IOConsumer\u003cjava.io.IOException\u003e)",
    "snippet": "public static void close(final Closeable closeable, final IOConsumer\u003cIOException\u003e consumer) throws IOException {\n        if (closeable !\u003d null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer !\u003d null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }",
    "begin_line": 341,
    "end_line": 351,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation.\n * @param closeable The resource to close, may be null.\n * @param consumer Consume the IOException thrown by {@link Closeable#close()}.\n * @throws IOException if an I/O error occurs.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.close#359",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.close(java.net.URLConnection)",
    "snippet": "public static void close(final URLConnection conn) {\n        if (conn instanceof HttpURLConnection) {\n            ((HttpURLConnection) conn).disconnect();\n        }\n    }",
    "begin_line": 359,
    "end_line": 363,
    "comment": "/** \n * Closes a URLConnection.\n * @param conn the connection to close.\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#405",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Closeable)",
    "snippet": "@Deprecated\n    public static void closeQuietly(final Closeable closeable) {\n        closeQuietly(closeable, (Consumer\u003cIOException\u003e) null);\n    }",
    "begin_line": 405,
    "end_line": 407,
    "comment": "/** \n * Closes a \u003ccode\u003eCloseable\u003c/code\u003e unconditionally. \u003cp\u003e Equivalent to  {@link Closeable#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Closeable closeable \u003d null; try { closeable \u003d new FileReader(\u0026quot;foo.txt\u0026quot;); // process closeable closeable.close(); } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(closeable); } \u003c/pre\u003e \u003cp\u003e Closing all streams: \u003c/p\u003e \u003cpre\u003e try { return IOUtils.copy(inputStream, outputStream); } finally { IOUtils.closeQuietly(inputStream); IOUtils.closeQuietly(outputStream); } \u003c/pre\u003e\n * @param closeable the objects to close, may be null or already closed\n * @since 2.0\n * @deprecated As of 2.6 deprecated without replacement. Please use the try-with-resources statement or handlesuppressed exceptions manually.\n * @see Throwable#addSuppressed(java.lang.Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#457",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Closeable)",
    "snippet": "@Deprecated\n    public static void closeQuietly(final Closeable... closeables) {\n        if (closeables \u003d\u003d null) {\n            return;\n        }\n        for (final Closeable closeable : closeables) {\n            closeQuietly(closeable);\n        }\n    }",
    "begin_line": 457,
    "end_line": 464,
    "comment": "/** \n * Closes a \u003ccode\u003eCloseable\u003c/code\u003e unconditionally. \u003cp\u003e Equivalent to  {@link Closeable#close()}, except any exceptions will be ignored. \u003cp\u003e This is typically used in finally blocks to ensure that the closeable is closed even if an Exception was thrown before the normal close statement was reached. \u003cbr\u003e \u003cb\u003eIt should not be used to replace the close statement(s) which should be present for the non-exceptional case.\u003c/b\u003e \u003cbr\u003e It is only intended to simplify tidying up where normal processing has already failed and reporting close failure as well is not necessary or useful. \u003cp\u003e Example code: \u003c/p\u003e \u003cpre\u003e Closeable closeable \u003d null; try { closeable \u003d new FileReader(\u0026quot;foo.txt\u0026quot;); // processing using the closeable; may throw an Exception closeable.close(); // Normal close - exceptions not ignored } catch (Exception e) { // error handling } finally { \u003cb\u003eIOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception\u003c/b\u003e } \u003c/pre\u003e \u003cp\u003e Closing all streams: \u003cbr\u003e \u003cpre\u003e try { return IOUtils.copy(inputStream, outputStream); } finally { IOUtils.closeQuietly(inputStream, outputStream); } \u003c/pre\u003e\n * @param closeables the objects to close, may be null or already closed\n * @see #closeQuietly(Closeable)\n * @since 2.5\n * @deprecated As of 2.6 deprecated without replacement. Please use the try-with-resources statement or handlesuppressed exceptions manually.\n * @see Throwable#addSuppressed(java.lang.Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#473",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Closeable, java.util.function.Consumer\u003cjava.io.IOException\u003e)",
    "snippet": "public static void closeQuietly(final Closeable closeable, final Consumer\u003cIOException\u003e consumer) {\n        if (closeable !\u003d null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer !\u003d null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }",
    "begin_line": 473,
    "end_line": 483,
    "comment": "/** \n * Closes the given  {@link Closeable} as a null-safe operation while consuming IOException by the given {@code consumer}.\n * @param closeable The resource to close, may be null.\n * @param consumer Consumes the IOException thrown by {@link Closeable#close()}.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#513",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static void closeQuietly(final InputStream input) {\n        closeQuietly((Closeable) input);\n    }",
    "begin_line": 513,
    "end_line": 515,
    "comment": "/** \n * Closes an \u003ccode\u003eInputStream\u003c/code\u003e unconditionally. \u003cp\u003e Equivalent to  {@link InputStream#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003cpre\u003e byte[] data \u003d new byte[1024]; InputStream in \u003d null; try { in \u003d new FileInputStream(\"foo.txt\"); in.read(data); in.close(); //close errors are handled } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(in); } \u003c/pre\u003e\n * @param input the InputStream to close, may be null or already closed\n * @deprecated As of 2.6 deprecated without replacement. Please use the try-with-resources statement or handlesuppressed exceptions manually.\n * @see Throwable#addSuppressed(java.lang.Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#546",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void closeQuietly(final OutputStream output) {\n        closeQuietly((Closeable) output);\n    }",
    "begin_line": 546,
    "end_line": 548,
    "comment": "/** \n * Closes an \u003ccode\u003eOutputStream\u003c/code\u003e unconditionally. \u003cp\u003e Equivalent to  {@link OutputStream#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003cpre\u003e byte[] data \u003d \"Hello, World\".getBytes(); OutputStream out \u003d null; try { out \u003d new FileOutputStream(\"foo.txt\"); out.write(data); out.close(); //close errors are handled } catch (IOException e) { // error handling } finally { IOUtils.closeQuietly(out); } \u003c/pre\u003e\n * @param output the OutputStream to close, may be null or already closed\n * @deprecated As of 2.6 deprecated without replacement. Please use the try-with-resources statement or handlesuppressed exceptions manually.\n * @see Throwable#addSuppressed(java.lang.Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#578",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Reader)",
    "snippet": "@Deprecated\n    public static void closeQuietly(final Reader input) {\n        closeQuietly((Closeable) input);\n    }",
    "begin_line": 578,
    "end_line": 580,
    "comment": "/** \n * Closes an \u003ccode\u003eReader\u003c/code\u003e unconditionally. \u003cp\u003e Equivalent to  {@link Reader#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003cpre\u003e char[] data \u003d new char[1024]; Reader in \u003d null; try { in \u003d new FileReader(\"foo.txt\"); in.read(data); in.close(); //close errors are handled } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(in); } \u003c/pre\u003e\n * @param input the Reader to close, may be null or already closed\n * @deprecated As of 2.6 deprecated without replacement. Please use the try-with-resources statement or handlesuppressed exceptions manually.\n * @see Throwable#addSuppressed(java.lang.Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#610",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.nio.channels.Selector)",
    "snippet": "@Deprecated\n    public static void closeQuietly(final Selector selector) {\n        closeQuietly((Closeable) selector);\n    }",
    "begin_line": 610,
    "end_line": 612,
    "comment": "/** \n * Closes a \u003ccode\u003eSelector\u003c/code\u003e unconditionally. \u003cp\u003e Equivalent to  {@link Selector#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003cpre\u003e Selector selector \u003d null; try { selector \u003d Selector.open(); // process socket } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(selector); } \u003c/pre\u003e\n * @param selector the Selector to close, may be null or already closed\n * @since 2.2\n * @deprecated As of 2.6 deprecated without replacement. Please use the try-with-resources statement or handlesuppressed exceptions manually.\n * @see Throwable#addSuppressed(java.lang.Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#642",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.net.ServerSocket)",
    "snippet": "@Deprecated\n    public static void closeQuietly(final ServerSocket serverSocket) {\n        closeQuietly((Closeable) serverSocket);\n    }",
    "begin_line": 642,
    "end_line": 644,
    "comment": "/** \n * Closes a \u003ccode\u003eServerSocket\u003c/code\u003e unconditionally. \u003cp\u003e Equivalent to  {@link ServerSocket#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003cpre\u003e ServerSocket socket \u003d null; try { socket \u003d new ServerSocket(); // process socket socket.close(); } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(socket); } \u003c/pre\u003e\n * @param serverSocket the ServerSocket to close, may be null or already closed\n * @since 2.2\n * @deprecated As of 2.6 deprecated without replacement. Please use the try-with-resources statement or handlesuppressed exceptions manually.\n * @see Throwable#addSuppressed(java.lang.Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#674",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.net.Socket)",
    "snippet": "@Deprecated\n    public static void closeQuietly(final Socket socket) {\n        closeQuietly((Closeable) socket);\n    }",
    "begin_line": 674,
    "end_line": 676,
    "comment": "/** \n * Closes a \u003ccode\u003eSocket\u003c/code\u003e unconditionally. \u003cp\u003e Equivalent to  {@link Socket#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003cpre\u003e Socket socket \u003d null; try { socket \u003d new Socket(\"http://www.foo.com/\", 80); // process socket socket.close(); } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(socket); } \u003c/pre\u003e\n * @param socket the Socket to close, may be null or already closed\n * @since 2.0\n * @deprecated As of 2.6 deprecated without replacement. Please use the try-with-resources statement or handlesuppressed exceptions manually.\n * @see Throwable#addSuppressed(java.lang.Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.closeQuietly#705",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.closeQuietly(java.io.Writer)",
    "snippet": "@Deprecated\n    public static void closeQuietly(final Writer output) {\n        closeQuietly((Closeable) output);\n    }",
    "begin_line": 705,
    "end_line": 707,
    "comment": "/** \n * Closes an \u003ccode\u003eWriter\u003c/code\u003e unconditionally. \u003cp\u003e Equivalent to  {@link Writer#close()}, except any exceptions will be ignored. This is typically used in finally blocks. \u003cp\u003e Example code: \u003cpre\u003e Writer out \u003d null; try { out \u003d new StringWriter(); out.write(\"Hello World\"); out.close(); //close errors are handled } catch (Exception e) { // error handling } finally { IOUtils.closeQuietly(out); } \u003c/pre\u003e\n * @param output the Writer to close, may be null or already closed\n * @deprecated As of 2.6 deprecated without replacement. Please use the try-with-resources statement or handlesuppressed exceptions manually.\n * @see Throwable#addSuppressed(java.lang.Throwable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.consume#721",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.consume(java.io.InputStream)",
    "snippet": "public static long consume(final InputStream input)\n            throws IOException {\n        return copyLarge(input, NullOutputStream.NULL_OUTPUT_STREAM);\n    }",
    "begin_line": 721,
    "end_line": 724,
    "comment": "/** \n * Consumes bytes from a \u003ccode\u003eInputStream\u003c/code\u003e and ignores them. \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}. \u003c/p\u003e\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.8.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#742",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.io.InputStream, java.io.InputStream)",
    "snippet": "@SuppressWarnings(\"resource\")\n    public static boolean contentEquals(final InputStream input1, final InputStream input2)\n            throws IOException {\n        if (input1 \u003d\u003d input2) {\n            return true;\n        }\n        if (input1 \u003d\u003d null ^ input2 \u003d\u003d null) {\n            return false;\n        }\n        final BufferedInputStream bufferedInput1 \u003d buffer(input1);\n        final BufferedInputStream bufferedInput2 \u003d buffer(input2);\n        int ch \u003d bufferedInput1.read();\n        while (EOF !\u003d ch) {\n            final int ch2 \u003d bufferedInput2.read();\n            if (ch !\u003d ch2) {\n                return false;\n            }\n            ch \u003d bufferedInput1.read();\n        }\n        return bufferedInput2.read() \u003d\u003d EOF;\n    }",
    "begin_line": 742,
    "end_line": 761,
    "comment": "/** \n * Compares the contents of two Streams to determine if they are equal or not. \u003cp\u003e This method buffers the input internally using \u003ccode\u003eBufferedInputStream\u003c/code\u003e if they are not already buffered. \u003c/p\u003e\n * @param input1 the first stream\n * @param input2 the second stream\n * @return true if the content of the streams are equal or they both don\u0027texist, false otherwise\n * @throws NullPointerException if either input is null\n * @throws IOException          if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEquals#780",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEquals(java.io.Reader, java.io.Reader)",
    "snippet": "@SuppressWarnings(\"resource\")\n    public static boolean contentEquals(final Reader input1, final Reader input2)\n            throws IOException {\n        if (input1 \u003d\u003d input2) {\n            return true;\n        }\n        if (input1 \u003d\u003d null ^ input2 \u003d\u003d null) {\n            return false;\n        }\n        final BufferedReader bufferedInput1 \u003d toBufferedReader(input1);\n        final BufferedReader bufferedInput2 \u003d toBufferedReader(input2);\n\n        int ch \u003d bufferedInput1.read();\n        while (EOF !\u003d ch) {\n            final int ch2 \u003d bufferedInput2.read();\n            if (ch !\u003d ch2) {\n                return false;\n            }\n            ch \u003d bufferedInput1.read();\n        }\n\n        return bufferedInput2.read() \u003d\u003d EOF;\n    }",
    "begin_line": 780,
    "end_line": 801,
    "comment": "/** \n * Compares the contents of two Readers to determine if they are equal or not. \u003cp\u003e This method buffers the input internally using \u003ccode\u003eBufferedReader\u003c/code\u003e if they are not already buffered. \u003c/p\u003e\n * @param input1 the first reader\n * @param input2 the second reader\n * @return true if the content of the readers are equal or they both don\u0027texist, false otherwise\n * @throws NullPointerException if either input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.contentEqualsIgnoreEOL#818",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.contentEqualsIgnoreEOL(java.io.Reader, java.io.Reader)",
    "snippet": "@SuppressWarnings(\"resource\")\n    public static boolean contentEqualsIgnoreEOL(final Reader input1, final Reader input2)\n            throws IOException {\n        if (input1 \u003d\u003d input2) {\n            return true;\n        }\n        if (input1 \u003d\u003d null ^ input2 \u003d\u003d null) {\n            return false;\n        }\n        final BufferedReader br1 \u003d toBufferedReader(input1);\n        final BufferedReader br2 \u003d toBufferedReader(input2);\n\n        String line1 \u003d br1.readLine();\n        String line2 \u003d br2.readLine();\n        while (line1 !\u003d null \u0026\u0026 line1.equals(line2)) {\n            line1 \u003d br1.readLine();\n            line2 \u003d br2.readLine();\n        }\n        return Objects.equals(line1, line2);\n    }",
    "begin_line": 818,
    "end_line": 836,
    "comment": "/** \n * Compares the contents of two Readers to determine if they are equal or not, ignoring EOL characters. \u003cp\u003e This method buffers the input internally using \u003ccode\u003eBufferedReader\u003c/code\u003e if they are not already buffered.\n * @param input1 the first reader\n * @param input2 the second reader\n * @return true if the content of the readers are equal (ignoring EOL differences),  false otherwise\n * @throws NullPointerException if either input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#857",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)",
    "snippet": "public static int copy(final InputStream input, final OutputStream output) throws IOException {\n        final long count \u003d copyLarge(input, output);\n        if (count \u003e Integer.MAX_VALUE) {\n            return -1;\n        }\n        return (int) count;\n    }",
    "begin_line": 857,
    "end_line": 863,
    "comment": "/** \n * Copies bytes from an \u003ccode\u003eInputStream\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003cp\u003e Large streams (over 2GB) will return a bytes copied value of \u003ccode\u003e-1\u003c/code\u003e after the copy has completed since the correct number of bytes cannot be returned as an int. For large streams use the \u003ccode\u003ecopyLarge(InputStream, OutputStream)\u003c/code\u003e method.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @return the number of bytes copied, or -1 if \u0026gt; Integer.MAX_VALUE\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#880",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream, int)",
    "snippet": "public static long copy(final InputStream input, final OutputStream output, final int bufferSize)\n            throws IOException {\n        return copyLarge(input, output, new byte[bufferSize]);\n    }",
    "begin_line": 880,
    "end_line": 883,
    "comment": "/** \n * Copies bytes from an \u003ccode\u003eInputStream\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e using an internal buffer of the given size. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003cp\u003e\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param bufferSize the bufferSize used to copy from the input to the output\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#902",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.Writer)",
    "snippet": "@Deprecated\n    public static void copy(final InputStream input, final Writer output)\n            throws IOException {\n        copy(input, output, Charset.defaultCharset());\n    }",
    "begin_line": 902,
    "end_line": 905,
    "comment": "/** \n * Copies bytes from an \u003ccode\u003eInputStream\u003c/code\u003e to chars on a \u003ccode\u003eWriter\u003c/code\u003e using the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003cp\u003e This method uses  {@link InputStreamReader}.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #copy(InputStream,Writer,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#923",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.Writer, java.nio.charset.Charset)",
    "snippet": "public static void copy(final InputStream input, final Writer output, final Charset inputCharset)\n            throws IOException {\n        final InputStreamReader in \u003d new InputStreamReader(input, Charsets.toCharset(inputCharset));\n        copy(in, output);\n    }",
    "begin_line": 923,
    "end_line": 927,
    "comment": "/** \n * Copies bytes from an \u003ccode\u003eInputStream\u003c/code\u003e to chars on a \u003ccode\u003eWriter\u003c/code\u003e using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003cp\u003e This method uses  {@link InputStreamReader}.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @param inputCharset the charset to use for the input stream, null means platform default\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#951",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.Writer, java.lang.String)",
    "snippet": "public static void copy(final InputStream input, final Writer output, final String inputCharsetName)\n            throws IOException {\n        copy(input, output, Charsets.toCharset(inputCharsetName));\n    }",
    "begin_line": 951,
    "end_line": 954,
    "comment": "/** \n * Copies bytes from an \u003ccode\u003eInputStream\u003c/code\u003e to chars on a \u003ccode\u003eWriter\u003c/code\u003e using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method uses  {@link InputStreamReader}.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @param inputCharsetName the name of the requested charset for the InputStream, null means platform default\n * @throws NullPointerException                         if the input or output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#974",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.lang.Appendable)",
    "snippet": "public static long copy(final Reader input, final Appendable output) throws IOException {\n        return copy(input, output, CharBuffer.allocate(DEFAULT_BUFFER_SIZE));\n    }",
    "begin_line": 974,
    "end_line": 976,
    "comment": "/** \n * Copies chars from a \u003ccode\u003eReader\u003c/code\u003e to a \u003ccode\u003eAppendable\u003c/code\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003cp\u003e Large streams (over 2GB) will return a chars copied value of \u003ccode\u003e-1\u003c/code\u003e after the copy has completed since the correct number of chars cannot be returned as an int. For large streams use the \u003ccode\u003ecopyLarge(Reader, Writer)\u003c/code\u003e method.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eAppendable\u003c/code\u003e to write to\n * @return the number of characters copied, or -1 if \u0026gt; Integer.MAX_VALUE\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#993",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.lang.Appendable, java.nio.CharBuffer)",
    "snippet": "public static long copy(final Reader input, final Appendable output, final CharBuffer buffer) throws IOException {\n        long count \u003d 0;\n        int n;\n        while (EOF !\u003d (n \u003d input.read(buffer))) {\n            buffer.flip();\n            output.append(buffer, 0, n);\n            count +\u003d n;\n        }\n        return count;\n    }",
    "begin_line": 993,
    "end_line": 1002,
    "comment": "/** \n * Copies chars from a \u003ccode\u003eReader\u003c/code\u003e to an \u003ccode\u003eAppendable\u003c/code\u003e. \u003cp\u003e This method uses the provided buffer, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003c/p\u003e\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eAppendable\u003c/code\u003e to write to\n * @param buffer the buffer to be used for the copy\n * @return the number of characters copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1025",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void copy(final Reader input, final OutputStream output)\n            throws IOException {\n        copy(input, output, Charset.defaultCharset());\n    }",
    "begin_line": 1025,
    "end_line": 1028,
    "comment": "/** \n * Copies chars from a \u003ccode\u003eReader\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the default character encoding of the platform, and calling flush. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003cp\u003e Due to the implementation of OutputStreamWriter, this method performs a flush. \u003cp\u003e This method uses  {@link OutputStreamWriter}.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #copy(Reader,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1053",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void copy(final Reader input, final OutputStream output, final Charset outputCharset)\n            throws IOException {\n        final OutputStreamWriter out \u003d new OutputStreamWriter(output, Charsets.toCharset(outputCharset));\n        copy(input, out);\n        // XXX Unless anyone is planning on rewriting OutputStreamWriter,\n        // we have to flush here.\n        out.flush();\n    }",
    "begin_line": 1053,
    "end_line": 1060,
    "comment": "/** \n * Copies chars from a \u003ccode\u003eReader\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the specified character encoding, and calling flush. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003c/p\u003e \u003cp\u003e Due to the implementation of OutputStreamWriter, this method performs a flush. \u003c/p\u003e \u003cp\u003e This method uses  {@link OutputStreamWriter}. \u003c/p\u003e\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param outputCharset the charset to use for the OutputStream, null means platform default\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1088",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void copy(final Reader input, final OutputStream output, final String outputCharsetName)\n            throws IOException {\n        copy(input, output, Charsets.toCharset(outputCharsetName));\n    }",
    "begin_line": 1088,
    "end_line": 1091,
    "comment": "/** \n * Copies chars from a \u003ccode\u003eReader\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the specified character encoding, and calling flush. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e Due to the implementation of OutputStreamWriter, this method performs a flush. \u003cp\u003e This method uses  {@link OutputStreamWriter}.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param outputCharsetName the name of the requested charset for the OutputStream, null means platform default\n * @throws NullPointerException                         if the input or output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copy#1111",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copy(java.io.Reader, java.io.Writer)",
    "snippet": "public static int copy(final Reader input, final Writer output) throws IOException {\n        final long count \u003d copyLarge(input, output);\n        if (count \u003e Integer.MAX_VALUE) {\n            return -1;\n        }\n        return (int) count;\n    }",
    "begin_line": 1111,
    "end_line": 1117,
    "comment": "/** \n * Copies chars from a \u003ccode\u003eReader\u003c/code\u003e to a \u003ccode\u003eWriter\u003c/code\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003cp\u003e Large streams (over 2GB) will return a chars copied value of \u003ccode\u003e-1\u003c/code\u003e after the copy has completed since the correct number of chars cannot be returned as an int. For large streams use the \u003ccode\u003ecopyLarge(Reader, Writer)\u003c/code\u003e method.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @return the number of characters copied, or -1 if \u0026gt; Integer.MAX_VALUE\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1135",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream)",
    "snippet": "public static long copyLarge(final InputStream input, final OutputStream output)\n            throws IOException {\n        return copy(input, output, DEFAULT_BUFFER_SIZE);\n    }",
    "begin_line": 1135,
    "end_line": 1138,
    "comment": "/** \n * Copies bytes from a large (over 2GB) \u003ccode\u003eInputStream\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1156",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, byte[])",
    "snippet": "public static long copyLarge(final InputStream input, final OutputStream output, final byte[] buffer)\n            throws IOException {\n        long count \u003d 0;\n        int n;\n        while (EOF !\u003d (n \u003d input.read(buffer))) {\n            output.write(buffer, 0, n);\n            count +\u003d n;\n        }\n        return count;\n    }",
    "begin_line": 1156,
    "end_line": 1165,
    "comment": "/** \n * Copies bytes from a large (over 2GB) \u003ccode\u003eInputStream\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e. \u003cp\u003e This method uses the provided buffer, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003cp\u003e\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param buffer the buffer to use for the copy\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1191",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long)",
    "snippet": "public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset,\n                                 final long length) throws IOException {\n        return copyLarge(input, output, inputOffset, length, new byte[DEFAULT_BUFFER_SIZE]);\n    }",
    "begin_line": 1191,
    "end_line": 1194,
    "comment": "/** \n * Copies some or all bytes from a large (over 2GB) \u003ccode\u003eInputStream\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e, optionally skipping input bytes. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param inputOffset : number of bytes to skip from input before copying-ve values are ignored\n * @param length : number of bytes to copy. -ve means all\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1220",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long, byte[])",
    "snippet": "public static long copyLarge(final InputStream input, final OutputStream output,\n                                 final long inputOffset, final long length, final byte[] buffer) throws IOException {\n        if (inputOffset \u003e 0) {\n            skipFully(input, inputOffset);\n        }\n        if (length \u003d\u003d 0) {\n            return 0;\n        }\n        final int bufferLength \u003d buffer.length;\n        int bytesToRead \u003d bufferLength;\n        if (length \u003e 0 \u0026\u0026 length \u003c bufferLength) {\n            bytesToRead \u003d (int) length;\n        }\n        int read;\n        long totalRead \u003d 0;\n        while (bytesToRead \u003e 0 \u0026\u0026 EOF !\u003d (read \u003d input.read(buffer, 0, bytesToRead))) {\n            output.write(buffer, 0, read);\n            totalRead +\u003d read;\n            if (length \u003e 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead \u003d (int) Math.min(length - totalRead, bufferLength);\n            }\n        }\n        return totalRead;\n    }",
    "begin_line": 1220,
    "end_line": 1244,
    "comment": "/** \n * Copies some or all bytes from a large (over 2GB) \u003ccode\u003eInputStream\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e, optionally skipping input bytes. \u003cp\u003e This method uses the provided buffer, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003c/p\u003e \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param inputOffset : number of bytes to skip from input before copying-ve values are ignored\n * @param length : number of bytes to copy. -ve means all\n * @param buffer the buffer to use for the copy\n * @return the number of bytes copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1261",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer)",
    "snippet": "public static long copyLarge(final Reader input, final Writer output) throws IOException {\n        return copyLarge(input, output, new char[DEFAULT_BUFFER_SIZE]);\n    }",
    "begin_line": 1261,
    "end_line": 1263,
    "comment": "/** \n * Copies chars from a large (over 2GB) \u003ccode\u003eReader\u003c/code\u003e to a \u003ccode\u003eWriter\u003c/code\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @return the number of characters copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1280",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, char[])",
    "snippet": "public static long copyLarge(final Reader input, final Writer output, final char[] buffer) throws IOException {\n        long count \u003d 0;\n        int n;\n        while (EOF !\u003d (n \u003d input.read(buffer))) {\n            output.write(buffer, 0, n);\n            count +\u003d n;\n        }\n        return count;\n    }",
    "begin_line": 1280,
    "end_line": 1288,
    "comment": "/** \n * Copies chars from a large (over 2GB) \u003ccode\u003eReader\u003c/code\u003e to a \u003ccode\u003eWriter\u003c/code\u003e. \u003cp\u003e This method uses the provided buffer, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003cp\u003e\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @param buffer the buffer to be used for the copy\n * @return the number of characters copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1309",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long)",
    "snippet": "public static long copyLarge(final Reader input, final Writer output, final long inputOffset, final long length)\n            throws IOException {\n        return copyLarge(input, output, inputOffset, length, new char[DEFAULT_BUFFER_SIZE]);\n    }",
    "begin_line": 1309,
    "end_line": 1312,
    "comment": "/** \n * Copies some or all chars from a large (over 2GB) \u003ccode\u003eInputStream\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e, optionally skipping input chars. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003cp\u003e The buffer size is given by  {@link #DEFAULT_BUFFER_SIZE}.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @param inputOffset : number of chars to skip from input before copying-ve values are ignored\n * @param length : number of chars to copy. -ve means all\n * @return the number of chars copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.copyLarge#1333",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long, char[])",
    "snippet": "public static long copyLarge(final Reader input, final Writer output, final long inputOffset, final long length,\n                                 final char[] buffer)\n            throws IOException {\n        if (inputOffset \u003e 0) {\n            skipFully(input, inputOffset);\n        }\n        if (length \u003d\u003d 0) {\n            return 0;\n        }\n        int bytesToRead \u003d buffer.length;\n        if (length \u003e 0 \u0026\u0026 length \u003c buffer.length) {\n            bytesToRead \u003d (int) length;\n        }\n        int read;\n        long totalRead \u003d 0;\n        while (bytesToRead \u003e 0 \u0026\u0026 EOF !\u003d (read \u003d input.read(buffer, 0, bytesToRead))) {\n            output.write(buffer, 0, read);\n            totalRead +\u003d read;\n            if (length \u003e 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead \u003d (int) Math.min(length - totalRead, buffer.length);\n            }\n        }\n        return totalRead;\n    }",
    "begin_line": 1333,
    "end_line": 1357,
    "comment": "/** \n * Copies some or all chars from a large (over 2GB) \u003ccode\u003eInputStream\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e, optionally skipping input chars. \u003cp\u003e This method uses the provided buffer, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e. \u003cp\u003e\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @param inputOffset : number of chars to skip from input before copying-ve values are ignored\n * @param length : number of chars to copy. -ve means all\n * @param buffer the buffer to be used for the copy\n * @return the number of chars copied\n * @throws NullPointerException if the input or output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1366",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(byte[])",
    "snippet": "public static int length(final byte[] array) {\n        return array \u003d\u003d null ? 0 : array.length;\n    }",
    "begin_line": 1366,
    "end_line": 1368,
    "comment": "/** \n * Returns the length of the given array in a null-safe manner.\n * @param array an array or null\n * @return the array length -- or 0 if the given array is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1377",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(char[])",
    "snippet": "public static int length(final char[] array) {\n        return array \u003d\u003d null ? 0 : array.length;\n    }",
    "begin_line": 1377,
    "end_line": 1379,
    "comment": "/** \n * Returns the length of the given array in a null-safe manner.\n * @param array an array or null\n * @return the array length -- or 0 if the given array is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1388",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(java.lang.CharSequence)",
    "snippet": "public static int length(final CharSequence csq) {\n        return csq \u003d\u003d null ? 0 : csq.length();\n    }",
    "begin_line": 1388,
    "end_line": 1390,
    "comment": "/** \n * Returns the length of the given CharSequence in a null-safe manner.\n * @param csq a CharSequence or null\n * @return the CharSequence length -- or 0 if the given CharSequence is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.length#1399",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.length(java.lang.Object[])",
    "snippet": "public static int length(final Object[] array) {\n        return array \u003d\u003d null ? 0 : array.length;\n    }",
    "begin_line": 1399,
    "end_line": 1401,
    "comment": "/** \n * Returns the length of the given array in a null-safe manner.\n * @param array an array or null\n * @return the array length -- or 0 if the given array is null.\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.lineIterator#1433",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.lineIterator(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static LineIterator lineIterator(final InputStream input, final Charset charset) throws IOException {\n        return new LineIterator(new InputStreamReader(input, Charsets.toCharset(charset)));\n    }",
    "begin_line": 1433,
    "end_line": 1435,
    "comment": "/** \n * Returns an Iterator for the lines in an \u003ccode\u003eInputStream\u003c/code\u003e, using the character encoding specified (or default encoding if null). \u003cp\u003e \u003ccode\u003eLineIterator\u003c/code\u003e holds a reference to the open \u003ccode\u003eInputStream\u003c/code\u003e specified here. When you have finished with the iterator you should close the stream to free internal resources. This can be done by closing the stream directly, or by calling {@link LineIterator#close()} or {@link LineIterator#closeQuietly(LineIterator)}. \u003cp\u003e The recommended usage pattern is: \u003cpre\u003e try { LineIterator it \u003d IOUtils.lineIterator(stream, charset); while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { IOUtils.closeQuietly(stream); } \u003c/pre\u003e\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from, not null\n * @param charset the charset to use, null means platform default\n * @return an Iterator of the lines in the reader, never null\n * @throws IllegalArgumentException if the input is null\n * @throws IOException              if an I/O error occurs, such as if the encoding is invalid\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.lineIterator#1470",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.lineIterator(java.io.InputStream, java.lang.String)",
    "snippet": "public static LineIterator lineIterator(final InputStream input, final String charsetName) throws IOException {\n        return lineIterator(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 1470,
    "end_line": 1472,
    "comment": "/** \n * Returns an Iterator for the lines in an \u003ccode\u003eInputStream\u003c/code\u003e, using the character encoding specified (or default encoding if null). \u003cp\u003e \u003ccode\u003eLineIterator\u003c/code\u003e holds a reference to the open \u003ccode\u003eInputStream\u003c/code\u003e specified here. When you have finished with the iterator you should close the stream to free internal resources. This can be done by closing the stream directly, or by calling {@link LineIterator#close()} or {@link LineIterator#closeQuietly(LineIterator)}. \u003cp\u003e The recommended usage pattern is: \u003cpre\u003e try { LineIterator it \u003d IOUtils.lineIterator(stream, \"UTF-8\"); while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { IOUtils.closeQuietly(stream); } \u003c/pre\u003e\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from, not null\n * @param charsetName the encoding to use, null means platform default\n * @return an Iterator of the lines in the reader, never null\n * @throws IllegalArgumentException                     if the input is null\n * @throws IOException                                  if an I/O error occurs, such as if the encoding is invalid\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.lineIterator#1501",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.lineIterator(java.io.Reader)",
    "snippet": "public static LineIterator lineIterator(final Reader reader) {\n        return new LineIterator(reader);\n    }",
    "begin_line": 1501,
    "end_line": 1503,
    "comment": "/** \n * Returns an Iterator for the lines in a \u003ccode\u003eReader\u003c/code\u003e. \u003cp\u003e \u003ccode\u003eLineIterator\u003c/code\u003e holds a reference to the open \u003ccode\u003eReader\u003c/code\u003e specified here. When you have finished with the iterator you should close the reader to free internal resources. This can be done by closing the reader directly, or by calling {@link LineIterator#close()} or {@link LineIterator#closeQuietly(LineIterator)}. \u003cp\u003e The recommended usage pattern is: \u003cpre\u003e try { LineIterator it \u003d IOUtils.lineIterator(reader); while (it.hasNext()) { String line \u003d it.nextLine(); /// do something with line } } finally { IOUtils.closeQuietly(reader); } \u003c/pre\u003e\n * @param reader the \u003ccode\u003eReader\u003c/code\u003e to read from, not null\n * @return an Iterator of the lines in the reader, never null\n * @throws IllegalArgumentException if the reader is null\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1517",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.InputStream, byte[])",
    "snippet": "public static int read(final InputStream input, final byte[] buffer) throws IOException {\n        return read(input, buffer, 0, buffer.length);\n    }",
    "begin_line": 1517,
    "end_line": 1519,
    "comment": "/** \n * Reads bytes from an input stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link InputStream}.\n * @param input where to read input from\n * @param buffer destination\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1535",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.InputStream, byte[], int, int)",
    "snippet": "public static int read(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length \u003c 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining \u003d length;\n        while (remaining \u003e 0) {\n            final int location \u003d length - remaining;\n            final int count \u003d input.read(buffer, offset + location, remaining);\n            if (EOF \u003d\u003d count) { // EOF\n                break;\n            }\n            remaining -\u003d count;\n        }\n        return length - remaining;\n    }",
    "begin_line": 1535,
    "end_line": 1550,
    "comment": "/** \n * Reads bytes from an input stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link InputStream}.\n * @param input where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1565",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)",
    "snippet": "public static int read(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int length \u003d buffer.remaining();\n        while (buffer.remaining() \u003e 0) {\n            final int count \u003d input.read(buffer);\n            if (EOF \u003d\u003d count) { // EOF\n                break;\n            }\n        }\n        return length - buffer.remaining();\n    }",
    "begin_line": 1565,
    "end_line": 1574,
    "comment": "/** \n * Reads bytes from a ReadableByteChannel. \u003cp\u003e This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for subclasses of  {@link ReadableByteChannel}.\n * @param input the byte channel to read\n * @param buffer byte buffer destination\n * @return the actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1588",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.Reader, char[])",
    "snippet": "public static int read(final Reader input, final char[] buffer) throws IOException {\n        return read(input, buffer, 0, buffer.length);\n    }",
    "begin_line": 1588,
    "end_line": 1590,
    "comment": "/** \n * Reads characters from an input character stream. This implementation guarantees that it will read as many characters as possible before giving up; this may not always be the case for subclasses of  {@link Reader}.\n * @param input where to read input from\n * @param buffer destination\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.read#1606",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.read(java.io.Reader, char[], int, int)",
    "snippet": "public static int read(final Reader input, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length \u003c 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining \u003d length;\n        while (remaining \u003e 0) {\n            final int location \u003d length - remaining;\n            final int count \u003d input.read(buffer, offset + location, remaining);\n            if (EOF \u003d\u003d count) { // EOF\n                break;\n            }\n            remaining -\u003d count;\n        }\n        return length - remaining;\n    }",
    "begin_line": 1606,
    "end_line": 1621,
    "comment": "/** \n * Reads characters from an input character stream. This implementation guarantees that it will read as many characters as possible before giving up; this may not always be the case for subclasses of  {@link Reader}.\n * @param input where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return actual length read; may be less than requested if EOF was reached\n * @throws IOException if a read error occurs\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#1637",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[])",
    "snippet": "public static void readFully(final InputStream input, final byte[] buffer) throws IOException {\n        readFully(input, buffer, 0, buffer.length);\n    }",
    "begin_line": 1637,
    "end_line": 1639,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#read(byte[],int,int)} maynot read as many bytes as requested (most likely because of reaching EOF).\n * @param input where to read input from\n * @param buffer destination\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of bytes read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#1657",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[], int, int)",
    "snippet": "public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual \u003d read(input, buffer, offset, length);\n        if (actual !\u003d length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }",
    "begin_line": 1657,
    "end_line": 1663,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#read(byte[],int,int)} maynot read as many bytes as requested (most likely because of reaching EOF).\n * @param input where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of bytes read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#1679",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, int)",
    "snippet": "public static byte[] readFully(final InputStream input, final int length) throws IOException {\n        final byte[] buffer \u003d new byte[length];\n        readFully(input, buffer, 0, buffer.length);\n        return buffer;\n    }",
    "begin_line": 1679,
    "end_line": 1683,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#read(byte[],int,int)} maynot read as many bytes as requested (most likely because of reaching EOF).\n * @param input where to read input from\n * @param length length to read, must be \u0026gt;\u003d 0\n * @return the bytes read from input\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of bytes read was incorrect\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#1697",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)",
    "snippet": "public static void readFully(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int expected \u003d buffer.remaining();\n        final int actual \u003d read(input, buffer);\n        if (actual !\u003d expected) {\n            throw new EOFException(\"Length to read: \" + expected + \" actual: \" + actual);\n        }\n    }",
    "begin_line": 1697,
    "end_line": 1703,
    "comment": "/** \n * Reads the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link ReadableByteChannel#read(ByteBuffer)} maynot read as many bytes as requested (most likely because of reaching EOF).\n * @param input the byte channel to read\n * @param buffer byte buffer destination\n * @throws IOException  if there is a problem reading the file\n * @throws EOFException if the number of bytes read was incorrect\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#1718",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[])",
    "snippet": "public static void readFully(final Reader input, final char[] buffer) throws IOException {\n        readFully(input, buffer, 0, buffer.length);\n    }",
    "begin_line": 1718,
    "end_line": 1720,
    "comment": "/** \n * Reads the requested number of characters or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link Reader#read(char[],int,int)} maynot read as many characters as requested (most likely because of reaching EOF).\n * @param input where to read input from\n * @param buffer destination\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of characters read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readFully#1737",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[], int, int)",
    "snippet": "public static void readFully(final Reader input, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual \u003d read(input, buffer, offset, length);\n        if (actual !\u003d length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }",
    "begin_line": 1737,
    "end_line": 1743,
    "comment": "/** \n * Reads the requested number of characters or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link Reader#read(char[],int,int)} maynot read as many characters as requested (most likely because of reaching EOF).\n * @param input where to read input from\n * @param buffer destination\n * @param offset initial offset into buffer\n * @param length length to read, must be \u0026gt;\u003d 0\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if length is negative\n * @throws EOFException             if the number of characters read was incorrect\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#1760",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static List\u003cString\u003e readLines(final InputStream input) throws IOException {\n        return readLines(input, Charset.defaultCharset());\n    }",
    "begin_line": 1760,
    "end_line": 1762,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a list of Strings, one entry per line, using the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from, not null\n * @return the list of Strings, never null\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #readLines(InputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#1778",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static List\u003cString\u003e readLines(final InputStream input, final Charset charset) throws IOException {\n        final InputStreamReader reader \u003d new InputStreamReader(input, Charsets.toCharset(charset));\n        return readLines(reader);\n    }",
    "begin_line": 1778,
    "end_line": 1781,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a list of Strings, one entry per line, using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from, not null\n * @param charset the charset to use, null means platform default\n * @return the list of Strings, never null\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#1803",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.InputStream, java.lang.String)",
    "snippet": "public static List\u003cString\u003e readLines(final InputStream input, final String charsetName) throws IOException {\n        return readLines(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 1803,
    "end_line": 1805,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a list of Strings, one entry per line, using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from, not null\n * @param charsetName the name of the requested charset, null means platform default\n * @return the list of Strings, never null\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.readLines#1820",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.readLines(java.io.Reader)",
    "snippet": "public static List\u003cString\u003e readLines(final Reader input) throws IOException {\n        final BufferedReader reader \u003d toBufferedReader(input);\n        final List\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String line \u003d reader.readLine();\n        while (line !\u003d null) {\n            list.add(line);\n            line \u003d reader.readLine();\n        }\n        return list;\n    }",
    "begin_line": 1820,
    "end_line": 1829,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eReader\u003c/code\u003e as a list of Strings, one entry per line. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from, not null\n * @return the list of Strings, never null\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToByteArray#1845",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToByteArray(java.lang.String)",
    "snippet": "public static byte[] resourceToByteArray(final String name) throws IOException {\n        return resourceToByteArray(name, null);\n    }",
    "begin_line": 1845,
    "end_line": 1847,
    "comment": "/** \n * Gets the contents of a classpath resource as a byte array. \u003cp\u003e It is expected the given \u003ccode\u003ename\u003c/code\u003e to be absolute. The behavior is not well-defined otherwise. \u003c/p\u003e\n * @param name name of the desired resource\n * @return the requested byte array\n * @throws IOException if an I/O error occurs\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToByteArray#1864",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToByteArray(java.lang.String, java.lang.ClassLoader)",
    "snippet": "public static byte[] resourceToByteArray(final String name, final ClassLoader classLoader) throws IOException {\n        return toByteArray(resourceToURL(name, classLoader));\n    }",
    "begin_line": 1864,
    "end_line": 1866,
    "comment": "/** \n * Gets the contents of a classpath resource as a byte array. \u003cp\u003e It is expected the given \u003ccode\u003ename\u003c/code\u003e to be absolute. The behavior is not well-defined otherwise. \u003c/p\u003e\n * @param name name of the desired resource\n * @param classLoader the class loader that the resolution of the resource is delegated to\n * @return the requested byte array\n * @throws IOException if an I/O error occurs\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToString#1884",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToString(java.lang.String, java.nio.charset.Charset)",
    "snippet": "public static String resourceToString(final String name, final Charset charset) throws IOException {\n        return resourceToString(name, charset, null);\n    }",
    "begin_line": 1884,
    "end_line": 1886,
    "comment": "/** \n * Gets the contents of a classpath resource as a String using the specified character encoding. \u003cp\u003e It is expected the given \u003ccode\u003ename\u003c/code\u003e to be absolute. The behavior is not well-defined otherwise. \u003c/p\u003e\n * @param name     name of the desired resource\n * @param charset the charset to use, null means platform default\n * @return the requested String\n * @throws IOException if an I/O error occurs\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToString#1905",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToString(java.lang.String, java.nio.charset.Charset, java.lang.ClassLoader)",
    "snippet": "public static String resourceToString(final String name, final Charset charset, final ClassLoader classLoader) throws IOException {\n        return toString(resourceToURL(name, classLoader), charset);\n    }",
    "begin_line": 1905,
    "end_line": 1907,
    "comment": "/** \n * Gets the contents of a classpath resource as a String using the specified character encoding. \u003cp\u003e It is expected the given \u003ccode\u003ename\u003c/code\u003e to be absolute. The behavior is not well-defined otherwise. \u003c/p\u003e\n * @param name     name of the desired resource\n * @param charset the charset to use, null means platform default\n * @param classLoader the class loader that the resolution of the resource is delegated to\n * @return the requested String\n * @throws IOException if an I/O error occurs\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToURL#1923",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToURL(java.lang.String)",
    "snippet": "public static URL resourceToURL(final String name) throws IOException {\n        return resourceToURL(name, null);\n    }",
    "begin_line": 1923,
    "end_line": 1925,
    "comment": "/** \n * Gets a URL pointing to the given classpath resource. \u003cp\u003e It is expected the given \u003ccode\u003ename\u003c/code\u003e to be absolute. The behavior is not well-defined otherwise. \u003c/p\u003e\n * @param name name of the desired resource\n * @return the requested URL\n * @throws IOException if an I/O error occurs\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.resourceToURL#1942",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.resourceToURL(java.lang.String, java.lang.ClassLoader)",
    "snippet": "public static URL resourceToURL(final String name, final ClassLoader classLoader) throws IOException {\n        // What about the thread context class loader?\n        // What about the system class loader?\n        final URL resource \u003d classLoader \u003d\u003d null ? IOUtils.class.getResource(name) : classLoader.getResource(name);\n\n        if (resource \u003d\u003d null) {\n            throw new IOException(\"Resource not found: \" + name);\n        }\n\n        return resource;\n    }",
    "begin_line": 1942,
    "end_line": 1952,
    "comment": "/** \n * Gets a URL pointing to the given classpath resource. \u003cp\u003e It is expected the given \u003ccode\u003ename\u003c/code\u003e to be absolute. The behavior is not well-defined otherwise. \u003c/p\u003e\n * @param name        name of the desired resource\n * @param classLoader the class loader that the resolution of the resource is delegated to\n * @return the requested URL\n * @throws IOException if an I/O error occurs\n * @since 2.6\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#1975",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)",
    "snippet": "public static long skip(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        /*\n         * N.B. no need to synchronize this because: - we don\u0027t care if the buffer is created multiple times (the data\n         * is ignored) - we always use the same size buffer, so if it it is recreated it will still be OK (if the buffer\n         * size were variable, we would need to synch. to ensure some other thread did not create a smaller one)\n         */\n        if (SKIP_BYTE_BUFFER \u003d\u003d null) {\n            SKIP_BYTE_BUFFER \u003d new byte[SKIP_BUFFER_SIZE];\n        }\n        long remain \u003d toSkip;\n        while (remain \u003e 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final long n \u003d input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE));\n            if (n \u003c 0) { // EOF\n                break;\n            }\n            remain -\u003d n;\n        }\n        return toSkip - remain;\n    }",
    "begin_line": 1975,
    "end_line": 1997,
    "comment": "/** \n * Skips bytes from an input byte stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for skip() implementations in subclasses of  {@link InputStream}. \u003cp\u003e Note that the implementation uses  {@link InputStream#read(byte[],int,int)} ratherthan delegating to  {@link InputStream#skip(long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of bytes are skipped. \u003c/p\u003e\n * @param input byte stream to skip\n * @param toSkip number of bytes to skip.\n * @return number of bytes actually skipped.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @see InputStream#skip(long)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-203\"\u003eIO-203 - Add skipFully() method for InputStreams\u003c/a\u003e\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2011",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.nio.channels.ReadableByteChannel, long)",
    "snippet": "public static long skip(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        final ByteBuffer skipByteBuffer \u003d ByteBuffer.allocate((int) Math.min(toSkip, SKIP_BUFFER_SIZE));\n        long remain \u003d toSkip;\n        while (remain \u003e 0) {\n            skipByteBuffer.position(0);\n            skipByteBuffer.limit((int) Math.min(remain, SKIP_BUFFER_SIZE));\n            final int n \u003d input.read(skipByteBuffer);\n            if (n \u003d\u003d EOF) {\n                break;\n            }\n            remain -\u003d n;\n        }\n        return toSkip - remain;\n    }",
    "begin_line": 2011,
    "end_line": 2027,
    "comment": "/** \n * Skips bytes from a ReadableByteChannel. This implementation guarantees that it will read as many bytes as possible before giving up.\n * @param input ReadableByteChannel to skip\n * @param toSkip number of bytes to skip.\n * @return number of bytes actually skipped.\n * @throws IOException              if there is a problem reading the ReadableByteChannel\n * @throws IllegalArgumentException if toSkip is negative\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skip#2050",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skip(java.io.Reader, long)",
    "snippet": "public static long skip(final Reader input, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        /*\n         * N.B. no need to synchronize this because: - we don\u0027t care if the buffer is created multiple times (the data\n         * is ignored) - we always use the same size buffer, so if it it is recreated it will still be OK (if the buffer\n         * size were variable, we would need to synch. to ensure some other thread did not create a smaller one)\n         */\n        if (SKIP_CHAR_BUFFER \u003d\u003d null) {\n            SKIP_CHAR_BUFFER \u003d new char[SKIP_BUFFER_SIZE];\n        }\n        long remain \u003d toSkip;\n        while (remain \u003e 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final long n \u003d input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE));\n            if (n \u003c 0) { // EOF\n                break;\n            }\n            remain -\u003d n;\n        }\n        return toSkip - remain;\n    }",
    "begin_line": 2050,
    "end_line": 2072,
    "comment": "/** \n * Skips characters from an input character stream. This implementation guarantees that it will read as many characters as possible before giving up; this may not always be the case for skip() implementations in subclasses of  {@link Reader}. \u003cp\u003e Note that the implementation uses  {@link Reader#read(char[],int,int)} ratherthan delegating to  {@link Reader#skip(long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input character stream to skip\n * @param toSkip number of characters to skip.\n * @return number of characters actually skipped.\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @see Reader#skip(long)\n * @see \u003ca href\u003d\"https://issues.apache.org/jira/browse/IO-203\"\u003eIO-203 - Add skipFully() method for InputStreams\u003c/a\u003e\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2093",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long)",
    "snippet": "public static void skipFully(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped \u003d skip(input, toSkip);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2093,
    "end_line": 2101,
    "comment": "/** \n * Skips the requested number of bytes or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link InputStream#skip(long)} maynot skip as many bytes as requested (most likely because of reaching EOF). \u003cp\u003e Note that the implementation uses  {@link #skip(InputStream,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input stream to skip\n * @param toSkip the number of bytes to skip\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of bytes skipped was incorrect\n * @see InputStream#skip(long)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2113",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.nio.channels.ReadableByteChannel, long)",
    "snippet": "public static void skipFully(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip \u003c 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped \u003d skip(input, toSkip);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2113,
    "end_line": 2121,
    "comment": "/** \n * Skips the requested number of bytes or fail if there are not enough left.\n * @param input ReadableByteChannel to skip\n * @param toSkip the number of bytes to skip\n * @throws IOException              if there is a problem reading the ReadableByteChannel\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of bytes skipped was incorrect\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.skipFully#2142",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.skipFully(java.io.Reader, long)",
    "snippet": "public static void skipFully(final Reader input, final long toSkip) throws IOException {\n        final long skipped \u003d skip(input, toSkip);\n        if (skipped !\u003d toSkip) {\n            throw new EOFException(\"Chars to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }",
    "begin_line": 2142,
    "end_line": 2147,
    "comment": "/** \n * Skips the requested number of characters or fail if there are not enough left. \u003cp\u003e This allows for the possibility that  {@link Reader#skip(long)} maynot skip as many characters as requested (most likely because of reaching EOF). \u003cp\u003e Note that the implementation uses  {@link #skip(Reader,long)}. This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of characters are skipped. \u003c/p\u003e\n * @param input stream to skip\n * @param toSkip the number of characters to skip\n * @throws IOException              if there is a problem reading the file\n * @throws IllegalArgumentException if toSkip is negative\n * @throws EOFException             if the number of characters skipped was incorrect\n * @see Reader#skip(long)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedInputStream#2170",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedInputStream(java.io.InputStream)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input);\n    }",
    "begin_line": 2170,
    "end_line": 2172,
    "comment": "/** \n * Fetches entire contents of an \u003ccode\u003eInputStream\u003c/code\u003e and represent same data as result InputStream. \u003cp\u003e This method is useful where, \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e It can be used in favor of  {@link #toByteArray(InputStream)}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input Stream to be fully buffered.\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedInputStream#2196",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedInputStream(java.io.InputStream, int)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input, final int size) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input, size);\n    }",
    "begin_line": 2196,
    "end_line": 2198,
    "comment": "/** \n * Fetches entire contents of an \u003ccode\u003eInputStream\u003c/code\u003e and represent same data as result InputStream. \u003cp\u003e This method is useful where, \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e It can be used in favor of  {@link #toByteArray(InputStream)}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input Stream to be fully buffered.\n * @param size the initial buffer size\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedReader#2210",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedReader(java.io.Reader)",
    "snippet": "public static BufferedReader toBufferedReader(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }",
    "begin_line": 2210,
    "end_line": 2212,
    "comment": "/** \n * Returns the given reader if it is a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @see #buffer(Reader)\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toBufferedReader#2225",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toBufferedReader(java.io.Reader, int)",
    "snippet": "public static BufferedReader toBufferedReader(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }",
    "begin_line": 2225,
    "end_line": 2227,
    "comment": "/** \n * Returns the given reader if it is a  {@link BufferedReader}, otherwise creates a BufferedReader from the given reader.\n * @param reader the reader to wrap or return (not null)\n * @param size the buffer size, if a new BufferedReader is created.\n * @return the given reader or a new {@link BufferedReader} for the given reader\n * @throws NullPointerException if the input parameter is null\n * @see #buffer(Reader)\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2240",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream)",
    "snippet": "public static byte[] toByteArray(final InputStream input) throws IOException {\n        try (final ByteArrayOutputStream output \u003d new ByteArrayOutputStream()) {\n            copy(input, output);\n            return output.toByteArray();\n        }\n    }",
    "begin_line": 2240,
    "end_line": 2245,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2260",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream, int)",
    "snippet": "public static byte[] toByteArray(final InputStream input, final int size) throws IOException {\n\n        if (size \u003c 0) {\n            throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + size);\n        }\n\n        if (size \u003d\u003d 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n\n        final byte[] data \u003d new byte[size];\n        int offset \u003d 0;\n        int read;\n\n        while (offset \u003c size \u0026\u0026 (read \u003d input.read(data, offset, size - offset)) !\u003d EOF) {\n            offset +\u003d read;\n        }\n\n        if (offset !\u003d size) {\n            throw new IOException(\"Unexpected read size. current: \" + offset + \", expected: \" + size);\n        }\n\n        return data;\n    }",
    "begin_line": 2260,
    "end_line": 2283,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e. Use this method instead of \u003ccode\u003etoByteArray(InputStream)\u003c/code\u003e when \u003ccode\u003eInputStream\u003c/code\u003e size is known\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param size the size of \u003ccode\u003eInputStream\u003c/code\u003e\n * @return the requested byte array\n * @throws IOException              if an I/O error occurs or \u003ccode\u003eInputStream\u003c/code\u003e size differ from parametersize\n * @throws IllegalArgumentException if size is less than zero\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2302",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream, long)",
    "snippet": "public static byte[] toByteArray(final InputStream input, final long size) throws IOException {\n\n        if (size \u003e Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Size cannot be greater than Integer max value: \" + size);\n        }\n\n        return toByteArray(input, (int) size);\n    }",
    "begin_line": 2302,
    "end_line": 2309,
    "comment": "/** \n * Gets contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e. Use this method instead of \u003ccode\u003etoByteArray(InputStream)\u003c/code\u003e when \u003ccode\u003eInputStream\u003c/code\u003e size is known. \u003cb\u003eNOTE:\u003c/b\u003e the method checks that the length can safely be cast to an int without truncation before using  {@link IOUtils#toByteArray(java.io.InputStream,int)} to read into the byte array.(Arrays can have no more than Integer.MAX_VALUE entries anyway)\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param size the size of \u003ccode\u003eInputStream\u003c/code\u003e\n * @return the requested byte array\n * @throws IOException              if an I/O error occurs or \u003ccode\u003eInputStream\u003c/code\u003e size differ from parametersize\n * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE\n * @see IOUtils#toByteArray(java.io.InputStream,int)\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2325",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.Reader)",
    "snippet": "@Deprecated\n    public static byte[] toByteArray(final Reader input) throws IOException {\n        return toByteArray(input, Charset.defaultCharset());\n    }",
    "begin_line": 2325,
    "end_line": 2327,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eReader\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e using the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @deprecated 2.5 use {@link #toByteArray(Reader,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2343",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.Reader, java.nio.charset.Charset)",
    "snippet": "public static byte[] toByteArray(final Reader input, final Charset charset) throws IOException {\n        try (final ByteArrayOutputStream output \u003d new ByteArrayOutputStream()) {\n            copy(input, output, charset);\n            return output.toByteArray();\n        }\n    }",
    "begin_line": 2343,
    "end_line": 2348,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eReader\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param charset the charset to use, null means platform default\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2370",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.io.Reader, java.lang.String)",
    "snippet": "public static byte[] toByteArray(final Reader input, final String charsetName) throws IOException {\n        return toByteArray(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2370,
    "end_line": 2372,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eReader\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested byte array\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2387",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.lang.String)",
    "snippet": "@Deprecated\n    public static byte[] toByteArray(final String input) throws IOException {\n        // make explicit the use of the default charset\n        return input.getBytes(Charset.defaultCharset());\n    }",
    "begin_line": 2387,
    "end_line": 2390,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eString\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e using the default character encoding of the platform. \u003cp\u003e This is the same as  {@link String#getBytes()}.\n * @param input the \u003ccode\u003eString\u003c/code\u003e to convert\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs (never occurs)\n * @deprecated 2.5 Use {@link String#getBytes()} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2401",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.net.URI)",
    "snippet": "public static byte[] toByteArray(final URI uri) throws IOException {\n        return IOUtils.toByteArray(uri.toURL());\n    }",
    "begin_line": 2401,
    "end_line": 2403,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eURI\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e.\n * @param uri the \u003ccode\u003eURI\u003c/code\u003e to read\n * @return the requested byte array\n * @throws NullPointerException if the uri is null\n * @throws IOException          if an I/O exception occurs\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2414",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.net.URL)",
    "snippet": "public static byte[] toByteArray(final URL url) throws IOException {\n        final URLConnection conn \u003d url.openConnection();\n        try {\n            return IOUtils.toByteArray(conn);\n        } finally {\n            close(conn);\n        }\n    }",
    "begin_line": 2414,
    "end_line": 2421,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eURL\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e.\n * @param url the \u003ccode\u003eURL\u003c/code\u003e to read\n * @return the requested byte array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O exception occurs\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toByteArray#2432",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toByteArray(java.net.URLConnection)",
    "snippet": "public static byte[] toByteArray(final URLConnection urlConn) throws IOException {\n        try (InputStream inputStream \u003d urlConn.getInputStream()) {\n            return IOUtils.toByteArray(inputStream);\n        }\n    }",
    "begin_line": 2432,
    "end_line": 2436,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eURLConnection\u003c/code\u003e as a \u003ccode\u003ebyte[]\u003c/code\u003e.\n * @param urlConn the \u003ccode\u003eURLConnection\u003c/code\u003e to read\n * @return the requested byte array\n * @throws NullPointerException if the urlConn is null\n * @throws IOException          if an I/O exception occurs\n * @since 2.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2453",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static char[] toCharArray(final InputStream is) throws IOException {\n        return toCharArray(is, Charset.defaultCharset());\n    }",
    "begin_line": 2453,
    "end_line": 2455,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a character array using the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param is the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @return the requested character array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #toCharArray(InputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2471",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static char[] toCharArray(final InputStream is, final Charset charset)\n            throws IOException {\n        final CharArrayWriter output \u003d new CharArrayWriter();\n        copy(is, output, charset);\n        return output.toCharArray();\n    }",
    "begin_line": 2471,
    "end_line": 2476,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a character array using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param is the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param charset the charset to use, null means platform default\n * @return the requested character array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2498",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.InputStream, java.lang.String)",
    "snippet": "public static char[] toCharArray(final InputStream is, final String charsetName) throws IOException {\n        return toCharArray(is, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2498,
    "end_line": 2500,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a character array using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param is the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested character array\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toCharArray#2514",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toCharArray(java.io.Reader)",
    "snippet": "public static char[] toCharArray(final Reader input) throws IOException {\n        final CharArrayWriter sw \u003d new CharArrayWriter();\n        copy(input, sw);\n        return sw.toCharArray();\n    }",
    "begin_line": 2514,
    "end_line": 2518,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eReader\u003c/code\u003e as a character array. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @return the requested character array\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#2530",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.CharSequence)",
    "snippet": "@Deprecated\n    public static InputStream toInputStream(final CharSequence input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }",
    "begin_line": 2530,
    "end_line": 2532,
    "comment": "/** \n * Converts the specified CharSequence to an input stream, encoded as bytes using the default character encoding of the platform.\n * @param input the CharSequence to convert\n * @return an input stream\n * @since 2.0\n * @deprecated 2.5 use {@link #toInputStream(CharSequence,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#2543",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.CharSequence, java.nio.charset.Charset)",
    "snippet": "public static InputStream toInputStream(final CharSequence input, final Charset charset) {\n        return toInputStream(input.toString(), charset);\n    }",
    "begin_line": 2543,
    "end_line": 2545,
    "comment": "/** \n * Converts the specified CharSequence to an input stream, encoded as bytes using the specified character encoding.\n * @param input the CharSequence to convert\n * @param charset the charset to use, null means platform default\n * @return an input stream\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#2563",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.CharSequence, java.lang.String)",
    "snippet": "public static InputStream toInputStream(final CharSequence input, final String charsetName) throws IOException {\n        return toInputStream(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2563,
    "end_line": 2565,
    "comment": "/** \n * Converts the specified CharSequence to an input stream, encoded as bytes using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e.\n * @param input the CharSequence to convert\n * @param charsetName the name of the requested charset, null means platform default\n * @return an input stream\n * @throws IOException                                  if the encoding is invalid\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#2577",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.String)",
    "snippet": "@Deprecated\n    public static InputStream toInputStream(final String input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }",
    "begin_line": 2577,
    "end_line": 2579,
    "comment": "/** \n * Converts the specified string to an input stream, encoded as bytes using the default character encoding of the platform.\n * @param input the string to convert\n * @return an input stream\n * @since 1.1\n * @deprecated 2.5 use {@link #toInputStream(String,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#2590",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.String, java.nio.charset.Charset)",
    "snippet": "public static InputStream toInputStream(final String input, final Charset charset) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charset)));\n    }",
    "begin_line": 2590,
    "end_line": 2592,
    "comment": "/** \n * Converts the specified string to an input stream, encoded as bytes using the specified character encoding.\n * @param input the string to convert\n * @param charset the charset to use, null means platform default\n * @return an input stream\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toInputStream#2610",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toInputStream(java.lang.String, java.lang.String)",
    "snippet": "public static InputStream toInputStream(final String input, final String charsetName) throws IOException {\n        final byte[] bytes \u003d input.getBytes(Charsets.toCharset(charsetName));\n        return new ByteArrayInputStream(bytes);\n    }",
    "begin_line": 2610,
    "end_line": 2613,
    "comment": "/** \n * Converts the specified string to an input stream, encoded as bytes using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e.\n * @param input the string to convert\n * @param charsetName the name of the requested charset, null means platform default\n * @return an input stream\n * @throws IOException                                  if the encoding is invalid\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2626",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(byte[])",
    "snippet": "@Deprecated\n    public static String toString(final byte[] input) throws IOException {\n        // make explicit the use of the default charset\n        return new String(input, Charset.defaultCharset());\n    }",
    "begin_line": 2626,
    "end_line": 2629,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003ebyte[]\u003c/code\u003e as a String using the default character encoding of the platform.\n * @param input the byte array to read from\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs (never occurs)\n * @deprecated 2.5 Use {@link String#String(byte[])} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2644",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(byte[], java.lang.String)",
    "snippet": "public static String toString(final byte[] input, final String charsetName) throws IOException {\n        return new String(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2644,
    "end_line": 2646,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003ebyte[]\u003c/code\u003e as a String using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e.\n * @param input the byte array to read from\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs (never occurs)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2662",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.InputStream)",
    "snippet": "@Deprecated\n    public static String toString(final InputStream input) throws IOException {\n        return toString(input, Charset.defaultCharset());\n    }",
    "begin_line": 2662,
    "end_line": 2664,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a String using the default character encoding of the platform. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @deprecated 2.5 use {@link #toString(InputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2681",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.InputStream, java.nio.charset.Charset)",
    "snippet": "public static String toString(final InputStream input, final Charset charset) throws IOException {\n        try (final StringBuilderWriter sw \u003d new StringBuilderWriter()) {\n            copy(input, sw, charset);\n            return sw.toString();\n        }\n    }",
    "begin_line": 2681,
    "end_line": 2686,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a String using the specified character encoding. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e. \u003c/p\u003e\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param charset the charset to use, null means platform default\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2707",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.InputStream, java.lang.String)",
    "snippet": "public static String toString(final InputStream input, final String charsetName)\n            throws IOException {\n        return toString(input, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2707,
    "end_line": 2710,
    "comment": "/** \n * Gets the contents of an \u003ccode\u003eInputStream\u003c/code\u003e as a String using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input the \u003ccode\u003eInputStream\u003c/code\u003e to read from\n * @param charsetName the name of the requested charset, null means platform default\n * @return the requested String\n * @throws NullPointerException                         if the input is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2723",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.io.Reader)",
    "snippet": "public static String toString(final Reader input) throws IOException {\n        try (final StringBuilderWriter sw \u003d new StringBuilderWriter()) {\n            copy(input, sw);\n            return sw.toString();\n        }\n    }",
    "begin_line": 2723,
    "end_line": 2728,
    "comment": "/** \n * Gets the contents of a \u003ccode\u003eReader\u003c/code\u003e as a String. \u003cp\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedReader\u003c/code\u003e.\n * @param input the \u003ccode\u003eReader\u003c/code\u003e to read from\n * @return the requested String\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2740",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URI)",
    "snippet": "@Deprecated\n    public static String toString(final URI uri) throws IOException {\n        return toString(uri, Charset.defaultCharset());\n    }",
    "begin_line": 2740,
    "end_line": 2742,
    "comment": "/** \n * Gets the contents at the given URI.\n * @param uri The URI source.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.1\n * @deprecated 2.5 use {@link #toString(URI,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2753",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URI, java.nio.charset.Charset)",
    "snippet": "public static String toString(final URI uri, final Charset encoding) throws IOException {\n        return toString(uri.toURL(), Charsets.toCharset(encoding));\n    }",
    "begin_line": 2753,
    "end_line": 2755,
    "comment": "/** \n * Gets the contents at the given URI.\n * @param uri The URI source.\n * @param encoding The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.3.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2769",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URI, java.lang.String)",
    "snippet": "public static String toString(final URI uri, final String charsetName) throws IOException {\n        return toString(uri, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2769,
    "end_line": 2771,
    "comment": "/** \n * Gets the contents at the given URI.\n * @param uri The URI source.\n * @param charsetName The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException                                  if an I/O exception occurs.\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2783",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URL)",
    "snippet": "@Deprecated\n    public static String toString(final URL url) throws IOException {\n        return toString(url, Charset.defaultCharset());\n    }",
    "begin_line": 2783,
    "end_line": 2785,
    "comment": "/** \n * Gets the contents at the given URL.\n * @param url The URL source.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.1\n * @deprecated 2.5 use {@link #toString(URL,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2796",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URL, java.nio.charset.Charset)",
    "snippet": "public static String toString(final URL url, final Charset encoding) throws IOException {\n        try (InputStream inputStream \u003d url.openStream()) {\n            return toString(inputStream, encoding);\n        }\n    }",
    "begin_line": 2796,
    "end_line": 2800,
    "comment": "/** \n * Gets the contents at the given URL.\n * @param url The URL source.\n * @param encoding The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException if an I/O exception occurs.\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.toString#2814",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.toString(java.net.URL, java.lang.String)",
    "snippet": "public static String toString(final URL url, final String charsetName) throws IOException {\n        return toString(url, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2814,
    "end_line": 2816,
    "comment": "/** \n * Gets the contents at the given URL.\n * @param url The URL source.\n * @param charsetName The encoding name for the URL contents.\n * @return The contents of the URL as a String.\n * @throws IOException                                  if an I/O exception occurs.\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#2828",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.OutputStream)",
    "snippet": "public static void write(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data !\u003d null) {\n            output.write(data);\n        }\n    }",
    "begin_line": 2828,
    "end_line": 2833,
    "comment": "/** \n * Writes bytes from a \u003ccode\u003ebyte[]\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e.\n * @param data the byte array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#2850",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.Writer)",
    "snippet": "@Deprecated\n    public static void write(final byte[] data, final Writer output) throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 2850,
    "end_line": 2852,
    "comment": "/** \n * Writes bytes from a \u003ccode\u003ebyte[]\u003c/code\u003e to chars on a \u003ccode\u003eWriter\u003c/code\u003e using the default character encoding of the platform. \u003cp\u003e This method uses  {@link String#String(byte[])}.\n * @param data the byte array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #write(byte[],Writer,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#2868",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.Writer, java.nio.charset.Charset)",
    "snippet": "public static void write(final byte[] data, final Writer output, final Charset charset) throws IOException {\n        if (data !\u003d null) {\n            output.write(new String(data, Charsets.toCharset(charset)));\n        }\n    }",
    "begin_line": 2868,
    "end_line": 2872,
    "comment": "/** \n * Writes bytes from a \u003ccode\u003ebyte[]\u003c/code\u003e to chars on a \u003ccode\u003eWriter\u003c/code\u003e using the specified character encoding. \u003cp\u003e This method uses  {@link String#String(byte[],String)}.\n * @param data the byte array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#2894",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(byte[], java.io.Writer, java.lang.String)",
    "snippet": "public static void write(final byte[] data, final Writer output, final String charsetName) throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2894,
    "end_line": 2896,
    "comment": "/** \n * Writes bytes from a \u003ccode\u003ebyte[]\u003c/code\u003e to chars on a \u003ccode\u003eWriter\u003c/code\u003e using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method uses  {@link String#String(byte[],String)}.\n * @param data the byte array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException                         if output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#2914",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final char[] data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 2914,
    "end_line": 2917,
    "comment": "/** \n * Writes chars from a \u003ccode\u003echar[]\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e. \u003cp\u003e This method uses  {@link String#String(char[])} and{@link String#getBytes()}.\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #write(char[],OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#2934",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void write(final char[] data, final OutputStream output, final Charset charset) throws IOException {\n        if (data !\u003d null) {\n            output.write(new String(data).getBytes(Charsets.toCharset(charset)));\n        }\n    }",
    "begin_line": 2934,
    "end_line": 2938,
    "comment": "/** \n * Writes chars from a \u003ccode\u003echar[]\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the specified character encoding. \u003cp\u003e This method uses  {@link String#String(char[])} and{@link String#getBytes(String)}.\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#2960",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.OutputStream, java.lang.String)",
    "snippet": "public static void write(final char[] data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 2960,
    "end_line": 2963,
    "comment": "/** \n * Writes chars from a \u003ccode\u003echar[]\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method uses  {@link String#String(char[])} and{@link String#getBytes(String)}.\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException                         if output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#2975",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(char[], java.io.Writer)",
    "snippet": "public static void write(final char[] data, final Writer output) throws IOException {\n        if (data !\u003d null) {\n            output.write(data);\n        }\n    }",
    "begin_line": 2975,
    "end_line": 2979,
    "comment": "/** \n * Writes chars from a \u003ccode\u003echar[]\u003c/code\u003e to a \u003ccode\u003eWriter\u003c/code\u003e\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#2996",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final CharSequence data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 2996,
    "end_line": 2999,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eCharSequence\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the default character encoding of the platform. \u003cp\u003e This method uses  {@link String#getBytes()}.\n * @param data the \u003ccode\u003eCharSequence\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.0\n * @deprecated 2.5 use {@link #write(CharSequence,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3014",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void write(final CharSequence data, final OutputStream output, final Charset charset)\n            throws IOException {\n        if (data !\u003d null) {\n            write(data.toString(), output, charset);\n        }\n    }",
    "begin_line": 3014,
    "end_line": 3019,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eCharSequence\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the specified character encoding. \u003cp\u003e This method uses  {@link String#getBytes(String)}.\n * @param data the \u003ccode\u003eCharSequence\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3039",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void write(final CharSequence data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3039,
    "end_line": 3042,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eCharSequence\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method uses  {@link String#getBytes(String)}.\n * @param data the \u003ccode\u003eCharSequence\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException        if output is null\n * @throws IOException                 if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3053",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.CharSequence, java.io.Writer)",
    "snippet": "public static void write(final CharSequence data, final Writer output) throws IOException {\n        if (data !\u003d null) {\n            write(data.toString(), output);\n        }\n    }",
    "begin_line": 3053,
    "end_line": 3057,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eCharSequence\u003c/code\u003e to a \u003ccode\u003eWriter\u003c/code\u003e.\n * @param data the \u003ccode\u003eCharSequence\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3075",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final String data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }",
    "begin_line": 3075,
    "end_line": 3078,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eString\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the default character encoding of the platform. \u003cp\u003e This method uses  {@link String#getBytes()}.\n * @param data the \u003ccode\u003eString\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #write(String,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3093",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void write(final String data, final OutputStream output, final Charset charset) throws IOException {\n        if (data !\u003d null) {\n            output.write(data.getBytes(Charsets.toCharset(charset)));\n        }\n    }",
    "begin_line": 3093,
    "end_line": 3097,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eString\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the specified character encoding. \u003cp\u003e This method uses  {@link String#getBytes(String)}.\n * @param data the \u003ccode\u003eString\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3117",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void write(final String data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3117,
    "end_line": 3120,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eString\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method uses  {@link String#getBytes(String)}.\n * @param data the \u003ccode\u003eString\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException        if output is null\n * @throws IOException                 if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3131",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.String, java.io.Writer)",
    "snippet": "public static void write(final String data, final Writer output) throws IOException {\n        if (data !\u003d null) {\n            output.write(data);\n        }\n    }",
    "begin_line": 3131,
    "end_line": 3135,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eString\u003c/code\u003e to a \u003ccode\u003eWriter\u003c/code\u003e.\n * @param data the \u003ccode\u003eString\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3152",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.StringBuffer, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void write(final StringBuffer data, final OutputStream output) //NOSONAR\n            throws IOException {\n        write(data, output, (String) null);\n    }",
    "begin_line": 3152,
    "end_line": 3155,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eStringBuffer\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the default character encoding of the platform. \u003cp\u003e This method uses  {@link String#getBytes()}.\n * @param data the \u003ccode\u003eStringBuffer\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated replaced by write(CharSequence, OutputStream)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3177",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.StringBuffer, java.io.OutputStream, java.lang.String)",
    "snippet": "@Deprecated\n    public static void write(final StringBuffer data, final OutputStream output, final String charsetName) //NOSONAR\n            throws IOException {\n        if (data !\u003d null) {\n            output.write(data.toString().getBytes(Charsets.toCharset(charsetName)));\n        }\n    }",
    "begin_line": 3177,
    "end_line": 3182,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eStringBuffer\u003c/code\u003e to bytes on an \u003ccode\u003eOutputStream\u003c/code\u003e using the specified character encoding. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e. \u003cp\u003e This method uses  {@link String#getBytes(String)}.\n * @param data the \u003ccode\u003eStringBuffer\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException        if output is null\n * @throws IOException                 if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n * @since 1.1\n * @deprecated replaced by write(CharSequence, OutputStream, String)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.write#3195",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.write(java.lang.StringBuffer, java.io.Writer)",
    "snippet": "@Deprecated\n    public static void write(final StringBuffer data, final Writer output) //NOSONAR\n            throws IOException {\n        if (data !\u003d null) {\n            output.write(data.toString());\n        }\n    }",
    "begin_line": 3195,
    "end_line": 3200,
    "comment": "/** \n * Writes chars from a \u003ccode\u003eStringBuffer\u003c/code\u003e to a \u003ccode\u003eWriter\u003c/code\u003e.\n * @param data the \u003ccode\u003eStringBuffer\u003c/code\u003e to write, null ignored\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated replaced by write(CharSequence, Writer)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeChunked#3214",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeChunked(byte[], java.io.OutputStream)",
    "snippet": "public static void writeChunked(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data !\u003d null) {\n            int bytes \u003d data.length;\n            int offset \u003d 0;\n            while (bytes \u003e 0) {\n                final int chunk \u003d Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                output.write(data, offset, chunk);\n                bytes -\u003d chunk;\n                offset +\u003d chunk;\n            }\n        }\n    }",
    "begin_line": 3214,
    "end_line": 3226,
    "comment": "/** \n * Writes bytes from a \u003ccode\u003ebyte[]\u003c/code\u003e to an \u003ccode\u003eOutputStream\u003c/code\u003e using chunked writes. This is intended for writing very large byte arrays which might otherwise cause excessive memory usage if the native code has to allocate a copy.\n * @param data the byte array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeChunked#3240",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeChunked(char[], java.io.Writer)",
    "snippet": "public static void writeChunked(final char[] data, final Writer output) throws IOException {\n        if (data !\u003d null) {\n            int bytes \u003d data.length;\n            int offset \u003d 0;\n            while (bytes \u003e 0) {\n                final int chunk \u003d Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                output.write(data, offset, chunk);\n                bytes -\u003d chunk;\n                offset +\u003d chunk;\n            }\n        }\n    }",
    "begin_line": 3240,
    "end_line": 3251,
    "comment": "/** \n * Writes chars from a \u003ccode\u003echar[]\u003c/code\u003e to a \u003ccode\u003eWriter\u003c/code\u003e using chunked writes. This is intended for writing very large byte arrays which might otherwise cause excessive memory usage if the native code has to allocate a copy.\n * @param data the char array to write, do not modify during output,null ignored\n * @param output the \u003ccode\u003eWriter\u003c/code\u003e to write to\n * @throws NullPointerException if output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3267",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.OutputStream)",
    "snippet": "@Deprecated\n    public static void writeLines(final Collection\u003c?\u003e lines, final String lineEnding,\n                                  final OutputStream output) throws IOException {\n        writeLines(lines, lineEnding, output, Charset.defaultCharset());\n    }",
    "begin_line": 3267,
    "end_line": 3270,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to an \u003ccode\u003eOutputStream\u003c/code\u003e line by line, using the default character encoding of the platform and the specified line ending.\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to, not null, not closed\n * @throws NullPointerException if the output is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n * @deprecated 2.5 use {@link #writeLines(Collection,String,OutputStream,Charset)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3285",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.OutputStream, java.nio.charset.Charset)",
    "snippet": "public static void writeLines(final Collection\u003c?\u003e lines, String lineEnding, final OutputStream output,\n                                  final Charset charset) throws IOException {\n        if (lines \u003d\u003d null) {\n            return;\n        }\n        if (lineEnding \u003d\u003d null) {\n            lineEnding \u003d LINE_SEPARATOR;\n        }\n        final Charset cs \u003d Charsets.toCharset(charset);\n        for (final Object line : lines) {\n            if (line !\u003d null) {\n                output.write(line.toString().getBytes(cs));\n            }\n            output.write(lineEnding.getBytes(cs));\n        }\n    }",
    "begin_line": 3285,
    "end_line": 3300,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to an \u003ccode\u003eOutputStream\u003c/code\u003e line by line, using the specified character encoding and the specified line ending.\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to, not null, not closed\n * @param charset the charset to use, null means platform default\n * @throws NullPointerException if the output is null\n * @throws IOException          if an I/O error occurs\n * @since 2.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3321",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.OutputStream, java.lang.String)",
    "snippet": "public static void writeLines(final Collection\u003c?\u003e lines, final String lineEnding,\n                                  final OutputStream output, final String charsetName) throws IOException {\n        writeLines(lines, lineEnding, output, Charsets.toCharset(charsetName));\n    }",
    "begin_line": 3321,
    "end_line": 3324,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to an \u003ccode\u003eOutputStream\u003c/code\u003e line by line, using the specified character encoding and the specified line ending. \u003cp\u003e Character encoding names can be found at \u003ca href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA\u003c/a\u003e.\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param output the \u003ccode\u003eOutputStream\u003c/code\u003e to write to, not null, not closed\n * @param charsetName the name of the requested charset, null means platform default\n * @throws NullPointerException                         if the output is null\n * @throws IOException                                  if an I/O error occurs\n * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io .UnsupportedEncodingException} in version 2.2 if theencoding is not supported.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writeLines#3337",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writeLines(java.util.Collection\u003c?\u003e, java.lang.String, java.io.Writer)",
    "snippet": "public static void writeLines(final Collection\u003c?\u003e lines, String lineEnding,\n                                  final Writer writer) throws IOException {\n        if (lines \u003d\u003d null) {\n            return;\n        }\n        if (lineEnding \u003d\u003d null) {\n            lineEnding \u003d LINE_SEPARATOR;\n        }\n        for (final Object line : lines) {\n            if (line !\u003d null) {\n                writer.write(line.toString());\n            }\n            writer.write(lineEnding);\n        }\n    }",
    "begin_line": 3337,
    "end_line": 3351,
    "comment": "/** \n * Writes the \u003ccode\u003etoString()\u003c/code\u003e value of each item in a collection to a \u003ccode\u003eWriter\u003c/code\u003e line by line, using the specified line ending.\n * @param lines the lines to write, null entries produce blank lines\n * @param lineEnding the line separator to use, null is system default\n * @param writer the \u003ccode\u003eWriter\u003c/code\u003e to write to, not null, not closed\n * @throws NullPointerException if the input is null\n * @throws IOException          if an I/O error occurs\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.writer#3362",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.writer(java.lang.Appendable)",
    "snippet": "public static Writer writer(final Appendable appendable) {\n        Objects.requireNonNull(appendable, \"appendable\");\n        if (appendable instanceof Writer) {\n            return (Writer) appendable;\n        }\n        if (appendable instanceof StringBuilder) {\n            return new StringBuilderWriter((StringBuilder) appendable);\n        }\n        return new AppendableWriter\u003c\u003e(appendable);\n    }",
    "begin_line": 3362,
    "end_line": 3371,
    "comment": "/** \n * Returns the given Appendable if it is already a  {@link Writer}, otherwise creates a Writer wrapper around the given Appendable.\n * @param appendable the Appendable to wrap or return (not null)\n * @return  the given Appendable or a Writer wrapper around the given Appendable\n * @throws NullPointerException if the input parameter is null\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IOUtils.IOUtils#3376",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOUtils.java",
    "class_name": "org.apache.commons.io.IOUtils",
    "signature": "org.apache.commons.io.IOUtils.IOUtils()",
    "snippet": "public IOUtils() { //NOSONAR\n        super();\n    }",
    "begin_line": 3376,
    "end_line": 3378,
    "comment": "/** \n * Instances should NOT be constructed in standard programming.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.needNewBuffer#85",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.needNewBuffer(int)",
    "snippet": "protected void needNewBuffer(final int newcount) {\n        if (currentBufferIndex \u003c buffers.size() - 1) {\n            //Recycling old buffer\n            filledBufferSum +\u003d currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer \u003d buffers.get(currentBufferIndex);\n        } else {\n            //Creating new buffer\n            int newBufferSize;\n            if (currentBuffer \u003d\u003d null) {\n                newBufferSize \u003d newcount;\n                filledBufferSum \u003d 0;\n            } else {\n                newBufferSize \u003d Math.max(\n                    currentBuffer.length \u003c\u003c 1,\n                    newcount - filledBufferSum);\n                filledBufferSum +\u003d currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer \u003d new byte[newBufferSize];\n            buffers.add(currentBuffer);\n        }\n    }",
    "begin_line": 85,
    "end_line": 109,
    "comment": "/** \n * Makes a new buffer available either by allocating a new one or re-cycling an existing one.\n * @param newcount  the size of the buffer if one is created\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.write#118",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.write(byte[], int, int)",
    "snippet": "@Override\n    public abstract void write(final byte[] b, final int off, final int len);",
    "begin_line": 118,
    "end_line": 118,
    "comment": "/** \n * Writes the bytes to the byte array.\n * @param b the bytes to write\n * @param off The start offset\n * @param len The number of bytes to write\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.writeImpl#126",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeImpl(byte[], int, int)",
    "snippet": "protected void writeImpl(final byte[] b, final int off, final int len) {\n        final int newcount \u003d count + len;\n        int remaining \u003d len;\n        int inBufferPos \u003d count - filledBufferSum;\n        while (remaining \u003e 0) {\n            final int part \u003d Math.min(remaining, currentBuffer.length - inBufferPos);\n            System.arraycopy(b, off + len - remaining, currentBuffer, inBufferPos, part);\n            remaining -\u003d part;\n            if (remaining \u003e 0) {\n                needNewBuffer(newcount);\n                inBufferPos \u003d 0;\n            }\n        }\n        count \u003d newcount;\n    }",
    "begin_line": 126,
    "end_line": 140,
    "comment": "/** \n * Writes the bytes to the byte array.\n * @param b the bytes to write\n * @param off The start offset\n * @param len The number of bytes to write\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.write#147",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.write(int)",
    "snippet": "@Override\n    public abstract void write(final int b);",
    "begin_line": 147,
    "end_line": 147,
    "comment": "/** \n * Write a byte to byte array.\n * @param b the byte to write\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.writeImpl#153",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeImpl(int)",
    "snippet": "protected void writeImpl(final int b) {\n        int inBufferPos \u003d count - filledBufferSum;\n        if (inBufferPos \u003d\u003d currentBuffer.length) {\n            needNewBuffer(count + 1);\n            inBufferPos \u003d 0;\n        }\n        currentBuffer[inBufferPos] \u003d (byte) b;\n        count++;\n    }",
    "begin_line": 153,
    "end_line": 161,
    "comment": "/** \n * Write a byte to byte array.\n * @param b the byte to write\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.write#175",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.write(java.io.InputStream)",
    "snippet": "public abstract int write(final InputStream in) throws IOException;",
    "begin_line": 175,
    "end_line": 175,
    "comment": "/** \n * Writes the entire contents of the specified input stream to this byte stream. Bytes from the input stream are read directly into the internal buffers of this streams.\n * @param in the input stream to read from\n * @return total number of bytes read from the input stream(and written to this stream)\n * @throws IOException if an I/O error occurs while reading the input stream\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.writeImpl#188",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeImpl(java.io.InputStream)",
    "snippet": "protected int writeImpl(final InputStream in) throws IOException {\n        int readCount \u003d 0;\n        int inBufferPos \u003d count - filledBufferSum;\n        int n \u003d in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);\n        while (n !\u003d EOF) {\n            readCount +\u003d n;\n            inBufferPos +\u003d n;\n            count +\u003d n;\n            if (inBufferPos \u003d\u003d currentBuffer.length) {\n                needNewBuffer(currentBuffer.length);\n                inBufferPos \u003d 0;\n            }\n            n \u003d in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);\n        }\n        return readCount;\n    }",
    "begin_line": 188,
    "end_line": 203,
    "comment": "/** \n * Writes the entire contents of the specified input stream to this byte stream. Bytes from the input stream are read directly into the internal buffers of this streams.\n * @param in the input stream to read from\n * @return total number of bytes read from the input stream(and written to this stream)\n * @throws IOException if an I/O error occurs while reading the input stream\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.size#210",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.size()",
    "snippet": "public abstract int size();",
    "begin_line": 210,
    "end_line": 210,
    "comment": "/** \n * Returns the current size of the byte array.\n * @return the current size of the byte array\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.close#221",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.close()",
    "snippet": "@Override\n    public void close() throws IOException {\n        //nop\n    }",
    "begin_line": 221,
    "end_line": 223,
    "comment": "/** \n * Closing a  {@code ByteArrayOutputStream} has no effect. The methods inthis class can be called after the stream has been closed without generating an  {@code IOException}.\n * @throws IOException never (this method should not declare this exceptionbut it has to now due to backwards compatibility)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.reset#228",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.reset()",
    "snippet": "public abstract void reset();",
    "begin_line": 228,
    "end_line": 228,
    "comment": "/** \n * @see java.io.ByteArrayOutputStream#reset()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.resetImpl#233",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.resetImpl()",
    "snippet": "protected void resetImpl() {\n        count \u003d 0;\n        filledBufferSum \u003d 0;\n        currentBufferIndex \u003d 0;\n        if (reuseBuffers) {\n            currentBuffer \u003d buffers.get(currentBufferIndex);\n        } else {\n            //Throw away old buffers\n            currentBuffer \u003d null;\n            final int size \u003d buffers.get(0).length;\n            buffers.clear();\n            needNewBuffer(size);\n            reuseBuffers \u003d true;\n        }\n    }",
    "begin_line": 233,
    "end_line": 247,
    "comment": "/** \n * @see java.io.ByteArrayOutputStream#reset()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.writeTo#257",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeTo(java.io.OutputStream)",
    "snippet": "public abstract void writeTo(final OutputStream out) throws IOException;",
    "begin_line": 257,
    "end_line": 257,
    "comment": "/** \n * Writes the entire contents of this byte stream to the specified output stream.\n * @param out  the output stream to write to\n * @throws IOException if an I/O error occurs, such as if the stream is closed\n * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.writeToImpl#267",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.writeToImpl(java.io.OutputStream)",
    "snippet": "protected void writeToImpl(final OutputStream out) throws IOException {\n        int remaining \u003d count;\n        for (final byte[] buf : buffers) {\n            final int c \u003d Math.min(buf.length, remaining);\n            out.write(buf, 0, c);\n            remaining -\u003d c;\n            if (remaining \u003d\u003d 0) {\n                break;\n            }\n        }\n    }",
    "begin_line": 267,
    "end_line": 277,
    "comment": "/** \n * Writes the entire contents of this byte stream to the specified output stream.\n * @param out  the output stream to write to\n * @throws IOException if an I/O error occurs, such as if the stream is closed\n * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.toInputStream#289",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toInputStream()",
    "snippet": "public abstract InputStream toInputStream();",
    "begin_line": 289,
    "end_line": 289,
    "comment": "/** \n * Gets the current contents of this byte stream as a Input Stream. The returned stream is backed by buffers of \u003ccode\u003ethis\u003c/code\u003e stream, avoiding memory allocation and copy, thus saving space and time.\u003cbr\u003e\n * @return the current contents of this output stream.\n * @see java.io.ByteArrayOutputStream#toByteArray()\n * @see #reset()\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractByteArrayOutputStream.toInputStream#306",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toInputStream(org.apache.commons.io.output.AbstractByteArrayOutputStream.InputStreamConstructor\u003cT\u003e)",
    "snippet": "protected \u003cT extends InputStream\u003e InputStream toInputStream(\n            final InputStreamConstructor\u003cT\u003e isConstructor) {\n        int remaining \u003d count;\n        if (remaining \u003d\u003d 0) {\n            return ClosedInputStream.CLOSED_INPUT_STREAM;\n        }\n        final List\u003cT\u003e list \u003d new ArrayList\u003c\u003e(buffers.size());\n        for (final byte[] buf : buffers) {\n            final int c \u003d Math.min(buf.length, remaining);\n            list.add(isConstructor.construct(buf, 0, c));\n            remaining -\u003d c;\n            if (remaining \u003d\u003d 0) {\n                break;\n            }\n        }\n        reuseBuffers \u003d false;\n        return new SequenceInputStream(Collections.enumeration(list));\n    }",
    "begin_line": 306,
    "end_line": 323,
    "comment": "/** \n * Gets the current contents of this byte stream as a Input Stream. The returned stream is backed by buffers of \u003ccode\u003ethis\u003c/code\u003e stream, avoiding memory allocation and copy, thus saving space and time.\u003cbr\u003e\n * @param \u003c T \u003e the type of the InputStream which makes upthe  {@link SequenceInputStream}.\n * @param isConstructor A constructor for an InputStream which makesup the  {@link SequenceInputStream}.\n * @return the current contents of this output stream.\n * @see java.io.ByteArrayOutputStream#toByteArray()\n * @see #reset()\n * @since 2.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.construct#342",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.construct(byte[], int, int)",
    "snippet": "T construct(final byte[] buf, final int offset, final int length);",
    "begin_line": 342,
    "end_line": 342,
    "comment": "/** \n * Construct an InputStream subclass.\n * @param buf the buffer\n * @param offset the offset into the buffer\n * @param length the length of the buffer\n * @return the InputStream subclass.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toByteArray#352",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toByteArray()",
    "snippet": "public abstract byte[] toByteArray();",
    "begin_line": 352,
    "end_line": 352,
    "comment": "/** \n * Gets the current contents of this byte stream as a byte array. The result is independent of this stream.\n * @return the current contents of this output stream, as a byte array\n * @see java.io.ByteArrayOutputStream#toByteArray()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toByteArrayImpl#361",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toByteArrayImpl()",
    "snippet": "protected byte[] toByteArrayImpl() {\n        int remaining \u003d count;\n        if (remaining \u003d\u003d 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte[] newbuf \u003d new byte[remaining];\n        int pos \u003d 0;\n        for (final byte[] buf : buffers) {\n            final int c \u003d Math.min(buf.length, remaining);\n            System.arraycopy(buf, 0, newbuf, pos, c);\n            pos +\u003d c;\n            remaining -\u003d c;\n            if (remaining \u003d\u003d 0) {\n                break;\n            }\n        }\n        return newbuf;\n    }",
    "begin_line": 361,
    "end_line": 378,
    "comment": "/** \n * Gets the current contents of this byte stream as a byte array. The result is independent of this stream.\n * @return the current contents of this output stream, as a byte array\n * @see java.io.ByteArrayOutputStream#toByteArray()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toString#389",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toString()",
    "snippet": "@Override\n    @Deprecated\n    public String toString() {\n        // make explicit the use of the default charset\n        return new String(toByteArray(), Charset.defaultCharset());\n    }",
    "begin_line": 389,
    "end_line": 392,
    "comment": "/** \n * Gets the current contents of this byte stream as a string using the platform default charset.\n * @return the contents of the byte array as a String\n * @see java.io.ByteArrayOutputStream#toString()\n * @deprecated 2.5 use {@link #toString(String)} instead\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toString#403",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toString(java.lang.String)",
    "snippet": "public String toString(final String enc) throws UnsupportedEncodingException {\n        return new String(toByteArray(), enc);\n    }",
    "begin_line": 403,
    "end_line": 405,
    "comment": "/** \n * Gets the current contents of this byte stream as a string using the specified encoding.\n * @param enc  the name of the character encoding\n * @return the string converted from the byte array\n * @throws UnsupportedEncodingException if the encoding is not supported\n * @see java.io.ByteArrayOutputStream#toString(String)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "InputStreamConstructor.toString#416",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/AbstractByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.AbstractByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.AbstractByteArrayOutputStream.toString(java.nio.charset.Charset)",
    "snippet": "public String toString(final Charset charset) {\n        return new String(toByteArray(), charset);\n    }",
    "begin_line": 416,
    "end_line": 418,
    "comment": "/** \n * Gets the current contents of this byte stream as a string using the specified encoding.\n * @param charset  the character encoding\n * @return the string converted from the byte array\n * @see java.io.ByteArrayOutputStream#toString(String)\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.ByteArrayOutputStream#33",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.ByteArrayOutputStream()",
    "snippet": "public ByteArrayOutputStream() {\n        this(DEFAULT_SIZE);\n    }",
    "begin_line": 33,
    "end_line": 35,
    "comment": "/** \n * Creates a new byte array output stream. The buffer capacity is initially  {@value AbstractByteArrayOutputStream#DEFAULT_SIZE} bytes, though its size increases if necessary.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.ByteArrayOutputStream#44",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.ByteArrayOutputStream(int)",
    "snippet": "public ByteArrayOutputStream(final int size) {\n        if (size \u003c 0) {\n            throw new IllegalArgumentException(\n                \"Negative initial size: \" + size);\n        }\n        synchronized (this) {\n            needNewBuffer(size);\n        }\n    }",
    "begin_line": 44,
    "end_line": 52,
    "comment": "/** \n * Creates a new byte array output stream, with a buffer capacity of the specified size, in bytes.\n * @param size  the initial size\n * @throws IllegalArgumentException if size is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.write#55",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.write(byte[], int, int)",
    "snippet": "@Override\n    public void write(final byte[] b, final int off, final int len) {\n        if ((off \u003c 0)\n                || (off \u003e b.length)\n                || (len \u003c 0)\n                || ((off + len) \u003e b.length)\n                || ((off + len) \u003c 0)) {\n            throw new IndexOutOfBoundsException();\n        } else if (len \u003d\u003d 0) {\n            return;\n        }\n        synchronized (this) {\n            writeImpl(b, off, len);\n        }\n    }",
    "begin_line": 55,
    "end_line": 68,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.write#71",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.write(int)",
    "snippet": "@Override\n    public synchronized void write(final int b) {\n        writeImpl(b);\n    }",
    "begin_line": 71,
    "end_line": 73,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.write#76",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.write(java.io.InputStream)",
    "snippet": "@Override\n    public synchronized int write(final InputStream in) throws IOException {\n        return writeImpl(in);\n    }",
    "begin_line": 76,
    "end_line": 78,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.size#81",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.size()",
    "snippet": "@Override\n    public synchronized int size() {\n        return count;\n    }",
    "begin_line": 81,
    "end_line": 83,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.reset#89",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.reset()",
    "snippet": "@Override\n    public synchronized void reset() {\n        resetImpl();\n    }",
    "begin_line": 89,
    "end_line": 91,
    "comment": "/** \n * @see java.io.ByteArrayOutputStream#reset()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.writeTo#94",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.writeTo(java.io.OutputStream)",
    "snippet": "@Override\n    public synchronized void writeTo(final OutputStream out) throws IOException {\n        writeToImpl(out);\n    }",
    "begin_line": 94,
    "end_line": 96,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.toBufferedInputStream#120",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.toBufferedInputStream(java.io.InputStream)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input)\n            throws IOException {\n        return toBufferedInputStream(input, DEFAULT_SIZE);\n    }",
    "begin_line": 120,
    "end_line": 123,
    "comment": "/** \n * Fetches entire contents of an \u003ccode\u003eInputStream\u003c/code\u003e and represent same data as result InputStream. \u003cp\u003e This method is useful where, \u003c/p\u003e \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e It can be used in favor of  {@link #toByteArray()}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input Stream to be fully buffered.\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.toBufferedInputStream#148",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.toBufferedInputStream(java.io.InputStream, int)",
    "snippet": "public static InputStream toBufferedInputStream(final InputStream input, final int size)\n        throws IOException {\n        try (final ByteArrayOutputStream output \u003d new ByteArrayOutputStream(size)) {\n            output.write(input);\n            return output.toInputStream();\n        }\n    }",
    "begin_line": 148,
    "end_line": 154,
    "comment": "/** \n * Fetches entire contents of an \u003ccode\u003eInputStream\u003c/code\u003e and represent same data as result InputStream. \u003cp\u003e This method is useful where, \u003c/p\u003e \u003cul\u003e \u003cli\u003eSource InputStream is slow.\u003c/li\u003e \u003cli\u003eIt has network resources associated, so we cannot keep it open for long time.\u003c/li\u003e \u003cli\u003eIt has network timeout associated.\u003c/li\u003e \u003c/ul\u003e It can be used in favor of  {@link #toByteArray()}, since it avoids unnecessary allocation and copy of byte[].\u003cbr\u003e This method buffers the input internally, so there is no need to use a \u003ccode\u003eBufferedInputStream\u003c/code\u003e.\n * @param input Stream to be fully buffered.\n * @param size the initial buffer size\n * @return A fully buffered stream.\n * @throws IOException if an I/O error occurs\n * @since 2.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.toInputStream#157",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.toInputStream()",
    "snippet": "@Override\n    public synchronized InputStream toInputStream() {\n        return toInputStream(java.io.ByteArrayInputStream::new);\n    }",
    "begin_line": 157,
    "end_line": 159,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ByteArrayOutputStream.toByteArray#162",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/ByteArrayOutputStream.java",
    "class_name": "org.apache.commons.io.output.ByteArrayOutputStream",
    "signature": "org.apache.commons.io.output.ByteArrayOutputStream.toByteArray()",
    "snippet": "@Override\n    public synchronized byte[] toByteArray() {\n        return toByteArrayImpl();\n    }",
    "begin_line": 162,
    "end_line": 164,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.StringBuilderWriter#41",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.StringBuilderWriter()",
    "snippet": "public StringBuilderWriter() {\n        this.builder \u003d new StringBuilder();\n    }",
    "begin_line": 41,
    "end_line": 43,
    "comment": "/** \n * Constructs a new  {@link StringBuilder} instance with default capacity.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.StringBuilderWriter#50",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.StringBuilderWriter(int)",
    "snippet": "public StringBuilderWriter(final int capacity) {\n        this.builder \u003d new StringBuilder(capacity);\n    }",
    "begin_line": 50,
    "end_line": 52,
    "comment": "/** \n * Constructs a new  {@link StringBuilder} instance with the specified capacity.\n * @param capacity The initial capacity of the underlying {@link StringBuilder}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.StringBuilderWriter#61",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.StringBuilderWriter(java.lang.StringBuilder)",
    "snippet": "public StringBuilderWriter(final StringBuilder builder) {\n        this.builder \u003d builder !\u003d null ? builder : new StringBuilder();\n    }",
    "begin_line": 61,
    "end_line": 63,
    "comment": "/** \n * Constructs a new instance with the specified  {@link StringBuilder}. \u003cp\u003eIf  {@code builder} is null a new instance with default capacity will be created.\u003c/p\u003e\n * @param builder The String builder. May be null.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.append#72",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.append(char)",
    "snippet": "@Override\n    public Writer append(final char value) {\n        builder.append(value);\n        return this;\n    }",
    "begin_line": 72,
    "end_line": 75,
    "comment": "/** \n * Appends a single character to this Writer.\n * @param value The character to append\n * @return This writer instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.append#84",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.append(java.lang.CharSequence)",
    "snippet": "@Override\n    public Writer append(final CharSequence value) {\n        builder.append(value);\n        return this;\n    }",
    "begin_line": 84,
    "end_line": 87,
    "comment": "/** \n * Appends a character sequence to this Writer.\n * @param value The character to append\n * @return This writer instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.append#98",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.append(java.lang.CharSequence, int, int)",
    "snippet": "@Override\n    public Writer append(final CharSequence value, final int start, final int end) {\n        builder.append(value, start, end);\n        return this;\n    }",
    "begin_line": 98,
    "end_line": 101,
    "comment": "/** \n * Appends a portion of a character sequence to the  {@link StringBuilder}.\n * @param value The character to append\n * @param start The index of the first character\n * @param end The index of the last character + 1\n * @return This writer instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.close#107",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.close()",
    "snippet": "@Override\n    public void close() {\n        // no-op\n    }",
    "begin_line": 107,
    "end_line": 109,
    "comment": "/** \n * Closing this writer has no effect.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.flush#115",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.flush()",
    "snippet": "@Override\n    public void flush() {\n        // no-op\n    }",
    "begin_line": 115,
    "end_line": 117,
    "comment": "/** \n * Flushing this writer has no effect.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.write#126",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.write(java.lang.String)",
    "snippet": "@Override\n    public void write(final String value) {\n        if (value !\u003d null) {\n            builder.append(value);\n        }\n    }",
    "begin_line": 126,
    "end_line": 130,
    "comment": "/** \n * Writes a String to the  {@link StringBuilder}.\n * @param value The value to write\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.write#140",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.write(char[], int, int)",
    "snippet": "@Override\n    public void write(final char[] value, final int offset, final int length) {\n        if (value !\u003d null) {\n            builder.append(value, offset, length);\n        }\n    }",
    "begin_line": 140,
    "end_line": 144,
    "comment": "/** \n * Writes a portion of a character array to the  {@link StringBuilder}.\n * @param value The value to write\n * @param offset The index of the first character\n * @param length The number of characters to write\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.getBuilder#151",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.getBuilder()",
    "snippet": "public StringBuilder getBuilder() {\n        return builder;\n    }",
    "begin_line": 151,
    "end_line": 153,
    "comment": "/** \n * Returns the underlying builder.\n * @return The underlying builder\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "StringBuilderWriter.toString#161",
    "is_bug": true,
    "src_path": "org/apache/commons/io/output/StringBuilderWriter.java",
    "class_name": "org.apache.commons.io.output.StringBuilderWriter",
    "signature": "org.apache.commons.io.output.StringBuilderWriter.toString()",
    "snippet": "@Override\n    public String toString() {\n        return builder.toString();\n    }",
    "begin_line": 161,
    "end_line": 163,
    "comment": "/** \n * Returns  {@link StringBuilder#toString()}.\n * @return The contents of the String builder.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]