[
  {
    "name": "null.current#139",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.current()",
    "snippet": "private static FileSystem current() {\n        if (IS_OS_LINUX) {\n            return LINUX;\n        }\n        if (IS_OS_MAC) {\n            return MAC_OSX;\n        }\n        if (IS_OS_WINDOWS) {\n            return WINDOWS;\n        }\n        return GENERIC;\n    }",
    "begin_line": 139,
    "end_line": 150,
    "comment": "/** \n * Gets the current file system.\n * @return the current file system\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getCurrent#157",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getCurrent()",
    "snippet": "public static FileSystem getCurrent() {\n        return CURRENT;\n    }",
    "begin_line": 157,
    "end_line": 159,
    "comment": "/** \n * Gets the current file system.\n * @return the current file system\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getOsMatchesName#168",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getOsMatchesName(java.lang.String)",
    "snippet": "private static boolean getOsMatchesName(final String osNamePrefix) {\n        return isOsNameMatch(getSystemProperty(\"os.name\"), osNamePrefix);\n    }",
    "begin_line": 168,
    "end_line": 170,
    "comment": "/** \n * Decides if the operating system matches.\n * @param osNamePrefix the prefix for the os name\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getSystemProperty#185",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getSystemProperty(java.lang.String)",
    "snippet": "private static String getSystemProperty(final String property) {\n        try {\n            return System.getProperty(property);\n        } catch (final SecurityException ex) {\n            // we are not allowed to look at this property\n            System.err.println(\"Caught a SecurityException reading the system property \u0027\" + property\n                    + \"\u0027; the SystemUtils property value will default to null.\");\n            return null;\n        }\n    }",
    "begin_line": 185,
    "end_line": 194,
    "comment": "/** \n * \u003cp\u003e Gets a System property, defaulting to  {@code null} if the property cannot be read.\u003c/p\u003e \u003cp\u003e If a  {@link SecurityException} is caught, the return value is {@code null} and a message is written to{@code System.err}. \u003c/p\u003e\n * @param property the system property name\n * @return the system property value or {@code null} if a security problem occurs\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.indexOf#239",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.indexOf(java.lang.CharSequence, int, int)",
    "snippet": "private static int indexOf(final CharSequence cs, final int searchChar, int start) {\n        if (cs instanceof String) {\n            return ((String) cs).indexOf(searchChar, start);\n        }\n        final int sz \u003d cs.length();\n        if (start \u003c 0) {\n            start \u003d 0;\n        }\n        if (searchChar \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            for (int i \u003d start; i \u003c sz; i++) {\n                if (cs.charAt(i) \u003d\u003d searchChar) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        //supplementary characters (LANG1300)\n        if (searchChar \u003c\u003d Character.MAX_CODE_POINT) {\n            final char[] chars \u003d Character.toChars(searchChar);\n            for (int i \u003d start; i \u003c sz - 1; i++) {\n                final char high \u003d cs.charAt(i);\n                final char low \u003d cs.charAt(i + 1);\n                if (high \u003d\u003d chars[0] \u0026\u0026 low \u003d\u003d chars[1]) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }",
    "begin_line": 239,
    "end_line": 267,
    "comment": "/** \n * Copied from Apache Commons Lang CharSequenceUtils. Returns the index within  {@code cs} of the first occurrence of thespecified character, starting the search at the specified index. \u003cp\u003e If a character with value  {@code searchChar} occurs in thecharacter sequence represented by the  {@code cs}object at an index no smaller than  {@code start}, then the index of the first such occurrence is returned. For values of  {@code searchChar} in the range from 0 to 0xFFFF (inclusive),this is the smallest value \u003ci\u003ek\u003c/i\u003e such that: \u003c/p\u003e \u003cblockquote\u003e\u003cpre\u003e (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d searchChar) \u0026amp;\u0026amp; (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d start) \u003c/pre\u003e\u003c/blockquote\u003e is true. For other values of  {@code searchChar}, it is the smallest value \u003ci\u003ek\u003c/i\u003e such that: \u003cblockquote\u003e\u003cpre\u003e (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d searchChar) \u0026amp;\u0026amp; (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d start) \u003c/pre\u003e\u003c/blockquote\u003e \u003cp\u003e is true. In either case, if no such character occurs in  {@code cs}at or after position  {@code start}, then {@code -1} is returned.\u003c/p\u003e \u003cp\u003e There is no restriction on the value of  {@code start}. If it is negative, it has the same effect as if it were zero: the entire {@link CharSequence} may be searched. If it is greater thanthe length of  {@code cs}, it has the same effect as if it were equal to the length of  {@code cs}:  {@code -1} is returned.\u003c/p\u003e \u003cp\u003eAll indices are specified in  {@code char} values(Unicode code units). \u003c/p\u003e\n * @param cs  the {@link CharSequence} to be processed, not null\n * @param searchChar  the char to be searched for\n * @param start  the start index, negative starts at the string start\n * @return the index where the search char was found, -1 if not found\n * @since 3.6 updated to behave more like {@link String}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isOsNameMatch#281",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isOsNameMatch(java.lang.String, java.lang.String)",
    "snippet": "private static boolean isOsNameMatch(final String osName, final String osNamePrefix) {\n        if (osName \u003d\u003d null) {\n            return false;\n        }\n        return osName.toUpperCase(Locale.ROOT).startsWith(osNamePrefix.toUpperCase(Locale.ROOT));\n    }",
    "begin_line": 281,
    "end_line": 286,
    "comment": "/** \n * Decides if the operating system matches. \u003cp\u003e This method is package private instead of private to support unit test invocation. \u003c/p\u003e\n * @param osName the actual OS name\n * @param osNamePrefix the prefix for the expected OS name\n * @return true if matches, or false if not or can\u0027t determine\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.replace#296",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.replace(java.lang.String, char, char)",
    "snippet": "private static String replace(final String path, final char oldChar, final char newChar) {\n        return path \u003d\u003d null ? null : path.replace(oldChar, newChar);\n    }",
    "begin_line": 296,
    "end_line": 298,
    "comment": "/** \n * Null-safe replace.\n * @param path the path to be changed, null ignored.\n * @param oldChar the old character.\n * @param newChar the new character.\n * @return the new path.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.FileSystem#326",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.FileSystem(int, boolean, boolean, int, int, int[], java.lang.String[], boolean, boolean, char)",
    "snippet": " FileSystem(final int blockSize, final boolean caseSensitive, final boolean casePreserving,\n        final int maxFileLength, final int maxPathLength, final int[] illegalFileNameChars,\n        final String[] reservedFileNames, final boolean reservedFileNamesExtensions, final boolean supportsDriveLetter, final char nameSeparator) {\n        this.blockSize \u003d blockSize;\n        this.maxFileNameLength \u003d maxFileLength;\n        this.maxPathLength \u003d maxPathLength;\n        this.illegalFileNameChars \u003d Objects.requireNonNull(illegalFileNameChars, \"illegalFileNameChars\");\n        this.reservedFileNames \u003d Objects.requireNonNull(reservedFileNames, \"reservedFileNames\");\n        this.reservedFileNamesExtensions \u003d reservedFileNamesExtensions;\n        this.caseSensitive \u003d caseSensitive;\n        this.casePreserving \u003d casePreserving;\n        this.supportsDriveLetter \u003d supportsDriveLetter;\n        this.nameSeparator \u003d nameSeparator;\n        this.nameSeparatorOther \u003d FilenameUtils.flipSeparator(nameSeparator);\n    }",
    "begin_line": 326,
    "end_line": 340,
    "comment": "/** \n * Constructs a new instance.\n * @param blockSize file allocation block size in bytes.\n * @param caseSensitive Whether this file system is case-sensitive.\n * @param casePreserving Whether this file system is case-preserving.\n * @param maxFileLength The maximum length for file names. The file name does not include folders.\n * @param maxPathLength The maximum length of the path to a file. This can include folders.\n * @param illegalFileNameChars Illegal characters for this file system.\n * @param reservedFileNames The reserved file names.\n * @param reservedFileNamesExtensions TODO\n * @param supportsDriveLetter Whether this file system support driver letters.\n * @param nameSeparator The name separator, \u0027\\\\\u0027 on Windows, \u0027/\u0027 on Linux.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getBlockSize#348",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getBlockSize()",
    "snippet": "public int getBlockSize() {\n        return blockSize;\n    }",
    "begin_line": 348,
    "end_line": 350,
    "comment": "/** \n * Gets the file allocation block size in bytes.\n * @return the file allocation block size in bytes.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getIllegalFileNameChars#357",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getIllegalFileNameChars()",
    "snippet": "public char[] getIllegalFileNameChars() {\n        final char[] chars \u003d new char[illegalFileNameChars.length];\n        for (int i \u003d 0; i \u003c illegalFileNameChars.length; i++) {\n            chars[i] \u003d (char) illegalFileNameChars[i];\n        }\n        return chars;\n    }",
    "begin_line": 357,
    "end_line": 363,
    "comment": "/** \n * Gets a cloned copy of the illegal characters for this file system.\n * @return the illegal characters for this file system.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getIllegalFileNameCodePoints#371",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getIllegalFileNameCodePoints()",
    "snippet": "public int[] getIllegalFileNameCodePoints() {\n        return this.illegalFileNameChars.clone();\n    }",
    "begin_line": 371,
    "end_line": 373,
    "comment": "/** \n * Gets a cloned copy of the illegal code points for this file system.\n * @return the illegal code points for this file system.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getMaxFileNameLength#380",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getMaxFileNameLength()",
    "snippet": "public int getMaxFileNameLength() {\n        return maxFileNameLength;\n    }",
    "begin_line": 380,
    "end_line": 382,
    "comment": "/** \n * Gets the maximum length for file names. The file name does not include folders.\n * @return the maximum length for file names.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getMaxPathLength#389",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getMaxPathLength()",
    "snippet": "public int getMaxPathLength() {\n        return maxPathLength;\n    }",
    "begin_line": 389,
    "end_line": 391,
    "comment": "/** \n * Gets the maximum length of the path to a file. This can include folders.\n * @return the maximum length of the path to a file.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getNameSeparator#400",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getNameSeparator()",
    "snippet": "public char getNameSeparator() {\n        return nameSeparator;\n    }",
    "begin_line": 400,
    "end_line": 402,
    "comment": "/** \n * Gets the name separator, \u0027\\\\\u0027 on Windows, \u0027/\u0027 on Linux.\n * @return \u0027\\\\\u0027 on Windows, \u0027/\u0027 on Linux.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getReservedFileNames#409",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.getReservedFileNames()",
    "snippet": "public String[] getReservedFileNames() {\n        return reservedFileNames.clone();\n    }",
    "begin_line": 409,
    "end_line": 411,
    "comment": "/** \n * Gets a cloned copy of the reserved file names.\n * @return the reserved file names.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isCasePreserving#418",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isCasePreserving()",
    "snippet": "public boolean isCasePreserving() {\n        return casePreserving;\n    }",
    "begin_line": 418,
    "end_line": 420,
    "comment": "/** \n * Tests whether this file system preserves case.\n * @return Whether this file system preserves case.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isCaseSensitive#427",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isCaseSensitive()",
    "snippet": "public boolean isCaseSensitive() {\n        return caseSensitive;\n    }",
    "begin_line": 427,
    "end_line": 429,
    "comment": "/** \n * Tests whether this file system is case-sensitive.\n * @return Whether this file system is case-sensitive.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isIllegalFileNameChar#438",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isIllegalFileNameChar(int)",
    "snippet": "private boolean isIllegalFileNameChar(final int c) {\n        return Arrays.binarySearch(illegalFileNameChars, c) \u003e\u003d 0;\n    }",
    "begin_line": 438,
    "end_line": 440,
    "comment": "/** \n * Tests if the given character is illegal in a file name,  {@code false} otherwise.\n * @param c the character to test\n * @return {@code true} if the given character is illegal in a file name, {@code false} otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isLegalFileName#451",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isLegalFileName(java.lang.CharSequence)",
    "snippet": "public boolean isLegalFileName(final CharSequence candidate) {\n        if (candidate \u003d\u003d null || candidate.length() \u003d\u003d 0 || candidate.length() \u003e maxFileNameLength) {\n            return false;\n        }\n        if (isReservedFileName(candidate)) {\n            return false;\n        }\n        return candidate.chars().noneMatch(this::isIllegalFileNameChar);\n    }",
    "begin_line": 451,
    "end_line": 459,
    "comment": "/** \n * Tests if a candidate file name (without a path) such as  {@code \"filename.ext\"} or {@code \"filename\"} is apotentially legal file name. If the file name length exceeds  {@link #getMaxFileNameLength()}, or if it contains an illegal character then the check fails.\n * @param candidate a candidate file name (without a path) like  {@code \"filename.ext\"} or {@code \"filename\"}\n * @return {@code true} if the candidate name is legal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isReservedFileName#468",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.isReservedFileName(java.lang.CharSequence)",
    "snippet": "public boolean isReservedFileName(final CharSequence candidate) {\n        final CharSequence test \u003d reservedFileNamesExtensions ? trimExtension(candidate) : candidate;\n        return Arrays.binarySearch(reservedFileNames, test) \u003e\u003d 0;\n    }",
    "begin_line": 468,
    "end_line": 471,
    "comment": "/** \n * Tests whether the given string is a reserved file name.\n * @param candidate the string to test\n * @return {@code true} if the given string is a reserved file name.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.normalizeSeparators#480",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.normalizeSeparators(java.lang.String)",
    "snippet": "public String normalizeSeparators(final String path) {\n        return replace(path, nameSeparatorOther, nameSeparator);\n    }",
    "begin_line": 480,
    "end_line": 482,
    "comment": "/** \n * Converts all separators to the Windows separator of backslash.\n * @param path the path to be changed, null ignored\n * @return the updated path\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.supportsDriveLetter#496",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.supportsDriveLetter()",
    "snippet": "public boolean supportsDriveLetter() {\n        return supportsDriveLetter;\n    }",
    "begin_line": 496,
    "end_line": 498,
    "comment": "/** \n * Tests whether this file system support driver letters. \u003cp\u003e Windows supports driver letters as do other operating systems. Whether these other OS\u0027s still support Java like OS/2, is a different matter. \u003c/p\u003e\n * @return whether this file system support driver letters.\n * @since 2.9.0\n * @see \u003ca href\u003d\"https://en.wikipedia.org/wiki/Drive_letter_assignment\"\u003eOperating systems that use drive letter\n     *      assignment\u003c/a\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.toLegalFileName#512",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.toLegalFileName(java.lang.String, char)",
    "snippet": "public String toLegalFileName(final String candidate, final char replacement) {\n        if (isIllegalFileNameChar(replacement)) {\n            // %s does not work properly with NUL\n            throw new IllegalArgumentException(String.format(\"The replacement character \u0027%s\u0027 cannot be one of the %s illegal characters: %s\",\n                replacement \u003d\u003d \u0027\\0\u0027 ? \"\\\\0\" : replacement, name(), Arrays.toString(illegalFileNameChars)));\n        }\n        final String truncated \u003d candidate.length() \u003e maxFileNameLength ? candidate.substring(0, maxFileNameLength) : candidate;\n        final int[] array \u003d truncated.chars().map(i -\u003e isIllegalFileNameChar(i) ? replacement : i).toArray();\n        return new String(array, 0, array.length);\n    }",
    "begin_line": 512,
    "end_line": 521,
    "comment": "/** \n * Converts a candidate file name (without a path) like  {@code \"filename.ext\"} or {@code \"filename\"} to a legal filename. Illegal characters in the candidate name are replaced by the  {@code replacement} character. If the filename length exceeds  {@link #getMaxFileNameLength()}, then the name is truncated to {@link #getMaxFileNameLength()}.\n * @param candidate a candidate file name (without a path) like  {@code \"filename.ext\"} or {@code \"filename\"}\n * @param replacement Illegal characters in the candidate name are replaced by this character\n * @return a String without illegal characters\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.trimExtension#523",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FileSystem.java",
    "class_name": "org.apache.commons.io.FileSystem",
    "signature": "org.apache.commons.io.FileSystem.trimExtension(java.lang.CharSequence)",
    "snippet": "CharSequence trimExtension(final CharSequence cs) {\n        final int index \u003d indexOf(cs, \u0027.\u0027, 0);\n        return index \u003c 0 ? cs : cs.subSequence(0, index);\n    }",
    "begin_line": 523,
    "end_line": 526,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.concat#201",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.concat(java.lang.String, java.lang.String)",
    "snippet": "public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix \u003d getPrefixLength(fullFileNameToAdd);\n        if (prefix \u003c 0) {\n            return null;\n        }\n        if (prefix \u003e 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath \u003d\u003d null) {\n            return null;\n        }\n        final int len \u003d basePath.length();\n        if (len \u003d\u003d 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch \u003d basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + \u0027/\u0027 + fullFileNameToAdd);\n    }",
    "begin_line": 201,
    "end_line": 221,
    "comment": "/** \n * Concatenates a fileName to a base path using normal command line style rules. \u003cp\u003e The effect is equivalent to resultant directory after changing directory to the first argument, followed by changing directory to the second argument. \u003c/p\u003e \u003cp\u003e The first argument is the base path, the second is the path to concatenate. The returned path is always normalized via  {@link #normalize(String)}, thus  {@code ..} is handled.\u003c/p\u003e \u003cp\u003e If  {@code pathToAdd} is absolute (has an absolute prefix), thenit will be normalized and returned. Otherwise, the paths will be joined, normalized and returned. \u003c/p\u003e \u003cp\u003e The output will be the same on both Unix and Windows except for the separator character. \u003c/p\u003e \u003cpre\u003e /foo/      + bar        --\u0026gt;  /foo/bar /foo       + bar        --\u0026gt;  /foo/bar /foo       + /bar       --\u0026gt;  /bar /foo       + C:/bar     --\u0026gt;  C:/bar /foo       + C:bar      --\u0026gt;  C:bar [1] /foo/a/    + ../bar     --\u0026gt;  /foo/bar /foo/      + ../../bar  --\u0026gt;  null /foo/      + /bar       --\u0026gt;  /bar /foo/..    + /bar       --\u0026gt;  /bar /foo       + bar/c.txt  --\u0026gt;  /foo/bar/c.txt /foo/c.txt + bar        --\u0026gt;  /foo/c.txt/bar [2] \u003c/pre\u003e \u003cp\u003e [1] Note that the Windows relative drive prefix is unreliable when used with this method. \u003c/p\u003e \u003cp\u003e [2] Note that the first parameter must be a path. If it ends with a name, then the name will be built into the concatenated path. If this might be a problem, use  {@link #getFullPath(String)} on the base path argument.\u003c/p\u003e\n * @param basePath  the base path to attach to, always treated as a path\n * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n * @return the concatenated path, or null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.directoryContains#244",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.directoryContains(java.lang.String, java.lang.String)",
    "snippet": "public static boolean directoryContains(final String canonicalParent, final String canonicalChild) {\n        if (isEmpty(canonicalParent) || isEmpty(canonicalChild)) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        final char separator \u003d toSeparator(canonicalParent.charAt(0) \u003d\u003d UNIX_NAME_SEPARATOR);\n        final String parentWithEndSeparator \u003d canonicalParent.charAt(canonicalParent.length() - 1) \u003d\u003d separator ? canonicalParent : canonicalParent + separator;\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, parentWithEndSeparator);\n    }",
    "begin_line": 244,
    "end_line": 257,
    "comment": "/** \n * Determines whether the  {@code parent} directory contains the {@code child} element (a file or directory).\u003cp\u003e The files names are expected to be normalized. \u003c/p\u003e Edge cases: \u003cul\u003e \u003cli\u003eA  {@code directory} must not be null: if null, throw IllegalArgumentException\u003c/li\u003e\u003cli\u003eA directory does not contain itself: return false\u003c/li\u003e \u003cli\u003eA null child file is not contained in any parent: return false\u003c/li\u003e \u003c/ul\u003e\n * @param canonicalParent the file to consider as the parent.\n * @param canonicalChild the file to consider as the child.\n * @return true is the candidate leaf is under by the specified composite. False otherwise.\n * @since 2.2\n * @see FileUtils#directoryContains(File,File)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.doGetFullPath#267",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.doGetFullPath(java.lang.String, boolean)",
    "snippet": "private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        final int prefix \u003d getPrefixLength(fileName);\n        if (prefix \u003c 0) {\n            return null;\n        }\n        if (prefix \u003e\u003d fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index \u003d indexOfLastSeparator(fileName);\n        if (index \u003c 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end \u003d index + (includeSeparator ?  1 : 0);\n        if (end \u003d\u003d 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }",
    "begin_line": 267,
    "end_line": 290,
    "comment": "/** \n * Does the work of getting the path.\n * @param fileName  the fileName\n * @param includeSeparator  true to include the end separator\n * @return the path\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.doGetPath#300",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.doGetPath(java.lang.String, int)",
    "snippet": "private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        final int prefix \u003d getPrefixLength(fileName);\n        if (prefix \u003c 0) {\n            return null;\n        }\n        final int index \u003d indexOfLastSeparator(fileName);\n        final int endIndex \u003d index + separatorAdd;\n        if (prefix \u003e\u003d fileName.length() || index \u003c 0 || prefix \u003e\u003d endIndex) {\n            return EMPTY_STRING;\n        }\n        return requireNonNullChars(fileName.substring(prefix, endIndex));\n    }",
    "begin_line": 300,
    "end_line": 314,
    "comment": "/** \n * Does the work of getting the path.\n * @param fileName  the fileName\n * @param separatorAdd  0 to omit the end separator, 1 to return it\n * @return the path\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.doNormalize#325",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.doNormalize(java.lang.String, char, boolean)",
    "snippet": "private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n\n        requireNonNullChars(fileName);\n\n        int size \u003d fileName.length();\n        if (size \u003d\u003d 0) {\n            return fileName;\n        }\n        final int prefix \u003d getPrefixLength(fileName);\n        if (prefix \u003c 0) {\n            return null;\n        }\n\n        final char[] array \u003d new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator \u003d flipSeparator(separator);\n        for (int i \u003d 0; i \u003c array.length; i++) {\n            if (array[i] \u003d\u003d otherSeparator) {\n                array[i] \u003d separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory \u003d true;\n        if (array[size - 1] !\u003d separator) {\n            array[size++] \u003d separator;\n            lastIsDirectory \u003d false;\n        }\n\n        // adjoining slashes\n        // If we get here, prefix can only be 0 or greater, size 1 or greater\n        // If prefix is 0, set loop start to 1 to prevent index errors\n        for (int i \u003d prefix !\u003d 0 ? prefix : 1; i \u003c size; i++) {\n            if (array[i] \u003d\u003d separator \u0026\u0026 array[i - 1] \u003d\u003d separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i \u003d prefix + 1; i \u003c size; i++) {\n            if (array[i] \u003d\u003d separator \u0026\u0026 array[i - 1] \u003d\u003d \u0027.\u0027 \u0026\u0026\n                    (i \u003d\u003d prefix + 1 || array[i - 2] \u003d\u003d separator)) {\n                if (i \u003d\u003d size - 1) {\n                    lastIsDirectory \u003d true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -\u003d2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i \u003d prefix + 2; i \u003c size; i++) {\n            if (array[i] \u003d\u003d separator \u0026\u0026 array[i - 1] \u003d\u003d \u0027.\u0027 \u0026\u0026 array[i - 2] \u003d\u003d \u0027.\u0027 \u0026\u0026\n                    (i \u003d\u003d prefix + 2 || array[i - 3] \u003d\u003d separator)) {\n                if (i \u003d\u003d prefix + 2) {\n                    return null;\n                }\n                if (i \u003d\u003d size - 1) {\n                    lastIsDirectory \u003d true;\n                }\n                int j;\n                for (j \u003d i - 4 ; j \u003e\u003d prefix; j--) {\n                    if (array[j] \u003d\u003d separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -\u003d i - j;\n                        i \u003d j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -\u003d i + 1 - prefix;\n                i \u003d prefix + 1;\n            }\n        }\n\n        if (size \u003c\u003d 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size \u003c\u003d prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory \u0026\u0026 keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }",
    "begin_line": 325,
    "end_line": 421,
    "comment": "/** \n * Internal method to perform the normalization.\n * @param fileName  the fileName\n * @param separator The separator character to use\n * @param keepSeparator  true to keep the final separator\n * @return the normalized fileName\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equals#435",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equals(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }",
    "begin_line": 435,
    "end_line": 437,
    "comment": "/** \n * Checks whether two fileNames are equal exactly. \u003cp\u003e No processing is performed on the fileNames other than comparison, thus this is merely a null-safe case-sensitive equals. \u003c/p\u003e\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @return true if the fileNames are equal, null equals null\n * @see IOCase#SENSITIVE\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equals#450",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equals(java.lang.String, java.lang.String, boolean, org.apache.commons.io.IOCase)",
    "snippet": "public static boolean equals(String fileName1, String fileName2, final boolean normalize, final IOCase ioCase) {\n\n        if (fileName1 \u003d\u003d null || fileName2 \u003d\u003d null) {\n            return fileName1 \u003d\u003d null \u0026\u0026 fileName2 \u003d\u003d null;\n        }\n        if (normalize) {\n            fileName1 \u003d normalize(fileName1);\n            if (fileName1 \u003d\u003d null) {\n                return false;\n            }\n            fileName2 \u003d normalize(fileName2);\n            if (fileName2 \u003d\u003d null) {\n                return false;\n            }\n        }\n        return IOCase.value(ioCase, IOCase.SENSITIVE).checkEquals(fileName1, fileName2);\n    }",
    "begin_line": 450,
    "end_line": 466,
    "comment": "/** \n * Checks whether two fileNames are equal, optionally normalizing and providing control over the case-sensitivity.\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @param normalize  whether to normalize the fileNames\n * @param ioCase  what case sensitivity rule to use, null means case-sensitive\n * @return true if the fileNames are equal, null equals null\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equalsNormalized#480",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equalsNormalized(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }",
    "begin_line": 480,
    "end_line": 482,
    "comment": "/** \n * Checks whether two fileNames are equal after both have been normalized. \u003cp\u003e Both fileNames are first passed to  {@link #normalize(String)}. The check is then performed in a case-sensitive manner. \u003c/p\u003e\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @return true if the fileNames are equal, null equals null\n * @see IOCase#SENSITIVE\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equalsNormalizedOnSystem#498",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equalsNormalizedOnSystem(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }",
    "begin_line": 498,
    "end_line": 500,
    "comment": "/** \n * Checks whether two fileNames are equal after both have been normalized and using the case rules of the system. \u003cp\u003e Both fileNames are first passed to  {@link #normalize(String)}. The check is then performed case-sensitive on Unix and case-insensitive on Windows. \u003c/p\u003e\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @return true if the fileNames are equal, null equals null\n * @see IOCase#SYSTEM\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.equalsOnSystem#514",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.equalsOnSystem(java.lang.String, java.lang.String)",
    "snippet": "public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }",
    "begin_line": 514,
    "end_line": 516,
    "comment": "/** \n * Checks whether two fileNames are equal using the case rules of the system. \u003cp\u003e No processing is performed on the fileNames other than comparison. The check is case-sensitive on Unix and case-insensitive on Windows. \u003c/p\u003e\n * @param fileName1  the first fileName to query, may be null\n * @param fileName2  the second fileName to query, may be null\n * @return true if the fileNames are equal, null equals null\n * @see IOCase#SYSTEM\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.flipSeparator#524",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.flipSeparator(char)",
    "snippet": "static char flipSeparator(final char ch) {\n        if (ch \u003d\u003d UNIX_NAME_SEPARATOR) {\n            return WINDOWS_NAME_SEPARATOR;\n        }\n        if (ch \u003d\u003d WINDOWS_NAME_SEPARATOR) {\n            return UNIX_NAME_SEPARATOR;\n        }\n        throw new IllegalArgumentException(String.valueOf(ch));\n    }",
    "begin_line": 524,
    "end_line": 532,
    "comment": "/** \n * Flips the Windows name separator to Linux and vice-versa.\n * @param ch The Windows or Linux name separator.\n * @return The Windows or Linux name separator.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getAdsCriticalOffset#540",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getAdsCriticalOffset(java.lang.String)",
    "snippet": "private static int getAdsCriticalOffset(final String fileName) {\n        // Step 1: Remove leading path segments.\n        final int offset1 \u003d fileName.lastIndexOf(SYSTEM_NAME_SEPARATOR);\n        final int offset2 \u003d fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 \u003d\u003d -1) {\n            if (offset2 \u003d\u003d -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 \u003d\u003d -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }",
    "begin_line": 540,
    "end_line": 554,
    "comment": "/** \n * Special handling for NTFS ADS: Don\u0027t accept colon in the fileName.\n * @param fileName a file name\n * @return ADS offsets.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getBaseName#576",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getBaseName(java.lang.String)",
    "snippet": "public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }",
    "begin_line": 576,
    "end_line": 578,
    "comment": "/** \n * Gets the base name, minus the full path and extension, from a full fileName. \u003cp\u003e This method will handle a file in either Unix or Windows format. The text after the last forward or backslash and before the last dot is returned. \u003c/p\u003e \u003cpre\u003e a/b/c.txt --\u0026gt; c a.txt     --\u0026gt; a a/b/c     --\u0026gt; c a/b/c/    --\u0026gt; \"\" \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the name of the file without the path, or an empty string if none exists\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getExtension#610",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getExtension(java.lang.String)",
    "snippet": "public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        final int index \u003d indexOfExtension(fileName);\n        if (index \u003d\u003d NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }",
    "begin_line": 610,
    "end_line": 619,
    "comment": "/** \n * Gets the extension of a fileName. \u003cp\u003e This method returns the textual part of the fileName after the last dot. There must be no directory separator after the dot. \u003c/p\u003e \u003cpre\u003e foo.txt      --\u0026gt; \"txt\" a/b/c.jpg    --\u0026gt; \"jpg\" a/b.txt/c    --\u0026gt; \"\" a/b/c        --\u0026gt; \"\" \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on, with the exception of a possible  {@link IllegalArgumentException} on Windows (see below).\u003c/p\u003e \u003cp\u003e \u003cb\u003eNote:\u003c/b\u003e This method used to have a hidden problem for names like \"foo.exe:bar.txt\". In this case, the name wouldn\u0027t be the name of a file, but the identifier of an alternate data stream (bar.txt) on the file foo.exe. The method used to return \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing an  {@link IllegalArgumentException} for names like this.\u003c/p\u003e\n * @param fileName the fileName to retrieve the extension of.\n * @return the extension of the file or an empty string if none exists or {@code null}if the fileName is  {@code null}.\n * @throws IllegalArgumentException \u003cb\u003eWindows only:\u003c/b\u003e The fileName parameter is, in fact,the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getFullPath#649",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getFullPath(java.lang.String)",
    "snippet": "public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }",
    "begin_line": 649,
    "end_line": 651,
    "comment": "/** \n * Gets the full path from a full fileName, which is the prefix + path. \u003cp\u003e This method will handle a file in either Unix or Windows format. The method is entirely text based, and returns the text before and including the last forward or backslash. \u003c/p\u003e \u003cpre\u003e C:\\a\\b\\c.txt --\u0026gt; C:\\a\\b\\ ~/a/b/c.txt  --\u0026gt; ~/a/b/ a.txt        --\u0026gt; \"\" a/b/c        --\u0026gt; a/b/ a/b/c/       --\u0026gt; a/b/c/ C:           --\u0026gt; C: C:\\          --\u0026gt; C:\\ ~            --\u0026gt; ~/ ~/           --\u0026gt; ~/ ~user        --\u0026gt; ~user/ ~user/       --\u0026gt; ~user/ \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the path of the file, an empty string if none exists, null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getFullPathNoEndSeparator#682",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getFullPathNoEndSeparator(java.lang.String)",
    "snippet": "public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }",
    "begin_line": 682,
    "end_line": 684,
    "comment": "/** \n * Gets the full path from a full fileName, which is the prefix + path, and also excluding the final directory separator. \u003cp\u003e This method will handle a file in either Unix or Windows format. The method is entirely text based, and returns the text before the last forward or backslash. \u003c/p\u003e \u003cpre\u003e C:\\a\\b\\c.txt --\u0026gt; C:\\a\\b ~/a/b/c.txt  --\u0026gt; ~/a/b a.txt        --\u0026gt; \"\" a/b/c        --\u0026gt; a/b a/b/c/       --\u0026gt; a/b/c C:           --\u0026gt; C: C:\\          --\u0026gt; C:\\ ~            --\u0026gt; ~ ~/           --\u0026gt; ~ ~user        --\u0026gt; ~user ~user/       --\u0026gt; ~user \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the path of the file, an empty string if none exists, null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getName#706",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getName(java.lang.String)",
    "snippet": "public static String getName(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        return requireNonNullChars(fileName).substring(indexOfLastSeparator(fileName) + 1);\n    }",
    "begin_line": 706,
    "end_line": 711,
    "comment": "/** \n * Gets the name minus the path from a full fileName. \u003cp\u003e This method will handle a file in either Unix or Windows format. The text after the last forward or backslash is returned. \u003c/p\u003e \u003cpre\u003e a/b/c.txt --\u0026gt; c.txt a.txt     --\u0026gt; a.txt a/b/c     --\u0026gt; c a/b/c/    --\u0026gt; \"\" \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the name of the file without the path, or an empty string if none exists\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getPath#739",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getPath(java.lang.String)",
    "snippet": "public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }",
    "begin_line": 739,
    "end_line": 741,
    "comment": "/** \n * Gets the path from a full fileName, which excludes the prefix. \u003cp\u003e This method will handle a file in either Unix or Windows format. The method is entirely text based, and returns the text before and including the last forward or backslash. \u003c/p\u003e \u003cpre\u003e C:\\a\\b\\c.txt --\u0026gt; a\\b\\ ~/a/b/c.txt  --\u0026gt; a/b/ a.txt        --\u0026gt; \"\" a/b/c        --\u0026gt; a/b/ a/b/c/       --\u0026gt; a/b/c/ \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e \u003cp\u003e This method drops the prefix from the result. See  {@link #getFullPath(String)} for the method that retains the prefix.\u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the path of the file, an empty string if none exists, null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getPathNoEndSeparator#770",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getPathNoEndSeparator(java.lang.String)",
    "snippet": "public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }",
    "begin_line": 770,
    "end_line": 772,
    "comment": "/** \n * Gets the path from a full fileName, which excludes the prefix, and also excluding the final directory separator. \u003cp\u003e This method will handle a file in either Unix or Windows format. The method is entirely text based, and returns the text before the last forward or backslash. \u003c/p\u003e \u003cpre\u003e C:\\a\\b\\c.txt --\u0026gt; a\\b ~/a/b/c.txt  --\u0026gt; a/b a.txt        --\u0026gt; \"\" a/b/c        --\u0026gt; a/b a/b/c/       --\u0026gt; a/b/c \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. \u003c/p\u003e \u003cp\u003e This method drops the prefix from the result. See  {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the path of the file, an empty string if none exists, null if invalid\n * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getPrefix#806",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
    "snippet": "public static String getPrefix(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        final int len \u003d getPrefixLength(fileName);\n        if (len \u003c 0) {\n            return null;\n        }\n        if (len \u003e fileName.length()) {\n            requireNonNullChars(fileName);\n            return fileName + UNIX_NAME_SEPARATOR;\n        }\n        return requireNonNullChars(fileName.substring(0, len));\n    }",
    "begin_line": 806,
    "end_line": 819,
    "comment": "/** \n * Gets the prefix from a full fileName, such as  {@code C:/}or  {@code ~/}. \u003cp\u003e This method will handle a file in either Unix or Windows format. The prefix includes the first slash in the full fileName where applicable. \u003c/p\u003e \u003cpre\u003e Windows: a\\b\\c.txt           --\u0026gt; \"\"          --\u0026gt; relative \\a\\b\\c.txt          --\u0026gt; \"\\\"         --\u0026gt; current drive absolute C:a\\b\\c.txt         --\u0026gt; \"C:\"        --\u0026gt; drive relative C:\\a\\b\\c.txt        --\u0026gt; \"C:\\\"       --\u0026gt; absolute \\\\server\\a\\b\\c.txt  --\u0026gt; \"\\\\server\\\" --\u0026gt; UNC Unix: a/b/c.txt           --\u0026gt; \"\"          --\u0026gt; relative /a/b/c.txt          --\u0026gt; \"/\"         --\u0026gt; absolute ~/a/b/c.txt         --\u0026gt; \"~/\"        --\u0026gt; current user ~                   --\u0026gt; \"~/\"        --\u0026gt; current user (slash added) ~user/a/b/c.txt     --\u0026gt; \"~user/\"    --\u0026gt; named user ~user               --\u0026gt; \"~user/\"    --\u0026gt; named user (slash added) \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. ie. both Unix and Windows prefixes are matched regardless. \u003c/p\u003e\n * @param fileName  the fileName to query, null returns null\n * @return the prefix of the file, null if invalid\n * @throws IllegalArgumentException if the result contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.getPrefixLength#864",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)",
    "snippet": "public static int getPrefixLength(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return NOT_FOUND;\n        }\n        final int len \u003d fileName.length();\n        if (len \u003d\u003d 0) {\n            return 0;\n        }\n        char ch0 \u003d fileName.charAt(0);\n        if (ch0 \u003d\u003d \u0027:\u0027) {\n            return NOT_FOUND;\n        }\n        if (len \u003d\u003d 1) {\n            if (ch0 \u003d\u003d \u0027~\u0027) {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 \u003d\u003d \u0027~\u0027) {\n            int posUnix \u003d fileName.indexOf(UNIX_NAME_SEPARATOR, 1);\n            int posWin \u003d fileName.indexOf(WINDOWS_NAME_SEPARATOR, 1);\n            if (posUnix \u003d\u003d NOT_FOUND \u0026\u0026 posWin \u003d\u003d NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix \u003d posUnix \u003d\u003d NOT_FOUND ? posWin : posUnix;\n            posWin \u003d posWin \u003d\u003d NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 \u003d fileName.charAt(1);\n        if (ch1 \u003d\u003d \u0027:\u0027) {\n            ch0 \u003d Character.toUpperCase(ch0);\n            if (ch0 \u003e\u003d \u0027A\u0027 \u0026\u0026 ch0 \u003c\u003d \u0027Z\u0027) {\n                if (len \u003d\u003d 2 \u0026\u0026 !FileSystem.getCurrent().supportsDriveLetter()) {\n                    return 0;\n                }\n                if (len \u003d\u003d 2 || !isSeparator(fileName.charAt(2))) {\n                    return 2;\n                }\n                return 3;\n            }\n            if (ch0 \u003d\u003d UNIX_NAME_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        }\n        if (!isSeparator(ch0) || !isSeparator(ch1)) {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        int posUnix \u003d fileName.indexOf(UNIX_NAME_SEPARATOR, 2);\n        int posWin \u003d fileName.indexOf(WINDOWS_NAME_SEPARATOR, 2);\n        if (posUnix \u003d\u003d NOT_FOUND \u0026\u0026 posWin \u003d\u003d NOT_FOUND || posUnix \u003d\u003d 2 || posWin \u003d\u003d 2) {\n            return NOT_FOUND;\n        }\n        posUnix \u003d posUnix \u003d\u003d NOT_FOUND ? posWin : posUnix;\n        posWin \u003d posWin \u003d\u003d NOT_FOUND ? posUnix : posWin;\n        final int pos \u003d Math.min(posUnix, posWin) + 1;\n        final String hostnamePart \u003d fileName.substring(2, pos - 1);\n        return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n    }",
    "begin_line": 864,
    "end_line": 923,
    "comment": "/** \n * Returns the length of the fileName prefix, such as  {@code C:/} or {@code ~/}. \u003cp\u003e This method will handle a file in either Unix or Windows format. \u003c/p\u003e \u003cp\u003e The prefix length includes the first slash in the full fileName if applicable. Thus, it is possible that the length returned is greater than the length of the input string. \u003c/p\u003e \u003cpre\u003e Windows: a\\b\\c.txt           --\u0026gt; 0           --\u0026gt; relative \\a\\b\\c.txt          --\u0026gt; 1           --\u0026gt; current drive absolute C:a\\b\\c.txt         --\u0026gt; 2           --\u0026gt; drive relative C:\\a\\b\\c.txt        --\u0026gt; 3           --\u0026gt; absolute \\\\server\\a\\b\\c.txt  --\u0026gt; 9           --\u0026gt; UNC \\\\\\a\\b\\c.txt        --\u0026gt; -1          --\u0026gt; error Unix: a/b/c.txt           --\u0026gt; 0           --\u0026gt; relative /a/b/c.txt          --\u0026gt; 1           --\u0026gt; absolute ~/a/b/c.txt         --\u0026gt; 2           --\u0026gt; current user ~                   --\u0026gt; 2           --\u0026gt; current user (slash added) ~user/a/b/c.txt     --\u0026gt; 6           --\u0026gt; named user ~user               --\u0026gt; 6           --\u0026gt; named user (slash added) //server/a/b/c.txt  --\u0026gt; 9 ///a/b/c.txt        --\u0026gt; -1          --\u0026gt; error C:                  --\u0026gt; 0           --\u0026gt; valid file name as only null character and / are reserved characters \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on. ie. both Unix and Windows prefixes are matched regardless. \u003c/p\u003e \u003cp\u003e Note that a leading // (or \\\\) is used to indicate a UNC name on Windows. These must be followed by a server name, so double-slashes are not collapsed to a single slash at the start of the fileName. \u003c/p\u003e\n * @param fileName  the fileName to find the prefix in, null returns -1\n * @return the length of the prefix, -1 if invalid or null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.indexOfExtension#947",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.indexOfExtension(java.lang.String)",
    "snippet": "public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName \u003d\u003d null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don\u0027t accept colon in the fileName.\n            final int offset \u003d fileName.indexOf(\u0027:\u0027, getAdsCriticalOffset(fileName));\n            if (offset !\u003d -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (\u0027:\u0027) in file name is forbidden.\");\n            }\n        }\n        final int extensionPos \u003d fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator \u003d indexOfLastSeparator(fileName);\n        return lastSeparator \u003e extensionPos ? NOT_FOUND : extensionPos;\n    }",
    "begin_line": 947,
    "end_line": 961,
    "comment": "/** \n * Returns the index of the last extension separator character, which is a dot. \u003cp\u003e This method also checks that there is no directory separator after the last dot. To do this it uses {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\u003c/p\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on, with the exception of a possible  {@link IllegalArgumentException} on Windows (see below).\u003c/p\u003e \u003cb\u003eNote:\u003c/b\u003e This method used to have a hidden problem for names like \"foo.exe:bar.txt\". In this case, the name wouldn\u0027t be the name of a file, but the identifier of an alternate data stream (bar.txt) on the file foo.exe. The method used to return \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing an  {@link IllegalArgumentException} for names like this.\n * @param fileName the fileName to find the last extension separator in, null returns -1\n * @return the index of the last extension separator character, or -1 if there is no such character\n * @throws IllegalArgumentException \u003cb\u003eWindows only:\u003c/b\u003e The fileName parameter is, in fact,the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.indexOfLastSeparator#975",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.indexOfLastSeparator(java.lang.String)",
    "snippet": "public static int indexOfLastSeparator(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos \u003d fileName.lastIndexOf(UNIX_NAME_SEPARATOR);\n        final int lastWindowsPos \u003d fileName.lastIndexOf(WINDOWS_NAME_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }",
    "begin_line": 975,
    "end_line": 982,
    "comment": "/** \n * Returns the index of the last directory separator character. \u003cp\u003e This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. \u003cp\u003e The output will be the same irrespective of the machine that the code is running on.\n * @param fileName  the fileName to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isEmpty#984",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isEmpty(java.lang.String)",
    "snippet": "private static boolean isEmpty(final String string) {\n        return string \u003d\u003d null || string.isEmpty();\n    }",
    "begin_line": 984,
    "end_line": 986,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isExtension#1000",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isExtension(java.lang.String, java.util.Collection\u003cjava.lang.String\u003e)",
    "snippet": "public static boolean isExtension(final String fileName, final Collection\u003cString\u003e extensions) {\n        if (fileName \u003d\u003d null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions \u003d\u003d null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) \u003d\u003d NOT_FOUND;\n        }\n        return extensions.contains(getExtension(fileName));\n    }",
    "begin_line": 1000,
    "end_line": 1010,
    "comment": "/** \n * Checks whether the extension of the fileName is one of those specified. \u003cp\u003e This method obtains the extension as the textual part of the fileName after the last dot. There must be no directory separator after the dot. The extension check is case-sensitive on all platforms.\n * @param fileName  the fileName to query, null returns false\n * @param extensions  the extensions to check for, null checks for no extension\n * @return true if the fileName is one of the extensions\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isExtension#1024",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isExtension(java.lang.String, java.lang.String)",
    "snippet": "public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName \u003d\u003d null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (isEmpty(extension)) {\n            return indexOfExtension(fileName) \u003d\u003d NOT_FOUND;\n        }\n        return getExtension(fileName).equals(extension);\n    }",
    "begin_line": 1024,
    "end_line": 1034,
    "comment": "/** \n * Checks whether the extension of the fileName is that specified. \u003cp\u003e This method obtains the extension as the textual part of the fileName after the last dot. There must be no directory separator after the dot. The extension check is case-sensitive on all platforms.\n * @param fileName  the fileName to query, null returns false\n * @param extension  the extension to check for, null or empty checks for no extension\n * @return true if the fileName has the specified extension\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isExtension#1048",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isExtension(java.lang.String, java.lang.String)",
    "snippet": "public static boolean isExtension(final String fileName, final String... extensions) {\n        if (fileName \u003d\u003d null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions \u003d\u003d null || extensions.length \u003d\u003d 0) {\n            return indexOfExtension(fileName) \u003d\u003d NOT_FOUND;\n        }\n        final String fileExt \u003d getExtension(fileName);\n        return Stream.of(extensions).anyMatch(fileExt::equals);\n    }",
    "begin_line": 1048,
    "end_line": 1059,
    "comment": "/** \n * Checks whether the extension of the fileName is one of those specified. \u003cp\u003e This method obtains the extension as the textual part of the fileName after the last dot. There must be no directory separator after the dot. The extension check is case-sensitive on all platforms.\n * @param fileName  the fileName to query, null returns false\n * @param extensions  the extensions to check for, null checks for no extension\n * @return true if the fileName is one of the extensions\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isIPv4Address#1068",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isIPv4Address(java.lang.String)",
    "snippet": " isIPv4Address(final String name) {\n        final Matcher m \u003d IPV4_PATTERN.matcher(name);\n        if (!m.matches() || m.groupCount() !\u003d 4) {\n            return false;\n        }\n\n        // verify that address subgroups are legal\n        for (int i \u003d 1; i \u003c\u003d 4; i++) {\n            final String ipSegment \u003d m.group(i);\n            final int iIpSegment \u003d Integer.parseInt(ipSegment);\n            if (iIpSegment \u003e IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n\n            if (ipSegment.length() \u003e 1 \u0026\u0026 ipSegment.startsWith(\"0\")) {\n                return false;\n            }\n\n        }\n\n        return true;\n    }",
    "begin_line": 1068,
    "end_line": 1089,
    "comment": "/** \n * Checks whether a given string represents a valid IPv4 address.\n * @param name the name to validate\n * @return true if the given name is a valid IPv4 address\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isIPv6Address#1098",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isIPv6Address(java.lang.String)",
    "snippet": "private static boolean isIPv6Address(final String inet6Address) {\n        final boolean containsCompressedZeroes \u003d inet6Address.contains(\"::\");\n        if (containsCompressedZeroes \u0026\u0026 inet6Address.indexOf(\"::\") !\u003d inet6Address.lastIndexOf(\"::\")) {\n            return false;\n        }\n        if (inet6Address.startsWith(\":\") \u0026\u0026 !inet6Address.startsWith(\"::\")\n                || inet6Address.endsWith(\":\") \u0026\u0026 !inet6Address.endsWith(\"::\")) {\n            return false;\n        }\n        String[] octets \u003d inet6Address.split(\":\");\n        if (containsCompressedZeroes) {\n            final List\u003cString\u003e octetList \u003d new ArrayList\u003c\u003e(Arrays.asList(octets));\n            if (inet6Address.endsWith(\"::\")) {\n                // String.split() drops ending empty segments\n                octetList.add(\"\");\n            } else if (inet6Address.startsWith(\"::\") \u0026\u0026 !octetList.isEmpty()) {\n                octetList.remove(0);\n            }\n            octets \u003d octetList.toArray(EMPTY_STRING_ARRAY);\n        }\n        if (octets.length \u003e IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n        int validOctets \u003d 0;\n        int emptyOctets \u003d 0; // consecutive empty chunks\n        for (int index \u003d 0; index \u003c octets.length; index++) {\n            final String octet \u003d octets[index];\n            if (octet.isEmpty()) {\n                emptyOctets++;\n                if (emptyOctets \u003e 1) {\n                    return false;\n                }\n            } else {\n                emptyOctets \u003d 0;\n                // Is last chunk an IPv4 address?\n                if (index \u003d\u003d octets.length - 1 \u0026\u0026 octet.contains(\".\")) {\n                    if (!isIPv4Address(octet)) {\n                        return false;\n                    }\n                    validOctets +\u003d 2;\n                    continue;\n                }\n                if (octet.length() \u003e IPV6_MAX_HEX_DIGITS_PER_GROUP) {\n                    return false;\n                }\n                final int octetInt;\n                try {\n                    octetInt \u003d Integer.parseInt(octet, BASE_16);\n                } catch (final NumberFormatException e) {\n                    return false;\n                }\n                if (octetInt \u003c 0 || octetInt \u003e MAX_UNSIGNED_SHORT) {\n                    return false;\n                }\n            }\n            validOctets++;\n        }\n        return validOctets \u003c\u003d IPV6_MAX_HEX_GROUPS \u0026\u0026 (validOctets \u003e\u003d IPV6_MAX_HEX_GROUPS || containsCompressedZeroes);\n    }",
    "begin_line": 1098,
    "end_line": 1156,
    "comment": "/** \n * Checks whether a given string represents a valid IPv6 address.\n * @param inet6Address the name to validate\n * @return true if the given name is a valid IPv6 address\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isRFC3986HostName#1166",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isRFC3986HostName(java.lang.String)",
    "snippet": "private static boolean isRFC3986HostName(final String name) {\n        final String[] parts \u003d name.split(\"\\\\.\", -1);\n        for (int i \u003d 0; i \u003c parts.length; i++) {\n            if (parts[i].isEmpty()) {\n                // trailing dot is legal, otherwise we\u0027ve hit a .. sequence\n                return i \u003d\u003d parts.length - 1;\n            }\n            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 1166,
    "end_line": 1178,
    "comment": "/** \n * Checks whether a given string is a valid host name according to RFC 3986 - not accepting IP addresses.\n * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n * @param name the hostname to validate\n * @return true if the given name is a valid host name\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isSeparator#1186",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isSeparator(char)",
    "snippet": "private static boolean isSeparator(final char ch) {\n        return ch \u003d\u003d UNIX_NAME_SEPARATOR || ch \u003d\u003d WINDOWS_NAME_SEPARATOR;\n    }",
    "begin_line": 1186,
    "end_line": 1188,
    "comment": "/** \n * Checks if the character is a separator.\n * @param ch  the character to check\n * @return true if it is a separator character\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isSystemWindows#1195",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isSystemWindows()",
    "snippet": "static boolean isSystemWindows() {\n        return SYSTEM_NAME_SEPARATOR \u003d\u003d WINDOWS_NAME_SEPARATOR;\n    }",
    "begin_line": 1195,
    "end_line": 1197,
    "comment": "/** \n * Determines if Windows file system is in use.\n * @return true if the system is Windows\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.isValidHostName#1211",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.isValidHostName(java.lang.String)",
    "snippet": "private static boolean isValidHostName(final String name) {\n        return isIPv6Address(name) || isRFC3986HostName(name);\n    }",
    "begin_line": 1211,
    "end_line": 1213,
    "comment": "/** \n * Checks whether a given string is a valid host name according to RFC 3986. \u003cp\u003eAccepted are IP addresses (v4 and v6) as well as what the RFC calls a \"reg-name\". Percent encoded names don\u0027t seem to be valid names in UNC paths.\u003c/p\u003e\n * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n * @param name the hostname to validate\n * @return true if the given name is a valid host name\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.normalize#1256",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.normalize(java.lang.String)",
    "snippet": "public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, true);\n    }",
    "begin_line": 1256,
    "end_line": 1258,
    "comment": "/** \n * Normalizes a path, removing double and single dot path steps. \u003cp\u003e This method normalizes a path to a standard format. The input may contain separators in either Unix or Windows format. The output will contain separators in the format of the system. \u003cp\u003e A trailing slash will be retained. A double slash will be merged to a single slash (but UNC names are handled). A single dot path segment will be removed. A double dot will cause that path segment and the one before to be removed. If the double dot has no parent path segment to work with,  {@code null}is returned. \u003cp\u003e The output will be the same on both Unix and Windows except for the separator character. \u003cpre\u003e /foo//               --\u0026gt;   /foo/ /foo/./              --\u0026gt;   /foo/ /foo/../bar          --\u0026gt;   /bar /foo/../bar/         --\u0026gt;   /bar/ /foo/../bar/../baz   --\u0026gt;   /baz //foo//./bar         --\u0026gt;   //foo/bar /../                 --\u0026gt;   null ../foo               --\u0026gt;   null foo/bar/..           --\u0026gt;   foo/ foo/../../bar        --\u0026gt;   null foo/../bar           --\u0026gt;   bar //server/foo/../bar  --\u0026gt;   //server/bar //server/../bar      --\u0026gt;   null C:\\foo\\..\\bar        --\u0026gt;   C:\\bar C:\\..\\bar            --\u0026gt;   null ~/foo/../bar/        --\u0026gt;   ~/bar/ ~/../bar             --\u0026gt;   null \u003c/pre\u003e (Note the file separator returned will be correct for Windows/Unix)\n * @param fileName  the fileName to normalize, null returns null\n * @return the normalized fileName, or null if invalid\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.normalize#1305",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.normalize(java.lang.String, boolean)",
    "snippet": "public static String normalize(final String fileName, final boolean unixSeparator) {\n        return doNormalize(fileName, toSeparator(unixSeparator), true);\n    }",
    "begin_line": 1305,
    "end_line": 1307,
    "comment": "/** \n * Normalizes a path, removing double and single dot path steps. \u003cp\u003e This method normalizes a path to a standard format. The input may contain separators in either Unix or Windows format. The output will contain separators in the format specified. \u003cp\u003e A trailing slash will be retained. A double slash will be merged to a single slash (but UNC names are handled). A single dot path segment will be removed. A double dot will cause that path segment and the one before to be removed. If the double dot has no parent path segment to work with,  {@code null}is returned. \u003cp\u003e The output will be the same on both Unix and Windows except for the separator character. \u003cpre\u003e /foo//               --\u0026gt;   /foo/ /foo/./              --\u0026gt;   /foo/ /foo/../bar          --\u0026gt;   /bar /foo/../bar/         --\u0026gt;   /bar/ /foo/../bar/../baz   --\u0026gt;   /baz //foo//./bar         --\u0026gt;   /foo/bar /../                 --\u0026gt;   null ../foo               --\u0026gt;   null foo/bar/..           --\u0026gt;   foo/ foo/../../bar        --\u0026gt;   null foo/../bar           --\u0026gt;   bar //server/foo/../bar  --\u0026gt;   //server/bar //server/../bar      --\u0026gt;   null C:\\foo\\..\\bar        --\u0026gt;   C:\\bar C:\\..\\bar            --\u0026gt;   null ~/foo/../bar/        --\u0026gt;   ~/bar/ ~/../bar             --\u0026gt;   null \u003c/pre\u003e The output will be the same on both Unix and Windows including the separator character.\n * @param fileName  the fileName to normalize, null returns null\n * @param unixSeparator {@code true} if a Unix separator shouldbe used or  {@code false} if a Windows separator should be used.\n * @return the normalized fileName, or null if invalid\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.normalizeNoEndSeparator#1351",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.normalizeNoEndSeparator(java.lang.String)",
    "snippet": "public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, false);\n    }",
    "begin_line": 1351,
    "end_line": 1353,
    "comment": "/** \n * Normalizes a path, removing double and single dot path steps, and removing any final directory separator. \u003cp\u003e This method normalizes a path to a standard format. The input may contain separators in either Unix or Windows format. The output will contain separators in the format of the system. \u003cp\u003e A trailing slash will be removed. A double slash will be merged to a single slash (but UNC names are handled). A single dot path segment will be removed. A double dot will cause that path segment and the one before to be removed. If the double dot has no parent path segment to work with,  {@code null}is returned. \u003cp\u003e The output will be the same on both Unix and Windows except for the separator character. \u003cpre\u003e /foo//               --\u0026gt;   /foo /foo/./              --\u0026gt;   /foo /foo/../bar          --\u0026gt;   /bar /foo/../bar/         --\u0026gt;   /bar /foo/../bar/../baz   --\u0026gt;   /baz //foo//./bar         --\u0026gt;   /foo/bar /../                 --\u0026gt;   null ../foo               --\u0026gt;   null foo/bar/..           --\u0026gt;   foo foo/../../bar        --\u0026gt;   null foo/../bar           --\u0026gt;   bar //server/foo/../bar  --\u0026gt;   //server/bar //server/../bar      --\u0026gt;   null C:\\foo\\..\\bar        --\u0026gt;   C:\\bar C:\\..\\bar            --\u0026gt;   null ~/foo/../bar/        --\u0026gt;   ~/bar ~/../bar             --\u0026gt;   null \u003c/pre\u003e (Note the file separator returned will be correct for Windows/Unix)\n * @param fileName  the fileName to normalize, null returns null\n * @return the normalized fileName, or null if invalid\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.normalizeNoEndSeparator#1399",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.normalizeNoEndSeparator(java.lang.String, boolean)",
    "snippet": "public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         return doNormalize(fileName, toSeparator(unixSeparator), false);\n    }",
    "begin_line": 1399,
    "end_line": 1401,
    "comment": "/** \n * Normalizes a path, removing double and single dot path steps, and removing any final directory separator. \u003cp\u003e This method normalizes a path to a standard format. The input may contain separators in either Unix or Windows format. The output will contain separators in the format specified. \u003cp\u003e A trailing slash will be removed. A double slash will be merged to a single slash (but UNC names are handled). A single dot path segment will be removed. A double dot will cause that path segment and the one before to be removed. If the double dot has no parent path segment to work with,  {@code null}is returned. \u003cp\u003e The output will be the same on both Unix and Windows including the separator character. \u003cpre\u003e /foo//               --\u0026gt;   /foo /foo/./              --\u0026gt;   /foo /foo/../bar          --\u0026gt;   /bar /foo/../bar/         --\u0026gt;   /bar /foo/../bar/../baz   --\u0026gt;   /baz //foo//./bar         --\u0026gt;   /foo/bar /../                 --\u0026gt;   null ../foo               --\u0026gt;   null foo/bar/..           --\u0026gt;   foo foo/../../bar        --\u0026gt;   null foo/../bar           --\u0026gt;   bar //server/foo/../bar  --\u0026gt;   //server/bar //server/../bar      --\u0026gt;   null C:\\foo\\..\\bar        --\u0026gt;   C:\\bar C:\\..\\bar            --\u0026gt;   null ~/foo/../bar/        --\u0026gt;   ~/bar ~/../bar             --\u0026gt;   null \u003c/pre\u003e\n * @param fileName  the fileName to normalize, null returns null\n * @param unixSeparator {@code true} if a Unix separator shouldbe used or  {@code false} if a Windows separator should be used.\n * @return the normalized fileName, or null if invalid\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.removeExtension#1421",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.removeExtension(java.lang.String)",
    "snippet": "public static String removeExtension(final String fileName) {\n        if (fileName \u003d\u003d null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n\n        final int index \u003d indexOfExtension(fileName);\n        if (index \u003d\u003d NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }",
    "begin_line": 1421,
    "end_line": 1432,
    "comment": "/** \n * Removes the extension from a fileName. \u003cp\u003e This method returns the textual part of the fileName before the last dot. There must be no directory separator after the dot. \u003cpre\u003e foo.txt    --\u0026gt; foo a\\b\\c.jpg  --\u0026gt; a\\b\\c a\\b\\c      --\u0026gt; a\\b\\c a.b\\c      --\u0026gt; a.b\\c \u003c/pre\u003e \u003cp\u003e The output will be the same irrespective of the machine that the code is running on.\n * @param fileName  the fileName to query, null returns null\n * @return the fileName minus the extension\n * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.requireNonNullChars#1443",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.requireNonNullChars(java.lang.String)",
    "snippet": "private static String requireNonNullChars(final String path) {\n        if (path.indexOf(0) \u003e\u003d 0) {\n            throw new IllegalArgumentException(\n                \"Null character present in file/path name. There are no known legitimate use cases for such data, but several injection attacks may use it\");\n        }\n        return path;\n    }",
    "begin_line": 1443,
    "end_line": 1449,
    "comment": "/** \n * Checks the input for null characters ( {@code U+0000}), a sign of unsanitized data being passed to file level functions. This may be used for poison byte attacks.\n * @param path the path to check\n * @return The input\n * @throws IllegalArgumentException if path contains the null character ({@code U+0000})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.separatorsToSystem#1457",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.separatorsToSystem(java.lang.String)",
    "snippet": "public static String separatorsToSystem(final String path) {\n        return FileSystem.getCurrent().normalizeSeparators(path);\n    }",
    "begin_line": 1457,
    "end_line": 1459,
    "comment": "/** \n * Converts all separators to the system separator.\n * @param path the path to be changed, null ignored.\n * @return the updated path.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.separatorsToUnix#1467",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.separatorsToUnix(java.lang.String)",
    "snippet": "public static String separatorsToUnix(final String path) {\n        return FileSystem.LINUX.normalizeSeparators(path);\n    }",
    "begin_line": 1467,
    "end_line": 1469,
    "comment": "/** \n * Converts all separators to the Unix separator of forward slash.\n * @param path the path to be changed, null ignored.\n * @return the new path.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.separatorsToWindows#1477",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.separatorsToWindows(java.lang.String)",
    "snippet": "public static String separatorsToWindows(final String path) {\n        return FileSystem.WINDOWS.normalizeSeparators(path);\n    }",
    "begin_line": 1477,
    "end_line": 1479,
    "comment": "/** \n * Converts all separators to the Windows separator of backslash.\n * @param path the path to be changed, null ignored.\n * @return the updated path.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.splitOnTokens#1489",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.splitOnTokens(java.lang.String)",
    "snippet": "static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf(\u0027?\u0027) \u003d\u003d NOT_FOUND \u0026\u0026 text.indexOf(\u0027*\u0027) \u003d\u003d NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array \u003d text.toCharArray();\n        final ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        final StringBuilder buffer \u003d new StringBuilder();\n        char prevChar \u003d 0;\n        for (final char ch : array) {\n            if (ch \u003d\u003d \u0027?\u0027 || ch \u003d\u003d \u0027*\u0027) {\n                if (buffer.length() !\u003d 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch \u003d\u003d \u0027?\u0027) {\n                    list.add(\"?\");\n                } else if (prevChar !\u003d \u0027*\u0027) {// ch \u003d\u003d \u0027*\u0027 here; check if previous char was \u0027*\u0027\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar \u003d ch;\n        }\n        if (buffer.length() !\u003d 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray(EMPTY_STRING_ARRAY);\n    }",
    "begin_line": 1489,
    "end_line": 1522,
    "comment": "/** \n * Splits a string into a number of tokens. The text is split by \u0027?\u0027 and \u0027*\u0027. Where multiple \u0027*\u0027 occur consecutively they are collapsed into a single \u0027*\u0027.\n * @param text  the text to split\n * @return the array of tokens, never null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.toSeparator#1530",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.toSeparator(boolean)",
    "snippet": "private static char toSeparator(final boolean unixSeparator) {\n        return unixSeparator ? UNIX_NAME_SEPARATOR : WINDOWS_NAME_SEPARATOR;\n    }",
    "begin_line": 1530,
    "end_line": 1532,
    "comment": "/** \n * Returns \u0027/\u0027 if given true, \u0027\\\\\u0027 otherwise.\n * @param unixSeparator which separator to return.\n * @return \u0027/\u0027 if given true, \u0027\\\\\u0027 otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.wildcardMatch#1556",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.wildcardMatch(java.lang.String, java.lang.String)",
    "snippet": "public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }",
    "begin_line": 1556,
    "end_line": 1558,
    "comment": "/** \n * Checks a fileName to see if it matches the specified wildcard matcher, always testing case-sensitive. \u003cp\u003e The wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a single or multiple (zero or more) wildcard characters. This is the same as often found on DOS/Unix command lines. The check is case-sensitive always. \u003cpre\u003e wildcardMatch(\"c.txt\", \"*.txt\")      --\u0026gt; true wildcardMatch(\"c.txt\", \"*.jpg\")      --\u0026gt; false wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u0026gt; true wildcardMatch(\"c.txt\", \"*.???\")      --\u0026gt; true wildcardMatch(\"c.txt\", \"*.????\")     --\u0026gt; false \u003c/pre\u003e N.B. the sequence \"*?\" does not work properly at present in match strings.\n * @param fileName  the fileName to match on\n * @param wildcardMatcher  the wildcard string to match against\n * @return true if the fileName matches the wildcard string\n * @see IOCase#SENSITIVE\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.wildcardMatch#1574",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.wildcardMatch(java.lang.String, java.lang.String, org.apache.commons.io.IOCase)",
    "snippet": "public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase ioCase) {\n        if (fileName \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n            return true;\n        }\n        if (fileName \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n            return false;\n        }\n        ioCase \u003d IOCase.value(ioCase, IOCase.SENSITIVE);\n        final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n        boolean anyChars \u003d false;\n        int textIdx \u003d 0;\n        int wcsIdx \u003d 0;\n        final Deque\u003cint[]\u003e backtrack \u003d new ArrayDeque\u003c\u003e(wcs.length);\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (!backtrack.isEmpty()) {\n                final int[] array \u003d backtrack.pop();\n                wcsIdx \u003d array[0];\n                textIdx \u003d array[1];\n                anyChars \u003d true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx \u003c wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx \u003e fileName.length()) {\n                        break;\n                    }\n                    anyChars \u003d false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars \u003d true;\n                    if (wcsIdx \u003d\u003d wcs.length - 1) {\n                        textIdx \u003d fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx \u003d ioCase.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx \u003d\u003d NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat \u003d ioCase.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat \u003e\u003d 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else if (!ioCase.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        // matching from current position\n                        // couldn\u0027t match token\n                        break;\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx +\u003d wcs[wcsIdx].length();\n                    anyChars \u003d false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d fileName.length()) {\n                return true;\n            }\n\n        } while (!backtrack.isEmpty());\n\n        return false;\n    }",
    "begin_line": 1574,
    "end_line": 1650,
    "comment": "/** \n * Checks a fileName to see if it matches the specified wildcard matcher allowing control over case-sensitivity. \u003cp\u003e The wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a single or multiple (zero or more) wildcard characters. N.B. the sequence \"*?\" does not work properly at present in match strings.\n * @param fileName  the fileName to match on\n * @param wildcardMatcher  the wildcard string to match against\n * @param ioCase  what case sensitivity rule to use, null means case-sensitive\n * @return true if the fileName matches the wildcard string\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.wildcardMatchOnSystem#1674",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.wildcardMatchOnSystem(java.lang.String, java.lang.String)",
    "snippet": "public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }",
    "begin_line": 1674,
    "end_line": 1676,
    "comment": "/** \n * Checks a fileName to see if it matches the specified wildcard matcher using the case rules of the system. \u003cp\u003e The wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a single or multiple (zero or more) wildcard characters. This is the same as often found on DOS/Unix command lines. The check is case-sensitive on Unix and case-insensitive on Windows. \u003cpre\u003e wildcardMatch(\"c.txt\", \"*.txt\")      --\u0026gt; true wildcardMatch(\"c.txt\", \"*.jpg\")      --\u0026gt; false wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u0026gt; true wildcardMatch(\"c.txt\", \"*.???\")      --\u0026gt; true wildcardMatch(\"c.txt\", \"*.????\")     --\u0026gt; false \u003c/pre\u003e N.B. the sequence \"*?\" does not work properly at present in match strings.\n * @param fileName  the fileName to match on\n * @param wildcardMatcher  the wildcard string to match against\n * @return true if the fileName matches the wildcard string\n * @see IOCase#SYSTEM\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FilenameUtils.FilenameUtils#1681",
    "is_bug": true,
    "src_path": "org/apache/commons/io/FilenameUtils.java",
    "class_name": "org.apache.commons.io.FilenameUtils",
    "signature": "org.apache.commons.io.FilenameUtils.FilenameUtils()",
    "snippet": "public FilenameUtils() {\n    }",
    "begin_line": 1681,
    "end_line": 1682,
    "comment": "/** \n * Instances should NOT be constructed in standard programming.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.forName#78",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.forName(java.lang.String)",
    "snippet": "public static IOCase forName(final String name) {\n        return Stream.of(IOCase.values()).filter(ioCase -\u003e ioCase.getName().equals(name)).findFirst()\n                .orElseThrow(() -\u003e new IllegalArgumentException(\"Illegal IOCase name: \" + name));\n    }",
    "begin_line": 78,
    "end_line": 81,
    "comment": "/** \n * Factory method to create an IOCase from a name.\n * @param name  the name to find\n * @return the IOCase object\n * @throws IllegalArgumentException if the name is invalid\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isCaseSensitive#90",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.isCaseSensitive(org.apache.commons.io.IOCase)",
    "snippet": "public static boolean isCaseSensitive(final IOCase ioCase) {\n        return ioCase !\u003d null \u0026\u0026 ioCase.isCaseSensitive();\n    }",
    "begin_line": 90,
    "end_line": 92,
    "comment": "/** \n * Tests for cases sensitivity in a null-safe manner.\n * @param ioCase an IOCase.\n * @return true if the input is non-null and {@link #isCaseSensitive()}.\n * @since 2.10.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.value#102",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.value(org.apache.commons.io.IOCase, org.apache.commons.io.IOCase)",
    "snippet": "public static IOCase value(final IOCase value, final IOCase defaultValue) {\n        return value !\u003d null ? value : defaultValue;\n    }",
    "begin_line": 102,
    "end_line": 104,
    "comment": "/** \n * Returns the given value if not-null, the defaultValue if null.\n * @param value the value to test.\n * @param defaultValue the default value.\n * @return the given value if not-null, the defaultValue if null.\n * @since 2.12.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.IOCase#118",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.IOCase(java.lang.String, boolean)",
    "snippet": " IOCase(final String name, final boolean sensitive) {\n        this.name \u003d name;\n        this.sensitive \u003d sensitive;\n    }",
    "begin_line": 118,
    "end_line": 121,
    "comment": "/** \n * Constructs a new instance.\n * @param name  the name\n * @param sensitive  the sensitivity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkCompareTo#135",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkCompareTo(java.lang.String, java.lang.String)",
    "snippet": "public int checkCompareTo(final String str1, final String str2) {\n        Objects.requireNonNull(str1, \"str1\");\n        Objects.requireNonNull(str2, \"str2\");\n        return sensitive ? str1.compareTo(str2) : str1.compareToIgnoreCase(str2);\n    }",
    "begin_line": 135,
    "end_line": 139,
    "comment": "/** \n * Compares two strings using the case-sensitivity rule. \u003cp\u003e This method mimics  {@link String#compareTo} but takes case-sensitivityinto account. \u003c/p\u003e\n * @param str1  the first string to compare, not null\n * @param str2  the second string to compare, not null\n * @return true if equal using the case rules\n * @throws NullPointerException if either string is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkEndsWith#152",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkEndsWith(java.lang.String, java.lang.String)",
    "snippet": "public boolean checkEndsWith(final String str, final String end) {\n        if (str \u003d\u003d null || end \u003d\u003d null) {\n            return false;\n        }\n        final int endLen \u003d end.length();\n        return str.regionMatches(!sensitive, str.length() - endLen, end, 0, endLen);\n    }",
    "begin_line": 152,
    "end_line": 158,
    "comment": "/** \n * Checks if one string ends with another using the case-sensitivity rule. \u003cp\u003e This method mimics  {@link String#endsWith} but takes case-sensitivityinto account. \u003c/p\u003e\n * @param str  the string to check\n * @param end  the end to compare against\n * @return true if equal using the case rules, false if either input is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkEquals#171",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkEquals(java.lang.String, java.lang.String)",
    "snippet": "public boolean checkEquals(final String str1, final String str2) {\n        return str1 \u003d\u003d str2 || str1 !\u003d null \u0026\u0026 (sensitive ? str1.equals(str2) : str1.equalsIgnoreCase(str2));\n    }",
    "begin_line": 171,
    "end_line": 173,
    "comment": "/** \n * Compares two strings using the case-sensitivity rule. \u003cp\u003e This method mimics  {@link String#equals} but takes case-sensitivityinto account. \u003c/p\u003e\n * @param str1  the first string to compare, not null\n * @param str2  the second string to compare, not null\n * @return true if equal using the case rules\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkIndexOf#191",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkIndexOf(java.lang.String, int, java.lang.String)",
    "snippet": "public int checkIndexOf(final String str, final int strStartIndex, final String search) {\n        final int endIndex \u003d str.length() - search.length();\n        if (endIndex \u003e\u003d strStartIndex) {\n            for (int i \u003d strStartIndex; i \u003c\u003d endIndex; i++) {\n                if (checkRegionMatches(str, i, search)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }",
    "begin_line": 191,
    "end_line": 201,
    "comment": "/** \n * Checks if one string contains another starting at a specific index using the case-sensitivity rule. \u003cp\u003e This method mimics parts of  {@link String#indexOf(String,int)}but takes case-sensitivity into account. \u003c/p\u003e\n * @param str  the string to check, not null\n * @param strStartIndex  the index to start at in str\n * @param search  the start to search for, not null\n * @return the first index of the search String,-1 if no match or  {@code null} string input\n * @throws NullPointerException if either string is null\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkRegionMatches#216",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkRegionMatches(java.lang.String, int, java.lang.String)",
    "snippet": "public boolean checkRegionMatches(final String str, final int strStartIndex, final String search) {\n        return str.regionMatches(!sensitive, strStartIndex, search, 0, search.length());\n    }",
    "begin_line": 216,
    "end_line": 218,
    "comment": "/** \n * Checks if one string contains another at a specific index using the case-sensitivity rule. \u003cp\u003e This method mimics parts of  {@link String#regionMatches(boolean,int,String,int,int)}but takes case-sensitivity into account. \u003c/p\u003e\n * @param str  the string to check, not null\n * @param strStartIndex  the index to start at in str\n * @param search  the start to search for, not null\n * @return true if equal using the case rules\n * @throws NullPointerException if either string is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.checkStartsWith#231",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.checkStartsWith(java.lang.String, java.lang.String)",
    "snippet": "public boolean checkStartsWith(final String str, final String start) {\n        return str !\u003d null \u0026\u0026 start !\u003d null \u0026\u0026 str.regionMatches(!sensitive, 0, start, 0, start.length());\n    }",
    "begin_line": 231,
    "end_line": 233,
    "comment": "/** \n * Checks if one string starts with another using the case-sensitivity rule. \u003cp\u003e This method mimics  {@link String#startsWith(String)} but takes case-sensitivityinto account. \u003c/p\u003e\n * @param str  the string to check\n * @param start  the start to compare against\n * @return true if equal using the case rules, false if either input is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getName#240",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.getName()",
    "snippet": "public String getName() {\n        return name;\n    }",
    "begin_line": 240,
    "end_line": 242,
    "comment": "/** \n * Gets the name of the constant.\n * @return the name of the constant\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.isCaseSensitive#249",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.isCaseSensitive()",
    "snippet": "public boolean isCaseSensitive() {\n        return sensitive;\n    }",
    "begin_line": 249,
    "end_line": 251,
    "comment": "/** \n * Does the object represent case-sensitive comparison.\n * @return true if case-sensitive\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.readResolve#259",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.readResolve()",
    "snippet": "private Object readResolve() {\n        return forName(name);\n    }",
    "begin_line": 259,
    "end_line": 261,
    "comment": "/** \n * Replaces the enumeration from the stream with a real one. This ensures that the correct flag is set for SYSTEM.\n * @return the resolved object\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.toString#269",
    "is_bug": true,
    "src_path": "org/apache/commons/io/IOCase.java",
    "class_name": "org.apache.commons.io.IOCase",
    "signature": "org.apache.commons.io.IOCase.toString()",
    "snippet": "@Override\n    public String toString() {\n        return name;\n    }",
    "begin_line": 269,
    "end_line": 271,
    "comment": "/** \n * Gets a string describing the sensitivity.\n * @return a string describing the sensitivity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]