[
  {
    "name": "ComparableObjectItem.ComparableObjectItem#72",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectItem.java",
    "class_name": "org.jfree.data.ComparableObjectItem",
    "signature": "org.jfree.data.ComparableObjectItem.ComparableObjectItem(java.lang.Comparable, java.lang.Object)",
    "snippet": "public ComparableObjectItem(Comparable x, Object y) {\r\n        if (x \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027x\u0027 argument.\");\r\n        }\r\n        this.x \u003d x;\r\n        this.obj \u003d y;\r\n    }",
    "begin_line": 72,
    "end_line": 78,
    "comment": "/** \n * Constructs a new data item.\n * @param x  the x-value (\u003ccode\u003enull\u003c/code\u003e NOT permitted).\n * @param y  the y-value (\u003ccode\u003enull\u003c/code\u003e permitted).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectItem.getComparable#85",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectItem.java",
    "class_name": "org.jfree.data.ComparableObjectItem",
    "signature": "org.jfree.data.ComparableObjectItem.getComparable()",
    "snippet": "protected Comparable getComparable() {\r\n        return this.x;\r\n    }",
    "begin_line": 85,
    "end_line": 87,
    "comment": "/** \n * Returns the x-value.\n * @return The x-value (never \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectItem.getObject#94",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectItem.java",
    "class_name": "org.jfree.data.ComparableObjectItem",
    "signature": "org.jfree.data.ComparableObjectItem.getObject()",
    "snippet": "protected Object getObject() {\r\n        return this.obj;\r\n    }",
    "begin_line": 94,
    "end_line": 96,
    "comment": "/** \n * Returns the y-value.\n * @return The y-value (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectItem.setObject#104",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectItem.java",
    "class_name": "org.jfree.data.ComparableObjectItem",
    "signature": "org.jfree.data.ComparableObjectItem.setObject(java.lang.Object)",
    "snippet": "protected void setObject(Object y) {\r\n        this.obj \u003d y;\r\n    }",
    "begin_line": 104,
    "end_line": 106,
    "comment": "/** \n * Sets the y-value for this data item.  Note that there is no corresponding method to change the x-value.\n * @param y  the new y-value (\u003ccode\u003enull\u003c/code\u003e permitted).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectItem.compareTo#120",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectItem.java",
    "class_name": "org.jfree.data.ComparableObjectItem",
    "signature": "org.jfree.data.ComparableObjectItem.compareTo(java.lang.Object)",
    "snippet": "public int compareTo(Object o1) {\r\n\r\n        int result;\r\n\r\n        // CASE 1 : Comparing to another ComparableObjectItem object\r\n        // ---------------------------------------------------------\r\n        if (o1 instanceof ComparableObjectItem) {\r\n            ComparableObjectItem that \u003d (ComparableObjectItem) o1;\r\n            return this.x.compareTo(that.x);\r\n        }\r\n\r\n        // CASE 2 : Comparing to a general object\r\n        // ---------------------------------------------\r\n        else {\r\n            // consider these to be ordered after general objects\r\n            result \u003d 1;\r\n        }\r\n\r\n        return result;\r\n\r\n    }",
    "begin_line": 120,
    "end_line": 140,
    "comment": "/** \n * Returns an integer indicating the order of this object relative to another object. \u003cP\u003e For the order we consider only the x-value: negative \u003d\u003d \"less-than\", zero \u003d\u003d \"equal\", positive \u003d\u003d \"greater-than\".\n * @param o1  the object being compared to.\n * @return An integer indicating the order of this data pair objectrelative to another object.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectItem.clone#150",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectItem.java",
    "class_name": "org.jfree.data.ComparableObjectItem",
    "signature": "org.jfree.data.ComparableObjectItem.clone()",
    "snippet": "public Object clone() throws CloneNotSupportedException {\r\n        return super.clone();\r\n    }",
    "begin_line": 150,
    "end_line": 152,
    "comment": "/** \n * Returns a clone of this object.\n * @return A clone.\n * @throws CloneNotSupportedException not thrown by this class, butsubclasses may differ.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectItem.equals#162",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectItem.java",
    "class_name": "org.jfree.data.ComparableObjectItem",
    "signature": "org.jfree.data.ComparableObjectItem.equals(java.lang.Object)",
    "snippet": "public boolean equals(Object obj) {\r\n        if (obj \u003d\u003d this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof ComparableObjectItem)) {\r\n            return false;\r\n        }\r\n        ComparableObjectItem that \u003d (ComparableObjectItem) obj;\r\n        if (!this.x.equals(that.x)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.obj, that.obj)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }",
    "begin_line": 162,
    "end_line": 177,
    "comment": "/** \n * Tests if this object is equal to another.\n * @param obj  the object to test against for equality (\u003ccode\u003enull\u003c/code\u003epermitted).\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectItem.hashCode#184",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectItem.java",
    "class_name": "org.jfree.data.ComparableObjectItem",
    "signature": "org.jfree.data.ComparableObjectItem.hashCode()",
    "snippet": "public int hashCode() {\r\n        int result;\r\n        result \u003d this.x.hashCode();\r\n        result \u003d 29 * result + (this.obj !\u003d null ? this.obj.hashCode() : 0);\r\n        return result;\r\n    }",
    "begin_line": 184,
    "end_line": 189,
    "comment": "/** \n * Returns a hash code.\n * @return A hash code.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.ComparableObjectSeries#82",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.ComparableObjectSeries(java.lang.Comparable)",
    "snippet": "public ComparableObjectSeries(Comparable key) {\r\n        this(key, true, true);\r\n    }",
    "begin_line": 82,
    "end_line": 84,
    "comment": "/** \n * Creates a new empty series.  By default, items added to the series will be sorted into ascending order by x-value, and duplicate x-values will be allowed (these defaults can be modified with another constructor.\n * @param key  the series key (\u003ccode\u003enull\u003c/code\u003e not permitted).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.ComparableObjectSeries#96",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.ComparableObjectSeries(java.lang.Comparable, boolean, boolean)",
    "snippet": "public ComparableObjectSeries(Comparable key, boolean autoSort,\r\n            boolean allowDuplicateXValues) {\r\n        super(key);\r\n        this.data \u003d new java.util.ArrayList();\r\n        this.autoSort \u003d autoSort;\r\n        this.allowDuplicateXValues \u003d allowDuplicateXValues;\r\n    }",
    "begin_line": 96,
    "end_line": 102,
    "comment": "/** \n * Constructs a new series that contains no data.  You can specify whether or not duplicate x-values are allowed for the series.\n * @param key  the series key (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param autoSort  a flag that controls whether or not the items in theseries are sorted.\n * @param allowDuplicateXValues  a flag that controls whether duplicatex-values are allowed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.getAutoSort#111",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.getAutoSort()",
    "snippet": "public boolean getAutoSort() {\r\n        return this.autoSort;\r\n    }",
    "begin_line": 111,
    "end_line": 113,
    "comment": "/** \n * Returns the flag that controls whether the items in the series are automatically sorted.  There is no setter for this flag, it must be defined in the series constructor.\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.getAllowDuplicateXValues#121",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.getAllowDuplicateXValues()",
    "snippet": "public boolean getAllowDuplicateXValues() {\r\n        return this.allowDuplicateXValues;\r\n    }",
    "begin_line": 121,
    "end_line": 123,
    "comment": "/** \n * Returns a flag that controls whether duplicate x-values are allowed. This flag can only be set in the constructor.\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.getItemCount#130",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.getItemCount()",
    "snippet": "public int getItemCount() {\r\n        return this.data.size();\r\n    }",
    "begin_line": 130,
    "end_line": 132,
    "comment": "/** \n * Returns the number of items in the series.\n * @return The item count.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.getMaximumItemCount#141",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.getMaximumItemCount()",
    "snippet": "public int getMaximumItemCount() {\r\n        return this.maximumItemCount;\r\n    }",
    "begin_line": 141,
    "end_line": 143,
    "comment": "/** \n * Returns the maximum number of items that will be retained in the series. The default value is \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n * @return The maximum item count.\n * @see #setMaximumItemCount(int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.setMaximumItemCount#159",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.setMaximumItemCount(int)",
    "snippet": "public void setMaximumItemCount(int maximum) {\r\n        this.maximumItemCount \u003d maximum;\r\n        boolean dataRemoved \u003d false;\r\n        while (this.data.size() \u003e maximum) {\r\n            this.data.remove(0);\r\n            dataRemoved \u003d true;\r\n        }\r\n        if (dataRemoved) {\r\n            fireSeriesChanged();\r\n        }\r\n    }",
    "begin_line": 159,
    "end_line": 169,
    "comment": "/** \n * Sets the maximum number of items that will be retained in the series. If you add a new item to the series such that the number of items will exceed the maximum item count, then the first element in the series is automatically removed, ensuring that the maximum item count is not exceeded. \u003cp\u003e Typically this value is set before the series is populated with data, but if it is applied later, it may cause some items to be removed from the series (in which case a  {@link SeriesChangeEvent} will be sent toall registered listeners.\n * @param maximum  the maximum number of items for the series.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.add#181",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.add(java.lang.Comparable, java.lang.Object)",
    "snippet": "protected void add(Comparable x, Object y) {\r\n        // argument checking delegated...\r\n        add(x, y, true);\r\n    }",
    "begin_line": 181,
    "end_line": 184,
    "comment": "/** \n * Adds new data to the series and sends a  {@link SeriesChangeEvent} toall registered listeners. \u003cP\u003e Throws an exception if the x-value is a duplicate AND the allowDuplicateXValues flag is false.\n * @param x  the x-value (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param y  the y-value (\u003ccode\u003enull\u003c/code\u003e permitted).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.add#199",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.add(java.lang.Comparable, java.lang.Object, boolean)",
    "snippet": "protected void add(Comparable x, Object y, boolean notify) {\r\n        // delegate argument checking to XYDataItem...\r\n        ComparableObjectItem item \u003d new ComparableObjectItem(x, y);\r\n        add(item, notify);\r\n    }",
    "begin_line": 199,
    "end_line": 203,
    "comment": "/** \n * Adds new data to the series and, if requested, sends a {@link SeriesChangeEvent} to all registered listeners.\u003cP\u003e Throws an exception if the x-value is a duplicate AND the allowDuplicateXValues flag is false.\n * @param x  the x-value (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param y  the y-value (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @param notify  a flag the controls whether or not a{@link SeriesChangeEvent} is sent to all registeredlisteners.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.add#214",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.add(org.jfree.data.ComparableObjectItem, boolean)",
    "snippet": "protected void add(ComparableObjectItem item, boolean notify) {\r\n\r\n        if (item \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027item\u0027 argument.\");\r\n        }\r\n\r\n        if (this.autoSort) {\r\n            int index \u003d Collections.binarySearch(this.data, item);\r\n            if (index \u003c 0) {\r\n                this.data.add(-index - 1, item);\r\n            }\r\n            else {\r\n                if (this.allowDuplicateXValues) {\r\n                    // need to make sure we are adding *after* any duplicates\r\n                    int size \u003d this.data.size();\r\n                    while (index \u003c size\r\n                           \u0026\u0026 item.compareTo(this.data.get(index)) \u003d\u003d 0) {\r\n                        index++;\r\n                    }\r\n                    if (index \u003c this.data.size()) {\r\n                        this.data.add(index, item);\r\n                    }\r\n                    else {\r\n                        this.data.add(item);\r\n                    }\r\n                }\r\n                else {\r\n                    throw new SeriesException(\"X-value already exists.\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (!this.allowDuplicateXValues) {\r\n                // can\u0027t allow duplicate values, so we need to check whether\r\n                // there is an item with the given x-value already\r\n                int index \u003d indexOf(item.getComparable());\r\n                if (index \u003e\u003d 0) {\r\n                    throw new SeriesException(\"X-value already exists.\");\r\n                }\r\n            }\r\n            this.data.add(item);\r\n        }\r\n        if (getItemCount() \u003e this.maximumItemCount) {\r\n            this.data.remove(0);\r\n        }\r\n        if (notify) {\r\n            fireSeriesChanged();\r\n        }\r\n    }",
    "begin_line": 214,
    "end_line": 262,
    "comment": "/** \n * Adds a data item to the series and, if requested, sends a {@link SeriesChangeEvent} to all registered listeners.\n * @param item  the (x, y) item (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param notify  a flag that controls whether or not a{@link SeriesChangeEvent} is sent to all registeredlisteners.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.indexOf#274",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.indexOf(java.lang.Comparable)",
    "snippet": "public int indexOf(Comparable x) {\r\n        if (this.autoSort) {\r\n            return Collections.binarySearch(this.data, new ComparableObjectItem(\r\n                    x, null));\r\n        }\r\n        else {\r\n            for (int i \u003d 0; i \u003c this.data.size(); i++) {\r\n                ComparableObjectItem item \u003d (ComparableObjectItem)\r\n                        this.data.get(i);\r\n                if (item.getComparable().equals(x)) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }",
    "begin_line": 274,
    "end_line": 289,
    "comment": "/** \n * Returns the index of the item with the specified x-value, or a negative index if the series does not contain an item with that x-value.  Be aware that for an unsorted series, the index is found by iterating through all items in the series.\n * @param x  the x-value (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The index.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.update#300",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.update(java.lang.Comparable, java.lang.Object)",
    "snippet": "protected void update(Comparable x, Object y) {\r\n        int index \u003d indexOf(x);\r\n        if (index \u003c 0) {\r\n            throw new SeriesException(\"No observation for x \u003d \" + x);\r\n        }\r\n        else {\r\n            ComparableObjectItem item \u003d getDataItem(index);\r\n            item.setObject(y);\r\n            fireSeriesChanged();\r\n        }\r\n    }",
    "begin_line": 300,
    "end_line": 310,
    "comment": "/** \n * Updates an item in the series.\n * @param x  the x-value (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param y  the y-value (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @throws SeriesException if there is no existing item with the specifiedx-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.updateByIndex#319",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.updateByIndex(int, java.lang.Object)",
    "snippet": "protected void updateByIndex(int index, Object y) {\r\n        ComparableObjectItem item \u003d getDataItem(index);\r\n        item.setObject(y);\r\n        fireSeriesChanged();\r\n    }",
    "begin_line": 319,
    "end_line": 323,
    "comment": "/** \n * Updates the value of an item in the series and sends a {@link SeriesChangeEvent} to all registered listeners.\n * @param index  the item (zero based index).\n * @param y  the new value (\u003ccode\u003enull\u003c/code\u003e permitted).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.getDataItem#332",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.getDataItem(int)",
    "snippet": "protected ComparableObjectItem getDataItem(int index) {\r\n        return (ComparableObjectItem) this.data.get(index);\r\n    }",
    "begin_line": 332,
    "end_line": 334,
    "comment": "/** \n * Return the data item with the specified index.\n * @param index  the index.\n * @return The data item with the specified index.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.delete#343",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.delete(int, int)",
    "snippet": "protected void delete(int start, int end) {\r\n        for (int i \u003d start; i \u003c\u003d end; i++) {\r\n            this.data.remove(start);\r\n        }\r\n        fireSeriesChanged();\r\n    }",
    "begin_line": 343,
    "end_line": 348,
    "comment": "/** \n * Deletes a range of items from the series and sends a {@link SeriesChangeEvent} to all registered listeners.\n * @param start  the start index (zero-based).\n * @param end  the end index (zero-based).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.clear#355",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.clear()",
    "snippet": "public void clear() {\r\n        if (this.data.size() \u003e 0) {\r\n            this.data.clear();\r\n            fireSeriesChanged();\r\n        }\r\n    }",
    "begin_line": 355,
    "end_line": 360,
    "comment": "/** \n * Removes all data items from the series and, unless the series is already empty, sends a  {@link SeriesChangeEvent} to all registeredlisteners.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.remove#370",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.remove(int)",
    "snippet": "protected ComparableObjectItem remove(int index) {\r\n        ComparableObjectItem result \u003d (ComparableObjectItem) this.data.remove(\r\n                index);\r\n        fireSeriesChanged();\r\n        return result;\r\n    }",
    "begin_line": 370,
    "end_line": 375,
    "comment": "/** \n * Removes the item at the specified index and sends a {@link SeriesChangeEvent} to all registered listeners.\n * @param index  the index.\n * @return The item removed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.remove#385",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.remove(java.lang.Comparable)",
    "snippet": "public ComparableObjectItem remove(Comparable x) {\r\n        return remove(indexOf(x));\r\n    }",
    "begin_line": 385,
    "end_line": 387,
    "comment": "/** \n * Removes the item with the specified x-value and sends a {@link SeriesChangeEvent} to all registered listeners.\n * @param x  the x-value.\n * @return The item removed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.equals#397",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.equals(java.lang.Object)",
    "snippet": "public boolean equals(Object obj) {\r\n        if (obj \u003d\u003d this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof ComparableObjectSeries)) {\r\n            return false;\r\n        }\r\n        if (!super.equals(obj)) {\r\n            return false;\r\n        }\r\n        ComparableObjectSeries that \u003d (ComparableObjectSeries) obj;\r\n        if (this.maximumItemCount !\u003d that.maximumItemCount) {\r\n            return false;\r\n        }\r\n        if (this.autoSort !\u003d that.autoSort) {\r\n            return false;\r\n        }\r\n        if (this.allowDuplicateXValues !\u003d that.allowDuplicateXValues) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.data, that.data)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }",
    "begin_line": 397,
    "end_line": 421,
    "comment": "/** \n * Tests this series for equality with an arbitrary object.\n * @param obj  the object to test against for equality(\u003ccode\u003enull\u003c/code\u003e permitted).\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ComparableObjectSeries.hashCode#428",
    "is_bug": true,
    "src_path": "org/jfree/data/ComparableObjectSeries.java",
    "class_name": "org.jfree.data.ComparableObjectSeries",
    "signature": "org.jfree.data.ComparableObjectSeries.hashCode()",
    "snippet": "public int hashCode() {\r\n        int result \u003d super.hashCode();\r\n        // it is too slow to look at every data item, so let\u0027s just look at\r\n        // the first, middle and last items...\r\n        int count \u003d getItemCount();\r\n        if (count \u003e 0) {\r\n            ComparableObjectItem item \u003d getDataItem(0);\r\n            result \u003d 29 * result + item.hashCode();\r\n        }\r\n        if (count \u003e 1) {\r\n            ComparableObjectItem item \u003d getDataItem(count - 1);\r\n            result \u003d 29 * result + item.hashCode();\r\n        }\r\n        if (count \u003e 2) {\r\n            ComparableObjectItem item \u003d getDataItem(count / 2);\r\n            result \u003d 29 * result + item.hashCode();\r\n        }\r\n        result \u003d 29 * result + this.maximumItemCount;\r\n        result \u003d 29 * result + (this.autoSort ? 1 : 0);\r\n        result \u003d 29 * result + (this.allowDuplicateXValues ? 1 : 0);\r\n        return result;\r\n    }",
    "begin_line": 428,
    "end_line": 449,
    "comment": "/** \n * Returns a hash code.\n * @return A hash code.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetChangeEvent.DatasetChangeEvent#85",
    "is_bug": true,
    "src_path": "org/jfree/data/event/DatasetChangeEvent.java",
    "class_name": "org.jfree.data.event.DatasetChangeEvent",
    "signature": "org.jfree.data.event.DatasetChangeEvent.DatasetChangeEvent(java.lang.Object, org.jfree.data.general.Dataset, org.jfree.chart.event.DatasetChangeInfo)",
    "snippet": "public DatasetChangeEvent(Object source, Dataset dataset,\r\n            DatasetChangeInfo info) {\r\n        super(source);\r\n        if (info \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027info\u0027 argument.\");\r\n        }\r\n        this.dataset \u003d dataset;\r\n        this.info \u003d info;\r\n    }",
    "begin_line": 85,
    "end_line": 93,
    "comment": "/** \n * Constructs a new event.  The source is either the dataset or the {@link Plot} class.  The dataset can be \u003ccode\u003enull\u003c/code\u003e (in this casethe source will be the  {@link Plot} class).\n * @param source  the source of the event.\n * @param dataset  the dataset that generated the event (\u003ccode\u003enull\u003c/code\u003epermitted).\n * @param info  information about the change (\u003ccode\u003enull\u003c/code\u003e notpermitted).\n * @since 1.2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetChangeEvent.getDataset#102",
    "is_bug": true,
    "src_path": "org/jfree/data/event/DatasetChangeEvent.java",
    "class_name": "org.jfree.data.event.DatasetChangeEvent",
    "signature": "org.jfree.data.event.DatasetChangeEvent.getDataset()",
    "snippet": "public Dataset getDataset() {\r\n        return this.dataset;\r\n    }",
    "begin_line": 102,
    "end_line": 104,
    "comment": "/** \n * Returns the dataset that generated the event.  Note that the dataset may be \u003ccode\u003enull\u003c/code\u003e since adding a \u003ccode\u003enull\u003c/code\u003e dataset to a plot will generated a change event.\n * @return The dataset (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetChangeEvent.getInfo#113",
    "is_bug": true,
    "src_path": "org/jfree/data/event/DatasetChangeEvent.java",
    "class_name": "org.jfree.data.event.DatasetChangeEvent",
    "signature": "org.jfree.data.event.DatasetChangeEvent.getInfo()",
    "snippet": "public DatasetChangeInfo getInfo() {\r\n        return this.info;\r\n    }",
    "begin_line": 113,
    "end_line": 115,
    "comment": "/** \n * Returns the dataset change info.\n * @return The dataset change info.\n * @since 1.2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SeriesChangeEvent.SeriesChangeEvent#69",
    "is_bug": true,
    "src_path": "org/jfree/data/event/SeriesChangeEvent.java",
    "class_name": "org.jfree.data.event.SeriesChangeEvent",
    "signature": "org.jfree.data.event.SeriesChangeEvent.SeriesChangeEvent(java.lang.Object)",
    "snippet": "public SeriesChangeEvent(Object source) {\r\n        this(source, null);\r\n    }",
    "begin_line": 69,
    "end_line": 71,
    "comment": "/** \n * Constructs a new event.\n * @param source  the source of the change event.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SeriesChangeEvent.SeriesChangeEvent#81",
    "is_bug": true,
    "src_path": "org/jfree/data/event/SeriesChangeEvent.java",
    "class_name": "org.jfree.data.event.SeriesChangeEvent",
    "signature": "org.jfree.data.event.SeriesChangeEvent.SeriesChangeEvent(java.lang.Object, org.jfree.data.general.SeriesChangeInfo)",
    "snippet": "public SeriesChangeEvent(Object source, SeriesChangeInfo summary) {\r\n        super(source);\r\n        this.summary \u003d summary;\r\n    }",
    "begin_line": 81,
    "end_line": 84,
    "comment": "/** \n * Constructs a new change event.\n * @param source  the event source.\n * @param summary  a summary of the change (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @since 1.2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SeriesChangeEvent.getSummary#93",
    "is_bug": true,
    "src_path": "org/jfree/data/event/SeriesChangeEvent.java",
    "class_name": "org.jfree.data.event.SeriesChangeEvent",
    "signature": "org.jfree.data.event.SeriesChangeEvent.getSummary()",
    "snippet": "public SeriesChangeInfo getSummary() {\r\n        return this.summary;\r\n}",
    "begin_line": 93,
    "end_line": 95,
    "comment": "/** \n * Returns a summary of the change for this event.\n * @return The change summary (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @since 1.2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SeriesChangeEvent.setSummary#104",
    "is_bug": true,
    "src_path": "org/jfree/data/event/SeriesChangeEvent.java",
    "class_name": "org.jfree.data.event.SeriesChangeEvent",
    "signature": "org.jfree.data.event.SeriesChangeEvent.setSummary(org.jfree.data.general.SeriesChangeInfo)",
    "snippet": "public void setSummary(SeriesChangeInfo summary) {\r\n        this.summary \u003d summary;\r\n    }",
    "begin_line": 104,
    "end_line": 106,
    "comment": "/** \n * Sets the change info for this event.\n * @param summary  the info (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @since 1.2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.AbstractDataset#95",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.AbstractDataset()",
    "snippet": "protected AbstractDataset() {\r\n        this.group \u003d new DatasetGroup();\r\n        this.listenerList \u003d new EventListenerList();\r\n    }",
    "begin_line": 95,
    "end_line": 98,
    "comment": "/** \n * Constructs a dataset. By default, the dataset is assigned to its own group.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.getGroup#107",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.getGroup()",
    "snippet": "public DatasetGroup getGroup() {\r\n        return this.group;\r\n    }",
    "begin_line": 107,
    "end_line": 109,
    "comment": "/** \n * Returns the dataset group for the dataset.\n * @return The group (never \u003ccode\u003enull\u003c/code\u003e).\n * @see #setGroup(DatasetGroup)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.setGroup#118",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.setGroup(org.jfree.data.general.DatasetGroup)",
    "snippet": "public void setGroup(DatasetGroup group) {\r\n        if (group \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027group\u0027 argument.\");\r\n        }\r\n        this.group \u003d group;\r\n    }",
    "begin_line": 118,
    "end_line": 123,
    "comment": "/** \n * Sets the dataset group for the dataset.\n * @param group  the group (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @see #getGroup()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.addChangeListener#132",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.addChangeListener(org.jfree.data.event.DatasetChangeListener)",
    "snippet": "public void addChangeListener(DatasetChangeListener listener) {\r\n        this.listenerList.add(DatasetChangeListener.class, listener);\r\n    }",
    "begin_line": 132,
    "end_line": 134,
    "comment": "/** \n * Registers an object to receive notification of changes to the dataset.\n * @param listener  the object to register.\n * @see #removeChangeListener(DatasetChangeListener)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.removeChangeListener#144",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.removeChangeListener(org.jfree.data.event.DatasetChangeListener)",
    "snippet": "public void removeChangeListener(DatasetChangeListener listener) {\r\n        this.listenerList.remove(DatasetChangeListener.class, listener);\r\n    }",
    "begin_line": 144,
    "end_line": 146,
    "comment": "/** \n * Deregisters an object so that it no longer receives notification of changes to the dataset.\n * @param listener  the object to deregister.\n * @see #addChangeListener(DatasetChangeListener)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.hasListener#160",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.hasListener(java.util.EventListener)",
    "snippet": "public boolean hasListener(EventListener listener) {\r\n        List list \u003d Arrays.asList(this.listenerList.getListenerList());\r\n        return list.contains(listener);\r\n    }",
    "begin_line": 160,
    "end_line": 163,
    "comment": "/** \n * Returns \u003ccode\u003etrue\u003c/code\u003e if the specified object is registered with the dataset as a listener.  Most applications won\u0027t need to call this method, it exists mainly for use by unit testing code.\n * @param listener  the listener.\n * @return A boolean.\n * @see #addChangeListener(DatasetChangeListener)\n * @see #removeChangeListener(DatasetChangeListener)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.fireDatasetChanged#175",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.fireDatasetChanged(org.jfree.chart.event.DatasetChangeInfo)",
    "snippet": "protected void fireDatasetChanged(DatasetChangeInfo info) {\r\n        notifyListeners(new DatasetChangeEvent(this, this, info));\r\n    }",
    "begin_line": 175,
    "end_line": 177,
    "comment": "/** \n * Notifies all registered listeners that the dataset has changed.\n * @param info  information about the change (\u003ccode\u003enull\u003c/code\u003e notpermitted).\n * @see #addChangeListener(DatasetChangeListener)\n * @since 1.2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.notifyListeners#188",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.notifyListeners(org.jfree.data.event.DatasetChangeEvent)",
    "snippet": "protected void notifyListeners(DatasetChangeEvent event) {\r\n        Object[] listeners \u003d this.listenerList.getListenerList();\r\n        for (int i \u003d listeners.length - 2; i \u003e\u003d 0; i -\u003d 2) {\r\n            if (listeners[i] \u003d\u003d DatasetChangeListener.class) {\r\n                ((DatasetChangeListener) listeners[i + 1]).datasetChanged(\r\n                        event);\r\n            }\r\n        }\r\n    }",
    "begin_line": 188,
    "end_line": 196,
    "comment": "/** \n * Notifies all registered listeners that the dataset has changed.\n * @param event  contains information about the event that triggered thenotification.\n * @see #addChangeListener(DatasetChangeListener)\n * @see #removeChangeListener(DatasetChangeListener)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.clone#208",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.clone()",
    "snippet": "public Object clone() throws CloneNotSupportedException {\r\n        AbstractDataset clone \u003d (AbstractDataset) super.clone();\r\n        clone.listenerList \u003d new EventListenerList();\r\n        return clone;\r\n    }",
    "begin_line": 208,
    "end_line": 212,
    "comment": "/** \n * Returns a clone of the dataset. The cloned dataset will NOT include the {@link DatasetChangeListener} references that have been registered withthis dataset.\n * @return A clone.\n * @throws CloneNotSupportedException  if the dataset does not supportcloning.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.writeObject#221",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.writeObject(java.io.ObjectOutputStream)",
    "snippet": "private void writeObject(ObjectOutputStream stream) throws IOException {\r\n        stream.defaultWriteObject();\r\n    }",
    "begin_line": 221,
    "end_line": 223,
    "comment": "/** \n * Handles serialization.\n * @param stream  the output stream.\n * @throws IOException if there is an I/O problem.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.readObject#233",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.readObject(java.io.ObjectInputStream)",
    "snippet": "private void readObject(ObjectInputStream stream)\r\n        throws IOException, ClassNotFoundException {\r\n        stream.defaultReadObject();\r\n        this.listenerList \u003d new EventListenerList();\r\n        stream.registerValidation(this, 10);  // see comments about priority of\r\n                                              // 10 in validateObject()\r\n    }",
    "begin_line": 233,
    "end_line": 239,
    "comment": "/** \n * Restores a serialized object.\n * @param stream  the input stream.\n * @throws IOException if there is an I/O problem.\n * @throws ClassNotFoundException if there is a problem loading a class.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractDataset.validateObject#258",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractDataset.java",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.validateObject()",
    "snippet": "public void validateObject() throws InvalidObjectException {\r\n        fireDatasetChanged(new DatasetChangeInfo());\r\n        // TODO:  fill in real dataset change info (maybe NEW_DATASET?)\r\n    }",
    "begin_line": 258,
    "end_line": 261,
    "comment": "/** \n * Validates the object. We use this opportunity to call listeners who have registered during the deserialization process, as listeners are not serialized. This method is called by the serialization system after the entire graph is read. This object has registered itself to the system with a priority of 10. Other callbacks may register with a higher priority number to be called before this object, or with a lower priority number to be called after the listeners were notified. All listeners are supposed to have register by now, either in their readObject or validateObject methods. Notify them that this dataset has changed.\n * @exception InvalidObjectException If the object cannot validate itself.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSeriesDataset.AbstractSeriesDataset#65",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractSeriesDataset.java",
    "class_name": "org.jfree.data.general.AbstractSeriesDataset",
    "signature": "org.jfree.data.general.AbstractSeriesDataset.AbstractSeriesDataset()",
    "snippet": "protected AbstractSeriesDataset() {\r\n        super();\r\n    }",
    "begin_line": 65,
    "end_line": 67,
    "comment": "/** \n * Creates a new dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSeriesDataset.getSeriesCount#74",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractSeriesDataset.java",
    "class_name": "org.jfree.data.general.AbstractSeriesDataset",
    "signature": "org.jfree.data.general.AbstractSeriesDataset.getSeriesCount()",
    "snippet": "public abstract int getSeriesCount();",
    "begin_line": 74,
    "end_line": 74,
    "comment": "/** \n * Returns the number of series in the dataset.\n * @return The series count.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSeriesDataset.getSeriesKey#88",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractSeriesDataset.java",
    "class_name": "org.jfree.data.general.AbstractSeriesDataset",
    "signature": "org.jfree.data.general.AbstractSeriesDataset.getSeriesKey(int)",
    "snippet": "public abstract Comparable getSeriesKey(int series);",
    "begin_line": 88,
    "end_line": 88,
    "comment": "/** \n * Returns the key for a series. \u003cp\u003e If \u003ccode\u003eseries\u003c/code\u003e is not within the specified range, the implementing method should throw an  {@link IndexOutOfBoundsException}(preferred) or an  {@link IllegalArgumentException}.\n * @param series  the series index (in the range \u003ccode\u003e0\u003c/code\u003e to\u003ccode\u003egetSeriesCount() - 1\u003c/code\u003e).\n * @return The series key.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSeriesDataset.indexOf#97",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractSeriesDataset.java",
    "class_name": "org.jfree.data.general.AbstractSeriesDataset",
    "signature": "org.jfree.data.general.AbstractSeriesDataset.indexOf(java.lang.Comparable)",
    "snippet": "public int indexOf(Comparable seriesKey) {\r\n        int seriesCount \u003d getSeriesCount();\r\n        for (int s \u003d 0; s \u003c seriesCount; s++) {\r\n           if (getSeriesKey(s).equals(seriesKey)) {\r\n               return s;\r\n           }\r\n        }\r\n        return -1;\r\n    }",
    "begin_line": 97,
    "end_line": 105,
    "comment": "/** \n * Returns the index of the named series, or -1.\n * @param seriesKey  the series key (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @return The index.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSeriesDataset.seriesChanged#112",
    "is_bug": true,
    "src_path": "org/jfree/data/general/AbstractSeriesDataset.java",
    "class_name": "org.jfree.data.general.AbstractSeriesDataset",
    "signature": "org.jfree.data.general.AbstractSeriesDataset.seriesChanged(org.jfree.data.event.SeriesChangeEvent)",
    "snippet": "public void seriesChanged(SeriesChangeEvent event) {\r\n        fireDatasetChanged(new DatasetChangeInfo());\r\n        // TODO: fill in change details - might need to override this method\r\n        // in each subclass to get details\r\n    }",
    "begin_line": 112,
    "end_line": 116,
    "comment": "/** \n * Called when a series belonging to the dataset changes.\n * @param event  information about the change.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetGroup.DatasetGroup#62",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetGroup.java",
    "class_name": "org.jfree.data.general.DatasetGroup",
    "signature": "org.jfree.data.general.DatasetGroup.DatasetGroup()",
    "snippet": "public DatasetGroup() {\r\n        super();\r\n        this.id \u003d \"NOID\";\r\n    }",
    "begin_line": 62,
    "end_line": 65,
    "comment": "/** \n * Constructs a new group.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetGroup.DatasetGroup#72",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetGroup.java",
    "class_name": "org.jfree.data.general.DatasetGroup",
    "signature": "org.jfree.data.general.DatasetGroup.DatasetGroup(java.lang.String)",
    "snippet": "public DatasetGroup(String id) {\r\n        if (id \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027id\u0027 argument.\");\r\n        }\r\n        this.id \u003d id;\r\n    }",
    "begin_line": 72,
    "end_line": 77,
    "comment": "/** \n * Creates a new group with the specified id.\n * @param id  the identification for the group.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetGroup.getID#84",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetGroup.java",
    "class_name": "org.jfree.data.general.DatasetGroup",
    "signature": "org.jfree.data.general.DatasetGroup.getID()",
    "snippet": "public String getID() {\r\n        return this.id;\r\n    }",
    "begin_line": 84,
    "end_line": 86,
    "comment": "/** \n * Returns the identification string for this group.\n * @return The identification string.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetGroup.clone#95",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetGroup.java",
    "class_name": "org.jfree.data.general.DatasetGroup",
    "signature": "org.jfree.data.general.DatasetGroup.clone()",
    "snippet": "public Object clone() throws CloneNotSupportedException {\r\n        return super.clone();\r\n    }",
    "begin_line": 95,
    "end_line": 97,
    "comment": "/** \n * Clones the group.\n * @return A clone.\n * @throws CloneNotSupportedException not by this class.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetGroup.equals#106",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetGroup.java",
    "class_name": "org.jfree.data.general.DatasetGroup",
    "signature": "org.jfree.data.general.DatasetGroup.equals(java.lang.Object)",
    "snippet": "public boolean equals(Object obj) {\r\n        if (obj \u003d\u003d this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof DatasetGroup)) {\r\n            return false;\r\n        }\r\n        DatasetGroup that \u003d (DatasetGroup) obj;\r\n        if (!this.id.equals(that.id)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }",
    "begin_line": 106,
    "end_line": 118,
    "comment": "/** \n * Tests this instance for equality with an arbitrary object.\n * @param obj  the object (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.DatasetUtilities#167",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.DatasetUtilities()",
    "snippet": "private DatasetUtilities() {\r\n        // now try to instantiate this ;-)\r\n    }",
    "begin_line": 167,
    "end_line": 169,
    "comment": "/** \n * Private constructor for non-instanceability.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.calculatePieDatasetTotal#180",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.calculatePieDatasetTotal(org.jfree.data.pie.PieDataset)",
    "snippet": "public static double calculatePieDatasetTotal(PieDataset dataset) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        List keys \u003d dataset.getKeys();\r\n        double totalValue \u003d 0;\r\n        Iterator iterator \u003d keys.iterator();\r\n        while (iterator.hasNext()) {\r\n            Comparable current \u003d (Comparable) iterator.next();\r\n            if (current !\u003d null) {\r\n                Number value \u003d dataset.getValue(current);\r\n                double v \u003d 0.0;\r\n                if (value !\u003d null) {\r\n                    v \u003d value.doubleValue();\r\n                }\r\n                if (v \u003e 0) {\r\n                    totalValue \u003d totalValue + v;\r\n                }\r\n            }\r\n        }\r\n        return totalValue;\r\n    }",
    "begin_line": 180,
    "end_line": 201,
    "comment": "/** \n * Calculates the total of all the values in a  {@link PieDataset}.  If the dataset contains negative or \u003ccode\u003enull\u003c/code\u003e values, they are ignored.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The total.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createPieDatasetForRow#212",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createPieDatasetForRow(org.jfree.data.category.CategoryDataset, java.lang.Comparable)",
    "snippet": "public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\r\n                                                    Comparable rowKey) {\r\n        int row \u003d dataset.getRowIndex(rowKey);\r\n        return createPieDatasetForRow(dataset, row);\r\n    }",
    "begin_line": 212,
    "end_line": 216,
    "comment": "/** \n * Creates a pie dataset from a table dataset by taking all the values for a single row.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param rowKey  the row key.\n * @return A pie dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createPieDatasetForRow#227",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createPieDatasetForRow(org.jfree.data.category.CategoryDataset, int)",
    "snippet": "public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\r\n                                                    int row) {\r\n        DefaultPieDataset result \u003d new DefaultPieDataset();\r\n        int columnCount \u003d dataset.getColumnCount();\r\n        for (int current \u003d 0; current \u003c columnCount; current++) {\r\n            Comparable columnKey \u003d dataset.getColumnKey(current);\r\n            result.setValue(columnKey, dataset.getValue(row, current));\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 227,
    "end_line": 236,
    "comment": "/** \n * Creates a pie dataset from a table dataset by taking all the values for a single row.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param row  the row (zero-based index).\n * @return A pie dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createPieDatasetForColumn#247",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createPieDatasetForColumn(org.jfree.data.category.CategoryDataset, java.lang.Comparable)",
    "snippet": "public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\r\n                                                       Comparable columnKey) {\r\n        int column \u003d dataset.getColumnIndex(columnKey);\r\n        return createPieDatasetForColumn(dataset, column);\r\n    }",
    "begin_line": 247,
    "end_line": 251,
    "comment": "/** \n * Creates a pie dataset from a table dataset by taking all the values for a single column.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param columnKey  the column key.\n * @return A pie dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createPieDatasetForColumn#262",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createPieDatasetForColumn(org.jfree.data.category.CategoryDataset, int)",
    "snippet": "public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\r\n                                                       int column) {\r\n        DefaultPieDataset result \u003d new DefaultPieDataset();\r\n        int rowCount \u003d dataset.getRowCount();\r\n        for (int i \u003d 0; i \u003c rowCount; i++) {\r\n            Comparable rowKey \u003d dataset.getRowKey(i);\r\n            result.setValue(rowKey, dataset.getValue(i, column));\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 262,
    "end_line": 271,
    "comment": "/** \n * Creates a pie dataset from a  {@link CategoryDataset} by taking all thevalues for a single column.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param column  the column (zero-based index).\n * @return A pie dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createConsolidatedPieDataset#286",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createConsolidatedPieDataset(org.jfree.data.pie.PieDataset, java.lang.Comparable, double)",
    "snippet": "public static PieDataset createConsolidatedPieDataset(PieDataset source,\r\n            Comparable key, double minimumPercent) {\r\n        return DatasetUtilities.createConsolidatedPieDataset(source, key,\r\n                minimumPercent, 2);\r\n    }",
    "begin_line": 286,
    "end_line": 290,
    "comment": "/** \n * Creates a new pie dataset based on the supplied dataset, but modified by aggregating all the low value items (those whose value is lower than the \u003ccode\u003epercentThreshold\u003c/code\u003e) into a single item with the key \"Other\".\n * @param source  the source dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param key  a new key for the aggregated items (\u003ccode\u003enull\u003c/code\u003e notpermitted).\n * @param minimumPercent  the percent threshold.\n * @return The pie dataset with (possibly) aggregated items.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createConsolidatedPieDataset#307",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createConsolidatedPieDataset(org.jfree.data.pie.PieDataset, java.lang.Comparable, double, int)",
    "snippet": "public static PieDataset createConsolidatedPieDataset(PieDataset source,\r\n            Comparable key, double minimumPercent, int minItems) {\r\n\r\n        DefaultPieDataset result \u003d new DefaultPieDataset();\r\n        double total \u003d DatasetUtilities.calculatePieDatasetTotal(source);\r\n\r\n        //  Iterate and find all keys below threshold percentThreshold\r\n        List keys \u003d source.getKeys();\r\n        ArrayList otherKeys \u003d new ArrayList();\r\n        Iterator iterator \u003d keys.iterator();\r\n        while (iterator.hasNext()) {\r\n            Comparable currentKey \u003d (Comparable) iterator.next();\r\n            Number dataValue \u003d source.getValue(currentKey);\r\n            if (dataValue !\u003d null) {\r\n                double value \u003d dataValue.doubleValue();\r\n                if (value / total \u003c minimumPercent) {\r\n                    otherKeys.add(currentKey);\r\n                }\r\n            }\r\n        }\r\n\r\n        //  Create new dataset with keys above threshold percentThreshold\r\n        iterator \u003d keys.iterator();\r\n        double otherValue \u003d 0;\r\n        while (iterator.hasNext()) {\r\n            Comparable currentKey \u003d (Comparable) iterator.next();\r\n            Number dataValue \u003d source.getValue(currentKey);\r\n            if (dataValue !\u003d null) {\r\n                if (otherKeys.contains(currentKey)\r\n                    \u0026\u0026 otherKeys.size() \u003e\u003d minItems) {\r\n                    //  Do not add key to dataset\r\n                    otherValue +\u003d dataValue.doubleValue();\r\n                }\r\n                else {\r\n                    //  Add key to dataset\r\n                    result.setValue(currentKey, dataValue);\r\n                }\r\n            }\r\n        }\r\n        //  Add other category if applicable\r\n        if (otherKeys.size() \u003e\u003d minItems) {\r\n            result.setValue(key, otherValue);\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 307,
    "end_line": 351,
    "comment": "/** \n * Creates a new pie dataset based on the supplied dataset, but modified by aggregating all the low value items (those whose value is lower than the \u003ccode\u003epercentThreshold\u003c/code\u003e) into a single item.  The aggregated items are assigned the specified key.  Aggregation only occurs if there are at least \u003ccode\u003eminItems\u003c/code\u003e items to aggregate.\n * @param source  the source dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param key  the key to represent the aggregated items.\n * @param minimumPercent  the percent threshold (ten percent is 0.10).\n * @param minItems  only aggregate low values if there are at least thismany.\n * @return The pie dataset with (possibly) aggregated items.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createCategoryDataset#367",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createCategoryDataset(java.lang.String, java.lang.String, double[][])",
    "snippet": "public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\r\n            String columnKeyPrefix, double[][] data) {\r\n\r\n        DefaultCategoryDataset result \u003d new DefaultCategoryDataset();\r\n        for (int r \u003d 0; r \u003c data.length; r++) {\r\n            String rowKey \u003d rowKeyPrefix + (r + 1);\r\n            for (int c \u003d 0; c \u003c data[r].length; c++) {\r\n                String columnKey \u003d columnKeyPrefix + (c + 1);\r\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }",
    "begin_line": 367,
    "end_line": 380,
    "comment": "/** \n * Creates a  {@link CategoryDataset} that contains a copy of the data in anarray (instances of \u003ccode\u003eDouble\u003c/code\u003e are created to represent the data items). \u003cp\u003e Row and column keys are created by appending 0, 1, 2, ... to the supplied prefixes.\n * @param rowKeyPrefix  the row key prefix.\n * @param columnKeyPrefix  the column key prefix.\n * @param data  the data.\n * @return The dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createCategoryDataset#395",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createCategoryDataset(java.lang.String, java.lang.String, java.lang.Number[][])",
    "snippet": "public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\r\n            String columnKeyPrefix, Number[][] data) {\r\n\r\n        DefaultCategoryDataset result \u003d new DefaultCategoryDataset();\r\n        for (int r \u003d 0; r \u003c data.length; r++) {\r\n            String rowKey \u003d rowKeyPrefix + (r + 1);\r\n            for (int c \u003d 0; c \u003c data[r].length; c++) {\r\n                String columnKey \u003d columnKeyPrefix + (c + 1);\r\n                result.addValue(data[r][c], rowKey, columnKey);\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }",
    "begin_line": 395,
    "end_line": 408,
    "comment": "/** \n * Creates a  {@link CategoryDataset} that contains a copy of the data inan array. \u003cp\u003e Row and column keys are created by appending 0, 1, 2, ... to the supplied prefixes.\n * @param rowKeyPrefix  the row key prefix.\n * @param columnKeyPrefix  the column key prefix.\n * @param data  the data.\n * @return The dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createCategoryDataset#423",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createCategoryDataset(java.lang.Comparable[], java.lang.Comparable[], double[][])",
    "snippet": "public static CategoryDataset createCategoryDataset(Comparable[] rowKeys,\r\n            Comparable[] columnKeys, double[][] data) {\r\n\r\n        // check arguments...\r\n        if (rowKeys \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027rowKeys\u0027 argument.\");\r\n        }\r\n        if (columnKeys \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027columnKeys\u0027 argument.\");\r\n        }\r\n        if (ArrayUtilities.hasDuplicateItems(rowKeys)) {\r\n            throw new IllegalArgumentException(\"Duplicate items in \u0027rowKeys\u0027.\");\r\n        }\r\n        if (ArrayUtilities.hasDuplicateItems(columnKeys)) {\r\n            throw new IllegalArgumentException(\r\n                    \"Duplicate items in \u0027columnKeys\u0027.\");\r\n        }\r\n        if (rowKeys.length !\u003d data.length) {\r\n            throw new IllegalArgumentException(\r\n                \"The number of row keys does not match the number of rows in \"\r\n                + \"the data array.\");\r\n        }\r\n        int columnCount \u003d 0;\r\n        for (int r \u003d 0; r \u003c data.length; r++) {\r\n            columnCount \u003d Math.max(columnCount, data[r].length);\r\n        }\r\n        if (columnKeys.length !\u003d columnCount) {\r\n            throw new IllegalArgumentException(\r\n                \"The number of column keys does not match the number of \"\r\n                + \"columns in the data array.\");\r\n        }\r\n\r\n        // now do the work...\r\n        DefaultCategoryDataset result \u003d new DefaultCategoryDataset();\r\n        for (int r \u003d 0; r \u003c data.length; r++) {\r\n            Comparable rowKey \u003d rowKeys[r];\r\n            for (int c \u003d 0; c \u003c data[r].length; c++) {\r\n                Comparable columnKey \u003d columnKeys[c];\r\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }",
    "begin_line": 423,
    "end_line": 466,
    "comment": "/** \n * Creates a  {@link CategoryDataset} that contains a copy of the data inan array (instances of \u003ccode\u003eDouble\u003c/code\u003e are created to represent the data items). \u003cp\u003e Row and column keys are taken from the supplied arrays.\n * @param rowKeys  the row keys (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param columnKeys  the column keys (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param data  the data.\n * @return The dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.createCategoryDataset#477",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.createCategoryDataset(java.lang.Comparable, org.jfree.data.KeyedValues)",
    "snippet": "public static CategoryDataset createCategoryDataset(Comparable rowKey,\r\n                                                        KeyedValues rowData) {\r\n\r\n        if (rowKey \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027rowKey\u0027 argument.\");\r\n        }\r\n        if (rowData \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027rowData\u0027 argument.\");\r\n        }\r\n        DefaultCategoryDataset result \u003d new DefaultCategoryDataset();\r\n        for (int i \u003d 0; i \u003c rowData.getItemCount(); i++) {\r\n            result.addValue(rowData.getValue(i), rowKey, rowData.getKey(i));\r\n        }\r\n        return result;\r\n\r\n    }",
    "begin_line": 477,
    "end_line": 492,
    "comment": "/** \n * Creates a  {@link CategoryDataset} by copying the data from the supplied{@link KeyedValues} instance.\n * @param rowKey  the row key (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param rowData  the row data (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return A dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.sampleFunction2D#507",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.sampleFunction2D(org.jfree.data.function.Function2D, double, double, int, java.lang.Comparable)",
    "snippet": "public static XYDataset sampleFunction2D(Function2D f, double start,\r\n            double end, int samples, Comparable seriesKey) {\r\n\r\n        // defer argument checking\r\n        XYSeries series \u003d sampleFunction2DToSeries(f, start, end, samples,\r\n                seriesKey);\r\n        XYSeriesCollection collection \u003d new XYSeriesCollection(series);\r\n        return collection;\r\n    }",
    "begin_line": 507,
    "end_line": 515,
    "comment": "/** \n * Creates an  {@link XYDataset} by sampling the specified function over afixed range.\n * @param f  the function (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param start  the start value for the range.\n * @param end  the end value for the range.\n * @param samples  the number of sample points (must be \u003e 1).\n * @param seriesKey  the key to give the resulting series(\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return A dataset.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.sampleFunction2DToSeries#532",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.sampleFunction2DToSeries(org.jfree.data.function.Function2D, double, double, int, java.lang.Comparable)",
    "snippet": "public static XYSeries sampleFunction2DToSeries(Function2D f,\r\n            double start, double end, int samples, Comparable seriesKey) {\r\n\r\n        if (f \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027f\u0027 argument.\");\r\n        }\r\n        if (seriesKey \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027seriesKey\u0027 argument.\");\r\n        }\r\n        if (start \u003e\u003d end) {\r\n            throw new IllegalArgumentException(\"Requires \u0027start\u0027 \u003c \u0027end\u0027.\");\r\n        }\r\n        if (samples \u003c 2) {\r\n            throw new IllegalArgumentException(\"Requires \u0027samples\u0027 \u003e 1\");\r\n        }\r\n\r\n        XYSeries series \u003d new XYSeries(seriesKey);\r\n        double step \u003d (end - start) / (samples - 1);\r\n        for (int i \u003d 0; i \u003c samples; i++) {\r\n            double x \u003d start + (step * i);\r\n            series.add(x, f.getValue(x));\r\n        }\r\n        return series;\r\n    }",
    "begin_line": 532,
    "end_line": 555,
    "comment": "/** \n * Creates an  {@link XYSeries} by sampling the specified function over afixed range.\n * @param f  the function (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param start  the start value for the range.\n * @param end  the end value for the range.\n * @param samples  the number of sample points (must be \u003e 1).\n * @param seriesKey  the key to give the resulting series(\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return A series.\n * @since 1.0.13\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.isEmptyOrNull#565",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.isEmptyOrNull(org.jfree.data.pie.PieDataset)",
    "snippet": "public static boolean isEmptyOrNull(PieDataset dataset) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            return true;\r\n        }\r\n\r\n        int itemCount \u003d dataset.getItemCount();\r\n        if (itemCount \u003d\u003d 0) {\r\n            return true;\r\n        }\r\n\r\n        for (int item \u003d 0; item \u003c itemCount; item++) {\r\n            Number y \u003d dataset.getValue(item);\r\n            if (y !\u003d null) {\r\n                double yy \u003d y.doubleValue();\r\n                if (yy \u003e 0.0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n\r\n    }",
    "begin_line": 565,
    "end_line": 588,
    "comment": "/** \n * Returns \u003ccode\u003etrue\u003c/code\u003e if the dataset is empty (or \u003ccode\u003enull\u003c/code\u003e), and \u003ccode\u003efalse\u003c/code\u003e otherwise.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.isEmptyOrNull#598",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.isEmptyOrNull(org.jfree.data.category.CategoryDataset)",
    "snippet": "public static boolean isEmptyOrNull(CategoryDataset dataset) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            return true;\r\n        }\r\n\r\n        int rowCount \u003d dataset.getRowCount();\r\n        int columnCount \u003d dataset.getColumnCount();\r\n        if (rowCount \u003d\u003d 0 || columnCount \u003d\u003d 0) {\r\n            return true;\r\n        }\r\n\r\n        for (int r \u003d 0; r \u003c rowCount; r++) {\r\n            for (int c \u003d 0; c \u003c columnCount; c++) {\r\n                if (dataset.getValue(r, c) !\u003d null) {\r\n                    return false;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return true;\r\n\r\n    }",
    "begin_line": 598,
    "end_line": 621,
    "comment": "/** \n * Returns \u003ccode\u003etrue\u003c/code\u003e if the dataset is empty (or \u003ccode\u003enull\u003c/code\u003e), and \u003ccode\u003efalse\u003c/code\u003e otherwise.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.isEmptyOrNull#631",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.isEmptyOrNull(org.jfree.data.xy.XYDataset)",
    "snippet": "public static boolean isEmptyOrNull(XYDataset dataset) {\r\n        if (dataset !\u003d null) {\r\n            for (int s \u003d 0; s \u003c dataset.getSeriesCount(); s++) {\r\n                if (dataset.getItemCount(s) \u003e 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }",
    "begin_line": 631,
    "end_line": 640,
    "comment": "/** \n * Returns \u003ccode\u003etrue\u003c/code\u003e if the dataset is empty (or \u003ccode\u003enull\u003c/code\u003e), and \u003ccode\u003efalse\u003c/code\u003e otherwise.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findDomainBounds#649",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findDomainBounds(org.jfree.data.xy.XYDataset)",
    "snippet": "public static Range findDomainBounds(XYDataset dataset) {\r\n        return findDomainBounds(dataset, true);\r\n    }",
    "begin_line": 649,
    "end_line": 651,
    "comment": "/** \n * Returns the range of values in the domain (x-values) of a dataset.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range of values (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findDomainBounds#663",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findDomainBounds(org.jfree.data.xy.XYDataset, boolean)",
    "snippet": "public static Range findDomainBounds(XYDataset dataset,\r\n                                         boolean includeInterval) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n\r\n        Range result \u003d null;\r\n        // if the dataset implements DomainInfo, life is easier\r\n        if (dataset instanceof DomainInfo) {\r\n            DomainInfo info \u003d (DomainInfo) dataset;\r\n            result \u003d info.getDomainBounds(includeInterval);\r\n        }\r\n        else {\r\n            result \u003d iterateDomainBounds(dataset, includeInterval);\r\n        }\r\n        return result;\r\n\r\n    }",
    "begin_line": 663,
    "end_line": 681,
    "comment": "/** \n * Returns the range of values in the domain (x-values) of a dataset.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  determines whether or not the x-interval is takeninto account (only applies if the dataset is an {@link IntervalXYDataset}).\n * @return The range of values (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findDomainBounds#698",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findDomainBounds(org.jfree.data.xy.XYDataset, java.util.List, boolean)",
    "snippet": "public static Range findDomainBounds(XYDataset dataset,\r\n            List visibleSeriesKeys, boolean includeInterval) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Range result \u003d null;\r\n        if (dataset instanceof XYDomainInfo) {\r\n            XYDomainInfo info \u003d (XYDomainInfo) dataset;\r\n            result \u003d info.getDomainBounds(visibleSeriesKeys, includeInterval);\r\n        }\r\n        else {\r\n            result \u003d iterateToFindDomainBounds(dataset, visibleSeriesKeys,\r\n                    includeInterval);\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 698,
    "end_line": 713,
    "comment": "/** \n * Returns the bounds of the x-values in the specified \u003ccode\u003edataset\u003c/code\u003e taking into account only the visible series and including any x-interval if requested.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param visibleSeriesKeys  the visible series keys (\u003ccode\u003enull\u003c/code\u003enot permitted).\n * @param includeInterval  include the x-interval (if any)?\n * @return The bounds (or \u003ccode\u003enull\u003c/code\u003e if the dataset contains novalues.\n * @since 1.0.13\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateDomainBounds#725",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateDomainBounds(org.jfree.data.xy.XYDataset)",
    "snippet": "public static Range iterateDomainBounds(XYDataset dataset) {\r\n        return iterateDomainBounds(dataset, true);\r\n    }",
    "begin_line": 725,
    "end_line": 727,
    "comment": "/** \n * Iterates over the items in an  {@link XYDataset} to findthe range of x-values.  If the dataset is an instance of {@link IntervalXYDataset}, the starting and ending x-values will be used for the bounds calculation.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateDomainBounds#740",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateDomainBounds(org.jfree.data.xy.XYDataset, boolean)",
    "snippet": "public static Range iterateDomainBounds(XYDataset dataset,\r\n                                            boolean includeInterval) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        double minimum \u003d Double.POSITIVE_INFINITY;\r\n        double maximum \u003d Double.NEGATIVE_INFINITY;\r\n        int seriesCount \u003d dataset.getSeriesCount();\r\n        double lvalue;\r\n        double uvalue;\r\n        if (includeInterval \u0026\u0026 dataset instanceof IntervalXYDataset) {\r\n            IntervalXYDataset intervalXYData \u003d (IntervalXYDataset) dataset;\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    lvalue \u003d intervalXYData.getStartXValue(series, item);\r\n                    uvalue \u003d intervalXYData.getEndXValue(series, item);\r\n                    if (!Double.isNaN(lvalue)) {\r\n                        minimum \u003d Math.min(minimum, lvalue);\r\n                    }\r\n                    if (!Double.isNaN(uvalue)) {\r\n                        maximum \u003d Math.max(maximum, uvalue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    lvalue \u003d dataset.getXValue(series, item);\r\n                    uvalue \u003d lvalue;\r\n                    if (!Double.isNaN(lvalue)) {\r\n                        minimum \u003d Math.min(minimum, lvalue);\r\n                        maximum \u003d Math.max(maximum, uvalue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (minimum \u003e maximum) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new Range(minimum, maximum);\r\n        }\r\n    }",
    "begin_line": 740,
    "end_line": 785,
    "comment": "/** \n * Iterates over the items in an  {@link XYDataset} to findthe range of x-values.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  a flag that determines, for an{@link IntervalXYDataset}, whether the x-interval or just the x-value is used to determine the overall range.\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findRangeBounds#794",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findRangeBounds(org.jfree.data.category.CategoryDataset)",
    "snippet": "public static Range findRangeBounds(CategoryDataset dataset) {\r\n        return findRangeBounds(dataset, true);\r\n    }",
    "begin_line": 794,
    "end_line": 796,
    "comment": "/** \n * Returns the range of values in the range for the dataset.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findRangeBounds#807",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findRangeBounds(org.jfree.data.category.CategoryDataset, boolean)",
    "snippet": "public static Range findRangeBounds(CategoryDataset dataset,\r\n                                        boolean includeInterval) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Range result \u003d null;\r\n        if (dataset instanceof RangeInfo) {\r\n            RangeInfo info \u003d (RangeInfo) dataset;\r\n            result \u003d info.getRangeBounds(includeInterval);\r\n        }\r\n        else {\r\n            result \u003d iterateRangeBounds(dataset, includeInterval);\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 807,
    "end_line": 821,
    "comment": "/** \n * Returns the range of values in the range for the dataset.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  a flag that determines whether or not they-interval is taken into account.\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findRangeBounds#837",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findRangeBounds(org.jfree.data.category.CategoryDataset, java.util.List, boolean)",
    "snippet": "public static Range findRangeBounds(CategoryDataset dataset,\r\n            List visibleSeriesKeys, boolean includeInterval) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Range result \u003d null;\r\n        if (dataset instanceof CategoryRangeInfo) {\r\n            CategoryRangeInfo info \u003d (CategoryRangeInfo) dataset;\r\n            result \u003d info.getRangeBounds(visibleSeriesKeys, includeInterval);\r\n        }\r\n        else {\r\n            result \u003d iterateToFindRangeBounds(dataset, visibleSeriesKeys,\r\n                    includeInterval);\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 837,
    "end_line": 852,
    "comment": "/** \n * Finds the bounds of the y-values in the specified dataset, including only those series that are listed in visibleSeriesKeys.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param visibleSeriesKeys  the keys for the visible series(\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  include the y-interval (if the dataset has ay-interval).\n * @return The data bounds.\n * @since 1.0.13\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findRangeBounds#862",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findRangeBounds(org.jfree.data.xy.XYDataset)",
    "snippet": "public static Range findRangeBounds(XYDataset dataset) {\r\n        return findRangeBounds(dataset, true);\r\n    }",
    "begin_line": 862,
    "end_line": 864,
    "comment": "/** \n * Returns the range of values in the range for the dataset.  This method is the partner for the  {@link #findDomainBounds(XYDataset)} method.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findRangeBounds#877",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findRangeBounds(org.jfree.data.xy.XYDataset, boolean)",
    "snippet": "public static Range findRangeBounds(XYDataset dataset,\r\n                                        boolean includeInterval) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Range result \u003d null;\r\n        if (dataset instanceof RangeInfo) {\r\n            RangeInfo info \u003d (RangeInfo) dataset;\r\n            result \u003d info.getRangeBounds(includeInterval);\r\n        }\r\n        else {\r\n            result \u003d iterateRangeBounds(dataset, includeInterval);\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 877,
    "end_line": 891,
    "comment": "/** \n * Returns the range of values in the range for the dataset.  This method is the partner for the  {@link #findDomainBounds(XYDataset,boolean)}method.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  a flag that determines whether or not they-interval is taken into account.\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findRangeBounds#909",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findRangeBounds(org.jfree.data.xy.XYDataset, java.util.List, org.jfree.data.Range, boolean)",
    "snippet": "public static Range findRangeBounds(XYDataset dataset,\r\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Range result \u003d null;\r\n        if (dataset instanceof XYRangeInfo) {\r\n            XYRangeInfo info \u003d (XYRangeInfo) dataset;\r\n            result \u003d info.getRangeBounds(visibleSeriesKeys, xRange,\r\n                    includeInterval);\r\n        }\r\n        else {\r\n            result \u003d iterateToFindRangeBounds(dataset, visibleSeriesKeys,\r\n                    xRange, includeInterval);\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 909,
    "end_line": 925,
    "comment": "/** \n * Finds the bounds of the y-values in the specified dataset, including only those series that are listed in visibleSeriesKeys, and those items whose x-values fall within the specified range.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param visibleSeriesKeys  the keys for the visible series(\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param xRange  the x-range (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  include the y-interval (if the dataset has ay-interval).\n * @return The data bounds.\n * @since 1.0.13\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateCategoryRangeBounds#940",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateCategoryRangeBounds(org.jfree.data.category.CategoryDataset, boolean)",
    "snippet": "public static Range iterateCategoryRangeBounds(CategoryDataset dataset,\r\n            boolean includeInterval) {\r\n        return iterateRangeBounds(dataset, includeInterval);\r\n    }",
    "begin_line": 940,
    "end_line": 943,
    "comment": "/** \n * Iterates over the data item of the category dataset to find the range bounds.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  a flag that determines whether or not they-interval is taken into account.\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @deprecated As of 1.0.10, use{@link #iterateRangeBounds(CategoryDataset,boolean)}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateRangeBounds#955",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateRangeBounds(org.jfree.data.category.CategoryDataset)",
    "snippet": "public static Range iterateRangeBounds(CategoryDataset dataset) {\r\n        return iterateRangeBounds(dataset, true);\r\n    }",
    "begin_line": 955,
    "end_line": 957,
    "comment": "/** \n * Iterates over the data item of the category dataset to find the range bounds.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @since 1.0.10\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateRangeBounds#971",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateRangeBounds(org.jfree.data.category.CategoryDataset, boolean)",
    "snippet": "public static Range iterateRangeBounds(CategoryDataset dataset,\r\n            boolean includeInterval) {\r\n        double minimum \u003d Double.POSITIVE_INFINITY;\r\n        double maximum \u003d Double.NEGATIVE_INFINITY;\r\n        int rowCount \u003d dataset.getRowCount();\r\n        int columnCount \u003d dataset.getColumnCount();\r\n        if (includeInterval \u0026\u0026 dataset instanceof IntervalCategoryDataset) {\r\n            // handle the special case where the dataset has y-intervals that\r\n            // we want to measure\r\n            IntervalCategoryDataset icd \u003d (IntervalCategoryDataset) dataset;\r\n            Number value, lvalue, uvalue;\r\n            for (int row \u003d 0; row \u003c rowCount; row++) {\r\n                for (int column \u003d 0; column \u003c columnCount; column++) {\r\n                    value \u003d icd.getValue(row, column);\r\n                    double v;\r\n                    if ((value !\u003d null)\r\n                            \u0026\u0026 !Double.isNaN(v \u003d value.doubleValue())) {\r\n                        minimum \u003d Math.min(v, minimum);\r\n                        maximum \u003d Math.max(v, maximum);\r\n                    }\r\n                    lvalue \u003d icd.getStartValue(row, column);\r\n                    if (lvalue !\u003d null\r\n                            \u0026\u0026 !Double.isNaN(v \u003d lvalue.doubleValue())) {\r\n                        minimum \u003d Math.min(v, minimum);\r\n                        maximum \u003d Math.max(v, maximum);\r\n                    }\r\n                    uvalue \u003d icd.getEndValue(row, column);\r\n                    if (uvalue !\u003d null \r\n                            \u0026\u0026 !Double.isNaN(v \u003d uvalue.doubleValue())) {\r\n                        minimum \u003d Math.min(v, minimum);\r\n                        maximum \u003d Math.max(v, maximum);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // handle the standard case (plain CategoryDataset)\r\n            for (int row \u003d 0; row \u003c rowCount; row++) {\r\n                for (int column \u003d 0; column \u003c columnCount; column++) {\r\n                    Number value \u003d dataset.getValue(row, column);\r\n                    if (value !\u003d null) {\r\n                        double v \u003d value.doubleValue();\r\n                        if (!Double.isNaN(v)) {\r\n                            minimum \u003d Math.min(minimum, v);\r\n                            maximum \u003d Math.max(maximum, v);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (minimum \u003d\u003d Double.POSITIVE_INFINITY) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new Range(minimum, maximum);\r\n        }\r\n    }",
    "begin_line": 971,
    "end_line": 1027,
    "comment": "/** \n * Iterates over the data item of the category dataset to find the range bounds.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  a flag that determines whether or not they-interval is taken into account.\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @since 1.0.10\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateToFindRangeBounds#1042",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateToFindRangeBounds(org.jfree.data.category.CategoryDataset, java.util.List, boolean)",
    "snippet": "public static Range iterateToFindRangeBounds(CategoryDataset dataset,\r\n            List visibleSeriesKeys, boolean includeInterval) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        if (visibleSeriesKeys \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\r\n                    \"Null \u0027visibleSeriesKeys\u0027 argument.\");\r\n        }\r\n\r\n        double minimum \u003d Double.POSITIVE_INFINITY;\r\n        double maximum \u003d Double.NEGATIVE_INFINITY;\r\n        int columnCount \u003d dataset.getColumnCount();\r\n        if (includeInterval\r\n                \u0026\u0026 dataset instanceof BoxAndWhiskerCategoryDataset) {\r\n            // handle special case of BoxAndWhiskerDataset\r\n            BoxAndWhiskerCategoryDataset bx\r\n                    \u003d (BoxAndWhiskerCategoryDataset) dataset;\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.getRowIndex(seriesKey);\r\n                int itemCount \u003d dataset.getColumnCount();\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    Number lvalue \u003d bx.getMinRegularValue(series, item);\r\n                    if (lvalue \u003d\u003d null) {\r\n                        lvalue \u003d bx.getValue(series, item);\r\n                    }\r\n                    Number uvalue \u003d bx.getMaxRegularValue(series, item);\r\n                    if (uvalue \u003d\u003d null) {\r\n                        uvalue \u003d bx.getValue(series, item);\r\n                    }\r\n                    if (lvalue !\u003d null) {\r\n                        minimum \u003d Math.min(minimum, lvalue.doubleValue());\r\n                    }\r\n                    if (uvalue !\u003d null) {\r\n                        maximum \u003d Math.max(maximum, uvalue.doubleValue());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (includeInterval\r\n                \u0026\u0026 dataset instanceof IntervalCategoryDataset) {\r\n            // handle the special case where the dataset has y-intervals that\r\n            // we want to measure\r\n            IntervalCategoryDataset icd \u003d (IntervalCategoryDataset) dataset;\r\n            Number lvalue, uvalue;\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.getRowIndex(seriesKey);\r\n                for (int column \u003d 0; column \u003c columnCount; column++) {\r\n                    lvalue \u003d icd.getStartValue(series, column);\r\n                    uvalue \u003d icd.getEndValue(series, column);\r\n                    if (lvalue !\u003d null \u0026\u0026 !Double.isNaN(lvalue.doubleValue())) {\r\n                        minimum \u003d Math.min(minimum, lvalue.doubleValue());\r\n                    }\r\n                    if (uvalue !\u003d null \u0026\u0026 !Double.isNaN(uvalue.doubleValue())) {\r\n                        maximum \u003d Math.max(maximum, uvalue.doubleValue());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (includeInterval\r\n                \u0026\u0026 dataset instanceof MultiValueCategoryDataset) {\r\n            // handle the special case where the dataset has y-intervals that\r\n            // we want to measure\r\n            MultiValueCategoryDataset mvcd\r\n                    \u003d (MultiValueCategoryDataset) dataset;\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.getRowIndex(seriesKey);\r\n                for (int column \u003d 0; column \u003c columnCount; column++) {\r\n                    List values \u003d mvcd.getValues(series, column);\r\n                    Iterator valueIterator \u003d values.iterator();\r\n                    while (valueIterator.hasNext()) {\r\n                    \tObject o \u003d valueIterator.next();\r\n\t\t\t\t\t\tif (o instanceof Number){\r\n\t\t\t\t\t\t\tdouble v \u003d ((Number) o).doubleValue();\r\n\t\t\t\t\t\t\tif (!Double.isNaN(v)){\r\n\t                            minimum \u003d Math.min(minimum, v);\r\n\t                            maximum \u003d Math.max(maximum, v);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n                    }\r\n               }\r\n            }\r\n        }\r\n        else if (includeInterval\r\n                \u0026\u0026 dataset instanceof StatisticalCategoryDataset) {\r\n            // handle the special case where the dataset has y-intervals that\r\n            // we want to measure\r\n            StatisticalCategoryDataset scd\r\n                    \u003d (StatisticalCategoryDataset) dataset;\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.getRowIndex(seriesKey);\r\n                for (int column \u003d 0; column \u003c columnCount; column++) {\r\n                    Number meanN \u003d scd.getMeanValue(series, column);\r\n                    if (meanN !\u003d null) {\r\n                        double std \u003d 0.0;\r\n                        Number stdN \u003d scd.getStdDevValue(series, column);\r\n                        if (stdN !\u003d null) {\r\n                            std \u003d stdN.doubleValue();\r\n                            if (Double.isNaN(std)) {\r\n                                std \u003d 0.0;\r\n                            }\r\n                        }\r\n                        double mean \u003d meanN.doubleValue();\r\n                        if (!Double.isNaN(mean)) {\r\n                            minimum \u003d Math.min(minimum, mean - std);\r\n                            maximum \u003d Math.max(maximum, mean + std);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // handle the standard case (plain CategoryDataset)\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.getRowIndex(seriesKey);\r\n                for (int column \u003d 0; column \u003c columnCount; column++) {\r\n                    Number value \u003d dataset.getValue(series, column);\r\n                    if (value !\u003d null) {\r\n                        double v \u003d value.doubleValue();\r\n                        if (!Double.isNaN(v)) {\r\n                            minimum \u003d Math.min(minimum, v);\r\n                            maximum \u003d Math.max(maximum, v);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (minimum \u003d\u003d Double.POSITIVE_INFINITY) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new Range(minimum, maximum);\r\n        }\r\n    }",
    "begin_line": 1042,
    "end_line": 1186,
    "comment": "/** \n * Iterates over the data item of the category dataset to find the range bounds.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  a flag that determines whether or not they-interval is taken into account.\n * @param visibleSeriesKeys  the visible series keys.\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @since 1.0.13\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateXYRangeBounds#1198",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateXYRangeBounds(org.jfree.data.xy.XYDataset)",
    "snippet": "public static Range iterateXYRangeBounds(XYDataset dataset) {\r\n        return iterateRangeBounds(dataset);\r\n    }",
    "begin_line": 1198,
    "end_line": 1200,
    "comment": "/** \n * Iterates over the data item of the xy dataset to find the range bounds.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @deprecated As of 1.0.10, use {@link #iterateRangeBounds(XYDataset)}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateRangeBounds#1212",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateRangeBounds(org.jfree.data.xy.XYDataset)",
    "snippet": "public static Range iterateRangeBounds(XYDataset dataset) {\r\n        return iterateRangeBounds(dataset, true);\r\n    }",
    "begin_line": 1212,
    "end_line": 1214,
    "comment": "/** \n * Iterates over the data item of the xy dataset to find the range bounds.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @since 1.0.10\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateRangeBounds#1229",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateRangeBounds(org.jfree.data.xy.XYDataset, boolean)",
    "snippet": "public static Range iterateRangeBounds(XYDataset dataset,\r\n            boolean includeInterval) {\r\n        double minimum \u003d Double.POSITIVE_INFINITY;\r\n        double maximum \u003d Double.NEGATIVE_INFINITY;\r\n        int seriesCount \u003d dataset.getSeriesCount();\r\n\r\n        // handle three cases by dataset type\r\n        if (includeInterval \u0026\u0026 dataset instanceof IntervalXYDataset) {\r\n            // handle special case of IntervalXYDataset\r\n            IntervalXYDataset ixyd \u003d (IntervalXYDataset) dataset;\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double lvalue \u003d ixyd.getStartYValue(series, item);\r\n                    double uvalue \u003d ixyd.getEndYValue(series, item);\r\n                    if (!Double.isNaN(lvalue)) {\r\n                        minimum \u003d Math.min(minimum, lvalue);\r\n                    }\r\n                    if (!Double.isNaN(uvalue)) {\r\n                        maximum \u003d Math.max(maximum, uvalue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (includeInterval \u0026\u0026 dataset instanceof OHLCDataset) {\r\n            // handle special case of OHLCDataset\r\n            OHLCDataset ohlc \u003d (OHLCDataset) dataset;\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double lvalue \u003d ohlc.getLowValue(series, item);\r\n                    double uvalue \u003d ohlc.getHighValue(series, item);\r\n                    if (!Double.isNaN(lvalue)) {\r\n                        minimum \u003d Math.min(minimum, lvalue);\r\n                    }\r\n                    if (!Double.isNaN(uvalue)) {\r\n                        maximum \u003d Math.max(maximum, uvalue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // standard case - plain XYDataset\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double value \u003d dataset.getYValue(series, item);\r\n                    if (!Double.isNaN(value)) {\r\n                        minimum \u003d Math.min(minimum, value);\r\n                        maximum \u003d Math.max(maximum, value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (minimum \u003d\u003d Double.POSITIVE_INFINITY) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new Range(minimum, maximum);\r\n        }\r\n    }",
    "begin_line": 1229,
    "end_line": 1289,
    "comment": "/** \n * Iterates over the data items of the xy dataset to find the range bounds.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  a flag that determines, for an{@link IntervalXYDataset}, whether the y-interval or just the y-value is used to determine the overall range.\n * @return The range (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @since 1.0.10\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateToFindDomainBounds#1306",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateToFindDomainBounds(org.jfree.data.xy.XYDataset, java.util.List, boolean)",
    "snippet": "public static Range iterateToFindDomainBounds(XYDataset dataset,\r\n            List visibleSeriesKeys, boolean includeInterval) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        if (visibleSeriesKeys \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\r\n                    \"Null \u0027visibleSeriesKeys\u0027 argument.\");\r\n        }\r\n\r\n        double minimum \u003d Double.POSITIVE_INFINITY;\r\n        double maximum \u003d Double.NEGATIVE_INFINITY;\r\n\r\n        if (includeInterval \u0026\u0026 dataset instanceof IntervalXYDataset) {\r\n            // handle special case of IntervalXYDataset\r\n            IntervalXYDataset ixyd \u003d (IntervalXYDataset) dataset;\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.indexOf(seriesKey);\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double lvalue \u003d ixyd.getStartXValue(series, item);\r\n                    double uvalue \u003d ixyd.getEndXValue(series, item);\r\n                    if (!Double.isNaN(lvalue)) {\r\n                        minimum \u003d Math.min(minimum, lvalue);\r\n                    }\r\n                    if (!Double.isNaN(uvalue)) {\r\n                        maximum \u003d Math.max(maximum, uvalue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // standard case - plain XYDataset\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.indexOf(seriesKey);\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double x \u003d dataset.getXValue(series, item);\r\n                    if (!Double.isNaN(x)) {\r\n                        minimum \u003d Math.min(minimum, x);\r\n                        maximum \u003d Math.max(maximum, x);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (minimum \u003d\u003d Double.POSITIVE_INFINITY) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new Range(minimum, maximum);\r\n        }\r\n    }",
    "begin_line": 1306,
    "end_line": 1363,
    "comment": "/** \n * Returns the range of x-values in the specified dataset for the data items belonging to the visible series.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param visibleSeriesKeys  the visible series keys (\u003ccode\u003enull\u003c/code\u003e notpermitted).\n * @param includeInterval  a flag that determines whether or not they-interval for the dataset is included (this only applies if the dataset is an instance of IntervalXYDataset).\n * @return The x-range (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @since 1.0.13\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.iterateToFindRangeBounds#1382",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.iterateToFindRangeBounds(org.jfree.data.xy.XYDataset, java.util.List, org.jfree.data.Range, boolean)",
    "snippet": "public static Range iterateToFindRangeBounds(XYDataset dataset,\r\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        if (visibleSeriesKeys \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\r\n                    \"Null \u0027visibleSeriesKeys\u0027 argument.\");\r\n        }\r\n        if (xRange \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027xRange\u0027 argument\");\r\n        }\r\n\r\n        double minimum \u003d Double.POSITIVE_INFINITY;\r\n        double maximum \u003d Double.NEGATIVE_INFINITY;\r\n\r\n        // handle three cases by dataset type\r\n        if (includeInterval \u0026\u0026 dataset instanceof OHLCDataset) {\r\n            // handle special case of OHLCDataset\r\n            OHLCDataset ohlc \u003d (OHLCDataset) dataset;\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.indexOf(seriesKey);\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double x \u003d ohlc.getXValue(series, item);\r\n                    if (xRange.contains(x)) {\r\n                        double lvalue \u003d ohlc.getLowValue(series, item);\r\n                        double uvalue \u003d ohlc.getHighValue(series, item);\r\n                        if (!Double.isNaN(lvalue)) {\r\n                            minimum \u003d Math.min(minimum, lvalue);\r\n                        }\r\n                        if (!Double.isNaN(uvalue)) {\r\n                            maximum \u003d Math.max(maximum, uvalue);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (includeInterval \u0026\u0026 dataset instanceof BoxAndWhiskerXYDataset) {\r\n            // handle special case of BoxAndWhiskerXYDataset\r\n            BoxAndWhiskerXYDataset bx \u003d (BoxAndWhiskerXYDataset) dataset;\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.indexOf(seriesKey);\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double x \u003d bx.getXValue(series, item);\r\n                    if (xRange.contains(x)) {\r\n                        Number lvalue \u003d bx.getMinRegularValue(series, item);\r\n                        Number uvalue \u003d bx.getMaxRegularValue(series, item);\r\n                        if (lvalue !\u003d null) {\r\n                            minimum \u003d Math.min(minimum, lvalue.doubleValue());\r\n                        }\r\n                        if (uvalue !\u003d null) {\r\n                            maximum \u003d Math.max(maximum, uvalue.doubleValue());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (includeInterval \u0026\u0026 dataset instanceof IntervalXYDataset) {\r\n            // handle special case of IntervalXYDataset\r\n            IntervalXYDataset ixyd \u003d (IntervalXYDataset) dataset;\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.indexOf(seriesKey);\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double x \u003d ixyd.getXValue(series, item);\r\n                    if (xRange.contains(x)) {\r\n                        double lvalue \u003d ixyd.getStartYValue(series, item);\r\n                        double uvalue \u003d ixyd.getEndYValue(series, item);\r\n                        if (!Double.isNaN(lvalue)) {\r\n                            minimum \u003d Math.min(minimum, lvalue);\r\n                        }\r\n                        if (!Double.isNaN(uvalue)) {\r\n                            maximum \u003d Math.max(maximum, uvalue);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // standard case - plain XYDataset\r\n            Iterator iterator \u003d visibleSeriesKeys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Comparable seriesKey \u003d (Comparable) iterator.next();\r\n                int series \u003d dataset.indexOf(seriesKey);\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double x \u003d dataset.getXValue(series, item);\r\n                    double y \u003d dataset.getYValue(series, item);\r\n                    if (xRange.contains(x)) {\r\n                        if (!Double.isNaN(y)) {\r\n                            minimum \u003d Math.min(minimum, y);\r\n                            maximum \u003d Math.max(maximum, y);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (minimum \u003d\u003d Double.POSITIVE_INFINITY) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new Range(minimum, maximum);\r\n        }\r\n    }",
    "begin_line": 1382,
    "end_line": 1494,
    "comment": "/** \n * Returns the range of y-values in the specified dataset for the data items belonging to the visible series and with x-values in the given range.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param visibleSeriesKeys  the visible series keys (\u003ccode\u003enull\u003c/code\u003e notpermitted).\n * @param xRange  the x-range (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param includeInterval  a flag that determines whether or not they-interval for the dataset is included (this only applies if the dataset is an instance of IntervalXYDataset).\n * @return The y-range (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @since 1.0.13\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findMinimumDomainValue#1509",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findMinimumDomainValue(org.jfree.data.xy.XYDataset)",
    "snippet": "public static Number findMinimumDomainValue(XYDataset dataset) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Number result \u003d null;\r\n        // if the dataset implements DomainInfo, life is easy\r\n        if (dataset instanceof DomainInfo) {\r\n            DomainInfo info \u003d (DomainInfo) dataset;\r\n            return new Double(info.getDomainLowerBound(true));\r\n        }\r\n        else {\r\n            double minimum \u003d Double.POSITIVE_INFINITY;\r\n            int seriesCount \u003d dataset.getSeriesCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n\r\n                    double value;\r\n                    if (dataset instanceof IntervalXYDataset) {\r\n                        IntervalXYDataset intervalXYData\r\n                            \u003d (IntervalXYDataset) dataset;\r\n                        value \u003d intervalXYData.getStartXValue(series, item);\r\n                    }\r\n                    else {\r\n                        value \u003d dataset.getXValue(series, item);\r\n                    }\r\n                    if (!Double.isNaN(value)) {\r\n                        minimum \u003d Math.min(minimum, value);\r\n                    }\r\n\r\n                }\r\n            }\r\n            if (minimum \u003d\u003d Double.POSITIVE_INFINITY) {\r\n                result \u003d null;\r\n            }\r\n            else {\r\n                result \u003d new Double(minimum);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }",
    "begin_line": 1509,
    "end_line": 1550,
    "comment": "/** \n * Finds the minimum domain (or X) value for the specified dataset.  This is easy if the dataset implements the  {@link DomainInfo} interface (agood idea if there is an efficient way to determine the minimum value). Otherwise, it involves iterating over the entire data-set. \u003cp\u003e Returns \u003ccode\u003enull\u003c/code\u003e if all the data values in the dataset are \u003ccode\u003enull\u003c/code\u003e.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The minimum value (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findMaximumDomainValue#1564",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findMaximumDomainValue(org.jfree.data.xy.XYDataset)",
    "snippet": "public static Number findMaximumDomainValue(XYDataset dataset) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Number result \u003d null;\r\n        // if the dataset implements DomainInfo, life is easy\r\n        if (dataset instanceof DomainInfo) {\r\n            DomainInfo info \u003d (DomainInfo) dataset;\r\n            return new Double(info.getDomainUpperBound(true));\r\n        }\r\n\r\n        // hasn\u0027t implemented DomainInfo, so iterate...\r\n        else {\r\n            double maximum \u003d Double.NEGATIVE_INFINITY;\r\n            int seriesCount \u003d dataset.getSeriesCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n\r\n                    double value;\r\n                    if (dataset instanceof IntervalXYDataset) {\r\n                        IntervalXYDataset intervalXYData\r\n                            \u003d (IntervalXYDataset) dataset;\r\n                        value \u003d intervalXYData.getEndXValue(series, item);\r\n                    }\r\n                    else {\r\n                        value \u003d dataset.getXValue(series, item);\r\n                    }\r\n                    if (!Double.isNaN(value)) {\r\n                        maximum \u003d Math.max(maximum, value);\r\n                    }\r\n                }\r\n            }\r\n            if (maximum \u003d\u003d Double.NEGATIVE_INFINITY) {\r\n                result \u003d null;\r\n            }\r\n            else {\r\n                result \u003d new Double(maximum);\r\n            }\r\n\r\n        }\r\n\r\n        return result;\r\n    }",
    "begin_line": 1564,
    "end_line": 1607,
    "comment": "/** \n * Returns the maximum domain value for the specified dataset.  This is easy if the dataset implements the  {@link DomainInfo} interface (a goodidea if there is an efficient way to determine the maximum value). Otherwise, it involves iterating over the entire data-set.  Returns \u003ccode\u003enull\u003c/code\u003e if all the data values in the dataset are \u003ccode\u003enull\u003c/code\u003e.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The maximum value (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findMinimumRangeValue#1621",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findMinimumRangeValue(org.jfree.data.category.CategoryDataset)",
    "snippet": "public static Number findMinimumRangeValue(CategoryDataset dataset) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n\r\n        if (dataset instanceof RangeInfo) {\r\n            RangeInfo info \u003d (RangeInfo) dataset;\r\n            return new Double(info.getRangeLowerBound(true));\r\n        }\r\n\r\n        // hasn\u0027t implemented RangeInfo, so we\u0027ll have to iterate...\r\n        else {\r\n            double minimum \u003d Double.POSITIVE_INFINITY;\r\n            int seriesCount \u003d dataset.getRowCount();\r\n            int itemCount \u003d dataset.getColumnCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    Number value;\r\n                    if (dataset instanceof IntervalCategoryDataset) {\r\n                        IntervalCategoryDataset icd\r\n                                \u003d (IntervalCategoryDataset) dataset;\r\n                        value \u003d icd.getStartValue(series, item);\r\n                    }\r\n                    else {\r\n                        value \u003d dataset.getValue(series, item);\r\n                    }\r\n                    if (value !\u003d null) {\r\n                        minimum \u003d Math.min(minimum, value.doubleValue());\r\n                    }\r\n                }\r\n            }\r\n            if (minimum \u003d\u003d Double.POSITIVE_INFINITY) {\r\n                return null;\r\n            }\r\n            else {\r\n                return new Double(minimum);\r\n            }\r\n\r\n        }\r\n\r\n    }",
    "begin_line": 1621,
    "end_line": 1662,
    "comment": "/** \n * Returns the minimum range value for the specified dataset.  This is easy if the dataset implements the  {@link RangeInfo} interface (a goodidea if there is an efficient way to determine the minimum value). Otherwise, it involves iterating over the entire data-set.  Returns \u003ccode\u003enull\u003c/code\u003e if all the data values in the dataset are \u003ccode\u003enull\u003c/code\u003e.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The minimum value (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findMinimumRangeValue#1676",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findMinimumRangeValue(org.jfree.data.xy.XYDataset)",
    "snippet": "public static Number findMinimumRangeValue(XYDataset dataset) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n\r\n        // work out the minimum value...\r\n        if (dataset instanceof RangeInfo) {\r\n            RangeInfo info \u003d (RangeInfo) dataset;\r\n            return new Double(info.getRangeLowerBound(true));\r\n        }\r\n\r\n        // hasn\u0027t implemented RangeInfo, so we\u0027ll have to iterate...\r\n        else {\r\n            double minimum \u003d Double.POSITIVE_INFINITY;\r\n            int seriesCount \u003d dataset.getSeriesCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n\r\n                    double value;\r\n                    if (dataset instanceof IntervalXYDataset) {\r\n                        IntervalXYDataset intervalXYData\r\n                                \u003d (IntervalXYDataset) dataset;\r\n                        value \u003d intervalXYData.getStartYValue(series, item);\r\n                    }\r\n                    else if (dataset instanceof OHLCDataset) {\r\n                        OHLCDataset highLowData \u003d (OHLCDataset) dataset;\r\n                        value \u003d highLowData.getLowValue(series, item);\r\n                    }\r\n                    else {\r\n                        value \u003d dataset.getYValue(series, item);\r\n                    }\r\n                    if (!Double.isNaN(value)) {\r\n                        minimum \u003d Math.min(minimum, value);\r\n                    }\r\n\r\n                }\r\n            }\r\n            if (minimum \u003d\u003d Double.POSITIVE_INFINITY) {\r\n                return null;\r\n            }\r\n            else {\r\n                return new Double(minimum);\r\n            }\r\n\r\n        }\r\n\r\n    }",
    "begin_line": 1676,
    "end_line": 1724,
    "comment": "/** \n * Returns the minimum range value for the specified dataset.  This is easy if the dataset implements the  {@link RangeInfo} interface (a goodidea if there is an efficient way to determine the minimum value). Otherwise, it involves iterating over the entire data-set.  Returns \u003ccode\u003enull\u003c/code\u003e if all the data values in the dataset are \u003ccode\u003enull\u003c/code\u003e.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The minimum value (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findMaximumRangeValue#1737",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findMaximumRangeValue(org.jfree.data.category.CategoryDataset)",
    "snippet": "public static Number findMaximumRangeValue(CategoryDataset dataset) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n\r\n        // work out the minimum value...\r\n        if (dataset instanceof RangeInfo) {\r\n            RangeInfo info \u003d (RangeInfo) dataset;\r\n            return new Double(info.getRangeUpperBound(true));\r\n        }\r\n\r\n        // hasn\u0027t implemented RangeInfo, so we\u0027ll have to iterate...\r\n        else {\r\n\r\n            double maximum \u003d Double.NEGATIVE_INFINITY;\r\n            int seriesCount \u003d dataset.getRowCount();\r\n            int itemCount \u003d dataset.getColumnCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    Number value;\r\n                    if (dataset instanceof IntervalCategoryDataset) {\r\n                        IntervalCategoryDataset icd\r\n                            \u003d (IntervalCategoryDataset) dataset;\r\n                        value \u003d icd.getEndValue(series, item);\r\n                    }\r\n                    else {\r\n                        value \u003d dataset.getValue(series, item);\r\n                    }\r\n                    if (value !\u003d null) {\r\n                        maximum \u003d Math.max(maximum, value.doubleValue());\r\n                    }\r\n                }\r\n            }\r\n            if (maximum \u003d\u003d Double.NEGATIVE_INFINITY) {\r\n                return null;\r\n            }\r\n            else {\r\n                return new Double(maximum);\r\n            }\r\n\r\n        }\r\n\r\n    }",
    "begin_line": 1737,
    "end_line": 1780,
    "comment": "/** \n * Returns the maximum range value for the specified dataset.  This is easy if the dataset implements the  {@link RangeInfo} interface (a good ideaif there is an efficient way to determine the maximum value). Otherwise, it involves iterating over the entire data-set.  Returns \u003ccode\u003enull\u003c/code\u003e if all the data values are \u003ccode\u003enull\u003c/code\u003e.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The maximum value (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findMaximumRangeValue#1793",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findMaximumRangeValue(org.jfree.data.xy.XYDataset)",
    "snippet": "public static Number findMaximumRangeValue(XYDataset dataset) {\r\n\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n\r\n        // work out the minimum value...\r\n        if (dataset instanceof RangeInfo) {\r\n            RangeInfo info \u003d (RangeInfo) dataset;\r\n            return new Double(info.getRangeUpperBound(true));\r\n        }\r\n\r\n        // hasn\u0027t implemented RangeInfo, so we\u0027ll have to iterate...\r\n        else  {\r\n\r\n            double maximum \u003d Double.NEGATIVE_INFINITY;\r\n            int seriesCount \u003d dataset.getSeriesCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                int itemCount \u003d dataset.getItemCount(series);\r\n                for (int item \u003d 0; item \u003c itemCount; item++) {\r\n                    double value;\r\n                    if (dataset instanceof IntervalXYDataset) {\r\n                        IntervalXYDataset intervalXYData\r\n                            \u003d (IntervalXYDataset) dataset;\r\n                        value \u003d intervalXYData.getEndYValue(series, item);\r\n                    }\r\n                    else if (dataset instanceof OHLCDataset) {\r\n                        OHLCDataset highLowData \u003d (OHLCDataset) dataset;\r\n                        value \u003d highLowData.getHighValue(series, item);\r\n                    }\r\n                    else {\r\n                        value \u003d dataset.getYValue(series, item);\r\n                    }\r\n                    if (!Double.isNaN(value)) {\r\n                        maximum \u003d Math.max(maximum, value);\r\n                    }\r\n                }\r\n            }\r\n            if (maximum \u003d\u003d Double.NEGATIVE_INFINITY) {\r\n                return null;\r\n            }\r\n            else {\r\n                return new Double(maximum);\r\n            }\r\n\r\n        }\r\n\r\n    }",
    "begin_line": 1793,
    "end_line": 1840,
    "comment": "/** \n * Returns the maximum range value for the specified dataset.  This is easy if the dataset implements the  {@link RangeInfo} interface (a goodidea if there is an efficient way to determine the maximum value). Otherwise, it involves iterating over the entire data-set.  Returns \u003ccode\u003enull\u003c/code\u003e if all the data values are \u003ccode\u003enull\u003c/code\u003e.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The maximum value (possibly \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findStackedRangeBounds#1850",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findStackedRangeBounds(org.jfree.data.category.CategoryDataset)",
    "snippet": "public static Range findStackedRangeBounds(CategoryDataset dataset) {\r\n        return findStackedRangeBounds(dataset, 0.0);\r\n    }",
    "begin_line": 1850,
    "end_line": 1852,
    "comment": "/** \n * Returns the minimum and maximum values for the dataset\u0027s range (y-values), assuming that the series in one category are stacked.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range (\u003ccode\u003enull\u003c/code\u003e if the dataset contains no values).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findStackedRangeBounds#1863",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findStackedRangeBounds(org.jfree.data.category.CategoryDataset, double)",
    "snippet": "public static Range findStackedRangeBounds(CategoryDataset dataset,\r\n            double base) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Range result \u003d null;\r\n        double minimum \u003d Double.POSITIVE_INFINITY;\r\n        double maximum \u003d Double.NEGATIVE_INFINITY;\r\n        int categoryCount \u003d dataset.getColumnCount();\r\n        for (int item \u003d 0; item \u003c categoryCount; item++) {\r\n            double positive \u003d base;\r\n            double negative \u003d base;\r\n            int seriesCount \u003d dataset.getRowCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                Number number \u003d dataset.getValue(series, item);\r\n                if (number !\u003d null) {\r\n                    double value \u003d number.doubleValue();\r\n                    if (value \u003e 0.0) {\r\n                        positive \u003d positive + value;\r\n                    }\r\n                    if (value \u003c 0.0) {\r\n                        negative \u003d negative + value;\r\n                        // \u0027+\u0027, remember value is negative\r\n                    }\r\n                }\r\n            }\r\n            minimum \u003d Math.min(minimum, negative);\r\n            maximum \u003d Math.max(maximum, positive);\r\n        }\r\n        if (minimum \u003c\u003d maximum) {\r\n            result \u003d new Range(minimum, maximum);\r\n        }\r\n        return result;\r\n\r\n    }",
    "begin_line": 1863,
    "end_line": 1897,
    "comment": "/** \n * Returns the minimum and maximum values for the dataset\u0027s range (y-values), assuming that the series in one category are stacked.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param base  the base value for the bars.\n * @return The range (\u003ccode\u003enull\u003c/code\u003e if the dataset contains no values).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findStackedRangeBounds#1909",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findStackedRangeBounds(org.jfree.data.category.CategoryDataset, org.jfree.data.KeyToGroupMap)",
    "snippet": "public static Range findStackedRangeBounds(CategoryDataset dataset,\r\n                                               KeyToGroupMap map) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        boolean hasValidData \u003d false;\r\n        Range result \u003d null;\r\n\r\n        // create an array holding the group indices for each series...\r\n        int[] groupIndex \u003d new int[dataset.getRowCount()];\r\n        for (int i \u003d 0; i \u003c dataset.getRowCount(); i++) {\r\n            groupIndex[i] \u003d map.getGroupIndex(map.getGroup(\r\n                    dataset.getRowKey(i)));\r\n        }\r\n\r\n        // minimum and maximum for each group...\r\n        int groupCount \u003d map.getGroupCount();\r\n        double[] minimum \u003d new double[groupCount];\r\n        double[] maximum \u003d new double[groupCount];\r\n\r\n        int categoryCount \u003d dataset.getColumnCount();\r\n        for (int item \u003d 0; item \u003c categoryCount; item++) {\r\n            double[] positive \u003d new double[groupCount];\r\n            double[] negative \u003d new double[groupCount];\r\n            int seriesCount \u003d dataset.getRowCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                Number number \u003d dataset.getValue(series, item);\r\n                if (number !\u003d null) {\r\n                    hasValidData \u003d true;\r\n                    double value \u003d number.doubleValue();\r\n                    if (value \u003e 0.0) {\r\n                        positive[groupIndex[series]]\r\n                                 \u003d positive[groupIndex[series]] + value;\r\n                    }\r\n                    if (value \u003c 0.0) {\r\n                        negative[groupIndex[series]]\r\n                                 \u003d negative[groupIndex[series]] + value;\r\n                                 // \u0027+\u0027, remember value is negative\r\n                    }\r\n                }\r\n            }\r\n            for (int g \u003d 0; g \u003c groupCount; g++) {\r\n                minimum[g] \u003d Math.min(minimum[g], negative[g]);\r\n                maximum[g] \u003d Math.max(maximum[g], positive[g]);\r\n            }\r\n        }\r\n        if (hasValidData) {\r\n            for (int j \u003d 0; j \u003c groupCount; j++) {\r\n                result \u003d Range.combine(result, new Range(minimum[j],\r\n                        maximum[j]));\r\n            }\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 1909,
    "end_line": 1962,
    "comment": "/** \n * Returns the minimum and maximum values for the dataset\u0027s range (y-values), assuming that the series in one category are stacked.\n * @param dataset  the dataset.\n * @param map  a structure that maps series to groups.\n * @return The value range (\u003ccode\u003enull\u003c/code\u003e if the dataset contains novalues).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findMinimumStackedRangeValue#1974",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findMinimumStackedRangeValue(org.jfree.data.category.CategoryDataset)",
    "snippet": "public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Number result \u003d null;\r\n        boolean hasValidData \u003d false;\r\n        double minimum \u003d 0.0;\r\n        int categoryCount \u003d dataset.getColumnCount();\r\n        for (int item \u003d 0; item \u003c categoryCount; item++) {\r\n            double total \u003d 0.0;\r\n            int seriesCount \u003d dataset.getRowCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                Number number \u003d dataset.getValue(series, item);\r\n                if (number !\u003d null) {\r\n                    hasValidData \u003d true;\r\n                    double value \u003d number.doubleValue();\r\n                    if (value \u003c 0.0) {\r\n                        total \u003d total + value;\r\n                        // \u0027+\u0027, remember value is negative\r\n                    }\r\n                }\r\n            }\r\n            minimum \u003d Math.min(minimum, total);\r\n        }\r\n        if (hasValidData) {\r\n            result \u003d new Double(minimum);\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 1974,
    "end_line": 2002,
    "comment": "/** \n * Returns the minimum value in the dataset range, assuming that values in each category are \"stacked\".\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The minimum value.\n * @see #findMaximumStackedRangeValue(CategoryDataset)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findMaximumStackedRangeValue#2014",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findMaximumStackedRangeValue(org.jfree.data.category.CategoryDataset)",
    "snippet": "public static Number findMaximumStackedRangeValue(CategoryDataset dataset) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        Number result \u003d null;\r\n        boolean hasValidData \u003d false;\r\n        double maximum \u003d 0.0;\r\n        int categoryCount \u003d dataset.getColumnCount();\r\n        for (int item \u003d 0; item \u003c categoryCount; item++) {\r\n            double total \u003d 0.0;\r\n            int seriesCount \u003d dataset.getRowCount();\r\n            for (int series \u003d 0; series \u003c seriesCount; series++) {\r\n                Number number \u003d dataset.getValue(series, item);\r\n                if (number !\u003d null) {\r\n                    hasValidData \u003d true;\r\n                    double value \u003d number.doubleValue();\r\n                    if (value \u003e 0.0) {\r\n                        total \u003d total + value;\r\n                    }\r\n                }\r\n            }\r\n            maximum \u003d Math.max(maximum, total);\r\n        }\r\n        if (hasValidData) {\r\n            result \u003d new Double(maximum);\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 2014,
    "end_line": 2041,
    "comment": "/** \n * Returns the maximum value in the dataset range, assuming that values in each category are \"stacked\".\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The maximum value (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @see #findMinimumStackedRangeValue(CategoryDataset)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findStackedRangeBounds#2051",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findStackedRangeBounds(org.jfree.data.xy.TableXYDataset)",
    "snippet": "public static Range findStackedRangeBounds(TableXYDataset dataset) {\r\n        return findStackedRangeBounds(dataset, 0.0);\r\n    }",
    "begin_line": 2051,
    "end_line": 2053,
    "comment": "/** \n * Returns the minimum and maximum values for the dataset\u0027s range, assuming that the series are stacked.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range ([0.0, 0.0] if the dataset contains no values).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findStackedRangeBounds#2064",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findStackedRangeBounds(org.jfree.data.xy.TableXYDataset, double)",
    "snippet": "public static Range findStackedRangeBounds(TableXYDataset dataset,\r\n                                               double base) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        double minimum \u003d base;\r\n        double maximum \u003d base;\r\n        for (int itemNo \u003d 0; itemNo \u003c dataset.getItemCount(); itemNo++) {\r\n            double positive \u003d base;\r\n            double negative \u003d base;\r\n            int seriesCount \u003d dataset.getSeriesCount();\r\n            for (int seriesNo \u003d 0; seriesNo \u003c seriesCount; seriesNo++) {\r\n                double y \u003d dataset.getYValue(seriesNo, itemNo);\r\n                if (!Double.isNaN(y)) {\r\n                    if (y \u003e 0.0) {\r\n                        positive +\u003d y;\r\n                    }\r\n                    else {\r\n                        negative +\u003d y;\r\n                    }\r\n                }\r\n            }\r\n            if (positive \u003e maximum) {\r\n                maximum \u003d positive;\r\n            }\r\n            if (negative \u003c minimum) {\r\n                minimum \u003d negative;\r\n            }\r\n        }\r\n        if (minimum \u003c\u003d maximum) {\r\n            return new Range(minimum, maximum);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }",
    "begin_line": 2064,
    "end_line": 2099,
    "comment": "/** \n * Returns the minimum and maximum values for the dataset\u0027s range, assuming that the series are stacked, using the specified base value.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param base  the base value.\n * @return The range (\u003ccode\u003enull\u003c/code\u003e if the dataset contains no values).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.calculateStackTotal#2112",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.calculateStackTotal(org.jfree.data.xy.TableXYDataset, int)",
    "snippet": "public static double calculateStackTotal(TableXYDataset dataset, int item) {\r\n        double total \u003d 0.0;\r\n        int seriesCount \u003d dataset.getSeriesCount();\r\n        for (int s \u003d 0; s \u003c seriesCount; s++) {\r\n            double value \u003d dataset.getYValue(s, item);\r\n            if (!Double.isNaN(value)) {\r\n                total \u003d total + value;\r\n            }\r\n        }\r\n        return total;\r\n    }",
    "begin_line": 2112,
    "end_line": 2122,
    "comment": "/** \n * Calculates the total for the y-values in all series for a given item index.\n * @param dataset  the dataset.\n * @param item  the item index.\n * @return The total.\n * @since 1.0.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DatasetUtilities.findCumulativeRangeBounds#2134",
    "is_bug": true,
    "src_path": "org/jfree/data/general/DatasetUtilities.java",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findCumulativeRangeBounds(org.jfree.data.category.CategoryDataset)",
    "snippet": "public static Range findCumulativeRangeBounds(CategoryDataset dataset) {\r\n        if (dataset \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027dataset\u0027 argument.\");\r\n        }\r\n        boolean allItemsNull \u003d true; // we\u0027ll set this to false if there is at\r\n                                     // least one non-null data item...\r\n        double minimum \u003d 0.0;\r\n        double maximum \u003d 0.0;\r\n        for (int row \u003d 0; row \u003c dataset.getRowCount(); row++) {\r\n            double runningTotal \u003d 0.0;\r\n            for (int column \u003d 0; column \u003c\u003d dataset.getColumnCount() - 1;\r\n                 column++) {\r\n                Number n \u003d dataset.getValue(row, column);\r\n                if (n !\u003d null) {\r\n                    allItemsNull \u003d false;\r\n                    double value \u003d n.doubleValue();\r\n                    if (!Double.isNaN(value)) {\r\n                        runningTotal \u003d runningTotal + value;\r\n                        minimum \u003d Math.min(minimum, runningTotal);\r\n                        maximum \u003d Math.max(maximum, runningTotal);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!allItemsNull) {\r\n            return new Range(minimum, maximum);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }",
    "begin_line": 2134,
    "end_line": 2164,
    "comment": "/** \n * Calculates the range of values for a dataset where each item is the running total of the items for the current series.\n * @param dataset  the dataset (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @return The range.\n * @see #findRangeBounds(CategoryDataset)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.Series#103",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.Series(java.lang.Comparable)",
    "snippet": "protected Series(Comparable key) {\r\n        this(key, null);\r\n    }",
    "begin_line": 103,
    "end_line": 105,
    "comment": "/** \n * Creates a new series with the specified key.\n * @param key  the series key (\u003ccode\u003enull\u003c/code\u003e not permitted).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.Series#113",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.Series(java.lang.Comparable, java.lang.String)",
    "snippet": "protected Series(Comparable key, String description) {\r\n        if (key \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027key\u0027 argument.\");\r\n        }\r\n        this.key \u003d key;\r\n        this.description \u003d description;\r\n        this.listeners \u003d new EventListenerList();\r\n        this.propertyChangeSupport \u003d new PropertyChangeSupport(this);\r\n        this.notify \u003d true;\r\n    }",
    "begin_line": 113,
    "end_line": 122,
    "comment": "/** \n * Creates a new series with the specified key and description.\n * @param key  the series key (\u003ccode\u003enull\u003c/code\u003e NOT permitted).\n * @param description  the series description (\u003ccode\u003enull\u003c/code\u003e permitted).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.getKey#131",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.getKey()",
    "snippet": "public Comparable getKey() {\r\n        return this.key;\r\n    }",
    "begin_line": 131,
    "end_line": 133,
    "comment": "/** \n * Returns the key for the series.\n * @return The series key (never \u003ccode\u003enull\u003c/code\u003e).\n * @see #setKey(Comparable)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.setKey#143",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.setKey(java.lang.Comparable)",
    "snippet": "public void setKey(Comparable key) {\r\n        if (key \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027key\u0027 argument.\");\r\n        }\r\n        Comparable old \u003d this.key;\r\n        this.key \u003d key;\r\n        this.propertyChangeSupport.firePropertyChange(\"Key\", old, key);\r\n    }",
    "begin_line": 143,
    "end_line": 150,
    "comment": "/** \n * Sets the key for the series and sends a \u003ccode\u003ePropertyChangeEvent\u003c/code\u003e (with the property name \"Key\") to all registered listeners.\n * @param key  the key (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @see #getKey()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.getDescription#159",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.getDescription()",
    "snippet": "public String getDescription() {\r\n        return this.description;\r\n    }",
    "begin_line": 159,
    "end_line": 161,
    "comment": "/** \n * Returns a description of the series.\n * @return The series description (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @see #setDescription(String)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.setDescription#171",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.setDescription(java.lang.String)",
    "snippet": "public void setDescription(String description) {\r\n        String old \u003d this.description;\r\n        this.description \u003d description;\r\n        this.propertyChangeSupport.firePropertyChange(\"Description\", old,\r\n                description);\r\n    }",
    "begin_line": 171,
    "end_line": 176,
    "comment": "/** \n * Sets the description of the series and sends a \u003ccode\u003ePropertyChangeEvent\u003c/code\u003e to all registered listeners.\n * @param description  the description (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @see #getDescription()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.getNotify#186",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.getNotify()",
    "snippet": "public boolean getNotify() {\r\n        return this.notify;\r\n    }",
    "begin_line": 186,
    "end_line": 188,
    "comment": "/** \n * Returns the flag that controls whether or not change events are sent to registered listeners.\n * @return A boolean.\n * @see #setNotify(boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.setNotify#198",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.setNotify(boolean)",
    "snippet": "public void setNotify(boolean notify) {\r\n        if (this.notify !\u003d notify) {\r\n            this.notify \u003d notify;\r\n            fireSeriesChanged();\r\n        }\r\n    }",
    "begin_line": 198,
    "end_line": 203,
    "comment": "/** \n * Sets the flag that controls whether or not change events are sent to registered listeners.\n * @param notify  the new value of the flag.\n * @see #getNotify()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.isEmpty#213",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.isEmpty()",
    "snippet": "public boolean isEmpty() {\r\n        return (getItemCount() \u003d\u003d 0);\r\n    }",
    "begin_line": 213,
    "end_line": 215,
    "comment": "/** \n * Returns \u003ccode\u003etrue\u003c/code\u003e if the series contains no data items, and \u003ccode\u003efalse\u003c/code\u003e otherwise.\n * @return A boolean.\n * @since 1.0.7\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.getItemCount#222",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.getItemCount()",
    "snippet": "public abstract int getItemCount();",
    "begin_line": 222,
    "end_line": 222,
    "comment": "/** \n * Returns the number of data items in the series.\n * @return The number of data items in the series.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.clone#241",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.clone()",
    "snippet": "public Object clone() throws CloneNotSupportedException {\r\n\r\n        Series clone \u003d (Series) super.clone();\r\n        clone.listeners \u003d new EventListenerList();\r\n        clone.propertyChangeSupport \u003d new PropertyChangeSupport(clone);\r\n        return clone;\r\n\r\n    }",
    "begin_line": 241,
    "end_line": 248,
    "comment": "/** \n * Returns a clone of the series. \u003cP\u003e Notes: \u003cul\u003e \u003cli\u003eNo need to clone the name or description, since String object is immutable.\u003c/li\u003e \u003cli\u003eWe set the listener list to empty, since the listeners did not register with the clone.\u003c/li\u003e \u003cli\u003eSame applies to the PropertyChangeSupport instance.\u003c/li\u003e \u003c/ul\u003e\n * @return A clone of the series.\n * @throws CloneNotSupportedException  not thrown by this class, butsubclasses may differ.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.equals#257",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.equals(java.lang.Object)",
    "snippet": "public boolean equals(Object obj) {\r\n        if (obj \u003d\u003d this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof Series)) {\r\n            return false;\r\n        }\r\n        Series that \u003d (Series) obj;\r\n        if (!getKey().equals(that.getKey())) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(getDescription(), that.getDescription())) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }",
    "begin_line": 257,
    "end_line": 272,
    "comment": "/** \n * Tests the series for equality with another object.\n * @param obj  the object (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @return \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.hashCode#279",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.hashCode()",
    "snippet": "public int hashCode() {\r\n        int result;\r\n        result \u003d this.key.hashCode();\r\n        result \u003d 29 * result + (this.description !\u003d null\r\n                ? this.description.hashCode() : 0);\r\n        return result;\r\n    }",
    "begin_line": 279,
    "end_line": 285,
    "comment": "/** \n * Returns a hash code.\n * @return A hash code.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.addChangeListener#296",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.addChangeListener(org.jfree.data.event.SeriesChangeListener)",
    "snippet": "public void addChangeListener(SeriesChangeListener listener) {\r\n        this.listeners.add(SeriesChangeListener.class, listener);\r\n    }",
    "begin_line": 296,
    "end_line": 298,
    "comment": "/** \n * Registers an object with this series, to receive notification whenever the series changes. \u003cP\u003e Objects being registered must implement the  {@link SeriesChangeListener}interface.\n * @param listener  the listener to register.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.removeChangeListener#306",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.removeChangeListener(org.jfree.data.event.SeriesChangeListener)",
    "snippet": "public void removeChangeListener(SeriesChangeListener listener) {\r\n        this.listeners.remove(SeriesChangeListener.class, listener);\r\n    }",
    "begin_line": 306,
    "end_line": 308,
    "comment": "/** \n * Deregisters an object, so that it not longer receives notification whenever the series changes.\n * @param listener  the listener to deregister.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.fireSeriesChanged#314",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.fireSeriesChanged()",
    "snippet": "public void fireSeriesChanged() {\r\n        if (this.notify) {\r\n            notifyListeners(new SeriesChangeEvent(this));\r\n        }\r\n    }",
    "begin_line": 314,
    "end_line": 318,
    "comment": "/** \n * General method for signalling to registered listeners that the series has been changed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.notifyListeners#326",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.notifyListeners(org.jfree.data.event.SeriesChangeEvent)",
    "snippet": "protected void notifyListeners(SeriesChangeEvent event) {\r\n\r\n        Object[] listenerList \u003d this.listeners.getListenerList();\r\n        for (int i \u003d listenerList.length - 2; i \u003e\u003d 0; i -\u003d 2) {\r\n            if (listenerList[i] \u003d\u003d SeriesChangeListener.class) {\r\n                ((SeriesChangeListener) listenerList[i + 1]).seriesChanged(\r\n                        event);\r\n            }\r\n        }\r\n\r\n    }",
    "begin_line": 326,
    "end_line": 336,
    "comment": "/** \n * Sends a change event to all registered listeners.\n * @param event  contains information about the event that triggered thenotification.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.addPropertyChangeListener#343",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.addPropertyChangeListener(java.beans.PropertyChangeListener)",
    "snippet": "public void addPropertyChangeListener(PropertyChangeListener listener) {\r\n        this.propertyChangeSupport.addPropertyChangeListener(listener);\r\n    }",
    "begin_line": 343,
    "end_line": 345,
    "comment": "/** \n * Adds a property change listener to the series.\n * @param listener  the listener.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.removePropertyChangeListener#352",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.removePropertyChangeListener(java.beans.PropertyChangeListener)",
    "snippet": "public void removePropertyChangeListener(PropertyChangeListener listener) {\r\n        this.propertyChangeSupport.removePropertyChangeListener(listener);\r\n    }",
    "begin_line": 352,
    "end_line": 354,
    "comment": "/** \n * Removes a property change listener from the series.\n * @param listener The listener.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Series.firePropertyChange#363",
    "is_bug": true,
    "src_path": "org/jfree/data/general/Series.java",
    "class_name": "org.jfree.data.general.Series",
    "signature": "org.jfree.data.general.Series.firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)",
    "snippet": "protected void firePropertyChange(String property, Object oldValue,\r\n            Object newValue) {\r\n        this.propertyChangeSupport.firePropertyChange(property, oldValue,\r\n                newValue);\r\n    }",
    "begin_line": 363,
    "end_line": 367,
    "comment": "/** \n * Fires a property change event.\n * @param property  the property key.\n * @param oldValue  the old value.\n * @param newValue  the new value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractIntervalXYDataset.getStartXValue#63",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/AbstractIntervalXYDataset.java",
    "class_name": "org.jfree.data.xy.AbstractIntervalXYDataset",
    "signature": "org.jfree.data.xy.AbstractIntervalXYDataset.getStartXValue(int, int)",
    "snippet": "public double getStartXValue(int series, int item) {\r\n        double result \u003d Double.NaN;\r\n        Number x \u003d getStartX(series, item);\r\n        if (x !\u003d null) {\r\n            result \u003d x.doubleValue();\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 63,
    "end_line": 70,
    "comment": "/** \n * Returns the start x-value (as a double primitive) for an item within a series.\n * @param series  the series index (zero-based).\n * @param item  the item index (zero-based).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractIntervalXYDataset.getEndXValue#81",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/AbstractIntervalXYDataset.java",
    "class_name": "org.jfree.data.xy.AbstractIntervalXYDataset",
    "signature": "org.jfree.data.xy.AbstractIntervalXYDataset.getEndXValue(int, int)",
    "snippet": "public double getEndXValue(int series, int item) {\r\n        double result \u003d Double.NaN;\r\n        Number x \u003d getEndX(series, item);\r\n        if (x !\u003d null) {\r\n            result \u003d x.doubleValue();\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 81,
    "end_line": 88,
    "comment": "/** \n * Returns the end x-value (as a double primitive) for an item within a series.\n * @param series  the series index (zero-based).\n * @param item  the item index (zero-based).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractIntervalXYDataset.getStartYValue#99",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/AbstractIntervalXYDataset.java",
    "class_name": "org.jfree.data.xy.AbstractIntervalXYDataset",
    "signature": "org.jfree.data.xy.AbstractIntervalXYDataset.getStartYValue(int, int)",
    "snippet": "public double getStartYValue(int series, int item) {\r\n        double result \u003d Double.NaN;\r\n        Number y \u003d getStartY(series, item);\r\n        if (y !\u003d null) {\r\n            result \u003d y.doubleValue();\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 99,
    "end_line": 106,
    "comment": "/** \n * Returns the start y-value (as a double primitive) for an item within a series.\n * @param series  the series index (zero-based).\n * @param item  the item index (zero-based).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractIntervalXYDataset.getEndYValue#117",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/AbstractIntervalXYDataset.java",
    "class_name": "org.jfree.data.xy.AbstractIntervalXYDataset",
    "signature": "org.jfree.data.xy.AbstractIntervalXYDataset.getEndYValue(int, int)",
    "snippet": "public double getEndYValue(int series, int item) {\r\n        double result \u003d Double.NaN;\r\n        Number y \u003d getEndY(series, item);\r\n        if (y !\u003d null) {\r\n            result \u003d y.doubleValue();\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 117,
    "end_line": 124,
    "comment": "/** \n * Returns the end y-value (as a double primitive) for an item within a series.\n * @param series  the series (zero-based index).\n * @param item  the item (zero-based index).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractXYDataset.getDomainOrder#63",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/AbstractXYDataset.java",
    "class_name": "org.jfree.data.xy.AbstractXYDataset",
    "signature": "org.jfree.data.xy.AbstractXYDataset.getDomainOrder()",
    "snippet": "public DomainOrder getDomainOrder() {\r\n        return DomainOrder.NONE;\r\n    }",
    "begin_line": 63,
    "end_line": 65,
    "comment": "/** \n * Returns the order of the domain (X) values.\n * @return The domain order.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractXYDataset.getXValue#75",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/AbstractXYDataset.java",
    "class_name": "org.jfree.data.xy.AbstractXYDataset",
    "signature": "org.jfree.data.xy.AbstractXYDataset.getXValue(int, int)",
    "snippet": "public double getXValue(int series, int item) {\r\n        double result \u003d Double.NaN;\r\n        Number x \u003d getX(series, item);\r\n        if (x !\u003d null) {\r\n            result \u003d x.doubleValue();\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 75,
    "end_line": 82,
    "comment": "/** \n * Returns the x-value (as a double primitive) for an item within a series.\n * @param series  the series index (zero-based).\n * @param item  the item index (zero-based).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractXYDataset.getYValue#92",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/AbstractXYDataset.java",
    "class_name": "org.jfree.data.xy.AbstractXYDataset",
    "signature": "org.jfree.data.xy.AbstractXYDataset.getYValue(int, int)",
    "snippet": "public double getYValue(int series, int item) {\r\n        double result \u003d Double.NaN;\r\n        Number y \u003d getY(series, item);\r\n        if (y !\u003d null) {\r\n            result \u003d y.doubleValue();\r\n        }\r\n        return result;\r\n    }",
    "begin_line": 92,
    "end_line": 99,
    "comment": "/** \n * Returns the y-value (as a double primitive) for an item within a series.\n * @param series  the series index (zero-based).\n * @param item  the item index (zero-based).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractXYDataset.getSelectionState#116",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/AbstractXYDataset.java",
    "class_name": "org.jfree.data.xy.AbstractXYDataset",
    "signature": "org.jfree.data.xy.AbstractXYDataset.getSelectionState()",
    "snippet": "public XYDatasetSelectionState getSelectionState() {\r\n        return this.selectionState;\r\n    }",
    "begin_line": 116,
    "end_line": 118,
    "comment": "/** \n * Returns the selection state for this dataset, if any.  The default value is \u003ccode\u003enull\u003c/code\u003e.\n * @return The selection state (possibly \u003ccode\u003enull\u003c/code\u003e).\n * @since 1.2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractXYDataset.setSelectionState#127",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/AbstractXYDataset.java",
    "class_name": "org.jfree.data.xy.AbstractXYDataset",
    "signature": "org.jfree.data.xy.AbstractXYDataset.setSelectionState(org.jfree.data.xy.XYDatasetSelectionState)",
    "snippet": "public void setSelectionState(XYDatasetSelectionState state) {\r\n        this.selectionState \u003d state;\r\n        fireDatasetChanged(new DatasetChangeInfo());\r\n        // TODO:  fill in change details\r\n    }",
    "begin_line": 127,
    "end_line": 131,
    "comment": "/** \n * Sets the selection state for this dataset.\n * @param state  the selection state (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @since 1.2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYInterval.XYInterval#77",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYInterval.java",
    "class_name": "org.jfree.data.xy.XYInterval",
    "signature": "org.jfree.data.xy.XYInterval.XYInterval(double, double, double, double, double)",
    "snippet": "public XYInterval(double xLow, double xHigh, double y, double yLow,\r\n            double yHigh) {\r\n        this.xLow \u003d xLow;\r\n        this.xHigh \u003d xHigh;\r\n        this.y \u003d y;\r\n        this.yLow \u003d yLow;\r\n        this.yHigh \u003d yHigh;\r\n    }",
    "begin_line": 77,
    "end_line": 84,
    "comment": "/** \n * Creates a new instance of \u003ccode\u003eXYInterval\u003c/code\u003e.\n * @param xLow  the lower bound of the x-interval.\n * @param xHigh  the upper bound of the y-interval.\n * @param y  the y-value.\n * @param yLow  the lower bound of the y-interval.\n * @param yHigh  the upper bound of the y-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYInterval.getXLow#91",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYInterval.java",
    "class_name": "org.jfree.data.xy.XYInterval",
    "signature": "org.jfree.data.xy.XYInterval.getXLow()",
    "snippet": "public double getXLow() {\r\n        return this.xLow;\r\n    }",
    "begin_line": 91,
    "end_line": 93,
    "comment": "/** \n * Returns the lower bound of the x-interval.\n * @return The lower bound of the x-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYInterval.getXHigh#100",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYInterval.java",
    "class_name": "org.jfree.data.xy.XYInterval",
    "signature": "org.jfree.data.xy.XYInterval.getXHigh()",
    "snippet": "public double getXHigh() {\r\n        return this.xHigh;\r\n    }",
    "begin_line": 100,
    "end_line": 102,
    "comment": "/** \n * Returns the upper bound of the x-interval.\n * @return The upper bound of the x-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYInterval.getY#109",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYInterval.java",
    "class_name": "org.jfree.data.xy.XYInterval",
    "signature": "org.jfree.data.xy.XYInterval.getY()",
    "snippet": "public double getY() {\r\n        return this.y;\r\n    }",
    "begin_line": 109,
    "end_line": 111,
    "comment": "/** \n * Returns the y-value.\n * @return The y-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYInterval.getYLow#118",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYInterval.java",
    "class_name": "org.jfree.data.xy.XYInterval",
    "signature": "org.jfree.data.xy.XYInterval.getYLow()",
    "snippet": "public double getYLow() {\r\n        return this.yLow;\r\n    }",
    "begin_line": 118,
    "end_line": 120,
    "comment": "/** \n * Returns the lower bound of the y-interval.\n * @return The lower bound of the y-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYInterval.getYHigh#127",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYInterval.java",
    "class_name": "org.jfree.data.xy.XYInterval",
    "signature": "org.jfree.data.xy.XYInterval.getYHigh()",
    "snippet": "public double getYHigh() {\r\n        return this.yHigh;\r\n    }",
    "begin_line": 127,
    "end_line": 129,
    "comment": "/** \n * Returns the upper bound of the y-interval.\n * @return The upper bound of the y-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYInterval.equals#138",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYInterval.java",
    "class_name": "org.jfree.data.xy.XYInterval",
    "signature": "org.jfree.data.xy.XYInterval.equals(java.lang.Object)",
    "snippet": "public boolean equals(Object obj) {\r\n        if (obj \u003d\u003d this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof XYInterval)) {\r\n            return false;\r\n        }\r\n        XYInterval that \u003d (XYInterval) obj;\r\n        if (this.xLow !\u003d that.xLow) {\r\n            return false;\r\n        }\r\n        if (this.xHigh !\u003d that.xHigh) {\r\n            return false;\r\n        }\r\n        if (this.y !\u003d that.y) {\r\n            return false;\r\n        }\r\n        if (this.yLow !\u003d that.yLow) {\r\n            return false;\r\n        }\r\n        if (this.yHigh !\u003d that.yHigh) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }",
    "begin_line": 138,
    "end_line": 162,
    "comment": "/** \n * Tests this instance for equality with an arbitrary object.\n * @param obj  the object (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalDataItem.XYIntervalDataItem#62",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalDataItem.java",
    "class_name": "org.jfree.data.xy.XYIntervalDataItem",
    "signature": "org.jfree.data.xy.XYIntervalDataItem.XYIntervalDataItem(double, double, double, double, double, double)",
    "snippet": "public XYIntervalDataItem(double x, double xLow, double xHigh, double y,\r\n            double yLow, double yHigh) {\r\n        super(new Double(x), new XYInterval(xLow, xHigh, y, yLow, yHigh));\r\n    }",
    "begin_line": 62,
    "end_line": 65,
    "comment": "/** \n * Creates a new instance of \u003ccode\u003eXYIntervalItem\u003c/code\u003e.\n * @param x  the x-value.\n * @param xLow  the lower bound of the x-interval.\n * @param xHigh  the upper bound of the x-interval.\n * @param y  the y-value.\n * @param yLow  the lower bound of the y-interval.\n * @param yHigh  the upper bound of the y-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalDataItem.getX#72",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalDataItem.java",
    "class_name": "org.jfree.data.xy.XYIntervalDataItem",
    "signature": "org.jfree.data.xy.XYIntervalDataItem.getX()",
    "snippet": "public Double getX() {\r\n        return (Double) getComparable();\r\n    }",
    "begin_line": 72,
    "end_line": 74,
    "comment": "/** \n * Returns the x-value.\n * @return The x-value (never \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalDataItem.getYValue#81",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalDataItem.java",
    "class_name": "org.jfree.data.xy.XYIntervalDataItem",
    "signature": "org.jfree.data.xy.XYIntervalDataItem.getYValue()",
    "snippet": "public double getYValue() {\r\n        XYInterval interval \u003d (XYInterval) getObject();\r\n        if (interval !\u003d null) {\r\n            return interval.getY();\r\n        }\r\n        else {\r\n            return Double.NaN;\r\n        }\r\n    }",
    "begin_line": 81,
    "end_line": 89,
    "comment": "/** \n * Returns the y-value.\n * @return The y-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalDataItem.getXLowValue#96",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalDataItem.java",
    "class_name": "org.jfree.data.xy.XYIntervalDataItem",
    "signature": "org.jfree.data.xy.XYIntervalDataItem.getXLowValue()",
    "snippet": "public double getXLowValue() {\r\n        XYInterval interval \u003d (XYInterval) getObject();\r\n        if (interval !\u003d null) {\r\n            return interval.getXLow();\r\n        }\r\n        else {\r\n            return Double.NaN;\r\n        }\r\n    }",
    "begin_line": 96,
    "end_line": 104,
    "comment": "/** \n * Returns the lower bound of the x-interval.\n * @return The lower bound of the x-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalDataItem.getXHighValue#111",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalDataItem.java",
    "class_name": "org.jfree.data.xy.XYIntervalDataItem",
    "signature": "org.jfree.data.xy.XYIntervalDataItem.getXHighValue()",
    "snippet": "public double getXHighValue() {\r\n        XYInterval interval \u003d (XYInterval) getObject();\r\n        if (interval !\u003d null) {\r\n            return interval.getXHigh();\r\n        }\r\n        else {\r\n            return Double.NaN;\r\n        }\r\n    }",
    "begin_line": 111,
    "end_line": 119,
    "comment": "/** \n * Returns the upper bound of the x-interval.\n * @return The upper bound of the x-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalDataItem.getYLowValue#126",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalDataItem.java",
    "class_name": "org.jfree.data.xy.XYIntervalDataItem",
    "signature": "org.jfree.data.xy.XYIntervalDataItem.getYLowValue()",
    "snippet": "public double getYLowValue() {\r\n        XYInterval interval \u003d (XYInterval) getObject();\r\n        if (interval !\u003d null) {\r\n            return interval.getYLow();\r\n        }\r\n        else {\r\n            return Double.NaN;\r\n        }\r\n    }",
    "begin_line": 126,
    "end_line": 134,
    "comment": "/** \n * Returns the lower bound of the y-interval.\n * @return The lower bound of the y-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalDataItem.getYHighValue#141",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalDataItem.java",
    "class_name": "org.jfree.data.xy.XYIntervalDataItem",
    "signature": "org.jfree.data.xy.XYIntervalDataItem.getYHighValue()",
    "snippet": "public double getYHighValue() {\r\n        XYInterval interval \u003d (XYInterval) getObject();\r\n        if (interval !\u003d null) {\r\n            return interval.getYHigh();\r\n        }\r\n        else {\r\n            return Double.NaN;\r\n        }\r\n    }",
    "begin_line": 141,
    "end_line": 149,
    "comment": "/** \n * Returns the upper bound of the y-interval.\n * @return The upper bound of the y-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.XYIntervalSeries#63",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.XYIntervalSeries(java.lang.Comparable)",
    "snippet": "public XYIntervalSeries(Comparable key) {\r\n        this(key, true, true);\r\n    }",
    "begin_line": 63,
    "end_line": 65,
    "comment": "/** \n * Creates a new empty series.  By default, items added to the series will be sorted into ascending order by x-value, and duplicate x-values will be allowed (these defaults can be modified with another constructor).\n * @param key  the series key (\u003ccode\u003enull\u003c/code\u003e not permitted).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.XYIntervalSeries#77",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.XYIntervalSeries(java.lang.Comparable, boolean, boolean)",
    "snippet": "public XYIntervalSeries(Comparable key, boolean autoSort,\r\n            boolean allowDuplicateXValues) {\r\n        super(key, autoSort, allowDuplicateXValues);\r\n    }",
    "begin_line": 77,
    "end_line": 80,
    "comment": "/** \n * Constructs a new xy-series that contains no data.  You can specify whether or not duplicate x-values are allowed for the series.\n * @param key  the series key (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @param autoSort  a flag that controls whether or not the items in theseries are sorted.\n * @param allowDuplicateXValues  a flag that controls whether duplicatex-values are allowed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.add#92",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.add(double, double, double, double, double, double)",
    "snippet": "public void add(double x, double xLow, double xHigh, double y, double yLow,\r\n            double yHigh) {\r\n        super.add(new XYIntervalDataItem(x, xLow, xHigh, y, yLow, yHigh), true);\r\n    }",
    "begin_line": 92,
    "end_line": 95,
    "comment": "/** \n * Adds a data item to the series.\n * @param x  the x-value.\n * @param xLow  the lower bound of the x-interval.\n * @param xHigh  the upper bound of the x-interval.\n * @param y  the y-value.\n * @param yLow  the lower bound of the y-interval.\n * @param yHigh  the upper bound of the y-interval.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.getX#104",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.getX(int)",
    "snippet": "public Number getX(int index) {\r\n        XYIntervalDataItem item \u003d (XYIntervalDataItem) getDataItem(index);\r\n        return item.getX();\r\n    }",
    "begin_line": 104,
    "end_line": 107,
    "comment": "/** \n * Returns the x-value for the specified item.\n * @param index  the item index.\n * @return The x-value (never \u003ccode\u003enull\u003c/code\u003e).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.getXLowValue#119",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.getXLowValue(int)",
    "snippet": "public double getXLowValue(int index) {\r\n        XYIntervalDataItem item \u003d (XYIntervalDataItem) getDataItem(index);\r\n        return item.getXLowValue();\r\n    }",
    "begin_line": 119,
    "end_line": 122,
    "comment": "/** \n * Returns the lower bound of the x-interval for the specified item in the series.\n * @param index  the item index.\n * @return The lower bound of the x-interval.\n * @since 1.0.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.getXHighValue#134",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.getXHighValue(int)",
    "snippet": "public double getXHighValue(int index) {\r\n        XYIntervalDataItem item \u003d (XYIntervalDataItem) getDataItem(index);\r\n        return item.getXHighValue();\r\n    }",
    "begin_line": 134,
    "end_line": 137,
    "comment": "/** \n * Returns the upper bound of the x-interval for the specified item in the series.\n * @param index  the item index.\n * @return The upper bound of the x-interval.\n * @since 1.0.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.getYValue#146",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.getYValue(int)",
    "snippet": "public double getYValue(int index) {\r\n        XYIntervalDataItem item \u003d (XYIntervalDataItem) getDataItem(index);\r\n        return item.getYValue();\r\n    }",
    "begin_line": 146,
    "end_line": 149,
    "comment": "/** \n * Returns the y-value for the specified item.\n * @param index  the item index.\n * @return The y-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.getYLowValue#161",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.getYLowValue(int)",
    "snippet": "public double getYLowValue(int index) {\r\n        XYIntervalDataItem item \u003d (XYIntervalDataItem) getDataItem(index);\r\n        return item.getYLowValue();\r\n    }",
    "begin_line": 161,
    "end_line": 164,
    "comment": "/** \n * Returns the lower bound of the Y-interval for the specified item in the series.\n * @param index  the item index.\n * @return The lower bound of the Y-interval.\n * @since 1.0.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.getYHighValue#176",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.getYHighValue(int)",
    "snippet": "public double getYHighValue(int index) {\r\n        XYIntervalDataItem item \u003d (XYIntervalDataItem) getDataItem(index);\r\n        return item.getYHighValue();\r\n    }",
    "begin_line": 176,
    "end_line": 179,
    "comment": "/** \n * Returns the upper bound of the y-interval for the specified item in the series.\n * @param index  the item index.\n * @return The upper bound of the y-interval.\n * @since 1.0.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeries.getDataItem#188",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeries.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeries",
    "signature": "org.jfree.data.xy.XYIntervalSeries.getDataItem(int)",
    "snippet": "public ComparableObjectItem getDataItem(int index) {\r\n        return super.getDataItem(index);\r\n    }",
    "begin_line": 188,
    "end_line": 190,
    "comment": "/** \n * Returns the data item at the specified index.\n * @param index  the item index.\n * @return The data item.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.XYIntervalSeriesCollection#73",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.XYIntervalSeriesCollection()",
    "snippet": "public XYIntervalSeriesCollection() {\r\n        this.data \u003d new java.util.ArrayList();\r\n    }",
    "begin_line": 73,
    "end_line": 75,
    "comment": "/** \n * Creates a new instance of \u003ccode\u003eXIntervalSeriesCollection\u003c/code\u003e.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.addSeries#83",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.addSeries(org.jfree.data.xy.XYIntervalSeries)",
    "snippet": "public void addSeries(XYIntervalSeries series) {\r\n        if (series \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027series\u0027 argument.\");\r\n        }\r\n        this.data.add(series);\r\n        series.addChangeListener(this);\r\n        fireDatasetChanged(new DatasetChangeInfo());\r\n        //TODO: fill in real change info\r\n    }",
    "begin_line": 83,
    "end_line": 91,
    "comment": "/** \n * Adds a series to the collection and sends a  {@link DatasetChangeEvent}to all registered listeners.\n * @param series  the series (\u003ccode\u003enull\u003c/code\u003e not permitted).\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getSeriesCount#98",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getSeriesCount()",
    "snippet": "public int getSeriesCount() {\r\n        return this.data.size();\r\n    }",
    "begin_line": 98,
    "end_line": 100,
    "comment": "/** \n * Returns the number of series in the collection.\n * @return The series count.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getSeries#112",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getSeries(int)",
    "snippet": "public XYIntervalSeries getSeries(int series) {\r\n        if ((series \u003c 0) || (series \u003e\u003d getSeriesCount())) {\r\n            throw new IllegalArgumentException(\"Series index out of bounds\");\r\n        }\r\n        return (XYIntervalSeries) this.data.get(series);\r\n    }",
    "begin_line": 112,
    "end_line": 117,
    "comment": "/** \n * Returns a series from the collection.\n * @param series  the series index (zero-based).\n * @return The series.\n * @throws IllegalArgumentException if \u003ccode\u003eseries\u003c/code\u003e is not in therange \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003egetSeriesCount() - 1\u003c/code\u003e.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getSeriesKey#130",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getSeriesKey(int)",
    "snippet": "public Comparable getSeriesKey(int series) {\r\n        // defer argument checking\r\n        return getSeries(series).getKey();\r\n    }",
    "begin_line": 130,
    "end_line": 133,
    "comment": "/** \n * Returns the key for a series.\n * @param series  the series index (in the range \u003ccode\u003e0\u003c/code\u003e to\u003ccode\u003egetSeriesCount() - 1\u003c/code\u003e).\n * @return The key for a series.\n * @throws IllegalArgumentException if \u003ccode\u003eseries\u003c/code\u003e is not in thespecified range.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getItemCount#145",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getItemCount(int)",
    "snippet": "public int getItemCount(int series) {\r\n        // defer argument checking\r\n        return getSeries(series).getItemCount();\r\n    }",
    "begin_line": 145,
    "end_line": 148,
    "comment": "/** \n * Returns the number of items in the specified series.\n * @param series  the series (zero-based index).\n * @return The item count.\n * @throws IllegalArgumentException if \u003ccode\u003eseries\u003c/code\u003e is not in therange \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003egetSeriesCount() - 1\u003c/code\u003e.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getX#158",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getX(int, int)",
    "snippet": "public Number getX(int series, int item) {\r\n        XYIntervalSeries s \u003d (XYIntervalSeries) this.data.get(series);\r\n        return s.getX(item);\r\n    }",
    "begin_line": 158,
    "end_line": 161,
    "comment": "/** \n * Returns the x-value for an item within a series.\n * @param series  the series index.\n * @param item  the item index.\n * @return The x-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getStartXValue#172",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getStartXValue(int, int)",
    "snippet": "public double getStartXValue(int series, int item) {\r\n        XYIntervalSeries s \u003d (XYIntervalSeries) this.data.get(series);\r\n        return s.getXLowValue(item);\r\n    }",
    "begin_line": 172,
    "end_line": 175,
    "comment": "/** \n * Returns the start x-value (as a double primitive) for an item within a series.\n * @param series  the series index (zero-based).\n * @param item  the item index (zero-based).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getEndXValue#186",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getEndXValue(int, int)",
    "snippet": "public double getEndXValue(int series, int item) {\r\n        XYIntervalSeries s \u003d (XYIntervalSeries) this.data.get(series);\r\n        return s.getXHighValue(item);\r\n    }",
    "begin_line": 186,
    "end_line": 189,
    "comment": "/** \n * Returns the end x-value (as a double primitive) for an item within a series.\n * @param series  the series index (zero-based).\n * @param item  the item index (zero-based).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getYValue#200",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getYValue(int, int)",
    "snippet": "public double getYValue(int series, int item) {\r\n        XYIntervalSeries s \u003d (XYIntervalSeries) this.data.get(series);\r\n        return s.getYValue(item);\r\n    }",
    "begin_line": 200,
    "end_line": 203,
    "comment": "/** \n * Returns the y-value (as a double primitive) for an item within a series.\n * @param series  the series index (zero-based).\n * @param item  the item index (zero-based).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getStartYValue#214",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getStartYValue(int, int)",
    "snippet": "public double getStartYValue(int series, int item) {\r\n        XYIntervalSeries s \u003d (XYIntervalSeries) this.data.get(series);\r\n        return s.getYLowValue(item);\r\n    }",
    "begin_line": 214,
    "end_line": 217,
    "comment": "/** \n * Returns the start y-value (as a double primitive) for an item within a series.\n * @param series  the series index (zero-based).\n * @param item  the item index (zero-based).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getEndYValue#228",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getEndYValue(int, int)",
    "snippet": "public double getEndYValue(int series, int item) {\r\n        XYIntervalSeries s \u003d (XYIntervalSeries) this.data.get(series);\r\n        return s.getYHighValue(item);\r\n    }",
    "begin_line": 228,
    "end_line": 231,
    "comment": "/** \n * Returns the end y-value (as a double primitive) for an item within a series.\n * @param series  the series (zero-based index).\n * @param item  the item (zero-based index).\n * @return The value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getY#241",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getY(int, int)",
    "snippet": "public Number getY(int series, int item) {\r\n        return new Double(getYValue(series, item));\r\n    }",
    "begin_line": 241,
    "end_line": 243,
    "comment": "/** \n * Returns the y-value for an item within a series.\n * @param series  the series index.\n * @param item  the item index.\n * @return The y-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getStartX#253",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getStartX(int, int)",
    "snippet": "public Number getStartX(int series, int item) {\r\n        return new Double(getStartXValue(series, item));\r\n    }",
    "begin_line": 253,
    "end_line": 255,
    "comment": "/** \n * Returns the start x-value for an item within a series.\n * @param series  the series index.\n * @param item  the item index.\n * @return The x-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getEndX#265",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getEndX(int, int)",
    "snippet": "public Number getEndX(int series, int item) {\r\n        return new Double(getEndXValue(series, item));\r\n    }",
    "begin_line": 265,
    "end_line": 267,
    "comment": "/** \n * Returns the end x-value for an item within a series.\n * @param series  the series index.\n * @param item  the item index.\n * @return The x-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getStartY#278",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getStartY(int, int)",
    "snippet": "public Number getStartY(int series, int item) {\r\n        return new Double(getStartYValue(series, item));\r\n    }",
    "begin_line": 278,
    "end_line": 280,
    "comment": "/** \n * Returns the start y-value for an item within a series.  This method maps directly to  {@link #getY(int,int)}.\n * @param series  the series index.\n * @param item  the item index.\n * @return The start y-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.getEndY#291",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.getEndY(int, int)",
    "snippet": "public Number getEndY(int series, int item) {\r\n        return new Double(getEndYValue(series, item));\r\n    }",
    "begin_line": 291,
    "end_line": 293,
    "comment": "/** \n * Returns the end y-value for an item within a series.  This method maps directly to  {@link #getY(int,int)}.\n * @param series  the series index.\n * @param item  the item index.\n * @return The end y-value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.removeSeries#303",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.removeSeries(int)",
    "snippet": "public void removeSeries(int series) {\r\n        if ((series \u003c 0) || (series \u003e\u003d getSeriesCount())) {\r\n            throw new IllegalArgumentException(\"Series index out of bounds.\");\r\n        }\r\n        XYIntervalSeries ts \u003d (XYIntervalSeries) this.data.get(series);\r\n        ts.removeChangeListener(this);\r\n        this.data.remove(series);\r\n        fireDatasetChanged(new DatasetChangeInfo());\r\n        //TODO: fill in real change info\r\n    }",
    "begin_line": 303,
    "end_line": 312,
    "comment": "/** \n * Removes a series from the collection and sends a {@link DatasetChangeEvent} to all registered listeners.\n * @param series  the series index (zero-based).\n * @since 1.0.10\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.removeSeries#322",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.removeSeries(org.jfree.data.xy.XYIntervalSeries)",
    "snippet": "public void removeSeries(XYIntervalSeries series) {\r\n        if (series \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Null \u0027series\u0027 argument.\");\r\n        }\r\n        if (this.data.contains(series)) {\r\n            series.removeChangeListener(this);\r\n            this.data.remove(series);\r\n            fireDatasetChanged(new DatasetChangeInfo());\r\n            //TODO: fill in real change info\r\n        }\r\n    }",
    "begin_line": 322,
    "end_line": 332,
    "comment": "/** \n * Removes a series from the collection and sends a {@link DatasetChangeEvent} to all registered listeners.\n * @param series  the series (\u003ccode\u003enull\u003c/code\u003e not permitted).\n * @since 1.0.10\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.removeAllSeries#340",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.removeAllSeries()",
    "snippet": "public void removeAllSeries() {\r\n        // Unregister the collection as a change listener to each series in\r\n        // the collection.\r\n        for (int i \u003d 0; i \u003c this.data.size(); i++) {\r\n          XYIntervalSeries series \u003d (XYIntervalSeries) this.data.get(i);\r\n          series.removeChangeListener(this);\r\n        }\r\n        this.data.clear();\r\n        fireDatasetChanged(new DatasetChangeInfo());\r\n        //TODO: fill in real change info\r\n    }",
    "begin_line": 340,
    "end_line": 350,
    "comment": "/** \n * Removes all the series from the collection and sends a {@link DatasetChangeEvent} to all registered listeners.\n * @since 1.0.10\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.equals#359",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.equals(java.lang.Object)",
    "snippet": "public boolean equals(Object obj) {\r\n        if (obj \u003d\u003d this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof XYIntervalSeriesCollection)) {\r\n            return false;\r\n        }\r\n        XYIntervalSeriesCollection that \u003d (XYIntervalSeriesCollection) obj;\r\n        return ObjectUtilities.equal(this.data, that.data);\r\n    }",
    "begin_line": 359,
    "end_line": 368,
    "comment": "/** \n * Tests this instance for equality with an arbitrary object.\n * @param obj  the object (\u003ccode\u003enull\u003c/code\u003e permitted).\n * @return A boolean.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "XYIntervalSeriesCollection.clone#377",
    "is_bug": true,
    "src_path": "org/jfree/data/xy/XYIntervalSeriesCollection.java",
    "class_name": "org.jfree.data.xy.XYIntervalSeriesCollection",
    "signature": "org.jfree.data.xy.XYIntervalSeriesCollection.clone()",
    "snippet": "public Object clone() throws CloneNotSupportedException {\r\n        XYIntervalSeriesCollection clone\r\n                \u003d (XYIntervalSeriesCollection) super.clone();\r\n        int seriesCount \u003d getSeriesCount();\r\n        clone.data \u003d new java.util.ArrayList(seriesCount);\r\n        for (int i \u003d 0; i \u003c this.data.size(); i++) {\r\n            clone.data.set(i, getSeries(i).clone());\r\n        }\r\n        return clone;\r\n    }",
    "begin_line": 377,
    "end_line": 386,
    "comment": "/** \n * Returns a clone of this dataset.\n * @return A clone of this dataset.\n * @throws CloneNotSupportedException if there is a problem cloning.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]