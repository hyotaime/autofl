[
  {
    "name": "null.translateName#38",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f) {\n      return f.getName();\n    }",
    "begin_line": 38,
    "end_line": 40,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.translateName#54",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f) {\n      return upperCaseFirstLetter(f.getName());\n    }",
    "begin_line": 54,
    "end_line": 56,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.translateName#73",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f) {\n      return upperCaseFirstLetter(separateCamelCase(f.getName(), \" \"));\n    }",
    "begin_line": 73,
    "end_line": 75,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.translateName#91",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f) {\n      return separateCamelCase(f.getName(), \"_\").toLowerCase(Locale.ENGLISH);\n    }",
    "begin_line": 91,
    "end_line": 93,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.translateName#114",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f) {\n      return separateCamelCase(f.getName(), \"-\").toLowerCase(Locale.ENGLISH);\n    }",
    "begin_line": 114,
    "end_line": 116,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.separateCamelCase#123",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.separateCamelCase(java.lang.String, java.lang.String)",
    "snippet": "static String separateCamelCase(String name, String separator) {\n    StringBuilder translation \u003d new StringBuilder();\n    for (int i \u003d 0; i \u003c name.length(); i++) {\n      char character \u003d name.charAt(i);\n      if (Character.isUpperCase(character) \u0026\u0026 translation.length() !\u003d 0) {\n        translation.append(separator);\n      }\n      translation.append(character);\n    }\n    return translation.toString();\n  }",
    "begin_line": 123,
    "end_line": 133,
    "comment": "/** \n * Converts the field name that uses camel-case define word separation into separate words that are separated by the provided  {@code separatorString}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.upperCaseFirstLetter#138",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.upperCaseFirstLetter(java.lang.String)",
    "snippet": "static String upperCaseFirstLetter(String name) {\n    StringBuilder fieldNameBuilder \u003d new StringBuilder();\n    int index \u003d 0;\n    char firstCharacter \u003d name.charAt(index);\n\n    while (index \u003c name.length() - 1) {\n      if (Character.isLetter(firstCharacter)) {\n        break;\n      }\n\n      fieldNameBuilder.append(firstCharacter);\n      firstCharacter \u003d name.charAt(++index);\n    }\n\n    if (index \u003d\u003d name.length()) {\n      return fieldNameBuilder.toString();\n    }\n\n    if (!Character.isUpperCase(firstCharacter)) {\n      String modifiedTarget \u003d modifyString(Character.toUpperCase(firstCharacter), name, ++index);\n      return fieldNameBuilder.append(modifiedTarget).toString();\n    } else {\n      return name;\n    }\n  }",
    "begin_line": 138,
    "end_line": 162,
    "comment": "/** \n * Ensures the JSON field names begins with an upper case letter.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.modifyString#164",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.modifyString(char, java.lang.String, int)",
    "snippet": "private static String modifyString(char firstCharacter, String srcString, int indexOfSubstring) {\n    return (indexOfSubstring \u003c srcString.length())\n        ? firstCharacter + srcString.substring(indexOfSubstring)\n        : String.valueOf(firstCharacter);\n  }",
    "begin_line": 164,
    "end_line": 168,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.deserialize#137",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.deserialize(com.google.gson.JsonElement, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n    @Override public \u003cT\u003e T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n      return (T) fromJson(json, typeOfT);\n    }",
    "begin_line": 137,
    "end_line": 139,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.serialize#143",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.serialize(java.lang.Object)",
    "snippet": "@Override public JsonElement serialize(Object src) {\n      return toJsonTree(src);\n    }",
    "begin_line": 143,
    "end_line": 145,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.serialize#146",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.serialize(java.lang.Object, java.lang.reflect.Type)",
    "snippet": "@Override public JsonElement serialize(Object src, Type typeOfSrc) {\n      return toJsonTree(src, typeOfSrc);\n    }",
    "begin_line": 146,
    "end_line": 148,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.Gson#185",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.Gson()",
    "snippet": "public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.\u003cType, InstanceCreator\u003c?\u003e\u003eemptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.\u003cTypeAdapterFactory\u003eemptyList());\n  }",
    "begin_line": 185,
    "end_line": 191,
    "comment": "/** \n * Constructs a Gson object with default configuration. The default configuration has the following settings: \u003cul\u003e \u003cli\u003eThe JSON generated by \u003ccode\u003etoJson\u003c/code\u003e methods is in compact representation. This means that all the unneeded white-space is removed. You can change this behavior with {@link GsonBuilder#setPrettyPrinting()}. \u003c/li\u003e \u003cli\u003eThe generated JSON omits all the fields that are null. Note that nulls in arrays are kept as is since an array is an ordered list. Moreover, if a field is not null, but its generated JSON is empty, the field is kept. You can configure Gson to serialize null values by setting  {@link GsonBuilder#serializeNulls()}.\u003c/li\u003e \u003cli\u003eGson provides default serialization and deserialization for Enums,  {@link Map}, {@link java.net.URL},  {@link java.net.URI},  {@link java.util.Locale},  {@link java.util.Date}, {@link java.math.BigDecimal}, and  {@link java.math.BigInteger} classes. If you would preferto change the default representation, you can do so by registering a type adapter through {@link GsonBuilder#registerTypeAdapter(Type,Object)}. \u003c/li\u003e \u003cli\u003eThe default Date format is same as  {@link java.text.DateFormat#DEFAULT}. This format ignores the millisecond portion of the date during serialization. You can change this by invoking  {@link GsonBuilder#setDateFormat(int)} or{@link GsonBuilder#setDateFormat(String)}. \u003c/li\u003e \u003cli\u003eBy default, Gson ignores the  {@link com.google.gson.annotations.Expose} annotation.You can enable Gson to serialize/deserialize only those fields marked with this annotation through  {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. \u003c/li\u003e \u003cli\u003eBy default, Gson ignores the  {@link com.google.gson.annotations.Since} annotation. Youcan enable Gson to use this annotation through  {@link GsonBuilder#setVersion(double)}.\u003c/li\u003e \u003cli\u003eThe default field naming policy for the output Json is same as in Java. So, a Java class field \u003ccode\u003eversionNumber\u003c/code\u003e will be output as \u003ccode\u003e\u0026quot;versionNumber\u0026quot;\u003c/code\u003e in Json. The same rules are applied for mapping incoming Json to the Java classes. You can change this policy through  {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.\u003c/li\u003e \u003cli\u003eBy default, Gson excludes \u003ccode\u003etransient\u003c/code\u003e or \u003ccode\u003estatic\u003c/code\u003e fields from consideration for serialization and deserialization. You can change this behavior through {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.\u003c/li\u003e \u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.Gson#193",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.Gson(com.google.gson.internal.Excluder, com.google.gson.FieldNamingStrategy, java.util.Map\u003cjava.lang.reflect.Type,com.google.gson.InstanceCreator\u003c?\u003e\u003e, boolean, boolean, boolean, boolean, boolean, boolean, boolean, com.google.gson.LongSerializationPolicy, java.util.List\u003ccom.google.gson.TypeAdapterFactory\u003e)",
    "snippet": " Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\n      final Map\u003cType, InstanceCreator\u003c?\u003e\u003e instanceCreators, boolean serializeNulls,\n      boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n      boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\n      LongSerializationPolicy longSerializationPolicy,\n      List\u003cTypeAdapterFactory\u003e typeAdapterFactories) {\n    this.constructorConstructor \u003d new ConstructorConstructor(instanceCreators);\n    this.serializeNulls \u003d serializeNulls;\n    this.generateNonExecutableJson \u003d generateNonExecutableGson;\n    this.htmlSafe \u003d htmlSafe;\n    this.prettyPrinting \u003d prettyPrinting;\n    this.lenient \u003d lenient;\n\n    List\u003cTypeAdapterFactory\u003e factories \u003d new ArrayList\u003cTypeAdapterFactory\u003e();\n\n    // built-in type adapters that cannot be overridden\n    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n    factories.add(ObjectTypeAdapter.FACTORY);\n\n    // the excluder must precede all adapters that handle user-defined types\n    factories.add(excluder);\n\n    // user\u0027s type adapters\n    factories.addAll(typeAdapterFactories);\n\n    // type adapters for basic platform types\n    factories.add(TypeAdapters.STRING_FACTORY);\n    factories.add(TypeAdapters.INTEGER_FACTORY);\n    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n    factories.add(TypeAdapters.BYTE_FACTORY);\n    factories.add(TypeAdapters.SHORT_FACTORY);\n    TypeAdapter\u003cNumber\u003e longAdapter \u003d longAdapter(longSerializationPolicy);\n    factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\n    factories.add(TypeAdapters.newFactory(double.class, Double.class,\n            doubleAdapter(serializeSpecialFloatingPointValues)));\n    factories.add(TypeAdapters.newFactory(float.class, Float.class,\n            floatAdapter(serializeSpecialFloatingPointValues)));\n    factories.add(TypeAdapters.NUMBER_FACTORY);\n    factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\n    factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\n    factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\n    factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\n    factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\n    factories.add(TypeAdapters.CHARACTER_FACTORY);\n    factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n    factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n    factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\n    factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\n    factories.add(TypeAdapters.URL_FACTORY);\n    factories.add(TypeAdapters.URI_FACTORY);\n    factories.add(TypeAdapters.UUID_FACTORY);\n    factories.add(TypeAdapters.CURRENCY_FACTORY);\n    factories.add(TypeAdapters.LOCALE_FACTORY);\n    factories.add(TypeAdapters.INET_ADDRESS_FACTORY);\n    factories.add(TypeAdapters.BIT_SET_FACTORY);\n    factories.add(DateTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.CALENDAR_FACTORY);\n    factories.add(TimeTypeAdapter.FACTORY);\n    factories.add(SqlDateTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.TIMESTAMP_FACTORY);\n    factories.add(ArrayTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.CLASS_FACTORY);\n\n    // type adapters for composite and user-defined types\n    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n    factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\n    factories.add(TypeAdapters.ENUM_FACTORY);\n    factories.add(new ReflectiveTypeAdapterFactory(\n        constructorConstructor, fieldNamingPolicy, excluder));\n\n    this.factories \u003d Collections.unmodifiableList(factories);\n  }",
    "begin_line": 193,
    "end_line": 265,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.doubleAdapter#267",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.doubleAdapter(boolean)",
    "snippet": "private TypeAdapter\u003cNumber\u003e doubleAdapter(boolean serializeSpecialFloatingPointValues) {\n    if (serializeSpecialFloatingPointValues) {\n      return TypeAdapters.DOUBLE;\n    }\n    return new TypeAdapter\u003cNumber\u003e() {\n      @Override public Double read(JsonReader in) throws IOException {\n        if (in.peek() \u003d\u003d JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return in.nextDouble();\n      }\n      @Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value \u003d\u003d null) {\n          out.nullValue();\n          return;\n        }\n        double doubleValue \u003d value.doubleValue();\n        checkValidFloatingPoint(doubleValue);\n        out.value(value);\n      }\n    };\n  }",
    "begin_line": 267,
    "end_line": 289,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#272",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Double read(JsonReader in) throws IOException {\n        if (in.peek() \u003d\u003d JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return in.nextDouble();\n      }",
    "begin_line": 272,
    "end_line": 278,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#279",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value \u003d\u003d null) {\n          out.nullValue();\n          return;\n        }\n        double doubleValue \u003d value.doubleValue();\n        checkValidFloatingPoint(doubleValue);\n        out.value(value);\n      }",
    "begin_line": 279,
    "end_line": 287,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.floatAdapter#291",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.floatAdapter(boolean)",
    "snippet": "private TypeAdapter\u003cNumber\u003e floatAdapter(boolean serializeSpecialFloatingPointValues) {\n    if (serializeSpecialFloatingPointValues) {\n      return TypeAdapters.FLOAT;\n    }\n    return new TypeAdapter\u003cNumber\u003e() {\n      @Override public Float read(JsonReader in) throws IOException {\n        if (in.peek() \u003d\u003d JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return (float) in.nextDouble();\n      }\n      @Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value \u003d\u003d null) {\n          out.nullValue();\n          return;\n        }\n        float floatValue \u003d value.floatValue();\n        checkValidFloatingPoint(floatValue);\n        out.value(value);\n      }\n    };\n  }",
    "begin_line": 291,
    "end_line": 313,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#296",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Float read(JsonReader in) throws IOException {\n        if (in.peek() \u003d\u003d JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return (float) in.nextDouble();\n      }",
    "begin_line": 296,
    "end_line": 302,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#303",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value \u003d\u003d null) {\n          out.nullValue();\n          return;\n        }\n        float floatValue \u003d value.floatValue();\n        checkValidFloatingPoint(floatValue);\n        out.value(value);\n      }",
    "begin_line": 303,
    "end_line": 311,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.checkValidFloatingPoint#315",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.checkValidFloatingPoint(double)",
    "snippet": "static void checkValidFloatingPoint(double value) {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(value\n          + \" is not a valid double value as per JSON specification. To override this\"\n          + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\n    }\n  }",
    "begin_line": 315,
    "end_line": 321,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.longAdapter#323",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.longAdapter(com.google.gson.LongSerializationPolicy)",
    "snippet": "private static TypeAdapter\u003cNumber\u003e longAdapter(LongSerializationPolicy longSerializationPolicy) {\n    if (longSerializationPolicy \u003d\u003d LongSerializationPolicy.DEFAULT) {\n      return TypeAdapters.LONG;\n    }\n    return new TypeAdapter\u003cNumber\u003e() {\n      @Override public Number read(JsonReader in) throws IOException {\n        if (in.peek() \u003d\u003d JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return in.nextLong();\n      }\n      @Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value \u003d\u003d null) {\n          out.nullValue();\n          return;\n        }\n        out.value(value.toString());\n      }\n    };\n  }",
    "begin_line": 323,
    "end_line": 343,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#328",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Number read(JsonReader in) throws IOException {\n        if (in.peek() \u003d\u003d JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return in.nextLong();\n      }",
    "begin_line": 328,
    "end_line": 334,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#335",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value \u003d\u003d null) {\n          out.nullValue();\n          return;\n        }\n        out.value(value.toString());\n      }",
    "begin_line": 335,
    "end_line": 341,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.atomicLongAdapter#345",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.atomicLongAdapter(com.google.gson.TypeAdapter\u003cjava.lang.Number\u003e)",
    "snippet": "private static TypeAdapter\u003cAtomicLong\u003e atomicLongAdapter(final TypeAdapter\u003cNumber\u003e longAdapter) {\n    return new TypeAdapter\u003cAtomicLong\u003e() {\n      @Override public void write(JsonWriter out, AtomicLong value) throws IOException {\n        longAdapter.write(out, value.get());\n      }\n      @Override public AtomicLong read(JsonReader in) throws IOException {\n        Number value \u003d longAdapter.read(in);\n        return new AtomicLong(value.longValue());\n      }\n    }.nullSafe();\n  }",
    "begin_line": 345,
    "end_line": 355,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#347",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicLong)",
    "snippet": "@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\n        longAdapter.write(out, value.get());\n      }",
    "begin_line": 347,
    "end_line": 349,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#350",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicLong read(JsonReader in) throws IOException {\n        Number value \u003d longAdapter.read(in);\n        return new AtomicLong(value.longValue());\n      }",
    "begin_line": 350,
    "end_line": 353,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.atomicLongArrayAdapter#357",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.atomicLongArrayAdapter(com.google.gson.TypeAdapter\u003cjava.lang.Number\u003e)",
    "snippet": "private static TypeAdapter\u003cAtomicLongArray\u003e atomicLongArrayAdapter(final TypeAdapter\u003cNumber\u003e longAdapter) {\n    return new TypeAdapter\u003cAtomicLongArray\u003e() {\n      @Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\n        out.beginArray();\n        for (int i \u003d 0, length \u003d value.length(); i \u003c length; i++) {\n          longAdapter.write(out, value.get(i));\n        }\n        out.endArray();\n      }\n      @Override public AtomicLongArray read(JsonReader in) throws IOException {\n        List\u003cLong\u003e list \u003d new ArrayList\u003cLong\u003e();\n        in.beginArray();\n        while (in.hasNext()) {\n            long value \u003d longAdapter.read(in).longValue();\n            list.add(value);\n        }\n        in.endArray();\n        int length \u003d list.size();\n        AtomicLongArray array \u003d new AtomicLongArray(length);\n        for (int i \u003d 0; i \u003c length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n      }\n    }.nullSafe();\n  }",
    "begin_line": 357,
    "end_line": 382,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#359",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicLongArray)",
    "snippet": "@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\n        out.beginArray();\n        for (int i \u003d 0, length \u003d value.length(); i \u003c length; i++) {\n          longAdapter.write(out, value.get(i));\n        }\n        out.endArray();\n      }",
    "begin_line": 359,
    "end_line": 365,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#366",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicLongArray read(JsonReader in) throws IOException {\n        List\u003cLong\u003e list \u003d new ArrayList\u003cLong\u003e();\n        in.beginArray();\n        while (in.hasNext()) {\n            long value \u003d longAdapter.read(in).longValue();\n            list.add(value);\n        }\n        in.endArray();\n        int length \u003d list.size();\n        AtomicLongArray array \u003d new AtomicLongArray(length);\n        for (int i \u003d 0; i \u003c length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n      }",
    "begin_line": 366,
    "end_line": 380,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.getAdapter#391",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.getAdapter(com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n    if (cached !\u003d null) {\n      return (TypeAdapter\u003cT\u003e) cached;\n    }\n\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    boolean requiresThreadLocalCleanup \u003d false;\n    if (threadCalls \u003d\u003d null) {\n      threadCalls \u003d new HashMap\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e();\n      calls.set(threadCalls);\n      requiresThreadLocalCleanup \u003d true;\n    }\n\n    // the key and value type parameters always agree\n    FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n      return ongoingCall;\n    }\n\n    try {\n      FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n      threadCalls.put(type, call);\n\n      for (TypeAdapterFactory factory : factories) {\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n          call.setDelegate(candidate);\n          typeTokenCache.put(type, candidate);\n          return candidate;\n        }\n      }\n      throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n      threadCalls.remove(type);\n\n      if (requiresThreadLocalCleanup) {\n        calls.remove();\n      }\n    }\n  }",
    "begin_line": 391,
    "end_line": 431,
    "comment": "/** \n * Returns the type adapter for  {@code} type.\n * @throws IllegalArgumentException if this GSON cannot serialize anddeserialize  {@code type}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.getDelegateAdapter#483",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.getDelegateAdapter(com.google.gson.TypeAdapterFactory, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    // Skip past if and only if the specified factory is present in the factories.\n    // This is useful because the factories created through JsonAdapter annotations are not\n    // registered in this list.\n    if (!factories.contains(skipPast)) skipPastFound \u003d true;\n\n    for (TypeAdapterFactory factory : factories) {\n      if (!skipPastFound) {\n        if (factory \u003d\u003d skipPast) {\n          skipPastFound \u003d true;\n        }\n        continue;\n      }\n\n      TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n      if (candidate !\u003d null) {\n        return candidate;\n      }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n  }",
    "begin_line": 483,
    "end_line": 504,
    "comment": "/** \n * This method is used to get an alternate type adapter for the specified type. This is used to access a type adapter that is overridden by a  {@link TypeAdapterFactory} that youmay have registered. This features is typically used when you want to register a type adapter that does a little bit of work but then delegates further processing to the Gson default type adapter. Here is an example: \u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read from or written to JSON. We can achieve this by writing a type adapter factory that uses the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method: \u003cpre\u003e  {@code class StatsTypeAdapterFactory implements TypeAdapterFactory  public int numReads \u003d 0; public int numWrites \u003d 0; public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type)  final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type); return new TypeAdapter\u0026lt;T\u0026gt;()  public void write(JsonWriter out, T value) throws IOException  ++numWrites; delegate.write(out, value);}public T read(JsonReader in) throws IOException  ++numReads; return delegate.read(in); } }; } } } \u003c/pre\u003e This factory can now be used like this: \u003cpre\u003e  {@code StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory(); Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create(); // Call gson.toJson() and fromJson methods on objects System.out.println(\"Num JSON reads\" + stats.numReads); System.out.println(\"Num JSON writes\" + stats.numWrites);}\u003c/pre\u003e Note that this call will skip all factories registered before  {@code skipPast}. In case of multiple TypeAdapterFactories registered it is up to the caller of this function to insure that the order of registration does not prevent this method from reaching a factory they would expect to reply from this call. Note that since you can not override type adapter factories for String and Java primitive types, our stats factory will not count the number of String or primitives that will be read or written.\n * @param skipPast The type adapter factory that needs to be skipped while searching fora matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter factory from where  {@link #getDelegateAdapter} method is being invoked).\n * @param type Type for which the delegate adapter is being searched for.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.getAdapter#512",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.getAdapter(java.lang.Class\u003cT\u003e)",
    "snippet": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(Class\u003cT\u003e type) {\n    return getAdapter(TypeToken.get(type));\n  }",
    "begin_line": 512,
    "end_line": 514,
    "comment": "/** \n * Returns the type adapter for  {@code} type.\n * @throws IllegalArgumentException if this GSON cannot serialize anddeserialize  {@code type}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJsonTree#529",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJsonTree(java.lang.Object)",
    "snippet": "public JsonElement toJsonTree(Object src) {\n    if (src \u003d\u003d null) {\n      return JsonNull.INSTANCE;\n    }\n    return toJsonTree(src, src.getClass());\n  }",
    "begin_line": 529,
    "end_line": 534,
    "comment": "/** \n * This method serializes the specified object into its equivalent representation as a tree of {@link JsonElement}s. This method should be used when the specified object is not a generic type. This method uses  {@link Class#getClass()} to get the type for the specified object, butthe  {@code getClass()} loses the generic type information because of the Type Erasure featureof Java. Note that this method works fine if the any of the object fields are of generic type, just the object itself should not be of a generic type. If the object is of generic type, use {@link #toJsonTree(Object,Type)} instead.\n * @param src the object for which Json representation is to be created setting for Gson\n * @return Json representation of {@code src}.\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJsonTree#552",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJsonTree(java.lang.Object, java.lang.reflect.Type)",
    "snippet": "public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\n    toJson(src, typeOfSrc, writer);\n    return writer.get();\n  }",
    "begin_line": 552,
    "end_line": 556,
    "comment": "/** \n * This method serializes the specified object, including those of generic types, into its equivalent representation as a tree of  {@link JsonElement}s. This method must be used if the specified object is a generic type. For non-generic objects, use  {@link #toJsonTree(Object)}instead.\n * @param src the object for which JSON representation is to be created\n * @param typeOfSrc The specific genericized type of src. You can obtainthis type by using the  {@link com.google.gson.reflect.TypeToken} class. For example,to get the type for  {@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfSrc \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return Json representation of {@code src}\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#571",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object)",
    "snippet": "public String toJson(Object src) {\n    if (src \u003d\u003d null) {\n      return toJson(JsonNull.INSTANCE);\n    }\n    return toJson(src, src.getClass());\n  }",
    "begin_line": 571,
    "end_line": 576,
    "comment": "/** \n * This method serializes the specified object into its equivalent Json representation. This method should be used when the specified object is not a generic type. This method uses {@link Class#getClass()} to get the type for the specified object, but the{@code getClass()} loses the generic type information because of the Type Erasure featureof Java. Note that this method works fine if the any of the object fields are of generic type, just the object itself should not be of a generic type. If the object is of generic type, use {@link #toJson(Object,Type)} instead. If you want to write out the object to a{@link Writer}, use  {@link #toJson(Object,Appendable)} instead.\n * @param src the object for which Json representation is to be created setting for Gson\n * @return Json representation of {@code src}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#593",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.reflect.Type)",
    "snippet": "public String toJson(Object src, Type typeOfSrc) {\n    StringWriter writer \u003d new StringWriter();\n    toJson(src, typeOfSrc, writer);\n    return writer.toString();\n  }",
    "begin_line": 593,
    "end_line": 597,
    "comment": "/** \n * This method serializes the specified object, including those of generic types, into its equivalent Json representation. This method must be used if the specified object is a generic type. For non-generic objects, use  {@link #toJson(Object)} instead. If you want to write outthe object to a  {@link Appendable}, use  {@link #toJson(Object,Type,Appendable)} instead.\n * @param src the object for which JSON representation is to be created\n * @param typeOfSrc The specific genericized type of src. You can obtainthis type by using the  {@link com.google.gson.reflect.TypeToken} class. For example,to get the type for  {@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfSrc \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return Json representation of {@code src}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#613",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.Appendable)",
    "snippet": "public void toJson(Object src, Appendable writer) throws JsonIOException {\n    if (src !\u003d null) {\n      toJson(src, src.getClass(), writer);\n    } else {\n      toJson(JsonNull.INSTANCE, writer);\n    }\n  }",
    "begin_line": 613,
    "end_line": 619,
    "comment": "/** \n * This method serializes the specified object into its equivalent Json representation. This method should be used when the specified object is not a generic type. This method uses {@link Class#getClass()} to get the type for the specified object, but the{@code getClass()} loses the generic type information because of the Type Erasure featureof Java. Note that this method works fine if the any of the object fields are of generic type, just the object itself should not be of a generic type. If the object is of generic type, use {@link #toJson(Object,Type,Appendable)} instead.\n * @param src the object for which Json representation is to be created setting for Gson\n * @param writer Writer to which the Json representation needs to be written\n * @throws JsonIOException if there was a problem writing to the writer\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#637",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.reflect.Type, java.lang.Appendable)",
    "snippet": "public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {\n    try {\n      JsonWriter jsonWriter \u003d newJsonWriter(Streams.writerForAppendable(writer));\n      toJson(src, typeOfSrc, jsonWriter);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    }\n  }",
    "begin_line": 637,
    "end_line": 644,
    "comment": "/** \n * This method serializes the specified object, including those of generic types, into its equivalent Json representation. This method must be used if the specified object is a generic type. For non-generic objects, use  {@link #toJson(Object,Appendable)} instead.\n * @param src the object for which JSON representation is to be created\n * @param typeOfSrc The specific genericized type of src. You can obtainthis type by using the  {@link com.google.gson.reflect.TypeToken} class. For example,to get the type for  {@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfSrc \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @param writer Writer to which the Json representation of src needs to be written.\n * @throws JsonIOException if there was a problem writing to the writer\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#652",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.reflect.Type, com.google.gson.stream.JsonWriter)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\n    TypeAdapter\u003c?\u003e adapter \u003d getAdapter(TypeToken.get(typeOfSrc));\n    boolean oldLenient \u003d writer.isLenient();\n    writer.setLenient(true);\n    boolean oldHtmlSafe \u003d writer.isHtmlSafe();\n    writer.setHtmlSafe(htmlSafe);\n    boolean oldSerializeNulls \u003d writer.getSerializeNulls();\n    writer.setSerializeNulls(serializeNulls);\n    try {\n      ((TypeAdapter\u003cObject\u003e) adapter).write(writer, src);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } finally {\n      writer.setLenient(oldLenient);\n      writer.setHtmlSafe(oldHtmlSafe);\n      writer.setSerializeNulls(oldSerializeNulls);\n    }\n  }",
    "begin_line": 652,
    "end_line": 669,
    "comment": "/** \n * Writes the JSON representation of  {@code src} of type {@code typeOfSrc} to{@code writer}.\n * @throws JsonIOException if there was a problem writing to the writer\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#678",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(com.google.gson.JsonElement)",
    "snippet": "public String toJson(JsonElement jsonElement) {\n    StringWriter writer \u003d new StringWriter();\n    toJson(jsonElement, writer);\n    return writer.toString();\n  }",
    "begin_line": 678,
    "end_line": 682,
    "comment": "/** \n * Converts a tree of  {@link JsonElement}s into its equivalent JSON representation.\n * @param jsonElement root of a tree of {@link JsonElement}s\n * @return JSON String representation of the tree\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#692",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(com.google.gson.JsonElement, java.lang.Appendable)",
    "snippet": "public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {\n    try {\n      JsonWriter jsonWriter \u003d newJsonWriter(Streams.writerForAppendable(writer));\n      toJson(jsonElement, jsonWriter);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }",
    "begin_line": 692,
    "end_line": 699,
    "comment": "/** \n * Writes out the equivalent JSON for a tree of  {@link JsonElement}s.\n * @param jsonElement root of a tree of {@link JsonElement}s\n * @param writer Writer to which the Json representation needs to be written\n * @throws JsonIOException if there was a problem writing to the writer\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.newJsonWriter#704",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.newJsonWriter(java.io.Writer)",
    "snippet": "public JsonWriter newJsonWriter(Writer writer) throws IOException {\n    if (generateNonExecutableJson) {\n      writer.write(JSON_NON_EXECUTABLE_PREFIX);\n    }\n    JsonWriter jsonWriter \u003d new JsonWriter(writer);\n    if (prettyPrinting) {\n      jsonWriter.setIndent(\"  \");\n    }\n    jsonWriter.setSerializeNulls(serializeNulls);\n    return jsonWriter;\n  }",
    "begin_line": 704,
    "end_line": 714,
    "comment": "/** \n * Returns a new JSON writer configured for the settings on this Gson instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.newJsonReader#719",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.newJsonReader(java.io.Reader)",
    "snippet": "public JsonReader newJsonReader(Reader reader) {\n    JsonReader jsonReader \u003d new JsonReader(reader);\n    jsonReader.setLenient(lenient);\n    return jsonReader;\n  }",
    "begin_line": 719,
    "end_line": 723,
    "comment": "/** \n * Returns a new JSON writer configured for the settings on this Gson instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#729",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(com.google.gson.JsonElement, com.google.gson.stream.JsonWriter)",
    "snippet": "public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOException {\n    boolean oldLenient \u003d writer.isLenient();\n    writer.setLenient(true);\n    boolean oldHtmlSafe \u003d writer.isHtmlSafe();\n    writer.setHtmlSafe(htmlSafe);\n    boolean oldSerializeNulls \u003d writer.getSerializeNulls();\n    writer.setSerializeNulls(serializeNulls);\n    try {\n      Streams.write(jsonElement, writer);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } finally {\n      writer.setLenient(oldLenient);\n      writer.setHtmlSafe(oldHtmlSafe);\n      writer.setSerializeNulls(oldSerializeNulls);\n    }\n  }",
    "begin_line": 729,
    "end_line": 745,
    "comment": "/** \n * Writes the JSON for  {@code jsonElement} to {@code writer}.\n * @throws JsonIOException if there was a problem writing to the writer\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#764",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(java.lang.String, java.lang.Class\u003cT\u003e)",
    "snippet": "public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n    Object object \u003d fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n  }",
    "begin_line": 764,
    "end_line": 767,
    "comment": "/** \n * This method deserializes the specified Json into an object of the specified class. It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java. Therefore, this method should not be used if the desired type is a generic type. Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type. For the cases when the object is of generic type, invoke {@link #fromJson(String,Type)}. If you have the Json in a  {@link Reader} instead ofa String, use  {@link #fromJson(Reader,Class)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the string from which the object is to be deserialized\n * @param classOfT the class of T\n * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.\n * @throws JsonSyntaxException if json is not a valid representation for an object of typeclassOfT\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#788",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(java.lang.String, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  public \u003cT\u003e T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\n    if (json \u003d\u003d null) {\n      return null;\n    }\n    StringReader reader \u003d new StringReader(json);\n    T target \u003d (T) fromJson(reader, typeOfT);\n    return target;\n  }",
    "begin_line": 788,
    "end_line": 795,
    "comment": "/** \n * This method deserializes the specified Json into an object of the specified type. This method is useful if the specified object is a generic type. For non-generic objects, use {@link #fromJson(String,Class)} instead. If you have the Json in a {@link Reader} instead ofa String, use  {@link #fromJson(Reader,Type)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the string from which the object is to be deserialized\n * @param typeOfT The specific genericized type of src. You can obtain this type by using the{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for{@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.\n * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n * @throws JsonSyntaxException if json is not a valid representation for an object of type\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#815",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(java.io.Reader, java.lang.Class\u003cT\u003e)",
    "snippet": "public \u003cT\u003e T fromJson(Reader json, Class\u003cT\u003e classOfT) throws JsonSyntaxException, JsonIOException {\n    JsonReader jsonReader \u003d newJsonReader(json);\n    Object object \u003d fromJson(jsonReader, classOfT);\n    assertFullConsumption(object, jsonReader);\n    return Primitives.wrap(classOfT).cast(object);\n  }",
    "begin_line": 815,
    "end_line": 820,
    "comment": "/** \n * This method deserializes the Json read from the specified reader into an object of the specified class. It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java. Therefore, this method should not be used if the desired type is a generic type. Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type. For the cases when the object is of generic type, invoke  {@link #fromJson(Reader,Type)}. If you have the Json in a String form instead of a {@link Reader}, use  {@link #fromJson(String,Class)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the reader producing the Json from which the object is to be deserialized.\n * @param classOfT the class of T\n * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.\n * @throws JsonIOException if there was a problem reading from the Reader\n * @throws JsonSyntaxException if json is not a valid representation for an object of type\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#842",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(java.io.Reader, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader \u003d newJsonReader(json);\n    T object \u003d (T) fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }",
    "begin_line": 842,
    "end_line": 847,
    "comment": "/** \n * This method deserializes the Json read from the specified reader into an object of the specified type. This method is useful if the specified object is a generic type. For non-generic objects, use  {@link #fromJson(Reader,Class)} instead. If you have the Json in aString form instead of a  {@link Reader}, use  {@link #fromJson(String,Type)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the reader producing Json from which the object is to be deserialized\n * @param typeOfT The specific genericized type of src. You can obtain this type by using the{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for{@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.\n * @throws JsonIOException if there was a problem reading from the Reader\n * @throws JsonSyntaxException if json is not a valid representation for an object of type\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.assertFullConsumption#849",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.assertFullConsumption(java.lang.Object, com.google.gson.stream.JsonReader)",
    "snippet": "private static void assertFullConsumption(Object obj, JsonReader reader) {\n    try {\n      if (obj !\u003d null \u0026\u0026 reader.peek() !\u003d JsonToken.END_DOCUMENT) {\n        throw new JsonIOException(\"JSON document was not fully consumed.\");\n      }\n    } catch (MalformedJsonException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    }\n  }",
    "begin_line": 849,
    "end_line": 859,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#870",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(com.google.gson.stream.JsonReader, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty \u003d true;\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty \u003d false;\n      TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n      TypeAdapter\u003cT\u003e typeAdapter \u003d getAdapter(typeToken);\n      T object \u003d typeAdapter.read(reader);\n      return object;\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return null for empty\n       * documents instead of throwing.\n       */\n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\n      throw new JsonSyntaxException(e);\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }",
    "begin_line": 870,
    "end_line": 898,
    "comment": "/** \n * Reads the next JSON value from  {@code reader} and convert it to an objectof type  {@code typeOfT}. Returns  {@code null}, if the  {@code reader} is at EOF.Since Type is not parameterized by T, this method is type unsafe and should be used carefully\n * @throws JsonIOException if there was a problem writing to the Reader\n * @throws JsonSyntaxException if json is not a valid representation for an object of type\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#916",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(com.google.gson.JsonElement, java.lang.Class\u003cT\u003e)",
    "snippet": "public \u003cT\u003e T fromJson(JsonElement json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n    Object object \u003d fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n  }",
    "begin_line": 916,
    "end_line": 919,
    "comment": "/** \n * This method deserializes the Json read from the specified parse tree into an object of the specified type. It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java. Therefore, this method should not be used if the desired type is a generic type. Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type. For the cases when the object is of generic type, invoke  {@link #fromJson(JsonElement,Type)}.\n * @param \u003c T \u003e the type of the desired object\n * @param json the root of the parse tree of {@link JsonElement}s from which the object is to be deserialized\n * @param classOfT The class of T\n * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#940",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(com.google.gson.JsonElement, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  public \u003cT\u003e T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {\n    if (json \u003d\u003d null) {\n      return null;\n    }\n    return (T) fromJson(new JsonTreeReader(json), typeOfT);\n  }",
    "begin_line": 940,
    "end_line": 945,
    "comment": "/** \n * This method deserializes the Json read from the specified parse tree into an object of the specified type. This method is useful if the specified object is a generic type. For non-generic objects, use  {@link #fromJson(JsonElement,Class)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the root of the parse tree of {@link JsonElement}s from which the object is to be deserialized\n * @param typeOfT The specific genericized type of src. You can obtain this type by using the{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for{@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FutureTypeAdapter.setDelegate#950",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.setDelegate(com.google.gson.TypeAdapter\u003cT\u003e)",
    "snippet": "public void setDelegate(TypeAdapter\u003cT\u003e typeAdapter) {\n      if (delegate !\u003d null) {\n        throw new AssertionError();\n      }\n      delegate \u003d typeAdapter;\n    }",
    "begin_line": 950,
    "end_line": 955,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FutureTypeAdapter.read#957",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader in) throws IOException {\n      if (delegate \u003d\u003d null) {\n        throw new IllegalStateException();\n      }\n      return delegate.read(in);\n    }",
    "begin_line": 957,
    "end_line": 962,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FutureTypeAdapter.write#964",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out, T value) throws IOException {\n      if (delegate \u003d\u003d null) {\n        throw new IllegalStateException();\n      }\n      delegate.write(out, value);\n    }",
    "begin_line": 964,
    "end_line": 969,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FutureTypeAdapter.toString#973",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toString()",
    "snippet": "@Override\n  public String toString() {\n    return new StringBuilder(\"{serializeNulls:\")\n        .append(serializeNulls)\n        .append(\"factories:\").append(factories)\n        .append(\",instanceCreators:\").append(constructorConstructor)\n        .append(\"}\")\n        .toString();\n  }",
    "begin_line": 973,
    "end_line": 980,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.serialize#35",
    "is_bug": true,
    "src_path": "com/google/gson/LongSerializationPolicy.java",
    "class_name": "com.google.gson.LongSerializationPolicy",
    "signature": "com.google.gson.LongSerializationPolicy.serialize(java.lang.Long)",
    "snippet": "@Override public JsonElement serialize(Long value) {\n      return new JsonPrimitive(value);\n    }",
    "begin_line": 35,
    "end_line": 37,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.serialize#46",
    "is_bug": true,
    "src_path": "com/google/gson/LongSerializationPolicy.java",
    "class_name": "com.google.gson.LongSerializationPolicy",
    "signature": "com.google.gson.LongSerializationPolicy.serialize(java.lang.Long)",
    "snippet": "@Override public JsonElement serialize(Long value) {\n      return new JsonPrimitive(String.valueOf(value));\n    }",
    "begin_line": 46,
    "end_line": 48,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.serialize#57",
    "is_bug": true,
    "src_path": "com/google/gson/LongSerializationPolicy.java",
    "class_name": "com.google.gson.LongSerializationPolicy",
    "signature": "com.google.gson.LongSerializationPolicy.serialize(java.lang.Long)",
    "snippet": "public abstract JsonElement serialize(Long value);",
    "begin_line": 57,
    "end_line": 57,
    "comment": "/** \n * Serialize this  {@code value} using this serialization policy.\n * @param value the long value to be serialized into a {@link JsonElement}\n * @return the serialized version of {@code value}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.write#127",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "public abstract void write(JsonWriter out, T value) throws IOException;",
    "begin_line": 127,
    "end_line": 127,
    "comment": "/** \n * Writes one JSON value (an array, object, string, number, boolean or null) for  {@code value}.\n * @param value the Java object to write. May be null.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.toJson#140",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.toJson(java.io.Writer, T)",
    "snippet": "public final void toJson(Writer out, T value) throws IOException {\n    JsonWriter writer \u003d new JsonWriter(out);\n    write(writer, value);\n  }",
    "begin_line": 140,
    "end_line": 143,
    "comment": "/** \n * Converts  {@code value} to a JSON document and writes it to {@code out}. Unlike Gson\u0027s similar  {@link Gson#toJson(JsonElement,Appendable) toJson}method, this write is strict. Create a  {@link JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call{@link #write(com.google.gson.stream.JsonWriter,Object)} for lenientwriting.\n * @param value the Java object to convert. May be null.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.nullSafe#185",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.nullSafe()",
    "snippet": "public final TypeAdapter\u003cT\u003e nullSafe() {\n    return new TypeAdapter\u003cT\u003e() {\n      @Override public void write(JsonWriter out, T value) throws IOException {\n        if (value \u003d\u003d null) {\n          out.nullValue();\n        } else {\n          TypeAdapter.this.write(out, value);\n        }\n      }\n      @Override public T read(JsonReader reader) throws IOException {\n        if (reader.peek() \u003d\u003d JsonToken.NULL) {\n          reader.nextNull();\n          return null;\n        }\n        return TypeAdapter.this.read(reader);\n      }\n    };\n  }",
    "begin_line": 185,
    "end_line": 202,
    "comment": "/** \n * This wrapper method is used to make a type adapter null tolerant. In general, a type adapter is required to handle nulls in write and read methods. Here is how this is typically done:\u003cbr\u003e \u003cpre\u003e    {@code Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, new TypeAdapter\u003cFoo\u003e()  public Foo read(JsonReader in) throws IOException  if (in.peek() \u003d\u003d JsonToken.NULL)  in.nextNull(); return null;}// read a Foo from in and return it } public void write(JsonWriter out, Foo src) throws IOException  if (src \u003d\u003d null)  out.nullValue(); return; } // write src as JSON to out } }).create(); }\u003c/pre\u003e You can avoid this boilerplate handling of nulls by wrapping your type adapter with this method. Here is how we will rewrite the above example: \u003cpre\u003e    {@code Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, new TypeAdapter\u003cFoo\u003e()  public Foo read(JsonReader in) throws IOException  // read a Foo from in and return it}public void write(JsonWriter out, Foo src) throws IOException  // write src as JSON to out } }.nullSafe()).create(); }\u003c/pre\u003e Note that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.write#187",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out, T value) throws IOException {\n        if (value \u003d\u003d null) {\n          out.nullValue();\n        } else {\n          TypeAdapter.this.write(out, value);\n        }\n      }",
    "begin_line": 187,
    "end_line": 193,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.read#194",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader reader) throws IOException {\n        if (reader.peek() \u003d\u003d JsonToken.NULL) {\n          reader.nextNull();\n          return null;\n        }\n        return TypeAdapter.this.read(reader);\n      }",
    "begin_line": 194,
    "end_line": 200,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.toJson#214",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.toJson(T)",
    "snippet": "public final String toJson(T value) {\n    StringWriter stringWriter \u003d new StringWriter();\n    try {\n      toJson(stringWriter, value);\n    } catch (IOException e) {\n      throw new AssertionError(e); // No I/O writing to a StringWriter.\n    }\n    return stringWriter.toString();\n  }",
    "begin_line": 214,
    "end_line": 222,
    "comment": "/** \n * Converts  {@code value} to a JSON document. Unlike Gson\u0027s similar {@link Gson#toJson(Object) toJson} method, this write is strict. Create a {@link JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call{@link #write(com.google.gson.stream.JsonWriter,Object)} for lenientwriting.\n * @param value the Java object to convert. May be null.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.toJsonTree#231",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.toJsonTree(T)",
    "snippet": "public final JsonElement toJsonTree(T value) {\n    try {\n      JsonTreeWriter jsonWriter \u003d new JsonTreeWriter();\n      write(jsonWriter, value);\n      return jsonWriter.get();\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    }\n  }",
    "begin_line": 231,
    "end_line": 239,
    "comment": "/** \n * Converts  {@code value} to a JSON tree.\n * @param value the Java object to convert. May be null.\n * @return the converted JSON tree. May be {@link JsonNull}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.read#247",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "public abstract T read(JsonReader in) throws IOException;",
    "begin_line": 247,
    "end_line": 247,
    "comment": "/** \n * Reads one JSON value (an array, object, string, number, boolean or null) and converts it to a Java object. Returns the converted object.\n * @return the converted Java object. May be null.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.fromJson#258",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.fromJson(java.io.Reader)",
    "snippet": "public final T fromJson(Reader in) throws IOException {\n    JsonReader reader \u003d new JsonReader(in);\n    return read(reader);\n  }",
    "begin_line": 258,
    "end_line": 261,
    "comment": "/** \n * Converts the JSON document in  {@code in} to a Java object. Unlike Gson\u0027ssimilar  {@link Gson#fromJson(java.io.Reader,Class) fromJson} method, thisread is strict. Create a  {@link JsonReader#setLenient(boolean) lenient}{@code JsonReader} and call {@link #read(JsonReader)} for lenient reading.\n * @return the converted Java object. May be null.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.fromJson#272",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.fromJson(java.lang.String)",
    "snippet": "public final T fromJson(String json) throws IOException {\n    return fromJson(new StringReader(json));\n  }",
    "begin_line": 272,
    "end_line": 274,
    "comment": "/** \n * Converts the JSON document in  {@code json} to a Java object. Unlike Gson\u0027ssimilar  {@link Gson#fromJson(String,Class) fromJson} method, this read isstrict. Create a  {@link JsonReader#setLenient(boolean) lenient} {@code JsonReader} and call {@link #read(JsonReader)} for lenient reading.\n * @return the converted Java object. May be null.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.fromJsonTree#282",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.fromJsonTree(com.google.gson.JsonElement)",
    "snippet": "public final T fromJsonTree(JsonElement jsonTree) {\n    try {\n      JsonReader jsonReader \u003d new JsonTreeReader(jsonTree);\n      return read(jsonReader);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    }\n  }",
    "begin_line": 282,
    "end_line": 289,
    "comment": "/** \n * Converts  {@code jsonTree} to a Java object.\n * @param jsonTree the Java object to convert. May be {@link JsonNull}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.ConstructorConstructor#51",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.ConstructorConstructor(java.util.Map\u003cjava.lang.reflect.Type,com.google.gson.InstanceCreator\u003c?\u003e\u003e)",
    "snippet": "public ConstructorConstructor(Map\u003cType, InstanceCreator\u003c?\u003e\u003e instanceCreators) {\n    this.instanceCreators \u003d instanceCreators;\n  }",
    "begin_line": 51,
    "end_line": 53,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.get#55",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.get(com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\n    final Type type \u003d typeToken.getType();\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n\n    // first try an instance creator\n\n    @SuppressWarnings(\"unchecked\") // types must agree\n    final InstanceCreator\u003cT\u003e typeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n    if (typeCreator !\u003d null) {\n      return new ObjectConstructor\u003cT\u003e() {\n        @Override public T construct() {\n          return typeCreator.createInstance(type);\n        }\n      };\n    }\n\n    // Next try raw type match for instance creators\n    @SuppressWarnings(\"unchecked\") // types must agree\n    final InstanceCreator\u003cT\u003e rawTypeCreator \u003d\n        (InstanceCreator\u003cT\u003e) instanceCreators.get(rawType);\n    if (rawTypeCreator !\u003d null) {\n      return new ObjectConstructor\u003cT\u003e() {\n        @Override public T construct() {\n          return rawTypeCreator.createInstance(type);\n        }\n      };\n    }\n\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n    if (defaultConstructor !\u003d null) {\n      return defaultConstructor;\n    }\n\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\n    if (defaultImplementation !\u003d null) {\n      return defaultImplementation;\n    }\n\n    // finally try unsafe\n    return newUnsafeAllocator(type, rawType);\n  }",
    "begin_line": 55,
    "end_line": 95,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#65",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n          return typeCreator.createInstance(type);\n        }",
    "begin_line": 65,
    "end_line": 67,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#77",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n          return rawTypeCreator.createInstance(type);\n        }",
    "begin_line": 77,
    "end_line": 79,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.newDefaultConstructor#97",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.newDefaultConstructor(java.lang.Class\u003c? super T\u003e)",
    "snippet": "private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultConstructor(Class\u003c? super T\u003e rawType) {\n    try {\n      final Constructor\u003c? super T\u003e constructor \u003d rawType.getDeclaredConstructor();\n      if (!constructor.isAccessible()) {\n        constructor.setAccessible(true);\n      }\n      return new ObjectConstructor\u003cT\u003e() {\n        @SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n        @Override public T construct() {\n          try {\n            Object[] args \u003d null;\n            return (T) constructor.newInstance(args);\n          } catch (InstantiationException e) {\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n          } catch (InvocationTargetException e) {\n            // TODO: don\u0027t wrap if cause is unchecked!\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\n                e.getTargetException());\n          } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n          }\n        }\n      };\n    } catch (NoSuchMethodException e) {\n      return null;\n    }\n  }",
    "begin_line": 97,
    "end_line": 125,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#105",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@SuppressWarnings(\"unchecked\") construct() {\n          try {\n            Object[] args \u003d null;\n            return (T) constructor.newInstance(args);\n          } catch (InstantiationException e) {\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n          } catch (InvocationTargetException e) {\n            // TODO: don\u0027t wrap if cause is unchecked!\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\n                e.getTargetException());\n          } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n          }\n        }",
    "begin_line": 105,
    "end_line": 120,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.newDefaultImplementationConstructor#132",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor(java.lang.reflect.Type, java.lang.Class\u003c? super T\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") newDefaultImplementationConstructor(\n      final Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n      if (SortedSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n          @Override public T construct() {\n            return (T) new TreeSet\u003cObject\u003e();\n          }\n        };\n      } else if (EnumSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n          @SuppressWarnings(\"rawtypes\")\n          @Override public T construct() {\n            if (type instanceof ParameterizedType) {\n              Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n              if (elementType instanceof Class) {\n                return (T) EnumSet.noneOf((Class)elementType);\n              } else {\n                throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n              }\n            } else {\n              throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n            }\n          }\n        };\n      } else if (Set.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n          @Override public T construct() {\n            return (T) new LinkedHashSet\u003cObject\u003e();\n          }\n        };\n      } else if (Queue.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n          @Override public T construct() {\n            return (T) new LinkedList\u003cObject\u003e();\n          }\n        };\n      } else {\n        return new ObjectConstructor\u003cT\u003e() {\n          @Override public T construct() {\n            return (T) new ArrayList\u003cObject\u003e();\n          }\n        };\n      }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n      if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n          @Override public T construct() {\n            return (T) new ConcurrentSkipListMap\u003cObject, Object\u003e();\n          }\n        };\n      } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n          @Override public T construct() {\n            return (T) new ConcurrentHashMap\u003cObject, Object\u003e();\n          }\n        };\n      } else if (SortedMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n          @Override public T construct() {\n            return (T) new TreeMap\u003cObject, Object\u003e();\n          }\n        };\n      } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(\n          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n        return new ObjectConstructor\u003cT\u003e() {\n          @Override public T construct() {\n            return (T) new LinkedHashMap\u003cObject, Object\u003e();\n          }\n        };\n      } else {\n        return new ObjectConstructor\u003cT\u003e() {\n          @Override public T construct() {\n            return (T) new LinkedTreeMap\u003cString, Object\u003e();\n          }\n        };\n      }\n    }\n\n    return null;\n  }",
    "begin_line": 132,
    "end_line": 214,
    "comment": "/** \n * Constructors for common interface types like Map and List and their subtypes.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#137",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n            return (T) new TreeSet\u003cObject\u003e();\n          }",
    "begin_line": 137,
    "end_line": 139,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#144",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@SuppressWarnings(\"rawtypes\")\n          @Override public T construct() {\n            if (type instanceof ParameterizedType) {\n              Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n              if (elementType instanceof Class) {\n                return (T) EnumSet.noneOf((Class)elementType);\n              } else {\n                throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n              }\n            } else {\n              throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n            }\n          }",
    "begin_line": 144,
    "end_line": 155,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#159",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n            return (T) new LinkedHashSet\u003cObject\u003e();\n          }",
    "begin_line": 159,
    "end_line": 161,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#165",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n            return (T) new LinkedList\u003cObject\u003e();\n          }",
    "begin_line": 165,
    "end_line": 167,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#171",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n            return (T) new ArrayList\u003cObject\u003e();\n          }",
    "begin_line": 171,
    "end_line": 173,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#181",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n            return (T) new ConcurrentSkipListMap\u003cObject, Object\u003e();\n          }",
    "begin_line": 181,
    "end_line": 183,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#187",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n            return (T) new ConcurrentHashMap\u003cObject, Object\u003e();\n          }",
    "begin_line": 187,
    "end_line": 189,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#193",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n            return (T) new TreeMap\u003cObject, Object\u003e();\n          }",
    "begin_line": 193,
    "end_line": 195,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#200",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n            return (T) new LinkedHashMap\u003cObject, Object\u003e();\n          }",
    "begin_line": 200,
    "end_line": 202,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#206",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct() {\n            return (T) new LinkedTreeMap\u003cString, Object\u003e();\n          }",
    "begin_line": 206,
    "end_line": 208,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.newUnsafeAllocator#216",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.newUnsafeAllocator(java.lang.reflect.Type, java.lang.Class\u003c? super T\u003e)",
    "snippet": "private \u003cT\u003e ObjectConstructor\u003cT\u003e newUnsafeAllocator(\n      final Type type, final Class\u003c? super T\u003e rawType) {\n    return new ObjectConstructor\u003cT\u003e() {\n      private final UnsafeAllocator unsafeAllocator \u003d UnsafeAllocator.create();\n      @SuppressWarnings(\"unchecked\")\n      @Override public T construct() {\n        try {\n          Object newInstance \u003d unsafeAllocator.newInstance(rawType);\n          return (T) newInstance;\n        } catch (Exception e) {\n          throw new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n              + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n        }\n      }\n    };\n  }",
    "begin_line": 216,
    "end_line": 231,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#221",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@SuppressWarnings(\"unchecked\")\n      @Override public T construct() {\n        try {\n          Object newInstance \u003d unsafeAllocator.newInstance(rawType);\n          return (T) newInstance;\n        } catch (Exception e) {\n          throw new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n              + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n        }\n      }",
    "begin_line": 221,
    "end_line": 229,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.toString#233",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.toString()",
    "snippet": "@Override public String toString() {\n    return instanceCreators.toString();\n  }",
    "begin_line": 233,
    "end_line": 235,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.clone#61",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.clone()",
    "snippet": "@Override protected Excluder clone() {\n    try {\n      return (Excluder) super.clone();\n    } catch (CloneNotSupportedException e) {\n      throw new AssertionError(e);\n    }\n  }",
    "begin_line": 61,
    "end_line": 67,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.withVersion#69",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.withVersion(double)",
    "snippet": "public Excluder withVersion(double ignoreVersionsAfter) {\n    Excluder result \u003d clone();\n    result.version \u003d ignoreVersionsAfter;\n    return result;\n  }",
    "begin_line": 69,
    "end_line": 73,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.withModifiers#75",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.withModifiers(int)",
    "snippet": "public Excluder withModifiers(int... modifiers) {\n    Excluder result \u003d clone();\n    result.modifiers \u003d 0;\n    for (int modifier : modifiers) {\n      result.modifiers |\u003d modifier;\n    }\n    return result;\n  }",
    "begin_line": 75,
    "end_line": 82,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.disableInnerClassSerialization#84",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.disableInnerClassSerialization()",
    "snippet": "public Excluder disableInnerClassSerialization() {\n    Excluder result \u003d clone();\n    result.serializeInnerClasses \u003d false;\n    return result;\n  }",
    "begin_line": 84,
    "end_line": 88,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.excludeFieldsWithoutExposeAnnotation#90",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.excludeFieldsWithoutExposeAnnotation()",
    "snippet": "public Excluder excludeFieldsWithoutExposeAnnotation() {\n    Excluder result \u003d clone();\n    result.requireExpose \u003d true;\n    return result;\n  }",
    "begin_line": 90,
    "end_line": 94,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.withExclusionStrategy#96",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.withExclusionStrategy(com.google.gson.ExclusionStrategy, boolean, boolean)",
    "snippet": "public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,\n      boolean serialization, boolean deserialization) {\n    Excluder result \u003d clone();\n    if (serialization) {\n      result.serializationStrategies \u003d new ArrayList\u003cExclusionStrategy\u003e(serializationStrategies);\n      result.serializationStrategies.add(exclusionStrategy);\n    }\n    if (deserialization) {\n      result.deserializationStrategies\n          \u003d new ArrayList\u003cExclusionStrategy\u003e(deserializationStrategies);\n      result.deserializationStrategies.add(exclusionStrategy);\n    }\n    return result;\n  }",
    "begin_line": 96,
    "end_line": 109,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.create#111",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d excludeClass(rawType, true);\n    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n      return null;\n    }\n\n    return new TypeAdapter\u003cT\u003e() {\n      /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n      private TypeAdapter\u003cT\u003e delegate;\n\n      @Override public T read(JsonReader in) throws IOException {\n        if (skipDeserialize) {\n          in.skipValue();\n          return null;\n        }\n        return delegate().read(in);\n      }\n\n      @Override public void write(JsonWriter out, T value) throws IOException {\n        if (skipSerialize) {\n          out.nullValue();\n          return;\n        }\n        delegate().write(out, value);\n      }\n\n      private TypeAdapter\u003cT\u003e delegate() {\n        TypeAdapter\u003cT\u003e d \u003d delegate;\n        return d !\u003d null\n            ? d\n            : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\n      }\n    };\n  }",
    "begin_line": 111,
    "end_line": 147,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.read#124",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader in) throws IOException {\n        if (skipDeserialize) {\n          in.skipValue();\n          return null;\n        }\n        return delegate().read(in);\n      }",
    "begin_line": 124,
    "end_line": 130,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.write#132",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out, T value) throws IOException {\n        if (skipSerialize) {\n          out.nullValue();\n          return;\n        }\n        delegate().write(out, value);\n      }",
    "begin_line": 132,
    "end_line": 138,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.delegate#140",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.delegate()",
    "snippet": "private TypeAdapter\u003cT\u003e delegate() {\n        TypeAdapter\u003cT\u003e d \u003d delegate;\n        return d !\u003d null\n            ? d\n            : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\n      }",
    "begin_line": 140,
    "end_line": 145,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.excludeField#149",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.excludeField(java.lang.reflect.Field, boolean)",
    "snippet": "public boolean excludeField(Field field, boolean serialize) {\n    if ((modifiers \u0026 field.getModifiers()) !\u003d 0) {\n      return true;\n    }\n\n    if (version !\u003d Excluder.IGNORE_VERSIONS\n        \u0026\u0026 !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\n      return true;\n    }\n\n    if (field.isSynthetic()) {\n      return true;\n    }\n\n    if (requireExpose) {\n      Expose annotation \u003d field.getAnnotation(Expose.class);\n      if (annotation \u003d\u003d null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\n        return true;\n      }\n    }\n\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(field.getType())) {\n      return true;\n    }\n\n    if (isAnonymousOrLocal(field.getType())) {\n      return true;\n    }\n\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\n    if (!list.isEmpty()) {\n      FieldAttributes fieldAttributes \u003d new FieldAttributes(field);\n      for (ExclusionStrategy exclusionStrategy : list) {\n        if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }",
    "begin_line": 149,
    "end_line": 189,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.excludeClass#191",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.excludeClass(java.lang.Class\u003c?\u003e, boolean)",
    "snippet": "public boolean excludeClass(Class\u003c?\u003e clazz, boolean serialize) {\n    if (version !\u003d Excluder.IGNORE_VERSIONS\n        \u0026\u0026 !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n      return true;\n    }\n\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(clazz)) {\n      return true;\n    }\n\n    if (isAnonymousOrLocal(clazz)) {\n      return true;\n    }\n\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\n    for (ExclusionStrategy exclusionStrategy : list) {\n      if (exclusionStrategy.shouldSkipClass(clazz)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "begin_line": 191,
    "end_line": 213,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isAnonymousOrLocal#215",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isAnonymousOrLocal(java.lang.Class\u003c?\u003e)",
    "snippet": "private boolean isAnonymousOrLocal(Class\u003c?\u003e clazz) {\n    return !Enum.class.isAssignableFrom(clazz)\n        \u0026\u0026 (clazz.isAnonymousClass() || clazz.isLocalClass());\n  }",
    "begin_line": 215,
    "end_line": 218,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isInnerClass#220",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isInnerClass(java.lang.Class\u003c?\u003e)",
    "snippet": "private boolean isInnerClass(Class\u003c?\u003e clazz) {\n    return clazz.isMemberClass() \u0026\u0026 !isStatic(clazz);\n  }",
    "begin_line": 220,
    "end_line": 222,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isStatic#224",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isStatic(java.lang.Class\u003c?\u003e)",
    "snippet": "private boolean isStatic(Class\u003c?\u003e clazz) {\n    return (clazz.getModifiers() \u0026 Modifier.STATIC) !\u003d 0;\n  }",
    "begin_line": 224,
    "end_line": 226,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isValidVersion#228",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isValidVersion(com.google.gson.annotations.Since, com.google.gson.annotations.Until)",
    "snippet": "private boolean isValidVersion(Since since, Until until) {\n    return isValidSince(since) \u0026\u0026 isValidUntil(until);\n  }",
    "begin_line": 228,
    "end_line": 230,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isValidSince#232",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isValidSince(com.google.gson.annotations.Since)",
    "snippet": "private boolean isValidSince(Since annotation) {\n    if (annotation !\u003d null) {\n      double annotationVersion \u003d annotation.value();\n      if (annotationVersion \u003e version) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "begin_line": 232,
    "end_line": 240,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isValidUntil#242",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isValidUntil(com.google.gson.annotations.Until)",
    "snippet": "private boolean isValidUntil(Until annotation) {\n    if (annotation !\u003d null) {\n      double annotationVersion \u003d annotation.value();\n      if (annotationVersion \u003c\u003d version) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "begin_line": 242,
    "end_line": 250,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReaderInternalAccess.promoteNameToValue#31",
    "is_bug": true,
    "src_path": "com/google/gson/internal/JsonReaderInternalAccess.java",
    "class_name": "com.google.gson.internal.JsonReaderInternalAccess",
    "signature": "com.google.gson.internal.JsonReaderInternalAccess.promoteNameToValue(com.google.gson.stream.JsonReader)",
    "snippet": "public abstract void promoteNameToValue(JsonReader reader) throws IOException;",
    "begin_line": 31,
    "end_line": 31,
    "comment": "/** \n * Changes the type of the current property name token to a string value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Streams.Streams#36",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.Streams()",
    "snippet": "private Streams() {\n    throw new UnsupportedOperationException();\n  }",
    "begin_line": 36,
    "end_line": 38,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Streams.parse#43",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.parse(com.google.gson.stream.JsonReader)",
    "snippet": "public static JsonElement parse(JsonReader reader) throws JsonParseException {\n    boolean isEmpty \u003d true;\n    try {\n      reader.peek();\n      isEmpty \u003d false;\n      return TypeAdapters.JSON_ELEMENT.read(reader);\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return a JsonNull for\n       * empty documents instead of throwing.\n       */\n      if (isEmpty) {\n        return JsonNull.INSTANCE;\n      }\n      // The stream ended prematurely so it is likely a syntax error.\n      throw new JsonSyntaxException(e);\n    } catch (MalformedJsonException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } catch (NumberFormatException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
    "begin_line": 43,
    "end_line": 66,
    "comment": "/** \n * Takes a reader in any state and returns the next value as a JsonElement.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Streams.write#71",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.write(com.google.gson.JsonElement, com.google.gson.stream.JsonWriter)",
    "snippet": "public static void write(JsonElement element, JsonWriter writer) throws IOException {\n    TypeAdapters.JSON_ELEMENT.write(writer, element);\n  }",
    "begin_line": 71,
    "end_line": 73,
    "comment": "/** \n * Writes the JSON element to the writer, recursively.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Streams.writerForAppendable#76",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.writerForAppendable(java.lang.Appendable)",
    "snippet": "@SuppressWarnings(\"resource\")\n  public static Writer writerForAppendable(Appendable appendable) {\n    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n  }",
    "begin_line": 76,
    "end_line": 78,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.AppendableWriter#88",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.AppendableWriter(java.lang.Appendable)",
    "snippet": " AppendableWriter(Appendable appendable) {\n      this.appendable \u003d appendable;\n    }",
    "begin_line": 88,
    "end_line": 90,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.write#92",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.write(char[], int, int)",
    "snippet": "@Override public void write(char[] chars, int offset, int length) throws IOException {\n      currentWrite.chars \u003d chars;\n      appendable.append(currentWrite, offset, offset + length);\n    }",
    "begin_line": 92,
    "end_line": 95,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.write#97",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.write(int)",
    "snippet": "@Override public void write(int i) throws IOException {\n      appendable.append((char) i);\n    }",
    "begin_line": 97,
    "end_line": 99,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.flush#101",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.flush()",
    "snippet": "@Override public void flush() {}",
    "begin_line": 101,
    "end_line": 101,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.close#102",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.close()",
    "snippet": "@Override public void close() {}",
    "begin_line": 102,
    "end_line": 102,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CurrentWrite.length#109",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.length()",
    "snippet": "public int length() {\n        return chars.length;\n      }",
    "begin_line": 109,
    "end_line": 111,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CurrentWrite.charAt#112",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.charAt(int)",
    "snippet": "public char charAt(int i) {\n        return chars[i];\n      }",
    "begin_line": 112,
    "end_line": 114,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CurrentWrite.subSequence#115",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.subSequence(int, int)",
    "snippet": "public CharSequence subSequence(int start, int end) {\n        return new String(chars, start, end - start);\n      }",
    "begin_line": 115,
    "end_line": 117,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArrayTypeAdapter.create#41",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ArrayTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n      Type type \u003d typeToken.getType();\n      if (!(type instanceof GenericArrayType || type instanceof Class \u0026\u0026 ((Class\u003c?\u003e) type).isArray())) {\n        return null;\n      }\n\n      Type componentType \u003d $Gson$Types.getArrayComponentType(type);\n      TypeAdapter\u003c?\u003e componentTypeAdapter \u003d gson.getAdapter(TypeToken.get(componentType));\n      return new ArrayTypeAdapter(\n              gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n    }",
    "begin_line": 41,
    "end_line": 51,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArrayTypeAdapter.ArrayTypeAdapter#57",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ArrayTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.ArrayTypeAdapter(com.google.gson.Gson, com.google.gson.TypeAdapter\u003cE\u003e, java.lang.Class\u003cE\u003e)",
    "snippet": "public ArrayTypeAdapter(Gson context, TypeAdapter\u003cE\u003e componentTypeAdapter, Class\u003cE\u003e componentType) {\n    this.componentTypeAdapter \u003d\n      new TypeAdapterRuntimeTypeWrapper\u003cE\u003e(context, componentTypeAdapter, componentType);\n    this.componentType \u003d componentType;\n  }",
    "begin_line": 57,
    "end_line": 61,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArrayTypeAdapter.read#63",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ArrayTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Object read(JsonReader in) throws IOException {\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n\n    List\u003cE\u003e list \u003d new ArrayList\u003cE\u003e();\n    in.beginArray();\n    while (in.hasNext()) {\n      E instance \u003d componentTypeAdapter.read(in);\n      list.add(instance);\n    }\n    in.endArray();\n    Object array \u003d Array.newInstance(componentType, list.size());\n    for (int i \u003d 0; i \u003c list.size(); i++) {\n      Array.set(array, i, list.get(i));\n    }\n    return array;\n  }",
    "begin_line": 63,
    "end_line": 81,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArrayTypeAdapter.write#84",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ArrayTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  @Override public void write(JsonWriter out, Object array) throws IOException {\n    if (array \u003d\u003d null) {\n      out.nullValue();\n      return;\n    }\n\n    out.beginArray();\n    for (int i \u003d 0, length \u003d Array.getLength(array); i \u003c length; i++) {\n      E value \u003d (E) Array.get(array, i);\n      componentTypeAdapter.write(out, value);\n    }\n    out.endArray();\n  }",
    "begin_line": 84,
    "end_line": 96,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CollectionTypeAdapterFactory.CollectionTypeAdapterFactory#39",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.CollectionTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor)",
    "snippet": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n    this.constructorConstructor \u003d constructorConstructor;\n  }",
    "begin_line": 39,
    "end_line": 41,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CollectionTypeAdapterFactory.create#44",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@Override\n  public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n      return null;\n    }\n\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn\u0027t define a type parameter\n    TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\n    return result;\n  }",
    "begin_line": 44,
    "end_line": 59,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.Adapter#65",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.Adapter(com.google.gson.Gson, java.lang.reflect.Type, com.google.gson.TypeAdapter\u003cE\u003e, com.google.gson.internal.ObjectConstructor\u003c? extends java.util.Collection\u003cE\u003e\u003e)",
    "snippet": "public Adapter(Gson context, Type elementType,\n        TypeAdapter\u003cE\u003e elementTypeAdapter,\n        ObjectConstructor\u003c? extends Collection\u003cE\u003e\u003e constructor) {\n      this.elementTypeAdapter \u003d\n          new TypeAdapterRuntimeTypeWrapper\u003cE\u003e(context, elementTypeAdapter, elementType);\n      this.constructor \u003d constructor;\n    }",
    "begin_line": 65,
    "end_line": 71,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.read#73",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Collection\u003cE\u003e read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      Collection\u003cE\u003e collection \u003d constructor.construct();\n      in.beginArray();\n      while (in.hasNext()) {\n        E instance \u003d elementTypeAdapter.read(in);\n        collection.add(instance);\n      }\n      in.endArray();\n      return collection;\n    }",
    "begin_line": 73,
    "end_line": 87,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.write#89",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, java.util.Collection\u003cE\u003e)",
    "snippet": "@Override public void write(JsonWriter out, Collection\u003cE\u003e collection) throws IOException {\n      if (collection \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (E element : collection) {\n        elementTypeAdapter.write(out, element);\n      }\n      out.endArray();\n    }",
    "begin_line": 89,
    "end_line": 100,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DateTypeAdapter.create#44",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/DateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
    "signature": "com.google.gson.internal.bind.DateTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n      return typeToken.getRawType() \u003d\u003d Date.class ? (TypeAdapter\u003cT\u003e) new DateTypeAdapter() : null;\n    }",
    "begin_line": 44,
    "end_line": 46,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DateTypeAdapter.read#54",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/DateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
    "signature": "com.google.gson.internal.bind.DateTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Date read(JsonReader in) throws IOException {\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    return deserializeToDate(in.nextString());\n  }",
    "begin_line": 54,
    "end_line": 60,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DateTypeAdapter.deserializeToDate#62",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/DateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
    "signature": "com.google.gson.internal.bind.DateTypeAdapter.deserializeToDate(java.lang.String)",
    "snippet": "private synchronized Date deserializeToDate(String json) {\n    try {\n      return localFormat.parse(json);\n    } catch (ParseException ignored) {\n    }\n    try {\n      return enUsFormat.parse(json);\n    } catch (ParseException ignored) {\n    }\n    try {\n    \treturn ISO8601Utils.parse(json, new ParsePosition(0));\n    } catch (ParseException e) {\n      throw new JsonSyntaxException(json, e);\n    }\n  }",
    "begin_line": 62,
    "end_line": 76,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DateTypeAdapter.write#78",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/DateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
    "signature": "com.google.gson.internal.bind.DateTypeAdapter.write(com.google.gson.stream.JsonWriter, java.util.Date)",
    "snippet": "@Override public synchronized void write(JsonWriter out, Date value) throws IOException {\n    if (value \u003d\u003d null) {\n      out.nullValue();\n      return;\n    }\n    String dateFormatAsString \u003d enUsFormat.format(value);\n    out.value(dateFormatAsString);\n  }",
    "begin_line": 78,
    "end_line": 85,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonAdapterAnnotationTypeAdapterFactory.JsonAdapterAnnotationTypeAdapterFactory#36",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.JsonAdapterAnnotationTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor)",
    "snippet": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n    this.constructorConstructor \u003d constructorConstructor;\n  }",
    "begin_line": 36,
    "end_line": 38,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonAdapterAnnotationTypeAdapterFactory.create#42",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  @Override\n  public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e targetType) {\n    JsonAdapter annotation \u003d targetType.getRawType().getAnnotation(JsonAdapter.class);\n    if (annotation \u003d\u003d null) {\n      return null;\n    }\n    return (TypeAdapter\u003cT\u003e) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n  }",
    "begin_line": 42,
    "end_line": 48,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter#51",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter(com.google.gson.internal.ConstructorConstructor, com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003c?\u003e, com.google.gson.annotations.JsonAdapter)",
    "snippet": "@SuppressWarnings(\"unchecked\") getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken\u003c?\u003e fieldType, JsonAdapter annotation) {\n    Class\u003c?\u003e value \u003d annotation.value();\n    TypeAdapter\u003c?\u003e typeAdapter;\n    if (TypeAdapter.class.isAssignableFrom(value)) {\n      Class\u003cTypeAdapter\u003c?\u003e\u003e typeAdapterClass \u003d (Class\u003cTypeAdapter\u003c?\u003e\u003e) value;\n      typeAdapter \u003d constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n      Class\u003cTypeAdapterFactory\u003e typeAdapterFactory \u003d (Class\u003cTypeAdapterFactory\u003e) value;\n      typeAdapter \u003d constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n          .construct()\n          .create(gson, fieldType);\n    } else {\n      throw new IllegalArgumentException(\n          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n    }\n      typeAdapter \u003d typeAdapter.nullSafe();\n    return typeAdapter;\n  }",
    "begin_line": 51,
    "end_line": 69,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MapTypeAdapterFactory.MapTypeAdapterFactory#109",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.MapTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor, boolean)",
    "snippet": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n      boolean complexMapKeySerialization) {\n    this.constructorConstructor \u003d constructorConstructor;\n    this.complexMapKeySerialization \u003d complexMapKeySerialization;\n  }",
    "begin_line": 109,
    "end_line": 113,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MapTypeAdapterFactory.create#115",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@Override public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n      return null;\n    }\n\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\n    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    // we don\u0027t define a type parameter for the key or value types\n    TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter,\n        keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n  }",
    "begin_line": 115,
    "end_line": 134,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MapTypeAdapterFactory.getKeyAdapter#139",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.getKeyAdapter(com.google.gson.Gson, java.lang.reflect.Type)",
    "snippet": "private TypeAdapter\u003c?\u003e getKeyAdapter(Gson context, Type keyType) {\n    return (keyType \u003d\u003d boolean.class || keyType \u003d\u003d Boolean.class)\n        ? TypeAdapters.BOOLEAN_AS_STRING\n        : context.getAdapter(TypeToken.get(keyType));\n  }",
    "begin_line": 139,
    "end_line": 143,
    "comment": "/** \n * Returns a type adapter that writes the value as a string.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.Adapter#150",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.Adapter(com.google.gson.Gson, java.lang.reflect.Type, com.google.gson.TypeAdapter\u003cK\u003e, java.lang.reflect.Type, com.google.gson.TypeAdapter\u003cV\u003e, com.google.gson.internal.ObjectConstructor\u003c? extends java.util.Map\u003cK,V\u003e\u003e)",
    "snippet": "public Adapter(Gson context, Type keyType, TypeAdapter\u003cK\u003e keyTypeAdapter,\n        Type valueType, TypeAdapter\u003cV\u003e valueTypeAdapter,\n        ObjectConstructor\u003c? extends Map\u003cK, V\u003e\u003e constructor) {\n      this.keyTypeAdapter \u003d\n        new TypeAdapterRuntimeTypeWrapper\u003cK\u003e(context, keyTypeAdapter, keyType);\n      this.valueTypeAdapter \u003d\n        new TypeAdapterRuntimeTypeWrapper\u003cV\u003e(context, valueTypeAdapter, valueType);\n      this.constructor \u003d constructor;\n    }",
    "begin_line": 150,
    "end_line": 158,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.read#160",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Map\u003cK, V\u003e read(JsonReader in) throws IOException {\n      JsonToken peek \u003d in.peek();\n      if (peek \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      Map\u003cK, V\u003e map \u003d constructor.construct();\n\n      if (peek \u003d\u003d JsonToken.BEGIN_ARRAY) {\n        in.beginArray();\n        while (in.hasNext()) {\n          in.beginArray(); // entry array\n          K key \u003d keyTypeAdapter.read(in);\n          V value \u003d valueTypeAdapter.read(in);\n          V replaced \u003d map.put(key, value);\n          if (replaced !\u003d null) {\n            throw new JsonSyntaxException(\"duplicate key: \" + key);\n          }\n          in.endArray();\n        }\n        in.endArray();\n      } else {\n        in.beginObject();\n        while (in.hasNext()) {\n          JsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\n          K key \u003d keyTypeAdapter.read(in);\n          V value \u003d valueTypeAdapter.read(in);\n          V replaced \u003d map.put(key, value);\n          if (replaced !\u003d null) {\n            throw new JsonSyntaxException(\"duplicate key: \" + key);\n          }\n        }\n        in.endObject();\n      }\n      return map;\n    }",
    "begin_line": 160,
    "end_line": 196,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.write#198",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, java.util.Map\u003cK,V\u003e)",
    "snippet": "@Override public void write(JsonWriter out, Map\u003cK, V\u003e map) throws IOException {\n      if (map \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n\n      if (!complexMapKeySerialization) {\n        out.beginObject();\n        for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\n          out.name(String.valueOf(entry.getKey()));\n          valueTypeAdapter.write(out, entry.getValue());\n        }\n        out.endObject();\n        return;\n      }\n\n      boolean hasComplexKeys \u003d false;\n      List\u003cJsonElement\u003e keys \u003d new ArrayList\u003cJsonElement\u003e(map.size());\n\n      List\u003cV\u003e values \u003d new ArrayList\u003cV\u003e(map.size());\n      for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\n        JsonElement keyElement \u003d keyTypeAdapter.toJsonTree(entry.getKey());\n        keys.add(keyElement);\n        values.add(entry.getValue());\n        hasComplexKeys |\u003d keyElement.isJsonArray() || keyElement.isJsonObject();\n      }\n\n      if (hasComplexKeys) {\n        out.beginArray();\n        for (int i \u003d 0; i \u003c keys.size(); i++) {\n          out.beginArray(); // entry array\n          Streams.write(keys.get(i), out);\n          valueTypeAdapter.write(out, values.get(i));\n          out.endArray();\n        }\n        out.endArray();\n      } else {\n        out.beginObject();\n        for (int i \u003d 0; i \u003c keys.size(); i++) {\n          JsonElement keyElement \u003d keys.get(i);\n          out.name(keyToString(keyElement));\n          valueTypeAdapter.write(out, values.get(i));\n        }\n        out.endObject();\n      }\n    }",
    "begin_line": 198,
    "end_line": 243,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.keyToString#245",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.keyToString(com.google.gson.JsonElement)",
    "snippet": "private String keyToString(JsonElement keyElement) {\n      if (keyElement.isJsonPrimitive()) {\n        JsonPrimitive primitive \u003d keyElement.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          return String.valueOf(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          return Boolean.toString(primitive.getAsBoolean());\n        } else if (primitive.isString()) {\n          return primitive.getAsString();\n        } else {\n          throw new AssertionError();\n        }\n      } else if (keyElement.isJsonNull()) {\n        return \"null\";\n      } else {\n        throw new AssertionError();\n      }\n    }",
    "begin_line": 245,
    "end_line": 262,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectTypeAdapter.create#40",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ObjectTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n    @Override public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\n      if (type.getRawType() \u003d\u003d Object.class) {\n        return (TypeAdapter\u003cT\u003e) new ObjectTypeAdapter(gson);\n      }\n      return null;\n    }",
    "begin_line": 40,
    "end_line": 45,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectTypeAdapter.ObjectTypeAdapter#50",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ObjectTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.ObjectTypeAdapter(com.google.gson.Gson)",
    "snippet": " ObjectTypeAdapter(Gson gson) {\n    this.gson \u003d gson;\n  }",
    "begin_line": 50,
    "end_line": 52,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectTypeAdapter.read#54",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ObjectTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Object read(JsonReader in) throws IOException {\n    JsonToken token \u003d in.peek();\n    switch (token) {\n    case BEGIN_ARRAY:\n      List\u003cObject\u003e list \u003d new ArrayList\u003cObject\u003e();\n      in.beginArray();\n      while (in.hasNext()) {\n        list.add(read(in));\n      }\n      in.endArray();\n      return list;\n\n    case BEGIN_OBJECT:\n      Map\u003cString, Object\u003e map \u003d new LinkedTreeMap\u003cString, Object\u003e();\n      in.beginObject();\n      while (in.hasNext()) {\n        map.put(in.nextName(), read(in));\n      }\n      in.endObject();\n      return map;\n\n    case STRING:\n      return in.nextString();\n\n    case NUMBER:\n      return in.nextDouble();\n\n    case BOOLEAN:\n      return in.nextBoolean();\n\n    case NULL:\n      in.nextNull();\n      return null;\n\n    default:\n      throw new IllegalStateException();\n    }\n  }",
    "begin_line": 54,
    "end_line": 91,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectTypeAdapter.write#94",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ObjectTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  @Override public void write(JsonWriter out, Object value) throws IOException {\n    if (value \u003d\u003d null) {\n      out.nullValue();\n      return;\n    }\n\n    TypeAdapter\u003cObject\u003e typeAdapter \u003d (TypeAdapter\u003cObject\u003e) gson.getAdapter(value.getClass());\n    if (typeAdapter instanceof ObjectTypeAdapter) {\n      out.beginObject();\n      out.endObject();\n      return;\n    }\n\n    typeAdapter.write(out, value);\n  }",
    "begin_line": 94,
    "end_line": 108,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.ReflectiveTypeAdapterFactory#53",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.ReflectiveTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor, com.google.gson.FieldNamingStrategy, com.google.gson.internal.Excluder)",
    "snippet": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n      FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\n    this.constructorConstructor \u003d constructorConstructor;\n    this.fieldNamingPolicy \u003d fieldNamingPolicy;\n    this.excluder \u003d excluder;\n  }",
    "begin_line": 53,
    "end_line": 58,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.excludeField#60",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.excludeField(java.lang.reflect.Field, boolean)",
    "snippet": "public boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }",
    "begin_line": 60,
    "end_line": 62,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.excludeField#64",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.excludeField(java.lang.reflect.Field, boolean, com.google.gson.internal.Excluder)",
    "snippet": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) \u0026\u0026 !excluder.excludeField(f, serialize);\n  }",
    "begin_line": 64,
    "end_line": 66,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.getFieldNames#69",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getFieldNames(java.lang.reflect.Field)",
    "snippet": "private List\u003cString\u003e getFieldNames(Field f) {\n    return getFieldName(fieldNamingPolicy, f);\n  }",
    "begin_line": 69,
    "end_line": 71,
    "comment": "/** \n * first element holds the default name \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.getFieldName#74",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getFieldName(com.google.gson.FieldNamingStrategy, java.lang.reflect.Field)",
    "snippet": "static List\u003cString\u003e getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {\n    SerializedName serializedName \u003d f.getAnnotation(SerializedName.class);\n    List\u003cString\u003e fieldNames \u003d new LinkedList\u003cString\u003e();\n    if (serializedName \u003d\u003d null) {\n      fieldNames.add(fieldNamingPolicy.translateName(f));\n    } else {\n      fieldNames.add(serializedName.value());\n      for (String alternate : serializedName.alternate()) {\n        fieldNames.add(alternate);\n      }\n    }\n    return fieldNames;\n  }",
    "begin_line": 74,
    "end_line": 86,
    "comment": "/** \n * first element holds the default name \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.create#88",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@Override public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, final TypeToken\u003cT\u003e type) {\n    Class\u003c? super T\u003e raw \u003d type.getRawType();\n\n    if (!Object.class.isAssignableFrom(raw)) {\n      return null; // it\u0027s a primitive!\n    }\n\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(type);\n    return new Adapter\u003cT\u003e(constructor, getBoundFields(gson, type, raw));\n  }",
    "begin_line": 88,
    "end_line": 97,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.createBoundField#99",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.createBoundField(com.google.gson.Gson, java.lang.reflect.Field, java.lang.String, com.google.gson.reflect.TypeToken\u003c?\u003e, boolean, boolean)",
    "snippet": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      final TypeAdapter\u003c?\u003e typeAdapter \u003d getFieldAdapter(context, field, fieldType);\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue \u003d field.get(value);\n        TypeAdapter t \u003d\n          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue \u003d typeAdapter.read(reader);\n        if (fieldValue !\u003d null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue \u003d field.get(value);\n        return fieldValue !\u003d value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }",
    "begin_line": 99,
    "end_line": 127,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.write#107",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
    "snippet": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue \u003d field.get(value);\n        TypeAdapter t \u003d\n          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }",
    "begin_line": 107,
    "end_line": 113,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.read#114",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.read(com.google.gson.stream.JsonReader, java.lang.Object)",
    "snippet": "@Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue \u003d typeAdapter.read(reader);\n        if (fieldValue !\u003d null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }",
    "begin_line": 114,
    "end_line": 120,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.writeField#121",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.writeField(java.lang.Object)",
    "snippet": "@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue \u003d field.get(value);\n        return fieldValue !\u003d value; // avoid recursion for example for Throwable.cause\n      }",
    "begin_line": 121,
    "end_line": 125,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.getFieldAdapter#129",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getFieldAdapter(com.google.gson.Gson, java.lang.reflect.Field, com.google.gson.reflect.TypeToken\u003c?\u003e)",
    "snippet": "TypeAdapter\u003c?\u003e getFieldAdapter(Gson gson, Field field, TypeToken\u003c?\u003e fieldType) {\n    JsonAdapter annotation \u003d field.getAnnotation(JsonAdapter.class);\n    if (annotation !\u003d null) {\n      TypeAdapter\u003c?\u003e adapter \u003d getTypeAdapter(constructorConstructor, gson, fieldType, annotation);\n      if (adapter !\u003d null) return adapter;\n    }\n    return gson.getAdapter(fieldType);\n  }",
    "begin_line": 129,
    "end_line": 136,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.getBoundFields#138",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getBoundFields(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003c?\u003e, java.lang.Class\u003c?\u003e)",
    "snippet": "private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n      Field[] fields \u003d raw.getDeclaredFields();\n      for (Field field : fields) {\n        boolean serialize \u003d excludeField(field, true);\n        boolean deserialize \u003d excludeField(field, false);\n        if (!serialize \u0026\u0026 !deserialize) {\n          continue;\n        }\n        field.setAccessible(true);\n        Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List\u003cString\u003e fieldNames \u003d getFieldNames(field);\n        BoundField previous \u003d null;\n        for (int i \u003d 0; i \u003c fieldNames.size(); ++i) {\n          String name \u003d fieldNames.get(i);\n          if (i !\u003d 0) serialize \u003d false; // only serialize the default name\n          BoundField boundField \u003d createBoundField(context, field, name,\n              TypeToken.get(fieldType), serialize, deserialize);\n          BoundField replaced \u003d result.put(name, boundField);\n          if (previous \u003d\u003d null) previous \u003d replaced;\n        }\n        if (previous !\u003d null) {\n          throw new IllegalArgumentException(declaredType\n              + \" declares multiple JSON fields named \" + previous.name);\n        }\n      }\n      type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw \u003d type.getRawType();\n    }\n    return result;\n  }",
    "begin_line": 138,
    "end_line": 174,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundField.BoundField#181",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField(java.lang.String, boolean, boolean)",
    "snippet": "protected BoundField(String name, boolean serialized, boolean deserialized) {\n      this.name \u003d name;\n      this.serialized \u003d serialized;\n      this.deserialized \u003d deserialized;\n    }",
    "begin_line": 181,
    "end_line": 185,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundField.writeField#186",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.writeField(java.lang.Object)",
    "snippet": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;",
    "begin_line": 186,
    "end_line": 186,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundField.write#187",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
    "snippet": "abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;",
    "begin_line": 187,
    "end_line": 187,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundField.read#188",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.read(com.google.gson.stream.JsonReader, java.lang.Object)",
    "snippet": "abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;",
    "begin_line": 188,
    "end_line": 188,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.Adapter#195",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter(com.google.gson.internal.ObjectConstructor\u003cT\u003e, java.util.Map\u003cjava.lang.String,com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField\u003e)",
    "snippet": " Adapter(ObjectConstructor\u003cT\u003e constructor, Map\u003cString, BoundField\u003e boundFields) {\n      this.constructor \u003d constructor;\n      this.boundFields \u003d boundFields;\n    }",
    "begin_line": 195,
    "end_line": 198,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.read#200",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      T instance \u003d constructor.construct();\n\n      try {\n        in.beginObject();\n        while (in.hasNext()) {\n          String name \u003d in.nextName();\n          BoundField field \u003d boundFields.get(name);\n          if (field \u003d\u003d null || !field.deserialized) {\n            in.skipValue();\n          } else {\n            field.read(in, instance);\n          }\n        }\n      } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      in.endObject();\n      return instance;\n    }",
    "begin_line": 200,
    "end_line": 226,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.write#228",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out, T value) throws IOException {\n      if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginObject();\n      try {\n        for (BoundField boundField : boundFields.values()) {\n          if (boundField.writeField(value)) {\n            out.name(boundField.name);\n            boundField.write(out, value);\n          }\n        }\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      out.endObject();\n    }",
    "begin_line": 228,
    "end_line": 246,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SqlDateTypeAdapter.create#41",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/SqlDateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.SqlDateTypeAdapter",
    "signature": "com.google.gson.internal.bind.SqlDateTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n      return typeToken.getRawType() \u003d\u003d java.sql.Date.class\n          ? (TypeAdapter\u003cT\u003e) new SqlDateTypeAdapter() : null;\n    }",
    "begin_line": 41,
    "end_line": 44,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SqlDateTypeAdapter.read#50",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/SqlDateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.SqlDateTypeAdapter",
    "signature": "com.google.gson.internal.bind.SqlDateTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n  public synchronized java.sql.Date read(JsonReader in) throws IOException {\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    try {\n      final long utilDate \u003d format.parse(in.nextString()).getTime();\n      return new java.sql.Date(utilDate);\n    } catch (ParseException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
    "begin_line": 50,
    "end_line": 61,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SqlDateTypeAdapter.write#64",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/SqlDateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.SqlDateTypeAdapter",
    "signature": "com.google.gson.internal.bind.SqlDateTypeAdapter.write(com.google.gson.stream.JsonWriter, java.sql.Date)",
    "snippet": "@Override\n  public synchronized void write(JsonWriter out, java.sql.Date value) throws IOException {\n    out.value(value \u003d\u003d null ? null : format.format(value));\n  }",
    "begin_line": 64,
    "end_line": 66,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TimeTypeAdapter.create#43",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TimeTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.TimeTypeAdapter",
    "signature": "com.google.gson.internal.bind.TimeTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n      return typeToken.getRawType() \u003d\u003d Time.class ? (TypeAdapter\u003cT\u003e) new TimeTypeAdapter() : null;\n    }",
    "begin_line": 43,
    "end_line": 45,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TimeTypeAdapter.read#50",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TimeTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.TimeTypeAdapter",
    "signature": "com.google.gson.internal.bind.TimeTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public synchronized Time read(JsonReader in) throws IOException {\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    try {\n      Date date \u003d format.parse(in.nextString());\n      return new Time(date.getTime());\n    } catch (ParseException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
    "begin_line": 50,
    "end_line": 61,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TimeTypeAdapter.write#63",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TimeTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.TimeTypeAdapter",
    "signature": "com.google.gson.internal.bind.TimeTypeAdapter.write(com.google.gson.stream.JsonWriter, java.sql.Time)",
    "snippet": "@Override public synchronized void write(JsonWriter out, Time value) throws IOException {\n    out.value(value \u003d\u003d null ? null : format.format(value));\n  }",
    "begin_line": 63,
    "end_line": 65,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.TypeAdapters#64",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.TypeAdapters()",
    "snippet": "private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }",
    "begin_line": 64,
    "end_line": 66,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#71",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Class)",
    "snippet": "@Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value \u003d\u003d null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }",
    "begin_line": 71,
    "end_line": 78,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#80",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }",
    "begin_line": 80,
    "end_line": 88,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#93",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset \u003d new BitSet();\n      in.beginArray();\n      int i \u003d 0;\n      JsonToken tokenType \u003d in.peek();\n      while (tokenType !\u003d JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set \u003d in.nextInt() !\u003d 0;\n          break;\n        case BOOLEAN:\n          set \u003d in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue \u003d in.nextString();\n          try {\n            set \u003d Integer.parseInt(stringValue) !\u003d 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType \u003d in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }",
    "begin_line": 93,
    "end_line": 132,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#134",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.BitSet)",
    "snippet": "@Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i \u003d 0; i \u003c src.length(); i++) {\n        int value \u003d (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }",
    "begin_line": 134,
    "end_line": 146,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#153",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() \u003d\u003d JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }",
    "begin_line": 153,
    "end_line": 162,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#164",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Boolean)",
    "snippet": "@Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      out.value(value);\n    }",
    "begin_line": 164,
    "end_line": 170,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#178",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }",
    "begin_line": 178,
    "end_line": 184,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#186",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Boolean)",
    "snippet": "@Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value \u003d\u003d null ? \"null\" : value.toString());\n    }",
    "begin_line": 186,
    "end_line": 188,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#196",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue \u003d in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
    "begin_line": 196,
    "end_line": 207,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#209",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 209,
    "end_line": 211,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#219",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
    "begin_line": 219,
    "end_line": 229,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#231",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 231,
    "end_line": 233,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#241",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
    "begin_line": 241,
    "end_line": 251,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#253",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 253,
    "end_line": 255,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#261",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
    "begin_line": 261,
    "end_line": 267,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#268",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicInteger)",
    "snippet": "@Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }",
    "begin_line": 268,
    "end_line": 270,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#276",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }",
    "begin_line": 276,
    "end_line": 278,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#279",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicBoolean)",
    "snippet": "@Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }",
    "begin_line": 279,
    "end_line": 281,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#287",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List\u003cInteger\u003e list \u003d new ArrayList\u003cInteger\u003e();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer \u003d in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length \u003d list.size();\n        AtomicIntegerArray array \u003d new AtomicIntegerArray(length);\n        for (int i \u003d 0; i \u003c length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }",
    "begin_line": 287,
    "end_line": 305,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#306",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicIntegerArray)",
    "snippet": "@Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i \u003d 0, length \u003d value.length(); i \u003c length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }",
    "begin_line": 306,
    "end_line": 312,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#319",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
    "begin_line": 319,
    "end_line": 329,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#331",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 331,
    "end_line": 333,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#338",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }",
    "begin_line": 338,
    "end_line": 344,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#346",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 346,
    "end_line": 348,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#353",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }",
    "begin_line": 353,
    "end_line": 359,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#361",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 361,
    "end_line": 363,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#368",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken \u003d in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }",
    "begin_line": 368,
    "end_line": 379,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#381",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 381,
    "end_line": 383,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#390",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str \u003d in.nextString();\n      if (str.length() !\u003d 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }",
    "begin_line": 390,
    "end_line": 400,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#402",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Character)",
    "snippet": "@Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value \u003d\u003d null ? null : String.valueOf(value));\n    }",
    "begin_line": 402,
    "end_line": 404,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#412",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek \u003d in.peek();\n      if (peek \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek \u003d\u003d JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }",
    "begin_line": 412,
    "end_line": 423,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#425",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.String)",
    "snippet": "@Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 425,
    "end_line": 427,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#431",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
    "begin_line": 431,
    "end_line": 441,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#443",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.math.BigDecimal)",
    "snippet": "@Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 443,
    "end_line": 445,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#449",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
    "begin_line": 449,
    "end_line": 459,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#461",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.math.BigInteger)",
    "snippet": "@Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }",
    "begin_line": 461,
    "end_line": 463,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#470",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }",
    "begin_line": 470,
    "end_line": 476,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#478",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.StringBuilder)",
    "snippet": "@Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value \u003d\u003d null ? null : value.toString());\n    }",
    "begin_line": 478,
    "end_line": 480,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#488",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }",
    "begin_line": 488,
    "end_line": 494,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#496",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.StringBuffer)",
    "snippet": "@Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value \u003d\u003d null ? null : value.toString());\n    }",
    "begin_line": 496,
    "end_line": 498,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#506",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString \u003d in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }",
    "begin_line": 506,
    "end_line": 513,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#515",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.net.URL)",
    "snippet": "@Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value \u003d\u003d null ? null : value.toExternalForm());\n    }",
    "begin_line": 515,
    "end_line": 517,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#524",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString \u003d in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }",
    "begin_line": 524,
    "end_line": 535,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#537",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.net.URI)",
    "snippet": "@Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value \u003d\u003d null ? null : value.toASCIIString());\n    }",
    "begin_line": 537,
    "end_line": 539,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#546",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }",
    "begin_line": 546,
    "end_line": 553,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#555",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.net.InetAddress)",
    "snippet": "@Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value \u003d\u003d null ? null : value.getHostAddress());\n    }",
    "begin_line": 555,
    "end_line": 557,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#565",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }",
    "begin_line": 565,
    "end_line": 571,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#573",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.UUID)",
    "snippet": "@Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value \u003d\u003d null ? null : value.toString());\n    }",
    "begin_line": 573,
    "end_line": 575,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#582",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }",
    "begin_line": 582,
    "end_line": 584,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#586",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.Currency)",
    "snippet": "@Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }",
    "begin_line": 586,
    "end_line": 588,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.create#594",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n      if (typeToken.getRawType() !\u003d Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter\u003cDate\u003e dateTypeAdapter \u003d gson.getAdapter(Date.class);\n      return (TypeAdapter\u003cT\u003e) new TypeAdapter\u003cTimestamp\u003e() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date \u003d dateTypeAdapter.read(in);\n          return date !\u003d null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }",
    "begin_line": 594,
    "end_line": 610,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#601",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Timestamp read(JsonReader in) throws IOException {\n          Date date \u003d dateTypeAdapter.read(in);\n          return date !\u003d null ? new Timestamp(date.getTime()) : null;\n        }",
    "begin_line": 601,
    "end_line": 604,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#606",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.sql.Timestamp)",
    "snippet": "@Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }",
    "begin_line": 606,
    "end_line": 608,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#622",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year \u003d 0;\n      int month \u003d 0;\n      int dayOfMonth \u003d 0;\n      int hourOfDay \u003d 0;\n      int minute \u003d 0;\n      int second \u003d 0;\n      while (in.peek() !\u003d JsonToken.END_OBJECT) {\n        String name \u003d in.nextName();\n        int value \u003d in.nextInt();\n        if (YEAR.equals(name)) {\n          year \u003d value;\n        } else if (MONTH.equals(name)) {\n          month \u003d value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth \u003d value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay \u003d value;\n        } else if (MINUTE.equals(name)) {\n          minute \u003d value;\n        } else if (SECOND.equals(name)) {\n          second \u003d value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }",
    "begin_line": 622,
    "end_line": 653,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#656",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.Calendar)",
    "snippet": "@Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }",
    "begin_line": 656,
    "end_line": 675,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#683",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale \u003d in.nextString();\n      StringTokenizer tokenizer \u003d new StringTokenizer(locale, \"_\");\n      String language \u003d null;\n      String country \u003d null;\n      String variant \u003d null;\n      if (tokenizer.hasMoreElements()) {\n        language \u003d tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country \u003d tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant \u003d tokenizer.nextToken();\n      }\n      if (country \u003d\u003d null \u0026\u0026 variant \u003d\u003d null) {\n        return new Locale(language);\n      } else if (variant \u003d\u003d null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }",
    "begin_line": 683,
    "end_line": 709,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#711",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.Locale)",
    "snippet": "@Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value \u003d\u003d null ? null : value.toString());\n    }",
    "begin_line": 711,
    "end_line": 713,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#719",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number \u003d in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array \u003d new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object \u003d new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }",
    "begin_line": 719,
    "end_line": 754,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#756",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, com.google.gson.JsonElement)",
    "snippet": "@Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value \u003d\u003d null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive \u003d value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry\u003cString, JsonElement\u003e e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn\u0027t write \" + value.getClass());\n      }\n    }",
    "begin_line": 756,
    "end_line": 787,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.EnumTypeAdapter#797",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.EnumTypeAdapter(java.lang.Class\u003cT\u003e)",
    "snippet": "public EnumTypeAdapter(Class\u003cT\u003e classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name \u003d constant.name();\n          SerializedName annotation \u003d classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation !\u003d null) {\n            name \u003d annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(\"Missing field in \" + classOfT.getName(), e);\n      }\n    }",
    "begin_line": 797,
    "end_line": 814,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.read#815",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }",
    "begin_line": 815,
    "end_line": 821,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.write#823",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value \u003d\u003d null ? null : constantToName.get(value));\n    }",
    "begin_line": 823,
    "end_line": 825,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#830",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n      Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType \u003d\u003d Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType \u003d rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter\u003cT\u003e) new EnumTypeAdapter(rawType);\n    }",
    "begin_line": 830,
    "end_line": 839,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newFactory#842",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newFactory(com.google.gson.reflect.TypeToken\u003cTT\u003e, com.google.gson.TypeAdapter\u003cTT\u003e)",
    "snippet": "public static \u003cTT\u003e TypeAdapterFactory newFactory(\n      final TypeToken\u003cTT\u003e type, final TypeAdapter\u003cTT\u003e typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the \u0027T\u0027s equal\n      @Override public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\n      }\n    };\n  }",
    "begin_line": 842,
    "end_line": 850,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#846",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\n      }",
    "begin_line": 846,
    "end_line": 848,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newFactory#852",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newFactory(java.lang.Class\u003cTT\u003e, com.google.gson.TypeAdapter\u003cTT\u003e)",
    "snippet": "public static \u003cTT\u003e TypeAdapterFactory newFactory(\n      final Class\u003cTT\u003e type, final TypeAdapter\u003cTT\u003e typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the \u0027T\u0027s equal\n      @Override public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n        return typeToken.getRawType() \u003d\u003d type ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type\u003d\" + type.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\n      }\n    };\n  }",
    "begin_line": 852,
    "end_line": 863,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#856",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n        return typeToken.getRawType() \u003d\u003d type ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\n      }",
    "begin_line": 856,
    "end_line": 858,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.toString#859",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.toString()",
    "snippet": "@Override public String toString() {\n        return \"Factory[type\u003d\" + type.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\n      }",
    "begin_line": 859,
    "end_line": 861,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newFactory#865",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newFactory(java.lang.Class\u003cTT\u003e, java.lang.Class\u003cTT\u003e, com.google.gson.TypeAdapter\u003c? super TT\u003e)",
    "snippet": "public static \u003cTT\u003e TypeAdapterFactory newFactory(\n      final Class\u003cTT\u003e unboxed, final Class\u003cTT\u003e boxed, final TypeAdapter\u003c? super TT\u003e typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the \u0027T\u0027s equal\n      @Override public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n        Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n        return (rawType \u003d\u003d unboxed || rawType \u003d\u003d boxed) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type\u003d\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\n      }\n    };\n  }",
    "begin_line": 865,
    "end_line": 878,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#869",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n        Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n        return (rawType \u003d\u003d unboxed || rawType \u003d\u003d boxed) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\n      }",
    "begin_line": 869,
    "end_line": 872,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.toString#873",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.toString()",
    "snippet": "@Override public String toString() {\n        return \"Factory[type\u003d\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\n      }",
    "begin_line": 873,
    "end_line": 876,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newFactoryForMultipleTypes#880",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newFactoryForMultipleTypes(java.lang.Class\u003cTT\u003e, java.lang.Class\u003c? extends TT\u003e, com.google.gson.TypeAdapter\u003c? super TT\u003e)",
    "snippet": "public static \u003cTT\u003e TypeAdapterFactory newFactoryForMultipleTypes(final Class\u003cTT\u003e base,\n      final Class\u003c? extends TT\u003e sub, final TypeAdapter\u003c? super TT\u003e typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the \u0027T\u0027s equal\n      @Override public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n        Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n        return (rawType \u003d\u003d base || rawType \u003d\u003d sub) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type\u003d\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\n      }\n    };\n  }",
    "begin_line": 880,
    "end_line": 893,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#884",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n        Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n        return (rawType \u003d\u003d base || rawType \u003d\u003d sub) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\n      }",
    "begin_line": 884,
    "end_line": 887,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.toString#888",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.toString()",
    "snippet": "@Override public String toString() {\n        return \"Factory[type\u003d\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\n      }",
    "begin_line": 888,
    "end_line": 891,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newTypeHierarchyFactory#899",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newTypeHierarchyFactory(java.lang.Class\u003cT1\u003e, com.google.gson.TypeAdapter\u003cT1\u003e)",
    "snippet": "public static \u003cT1\u003e TypeAdapterFactory newTypeHierarchyFactory(\n      final Class\u003cT1\u003e clazz, final TypeAdapter\u003cT1\u003e typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public \u003cT2\u003e TypeAdapter\u003cT2\u003e create(Gson gson, TypeToken\u003cT2\u003e typeToken) {\n        final Class\u003c? super T2\u003e requestedType \u003d typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter\u003cT2\u003e) new TypeAdapter\u003cT1\u003e() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result \u003d typeAdapter.read(in);\n            if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\n      }\n    };\n  }",
    "begin_line": 899,
    "end_line": 927,
    "comment": "/** \n * Returns a factory for all subtypes of  {@code typeAdapter}. We do a runtime check to confirm that the deserialized type matches the type requested.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#903",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT2\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n      @Override public \u003cT2\u003e TypeAdapter\u003cT2\u003e create(Gson gson, TypeToken\u003cT2\u003e typeToken) {\n        final Class\u003c? super T2\u003e requestedType \u003d typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter\u003cT2\u003e) new TypeAdapter\u003cT1\u003e() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result \u003d typeAdapter.read(in);\n            if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }",
    "begin_line": 903,
    "end_line": 922,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.write#909",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, T1)",
    "snippet": "@Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }",
    "begin_line": 909,
    "end_line": 911,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.read#913",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T1 read(JsonReader in) throws IOException {\n            T1 result \u003d typeAdapter.read(in);\n            if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }",
    "begin_line": 913,
    "end_line": 920,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.toString#923",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.toString()",
    "snippet": "@Override public String toString() {\n        return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\n      }",
    "begin_line": 923,
    "end_line": 925,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.TypeToken#61",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.TypeToken()",
    "snippet": "@SuppressWarnings(\"unchecked\")\n  protected TypeToken() {\n    this.type \u003d getSuperclassTypeParameter(getClass());\n    this.rawType \u003d (Class\u003c? super T\u003e) $Gson$Types.getRawType(type);\n    this.hashCode \u003d type.hashCode();\n  }",
    "begin_line": 61,
    "end_line": 65,
    "comment": "/** \n * Constructs a new type literal. Derives represented class from type parameter. \u003cp\u003eClients create an empty anonymous subclass. Doing so embeds the type parameter in the anonymous class\u0027s type hierarchy so we can reconstitute it at runtime despite erasure.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.TypeToken#71",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.TypeToken(java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\") TypeToken(Type type) {\n    this.type \u003d $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n    this.rawType \u003d (Class\u003c? super T\u003e) $Gson$Types.getRawType(this.type);\n    this.hashCode \u003d this.type.hashCode();\n  }",
    "begin_line": 71,
    "end_line": 75,
    "comment": "/** \n * Unsafe. Constructs a type literal manually.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.getSuperclassTypeParameter#81",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.getSuperclassTypeParameter(java.lang.Class\u003c?\u003e)",
    "snippet": "static Type getSuperclassTypeParameter(Class\u003c?\u003e subclass) {\n    Type superclass \u003d subclass.getGenericSuperclass();\n    if (superclass instanceof Class) {\n      throw new RuntimeException(\"Missing type parameter.\");\n    }\n    ParameterizedType parameterized \u003d (ParameterizedType) superclass;\n    return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n  }",
    "begin_line": 81,
    "end_line": 88,
    "comment": "/** \n * Returns the type from super class\u0027s type parameter in  {@link $Gson$Types#canonicalize canonical form}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.getRawType#93",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.getRawType()",
    "snippet": "public final Class\u003c? super T\u003e getRawType() {\n    return rawType;\n  }",
    "begin_line": 93,
    "end_line": 95,
    "comment": "/** \n * Returns the raw (non-generic) type for this type.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.getType#100",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.getType()",
    "snippet": "public final Type getType() {\n    return type;\n  }",
    "begin_line": 100,
    "end_line": 102,
    "comment": "/** \n * Gets underlying  {@code Type} instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#111",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.Class\u003c?\u003e)",
    "snippet": "@Deprecated\n  public boolean isAssignableFrom(Class\u003c?\u003e cls) {\n    return isAssignableFrom((Type) cls);\n  }",
    "begin_line": 111,
    "end_line": 113,
    "comment": "/** \n * Check if this type is assignable from the given class object.\n * @deprecated this implementation may be inconsistent with javac for typeswith wildcards.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#122",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.reflect.Type)",
    "snippet": "@Deprecated\n  public boolean isAssignableFrom(Type from) {\n    if (from \u003d\u003d null) {\n      return false;\n    }\n\n    if (type.equals(from)) {\n      return true;\n    }\n\n    if (type instanceof Class\u003c?\u003e) {\n      return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n    } else if (type instanceof ParameterizedType) {\n      return isAssignableFrom(from, (ParameterizedType) type,\n          new HashMap\u003cString, Type\u003e());\n    } else if (type instanceof GenericArrayType) {\n      return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n          \u0026\u0026 isAssignableFrom(from, (GenericArrayType) type);\n    } else {\n      throw buildUnexpectedTypeError(\n          type, Class.class, ParameterizedType.class, GenericArrayType.class);\n    }\n  }",
    "begin_line": 122,
    "end_line": 143,
    "comment": "/** \n * Check if this type is assignable from the given Type.\n * @deprecated this implementation may be inconsistent with javac for typeswith wildcards.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#152",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(com.google.gson.reflect.TypeToken\u003c?\u003e)",
    "snippet": "@Deprecated\n  public boolean isAssignableFrom(TypeToken\u003c?\u003e token) {\n    return isAssignableFrom(token.getType());\n  }",
    "begin_line": 152,
    "end_line": 154,
    "comment": "/** \n * Check if this type is assignable from the given type token.\n * @deprecated this implementation may be inconsistent with javac for typeswith wildcards.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#160",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.reflect.Type, java.lang.reflect.GenericArrayType)",
    "snippet": "private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n    Type toGenericComponentType \u003d to.getGenericComponentType();\n    if (toGenericComponentType instanceof ParameterizedType) {\n      Type t \u003d from;\n      if (from instanceof GenericArrayType) {\n        t \u003d ((GenericArrayType) from).getGenericComponentType();\n      } else if (from instanceof Class\u003c?\u003e) {\n        Class\u003c?\u003e classType \u003d (Class\u003c?\u003e) from;\n        while (classType.isArray()) {\n          classType \u003d classType.getComponentType();\n        }\n        t \u003d classType;\n      }\n      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n          new HashMap\u003cString, Type\u003e());\n    }\n    // No generic defined on \"to\"; therefore, return true and let other\n    // checks determine assignability\n    return true;\n  }",
    "begin_line": 160,
    "end_line": 179,
    "comment": "/** \n * Private helper function that performs some assignability checks for the provided GenericArrayType.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#185",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.reflect.Type, java.lang.reflect.ParameterizedType, java.util.Map\u003cjava.lang.String,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean isAssignableFrom(Type from, ParameterizedType to,\n      Map\u003cString, Type\u003e typeVarMap) {\n\n    if (from \u003d\u003d null) {\n      return false;\n    }\n\n    if (to.equals(from)) {\n      return true;\n    }\n\n    // First figure out the class and any type information.\n    Class\u003c?\u003e clazz \u003d $Gson$Types.getRawType(from);\n    ParameterizedType ptype \u003d null;\n    if (from instanceof ParameterizedType) {\n      ptype \u003d (ParameterizedType) from;\n    }\n\n    // Load up parameterized variable info if it was parameterized.\n    if (ptype !\u003d null) {\n      Type[] tArgs \u003d ptype.getActualTypeArguments();\n      TypeVariable\u003c?\u003e[] tParams \u003d clazz.getTypeParameters();\n      for (int i \u003d 0; i \u003c tArgs.length; i++) {\n        Type arg \u003d tArgs[i];\n        TypeVariable\u003c?\u003e var \u003d tParams[i];\n        while (arg instanceof TypeVariable\u003c?\u003e) {\n          TypeVariable\u003c?\u003e v \u003d (TypeVariable\u003c?\u003e) arg;\n          arg \u003d typeVarMap.get(v.getName());\n        }\n        typeVarMap.put(var.getName(), arg);\n      }\n\n      // check if they are equivalent under our current mapping.\n      if (typeEquals(ptype, to, typeVarMap)) {\n        return true;\n      }\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap\u003cString, Type\u003e(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn\u0027t work, try the superclass.\n    Type sType \u003d clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap\u003cString, Type\u003e(typeVarMap));\n  }",
    "begin_line": 185,
    "end_line": 232,
    "comment": "/** \n * Private recursive helper function to actually do the type-safe checking of assignability.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.typeEquals#238",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.typeEquals(java.lang.reflect.ParameterizedType, java.lang.reflect.ParameterizedType, java.util.Map\u003cjava.lang.String,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map\u003cString, Type\u003e typeVarMap) {\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs \u003d from.getActualTypeArguments();\n      Type[] toArgs \u003d to.getActualTypeArguments();\n      for (int i \u003d 0; i \u003c fromArgs.length; i++) {\n        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
    "begin_line": 238,
    "end_line": 251,
    "comment": "/** \n * Checks if two parameterized types are exactly equal, under the variable replacement described in the typeVarMap.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.buildUnexpectedTypeError#253",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.buildUnexpectedTypeError(java.lang.reflect.Type, java.lang.Class\u003c?\u003e)",
    "snippet": "private static AssertionError buildUnexpectedTypeError(\n      Type token, Class\u003c?\u003e... expected) {\n\n    // Build exception message\n    StringBuilder exceptionMessage \u003d\n        new StringBuilder(\"Unexpected type. Expected one of: \");\n    for (Class\u003c?\u003e clazz : expected) {\n      exceptionMessage.append(clazz.getName()).append(\", \");\n    }\n    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n        .append(\", for type token: \").append(token.toString()).append(\u0027.\u0027);\n\n    return new AssertionError(exceptionMessage.toString());\n  }",
    "begin_line": 253,
    "end_line": 266,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.matches#272",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.matches(java.lang.reflect.Type, java.lang.reflect.Type, java.util.Map\u003cjava.lang.String,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean matches(Type from, Type to, Map\u003cString, Type\u003e typeMap) {\n    return to.equals(from)\n        || (from instanceof TypeVariable\n        \u0026\u0026 to.equals(typeMap.get(((TypeVariable\u003c?\u003e) from).getName())));\n\n  }",
    "begin_line": 272,
    "end_line": 277,
    "comment": "/** \n * Checks if two types are the same or are equivalent under a variable mapping given in the type map that was provided.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.hashCode#279",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.hashCode()",
    "snippet": "@Override public final int hashCode() {\n    return this.hashCode;\n  }",
    "begin_line": 279,
    "end_line": 281,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.equals#283",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.equals(java.lang.Object)",
    "snippet": "@Override public final boolean equals(Object o) {\n    return o instanceof TypeToken\u003c?\u003e\n        \u0026\u0026 $Gson$Types.equals(type, ((TypeToken\u003c?\u003e) o).type);\n  }",
    "begin_line": 283,
    "end_line": 286,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.toString#288",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.toString()",
    "snippet": "@Override public final String toString() {\n    return $Gson$Types.typeToString(type);\n  }",
    "begin_line": 288,
    "end_line": 290,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.get#295",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.get(java.lang.reflect.Type)",
    "snippet": "public static TypeToken\u003c?\u003e get(Type type) {\n    return new TypeToken\u003cObject\u003e(type);\n  }",
    "begin_line": 295,
    "end_line": 297,
    "comment": "/** \n * Gets type literal for the given  {@code Type} instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.get#302",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.get(java.lang.Class\u003cT\u003e)",
    "snippet": "public static \u003cT\u003e TypeToken\u003cT\u003e get(Class\u003cT\u003e type) {\n    return new TypeToken\u003cT\u003e(type);\n  }",
    "begin_line": 302,
    "end_line": 304,
    "comment": "/** \n * Gets type literal for the given  {@code Class} instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.JsonReader#289",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.JsonReader(java.io.Reader)",
    "snippet": "public JsonReader(Reader in) {\n    if (in \u003d\u003d null) {\n      throw new NullPointerException(\"in \u003d\u003d null\");\n    }\n    this.in \u003d in;\n  }",
    "begin_line": 289,
    "end_line": 294,
    "comment": "/** \n * Creates a new instance that reads a JSON-encoded stream from  {@code in}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.setLenient#325",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.setLenient(boolean)",
    "snippet": "public final void setLenient(boolean lenient) {\n    this.lenient \u003d lenient;\n  }",
    "begin_line": 325,
    "end_line": 327,
    "comment": "/** \n * Configure this parser to be liberal in what it accepts. By default, this parser is strict and only accepts JSON as specified by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc4627.txt\"\u003eRFC 4627\u003c/a\u003e. Setting the parser to lenient causes it to ignore the following syntax errors: \u003cul\u003e \u003cli\u003eStreams that start with the \u003ca href\u003d\"#nonexecuteprefix\"\u003enon-execute prefix\u003c/a\u003e, \u003ccode\u003e\")]}\u0027\\n\"\u003c/code\u003e. \u003cli\u003eStreams that include multiple top-level values. With strict parsing, each stream must contain exactly one top-level value. \u003cli\u003eTop-level values of any type. With strict parsing, the top-level value must be an object or an array. \u003cli\u003eNumbers may be  {@link Double#isNaN() NaNs} or {@link Double#isInfinite() infinities}. \u003cli\u003eEnd of line comments starting with  {@code //} or {@code #} andending with a newline character. \u003cli\u003eC-style comments starting with  {@code /*} and ending with{@code *}{@code /}. Such comments may not be nested. \u003cli\u003eNames that are unquoted or  {@code \u0027single quoted\u0027}. \u003cli\u003eStrings that are unquoted or  {@code \u0027single quoted\u0027}. \u003cli\u003eArray elements separated by  {@code ;} instead of {@code ,}. \u003cli\u003eUnnecessary array separators. These are interpreted as if null was the omitted value. \u003cli\u003eNames and values separated by  {@code \u003d} or {@code \u003d\u003e} instead of{@code :}. \u003cli\u003eName/value pairs separated by  {@code ;} instead of {@code ,}. \u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.isLenient#332",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.isLenient()",
    "snippet": "public final boolean isLenient() {\n    return lenient;\n  }",
    "begin_line": 332,
    "end_line": 334,
    "comment": "/** \n * Returns true if this parser is liberal in what it accepts.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.beginArray#340",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.beginArray()",
    "snippet": "public void beginArray() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n    if (p \u003d\u003d PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] \u003d 0;\n      peeked \u003d PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
    "begin_line": 340,
    "end_line": 353,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is the beginning of a new array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.endArray#359",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.endArray()",
    "snippet": "public void endArray() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n    if (p \u003d\u003d PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked \u003d PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
    "begin_line": 359,
    "end_line": 372,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is the end of the current array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.beginObject#378",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.beginObject()",
    "snippet": "public void beginObject() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n    if (p \u003d\u003d PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked \u003d PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
    "begin_line": 378,
    "end_line": 390,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is the beginning of a new object.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.endObject#396",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.endObject()",
    "snippet": "public void endObject() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n    if (p \u003d\u003d PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] \u003d null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked \u003d PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
    "begin_line": 396,
    "end_line": 410,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is the end of the current object.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.hasNext#415",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.hasNext()",
    "snippet": "public boolean hasNext() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n    return p !\u003d PEEKED_END_OBJECT \u0026\u0026 p !\u003d PEEKED_END_ARRAY;\n  }",
    "begin_line": 415,
    "end_line": 421,
    "comment": "/** \n * Returns true if the current array or object has another element.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.peek#426",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.peek()",
    "snippet": "public JsonToken peek() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }",
    "begin_line": 426,
    "end_line": 463,
    "comment": "/** \n * Returns the type of the next token without consuming it.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.doPeek#465",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.doPeek()",
    "snippet": "int doPeek() throws IOException {\n    int peekStack \u003d stack[stackSize - 1];\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c \u003d nextNonWhitespace(true);\n      switch (c) {\n      case \u0027]\u0027:\n        return peeked \u003d PEEKED_END_ARRAY;\n      case \u0027;\u0027:\n        checkLenient(); // fall-through\n      case \u0027,\u0027:\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\n        int c \u003d nextNonWhitespace(true);\n        switch (c) {\n        case \u0027}\u0027:\n          return peeked \u003d PEEKED_END_OBJECT;\n        case \u0027;\u0027:\n          checkLenient(); // fall-through\n        case \u0027,\u0027:\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c \u003d nextNonWhitespace(true);\n      switch (c) {\n      case \u0027\"\u0027:\n        return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\n      case \u0027\\\u0027\u0027:\n        checkLenient();\n        return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\n      case \u0027}\u0027:\n        if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\n          return peeked \u003d PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don\u0027t consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked \u003d PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c \u003d nextNonWhitespace(true);\n      switch (c) {\n      case \u0027:\u0027:\n        break;\n      case \u0027\u003d\u0027:\n        checkLenient();\n        if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected \u0027:\u0027\");\n      }\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\n      int c \u003d nextNonWhitespace(false);\n      if (c \u003d\u003d -1) {\n        return peeked \u003d PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c \u003d nextNonWhitespace(true);\n    switch (c) {\n    case \u0027]\u0027:\n      if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\n        return peeked \u003d PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case \u0027;\u0027:\n    case \u0027,\u0027:\n      // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\n      if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked \u003d PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case \u0027\\\u0027\u0027:\n      checkLenient();\n      return peeked \u003d PEEKED_SINGLE_QUOTED;\n    case \u0027\"\u0027:\n      return peeked \u003d PEEKED_DOUBLE_QUOTED;\n    case \u0027[\u0027:\n      return peeked \u003d PEEKED_BEGIN_ARRAY;\n    case \u0027{\u0027:\n      return peeked \u003d PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don\u0027t consume the first character in a literal value.\n    }\n\n    int result \u003d peekKeyword();\n    if (result !\u003d PEEKED_NONE) {\n      return result;\n    }\n\n    result \u003d peekNumber();\n    if (result !\u003d PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked \u003d PEEKED_UNQUOTED;\n  }",
    "begin_line": 465,
    "end_line": 599,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.peekKeyword#601",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.peekKeyword()",
    "snippet": "private int peekKeyword() throws IOException {\n    // Figure out which keyword we\u0027re matching against by its first character.\n    char c \u003d buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c \u003d\u003d \u0027t\u0027 || c \u003d\u003d \u0027T\u0027) {\n      keyword \u003d \"true\";\n      keywordUpper \u003d \"TRUE\";\n      peeking \u003d PEEKED_TRUE;\n    } else if (c \u003d\u003d \u0027f\u0027 || c \u003d\u003d \u0027F\u0027) {\n      keyword \u003d \"false\";\n      keywordUpper \u003d \"FALSE\";\n      peeking \u003d PEEKED_FALSE;\n    } else if (c \u003d\u003d \u0027n\u0027 || c \u003d\u003d \u0027N\u0027) {\n      keyword \u003d \"null\";\n      keywordUpper \u003d \"NULL\";\n      peeking \u003d PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length \u003d keyword.length();\n    for (int i \u003d 1; i \u003c length; i++) {\n      if (pos + i \u003e\u003d limit \u0026\u0026 !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c \u003d buffer[pos + i];\n      if (c !\u003d keyword.charAt(i) \u0026\u0026 c !\u003d keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length \u003c limit || fillBuffer(length + 1))\n        \u0026\u0026 isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don\u0027t match trues, falsey or nullsoft!\n    }\n\n    // We\u0027ve found the keyword followed either by EOF or by a non-literal character.\n    pos +\u003d length;\n    return peeked \u003d peeking;\n  }",
    "begin_line": 601,
    "end_line": 643,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.peekNumber#645",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.peekNumber()",
    "snippet": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\n    char[] buffer \u003d this.buffer;\n    int p \u003d pos;\n    int l \u003d limit;\n\n    long value \u003d 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative \u003d false;\n    boolean fitsInLong \u003d true;\n    int last \u003d NUMBER_CHAR_NONE;\n\n    int i \u003d 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i \u003d\u003d l) {\n        if (i \u003d\u003d buffer.length) {\n          // Though this looks like a well-formed number, it\u0027s too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p \u003d pos;\n        l \u003d limit;\n      }\n\n      char c \u003d buffer[p + i];\n      switch (c) {\n      case \u0027-\u0027:\n        if (last \u003d\u003d NUMBER_CHAR_NONE) {\n          negative \u003d true;\n          last \u003d NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\n          last \u003d NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case \u0027+\u0027:\n        if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\n          last \u003d NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case \u0027e\u0027:\n      case \u0027E\u0027:\n        if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT) {\n          last \u003d NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case \u0027.\u0027:\n        if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\n          last \u003d NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c \u003c \u00270\u0027 || c \u003e \u00279\u0027) {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last \u003d\u003d NUMBER_CHAR_SIGN || last \u003d\u003d NUMBER_CHAR_NONE) {\n          value \u003d -(c - \u00270\u0027);\n          last \u003d NUMBER_CHAR_DIGIT;\n        } else if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\n          if (value \u003d\u003d 0) {\n            return PEEKED_NONE; // Leading \u00270\u0027 prefix is not allowed (since it could be octal).\n          }\n          long newValue \u003d value * 10 - (c - \u00270\u0027);\n          fitsInLong \u0026\u003d value \u003e MIN_INCOMPLETE_INTEGER\n              || (value \u003d\u003d MIN_INCOMPLETE_INTEGER \u0026\u0026 newValue \u003c value);\n          value \u003d newValue;\n        } else if (last \u003d\u003d NUMBER_CHAR_DECIMAL) {\n          last \u003d NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last \u003d\u003d NUMBER_CHAR_EXP_E || last \u003d\u003d NUMBER_CHAR_EXP_SIGN) {\n          last \u003d NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We\u0027ve read a complete number. Decide if it\u0027s a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last \u003d\u003d NUMBER_CHAR_DIGIT \u0026\u0026 fitsInLong \u0026\u0026 (value !\u003d Long.MIN_VALUE || negative)) {\n      peekedLong \u003d negative ? value : -value;\n      pos +\u003d i;\n      return peeked \u003d PEEKED_LONG;\n    } else if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT\n        || last \u003d\u003d NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength \u003d i;\n      return peeked \u003d PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
    "begin_line": 645,
    "end_line": 746,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.isLiteral#748",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.isLiteral(char)",
    "snippet": "private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case \u0027/\u0027:\n    case \u0027\\\\\u0027:\n    case \u0027;\u0027:\n    case \u0027#\u0027:\n    case \u0027\u003d\u0027:\n      checkLenient(); // fall-through\n    case \u0027{\u0027:\n    case \u0027}\u0027:\n    case \u0027[\u0027:\n    case \u0027]\u0027:\n    case \u0027:\u0027:\n    case \u0027,\u0027:\n    case \u0027 \u0027:\n    case \u0027\\t\u0027:\n    case \u0027\\f\u0027:\n    case \u0027\\r\u0027:\n    case \u0027\\n\u0027:\n      return false;\n    default:\n      return true;\n    }\n  }",
    "begin_line": 748,
    "end_line": 771,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextName#780",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextName()",
    "snippet": "public String nextName() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n    String result;\n    if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\n      result \u003d nextUnquotedValue();\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\n      result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\n      result \u003d nextQuotedValue(\u0027\"\u0027);\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked \u003d PEEKED_NONE;\n    pathNames[stackSize - 1] \u003d result;\n    return result;\n  }",
    "begin_line": 780,
    "end_line": 799,
    "comment": "/** \n * Returns the next token, a  {@link com.google.gson.stream.JsonToken#NAME property name}, and consumes it.\n * @throws java.io.IOException if the next token in the stream is not a propertyname.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextString#809",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextString()",
    "snippet": "public String nextString() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n    String result;\n    if (p \u003d\u003d PEEKED_UNQUOTED) {\n      result \u003d nextUnquotedValue();\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED) {\n      result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\n      result \u003d nextQuotedValue(\u0027\"\u0027);\n    } else if (p \u003d\u003d PEEKED_BUFFERED) {\n      result \u003d peekedString;\n      peekedString \u003d null;\n    } else if (p \u003d\u003d PEEKED_LONG) {\n      result \u003d Long.toString(peekedLong);\n    } else if (p \u003d\u003d PEEKED_NUMBER) {\n      result \u003d new String(buffer, pos, peekedNumberLength);\n      pos +\u003d peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked \u003d PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
    "begin_line": 809,
    "end_line": 836,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,consuming it. If the next token is a number, this method will return its string form.\n * @throws IllegalStateException if the next token is not a string or ifthis reader is closed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextBoolean#845",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextBoolean()",
    "snippet": "public boolean nextBoolean() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n    if (p \u003d\u003d PEEKED_TRUE) {\n      peeked \u003d PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p \u003d\u003d PEEKED_FALSE) {\n      peeked \u003d PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }",
    "begin_line": 845,
    "end_line": 861,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,consuming it.\n * @throws IllegalStateException if the next token is not a boolean or ifthis reader is closed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextNull#870",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextNull()",
    "snippet": "public void nextNull() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n    if (p \u003d\u003d PEEKED_NULL) {\n      peeked \u003d PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
    "begin_line": 870,
    "end_line": 882,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is a literal null.\n * @throws IllegalStateException if the next token is not null or if thisreader is closed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextDouble#893",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextDouble()",
    "snippet": "public double nextDouble() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n\n    if (p \u003d\u003d PEEKED_LONG) {\n      peeked \u003d PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p \u003d\u003d PEEKED_NUMBER) {\n      peekedString \u003d new String(buffer, pos, peekedNumberLength);\n      pos +\u003d peekedNumberLength;\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\n      peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\n    } else if (p \u003d\u003d PEEKED_UNQUOTED) {\n      peekedString \u003d nextUnquotedValue();\n    } else if (p !\u003d PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked \u003d PEEKED_BUFFERED;\n    double result \u003d Double.parseDouble(peekedString); // don\u0027t catch this NumberFormatException.\n    if (!lenient \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString \u003d null;\n    peeked \u003d PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
    "begin_line": 893,
    "end_line": 927,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,consuming it. If the next token is a string, this method will attempt to parse it as a double using  {@link Double#parseDouble(String)}.\n * @throws IllegalStateException if the next token is not a literal value.\n * @throws NumberFormatException if the next literal value cannot be parsedas a double, or is non-finite.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextLong#939",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextLong()",
    "snippet": "public long nextLong() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n\n    if (p \u003d\u003d PEEKED_LONG) {\n      peeked \u003d PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p \u003d\u003d PEEKED_NUMBER) {\n      peekedString \u003d new String(buffer, pos, peekedNumberLength);\n      pos +\u003d peekedNumberLength;\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\n      peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\n      try {\n        long result \u003d Long.parseLong(peekedString);\n        peeked \u003d PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked \u003d PEEKED_BUFFERED;\n    double asDouble \u003d Double.parseDouble(peekedString); // don\u0027t catch this NumberFormatException.\n    long result \u003d (long) asDouble;\n    if (result !\u003d asDouble) { // Make sure no precision was lost casting to \u0027long\u0027.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString \u003d null;\n    peeked \u003d PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
    "begin_line": 939,
    "end_line": 980,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,consuming it. If the next token is a string, this method will attempt to parse it as a long. If the next token\u0027s numeric value cannot be exactly represented by a Java  {@code long}, this method throws.\n * @throws IllegalStateException if the next token is not a literal value.\n * @throws NumberFormatException if the next literal value cannot be parsedas a number, or exactly represented as a long.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextQuotedValue#992",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextQuotedValue(char)",
    "snippet": "private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\n    char[] buffer \u003d this.buffer;\n    StringBuilder builder \u003d new StringBuilder();\n    while (true) {\n      int p \u003d pos;\n      int l \u003d limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start \u003d p;\n      while (p \u003c l) {\n        int c \u003d buffer[p++];\n\n        if (c \u003d\u003d quote) {\n          pos \u003d p;\n          builder.append(buffer, start, p - start - 1);\n          return builder.toString();\n        } else if (c \u003d\u003d \u0027\\\\\u0027) {\n          pos \u003d p;\n          builder.append(buffer, start, p - start - 1);\n          builder.append(readEscapeCharacter());\n          p \u003d pos;\n          l \u003d limit;\n          start \u003d p;\n        } else if (c \u003d\u003d \u0027\\n\u0027) {\n          lineNumber++;\n          lineStart \u003d p;\n        }\n      }\n\n      builder.append(buffer, start, p - start);\n      pos \u003d p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }",
    "begin_line": 992,
    "end_line": 1027,
    "comment": "/** \n * Returns the string up to but not including  {@code quote}, unescaping any character escape sequences encountered along the way. The opening quote should have already been read. This consumes the closing quote, but does not include it in the returned string.\n * @param quote either \u0027 or \".\n * @throws NumberFormatException if any unicode escape sequences aremalformed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextUnquotedValue#1033",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextUnquotedValue()",
    "snippet": "@SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder \u003d null;\n    int i \u003d 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i \u003c limit; i++) {\n        switch (buffer[pos + i]) {\n        case \u0027/\u0027:\n        case \u0027\\\\\u0027:\n        case \u0027;\u0027:\n        case \u0027#\u0027:\n        case \u0027\u003d\u0027:\n          checkLenient(); // fall-through\n        case \u0027{\u0027:\n        case \u0027}\u0027:\n        case \u0027[\u0027:\n        case \u0027]\u0027:\n        case \u0027:\u0027:\n        case \u0027,\u0027:\n        case \u0027 \u0027:\n        case \u0027\\t\u0027:\n        case \u0027\\f\u0027:\n        case \u0027\\r\u0027:\n        case \u0027\\n\u0027:\n          break findNonLiteralCharacter;\n        }\n      }\n\n      // Attempt to load the entire literal into the buffer at once.\n      if (i \u003c buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // use a StringBuilder when the value is too long. This is too long to be a number!\n      if (builder \u003d\u003d null) {\n        builder \u003d new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos +\u003d i;\n      i \u003d 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder \u003d\u003d null) {\n      result \u003d new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result \u003d builder.toString();\n    }\n    pos +\u003d i;\n    return result;\n  }",
    "begin_line": 1033,
    "end_line": 1092,
    "comment": "/** \n * Returns an unquoted value as a string.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipQuotedValue#1094",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipQuotedValue(char)",
    "snippet": "private void skipQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\n    char[] buffer \u003d this.buffer;\n    do {\n      int p \u003d pos;\n      int l \u003d limit;\n      /* the index of the first character not yet appended to the builder. */\n      while (p \u003c l) {\n        int c \u003d buffer[p++];\n        if (c \u003d\u003d quote) {\n          pos \u003d p;\n          return;\n        } else if (c \u003d\u003d \u0027\\\\\u0027) {\n          pos \u003d p;\n          readEscapeCharacter();\n          p \u003d pos;\n          l \u003d limit;\n        } else if (c \u003d\u003d \u0027\\n\u0027) {\n          lineNumber++;\n          lineStart \u003d p;\n        }\n      }\n      pos \u003d p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }",
    "begin_line": 1094,
    "end_line": 1119,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipUnquotedValue#1121",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipUnquotedValue()",
    "snippet": "private void skipUnquotedValue() throws IOException {\n    do {\n      int i \u003d 0;\n      for (; pos + i \u003c limit; i++) {\n        switch (buffer[pos + i]) {\n        case \u0027/\u0027:\n        case \u0027\\\\\u0027:\n        case \u0027;\u0027:\n        case \u0027#\u0027:\n        case \u0027\u003d\u0027:\n          checkLenient(); // fall-through\n        case \u0027{\u0027:\n        case \u0027}\u0027:\n        case \u0027[\u0027:\n        case \u0027]\u0027:\n        case \u0027:\u0027:\n        case \u0027,\u0027:\n        case \u0027 \u0027:\n        case \u0027\\t\u0027:\n        case \u0027\\f\u0027:\n        case \u0027\\r\u0027:\n        case \u0027\\n\u0027:\n          pos +\u003d i;\n          return;\n        }\n      }\n      pos +\u003d i;\n    } while (fillBuffer(1));\n  }",
    "begin_line": 1121,
    "end_line": 1149,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextInt#1161",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextInt()",
    "snippet": "public int nextInt() throws IOException {\n    int p \u003d peeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p \u003d doPeek();\n    }\n\n    int result;\n    if (p \u003d\u003d PEEKED_LONG) {\n      result \u003d (int) peekedLong;\n      if (peekedLong !\u003d result) { // Make sure no precision was lost casting to \u0027int\u0027.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked \u003d PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p \u003d\u003d PEEKED_NUMBER) {\n      peekedString \u003d new String(buffer, pos, peekedNumberLength);\n      pos +\u003d peekedNumberLength;\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\n      peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\n      try {\n        result \u003d Integer.parseInt(peekedString);\n        peeked \u003d PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked \u003d PEEKED_BUFFERED;\n    double asDouble \u003d Double.parseDouble(peekedString); // don\u0027t catch this NumberFormatException.\n    result \u003d (int) asDouble;\n    if (result !\u003d asDouble) { // Make sure no precision was lost casting to \u0027int\u0027.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString \u003d null;\n    peeked \u003d PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
    "begin_line": 1161,
    "end_line": 1208,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,consuming it. If the next token is a string, this method will attempt to parse it as an int. If the next token\u0027s numeric value cannot be exactly represented by a Java  {@code int}, this method throws.\n * @throws IllegalStateException if the next token is not a literal value.\n * @throws NumberFormatException if the next literal value cannot be parsedas a number, or exactly represented as an int.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.close#1213",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.close()",
    "snippet": "public void close() throws IOException {\n    peeked \u003d PEEKED_NONE;\n    stack[0] \u003d JsonScope.CLOSED;\n    stackSize \u003d 1;\n    in.close();\n  }",
    "begin_line": 1213,
    "end_line": 1218,
    "comment": "/** \n * Closes this JSON reader and the underlying  {@link java.io.Reader}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipValue#1225",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipValue()",
    "snippet": "public void skipValue() throws IOException {\n    int count \u003d 0;\n    do {\n      int p \u003d peeked;\n      if (p \u003d\u003d PEEKED_NONE) {\n        p \u003d doPeek();\n      }\n\n      if (p \u003d\u003d PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p \u003d\u003d PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p \u003d\u003d PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p \u003d\u003d PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p \u003d\u003d PEEKED_UNQUOTED_NAME || p \u003d\u003d PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue(\u0027\\\u0027\u0027);\n      } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue(\u0027\"\u0027);\n      } else if (p \u003d\u003d PEEKED_NUMBER) {\n        pos +\u003d peekedNumberLength;\n      }\n      peeked \u003d PEEKED_NONE;\n    } while (count !\u003d 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] \u003d \"null\";\n  }",
    "begin_line": 1225,
    "end_line": 1259,
    "comment": "/** \n * Skips the next value recursively. If it is an object or array, all nested elements are skipped. This method is intended for use when the JSON token stream contains unrecognized or unhandled values.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.push#1261",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.push(int)",
    "snippet": "private void push(int newTop) {\n    if (stackSize \u003d\u003d stack.length) {\n      int[] newStack \u003d new int[stackSize * 2];\n      int[] newPathIndices \u003d new int[stackSize * 2];\n      String[] newPathNames \u003d new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack \u003d newStack;\n      pathIndices \u003d newPathIndices;\n      pathNames \u003d newPathNames;\n    }\n    stack[stackSize++] \u003d newTop;\n  }",
    "begin_line": 1261,
    "end_line": 1274,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.fillBuffer#1281",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.fillBuffer(int)",
    "snippet": "private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer \u003d this.buffer;\n    lineStart -\u003d pos;\n    if (limit !\u003d pos) {\n      limit -\u003d pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit \u003d 0;\n    }\n\n    pos \u003d 0;\n    int total;\n    while ((total \u003d in.read(buffer, limit, buffer.length - limit)) !\u003d -1) {\n      limit +\u003d total;\n\n      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n      if (lineNumber \u003d\u003d 0 \u0026\u0026 lineStart \u003d\u003d 0 \u0026\u0026 limit \u003e 0 \u0026\u0026 buffer[0] \u003d\u003d \u0027\\ufeff\u0027) {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit \u003e\u003d minimum) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "begin_line": 1281,
    "end_line": 1308,
    "comment": "/** \n * Returns true once  {@code limit - pos \u003e\u003d minimum}. If the data is exhausted before that many characters are available, this returns false.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.getLineNumber#1310",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.getLineNumber()",
    "snippet": "int getLineNumber() {\n    return lineNumber + 1;\n  }",
    "begin_line": 1310,
    "end_line": 1312,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.getColumnNumber#1314",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.getColumnNumber()",
    "snippet": "int getColumnNumber() {\n    return pos - lineStart + 1;\n  }",
    "begin_line": 1314,
    "end_line": 1316,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextNonWhitespace#1324",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextNonWhitespace(boolean)",
    "snippet": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    /*\n     * This code uses ugly local variables \u0027p\u0027 and \u0027l\u0027 representing the \u0027pos\u0027\n     * and \u0027limit\u0027 fields respectively. Using locals rather than fields saves\n     * a few field reads for each whitespace character in a pretty-printed\n     * document, resulting in a 5% speedup. We need to flush \u0027p\u0027 to its field\n     * before any (potentially indirect) call to fillBuffer() and reread both\n     * \u0027p\u0027 and \u0027l\u0027 after any (potentially indirect) call to the same method.\n     */\n    char[] buffer \u003d this.buffer;\n    int p \u003d pos;\n    int l \u003d limit;\n    while (true) {\n      if (p \u003d\u003d l) {\n        pos \u003d p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p \u003d pos;\n        l \u003d limit;\n      }\n\n      int c \u003d buffer[p++];\n      if (c \u003d\u003d \u0027\\n\u0027) {\n        lineNumber++;\n        lineStart \u003d p;\n        continue;\n      } else if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\t\u0027) {\n        continue;\n      }\n\n      if (c \u003d\u003d \u0027/\u0027) {\n        pos \u003d p;\n        if (p \u003d\u003d l) {\n          pos--; // push back \u0027/\u0027 so it\u0027s still in the buffer when this method returns\n          boolean charsLoaded \u003d fillBuffer(2);\n          pos++; // consume the \u0027/\u0027 again\n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek \u003d buffer[pos];\n        switch (peek) {\n        case \u0027*\u0027:\n          // skip a /* c-style comment */\n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p \u003d pos + 2;\n          l \u003d limit;\n          continue;\n\n        case \u0027/\u0027:\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          p \u003d pos;\n          l \u003d limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c \u003d\u003d \u0027#\u0027) {\n        pos \u003d p;\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn\u0027t\n         * specify this behaviour, but it\u0027s required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        p \u003d pos;\n        l \u003d limit;\n      } else {\n        pos \u003d p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\"\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    } else {\n      return -1;\n    }\n  }",
    "begin_line": 1324,
    "end_line": 1412,
    "comment": "/** \n * Returns the next character in the stream that is neither whitespace nor a part of a comment. When this returns, the returned character is always at {@code buffer[pos-1]}; this means the caller can always push back the returned character by decrementing  {@code pos}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.checkLenient#1414",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.checkLenient()",
    "snippet": "private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }",
    "begin_line": 1414,
    "end_line": 1418,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipToEndOfLine#1425",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipToEndOfLine()",
    "snippet": "private void skipToEndOfLine() throws IOException {\n    while (pos \u003c limit || fillBuffer(1)) {\n      char c \u003d buffer[pos++];\n      if (c \u003d\u003d \u0027\\n\u0027) {\n        lineNumber++;\n        lineStart \u003d pos;\n        break;\n      } else if (c \u003d\u003d \u0027\\r\u0027) {\n        break;\n      }\n    }\n  }",
    "begin_line": 1425,
    "end_line": 1436,
    "comment": "/** \n * Advances the position until after the next newline character. If the line is terminated by \"\\r\\n\", the \u0027\\n\u0027 must be consumed as whitespace by the caller.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipTo#1441",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipTo(java.lang.String)",
    "snippet": "private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() \u003c\u003d limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] \u003d\u003d \u0027\\n\u0027) {\n        lineNumber++;\n        lineStart \u003d pos + 1;\n        continue;\n      }\n      for (int c \u003d 0; c \u003c toFind.length(); c++) {\n        if (buffer[pos + c] !\u003d toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
    "begin_line": 1441,
    "end_line": 1457,
    "comment": "/** \n * @param toFind a string to search for. Must not contain a newline.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.toString#1459",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.toString()",
    "snippet": "@Override public String toString() {\n    return getClass().getSimpleName()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber();\n  }",
    "begin_line": 1459,
    "end_line": 1462,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.getPath#1468",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.getPath()",
    "snippet": "public String getPath() {\n    StringBuilder result \u003d new StringBuilder().append(\u0027$\u0027);\n    for (int i \u003d 0, size \u003d stackSize; i \u003c size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append(\u0027[\u0027).append(pathIndices[i]).append(\u0027]\u0027);\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append(\u0027.\u0027);\n          if (pathNames[i] !\u003d null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }",
    "begin_line": 1468,
    "end_line": 1493,
    "comment": "/** \n * Returns a \u003ca href\u003d\"http://goessner.net/articles/JsonPath/\"\u003eJsonPath\u003c/a\u003e to the current location in the JSON value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.readEscapeCharacter#1504",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.readEscapeCharacter()",
    "snippet": "private char readEscapeCharacter() throws IOException {\n    if (pos \u003d\u003d limit \u0026\u0026 !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped \u003d buffer[pos++];\n    switch (escaped) {\n    case \u0027u\u0027:\n      if (pos + 4 \u003e limit \u0026\u0026 !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n      char result \u003d 0;\n      for (int i \u003d pos, end \u003d i + 4; i \u003c end; i++) {\n        char c \u003d buffer[i];\n        result \u003c\u003c\u003d 4;\n        if (c \u003e\u003d \u00270\u0027 \u0026\u0026 c \u003c\u003d \u00279\u0027) {\n          result +\u003d (c - \u00270\u0027);\n        } else if (c \u003e\u003d \u0027a\u0027 \u0026\u0026 c \u003c\u003d \u0027f\u0027) {\n          result +\u003d (c - \u0027a\u0027 + 10);\n        } else if (c \u003e\u003d \u0027A\u0027 \u0026\u0026 c \u003c\u003d \u0027F\u0027) {\n          result +\u003d (c - \u0027A\u0027 + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos +\u003d 4;\n      return result;\n\n    case \u0027t\u0027:\n      return \u0027\\t\u0027;\n\n    case \u0027b\u0027:\n      return \u0027\\b\u0027;\n\n    case \u0027n\u0027:\n      return \u0027\\n\u0027;\n\n    case \u0027r\u0027:\n      return \u0027\\r\u0027;\n\n    case \u0027f\u0027:\n      return \u0027\\f\u0027;\n\n    case \u0027\\n\u0027:\n      lineNumber++;\n      lineStart \u003d pos;\n      // fall-through\n\n    case \u0027\\\u0027\u0027:\n    case \u0027\"\u0027:\n    case \u0027\\\\\u0027:\n    default:\n      return escaped;\n    }\n  }",
    "begin_line": 1504,
    "end_line": 1559,
    "comment": "/** \n * Unescapes the character identified by the character or characters that immediately follow a backslash. The backslash \u0027\\\u0027 should have already been read. This supports both unicode escapes \"u000A\" and two-character escapes \"\\n\".\n * @throws NumberFormatException if any unicode escape sequences aremalformed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.syntaxError#1565",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.syntaxError(java.lang.String)",
    "snippet": "private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }",
    "begin_line": 1565,
    "end_line": 1568,
    "comment": "/** \n * Throws a new IO exception with the given message and a context snippet with this reader\u0027s content.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.consumeNonExecutePrefix#1573",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.consumeNonExecutePrefix()",
    "snippet": "private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length \u003e limit \u0026\u0026 !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i \u003d 0; i \u003c NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] !\u003d NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n\n    // we consumed a security token!\n    pos +\u003d NON_EXECUTE_PREFIX.length;\n  }",
    "begin_line": 1573,
    "end_line": 1590,
    "comment": "/** \n * Consumes the non-execute prefix if it exists.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.promoteNameToValue#1594",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.promoteNameToValue(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p \u003d reader.peeked;\n        if (p \u003d\u003d PEEKED_NONE) {\n          p \u003d reader.doPeek();\n        }\n        if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked \u003d PEEKED_DOUBLE_QUOTED;\n        } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked \u003d PEEKED_SINGLE_QUOTED;\n        } else if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\n          reader.peeked \u003d PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n              + \" path \" + reader.getPath());\n        }\n      }",
    "begin_line": 1594,
    "end_line": 1614,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.JsonWriter#197",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.JsonWriter(java.io.Writer)",
    "snippet": "public JsonWriter(Writer out) {\n    if (out \u003d\u003d null) {\n      throw new NullPointerException(\"out \u003d\u003d null\");\n    }\n    this.out \u003d out;\n  }",
    "begin_line": 197,
    "end_line": 202,
    "comment": "/** \n * Creates a new instance that writes a JSON-encoded stream to  {@code out}. For best performance, ensure  {@link Writer} is buffered; wrapping in{@link java.io.BufferedWriter BufferedWriter} if necessary.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.setIndent#212",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.setIndent(java.lang.String)",
    "snippet": "public final void setIndent(String indent) {\n    if (indent.length() \u003d\u003d 0) {\n      this.indent \u003d null;\n      this.separator \u003d \":\";\n    } else {\n      this.indent \u003d indent;\n      this.separator \u003d \": \";\n    }\n  }",
    "begin_line": 212,
    "end_line": 220,
    "comment": "/** \n * Sets the indentation string to be repeated for each level of indentation in the encoded document. If  {@code indent.isEmpty()} the encoded documentwill be compact. Otherwise the encoded document will be more human-readable.\n * @param indent a string containing only whitespace.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.setLenient#234",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.setLenient(boolean)",
    "snippet": "public final void setLenient(boolean lenient) {\n    this.lenient \u003d lenient;\n  }",
    "begin_line": 234,
    "end_line": 236,
    "comment": "/** \n * Configure this writer to relax its syntax rules. By default, this writer only emits well-formed JSON as specified by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc7159.txt\"\u003eRFC 7159\u003c/a\u003e. Setting the writer to lenient permits the following: \u003cul\u003e \u003cli\u003eTop-level values of any type. With strict writing, the top-level value must be an object or an array. \u003cli\u003eNumbers may be  {@link Double#isNaN() NaNs} or {@link Double#isInfinite() infinities}. \u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.isLenient#241",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.isLenient()",
    "snippet": "public boolean isLenient() {\n    return lenient;\n  }",
    "begin_line": 241,
    "end_line": 243,
    "comment": "/** \n * Returns true if this writer has relaxed syntax rules.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.setHtmlSafe#252",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.setHtmlSafe(boolean)",
    "snippet": "public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe \u003d htmlSafe;\n  }",
    "begin_line": 252,
    "end_line": 254,
    "comment": "/** \n * Configure this writer to emit JSON that\u0027s safe for direct inclusion in HTML and XML documents. This escapes the HTML characters  {@code \u003c},  {@code \u003e}, {@code \u0026} and {@code \u003d} before writing them to the stream. Without thissetting, your XML/HTML encoder should replace these characters with the corresponding escape sequences.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.isHtmlSafe#260",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.isHtmlSafe()",
    "snippet": "public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }",
    "begin_line": 260,
    "end_line": 262,
    "comment": "/** \n * Returns true if this writer writes JSON that\u0027s safe for inclusion in HTML and XML documents.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.setSerializeNulls#268",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.setSerializeNulls(boolean)",
    "snippet": "public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls \u003d serializeNulls;\n  }",
    "begin_line": 268,
    "end_line": 270,
    "comment": "/** \n * Sets whether object members are serialized when their value is null. This has no impact on array elements. The default is true.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.getSerializeNulls#276",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.getSerializeNulls()",
    "snippet": "public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }",
    "begin_line": 276,
    "end_line": 278,
    "comment": "/** \n * Returns true if object members are serialized when their value is null. This has no impact on array elements. The default is true.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.beginArray#286",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.beginArray()",
    "snippet": "public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }",
    "begin_line": 286,
    "end_line": 289,
    "comment": "/** \n * Begins encoding a new array. Each call to this method must be paired with a call to  {@link #endArray}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.endArray#296",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.endArray()",
    "snippet": "public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }",
    "begin_line": 296,
    "end_line": 298,
    "comment": "/** \n * Ends encoding the current array.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.beginObject#306",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.beginObject()",
    "snippet": "public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }",
    "begin_line": 306,
    "end_line": 309,
    "comment": "/** \n * Begins encoding a new object. Each call to this method must be paired with a call to  {@link #endObject}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.endObject#316",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.endObject()",
    "snippet": "public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }",
    "begin_line": 316,
    "end_line": 318,
    "comment": "/** \n * Ends encoding the current object.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.open#324",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.open(int, java.lang.String)",
    "snippet": "private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }",
    "begin_line": 324,
    "end_line": 329,
    "comment": "/** \n * Enters a new scope by appending any necessary whitespace and the given bracket.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.close#335",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.close(int, int, java.lang.String)",
    "snippet": "private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context \u003d peek();\n    if (context !\u003d nonempty \u0026\u0026 context !\u003d empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName !\u003d null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context \u003d\u003d nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }",
    "begin_line": 335,
    "end_line": 351,
    "comment": "/** \n * Closes the current scope by appending any necessary whitespace and the given bracket.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.push#353",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.push(int)",
    "snippet": "private void push(int newTop) {\n    if (stackSize \u003d\u003d stack.length) {\n      int[] newStack \u003d new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack \u003d newStack;\n    }\n    stack[stackSize++] \u003d newTop;\n  }",
    "begin_line": 353,
    "end_line": 360,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.peek#365",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.peek()",
    "snippet": "private int peek() {\n    if (stackSize \u003d\u003d 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }",
    "begin_line": 365,
    "end_line": 370,
    "comment": "/** \n * Returns the value on the top of the stack.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.replaceTop#375",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.replaceTop(int)",
    "snippet": "private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] \u003d topOfStack;\n  }",
    "begin_line": 375,
    "end_line": 377,
    "comment": "/** \n * Replace the value on the top of the stack with the given value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.name#385",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.name(java.lang.String)",
    "snippet": "public JsonWriter name(String name) throws IOException {\n    if (name \u003d\u003d null) {\n      throw new NullPointerException(\"name \u003d\u003d null\");\n    }\n    if (deferredName !\u003d null) {\n      throw new IllegalStateException();\n    }\n    if (stackSize \u003d\u003d 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName \u003d name;\n    return this;\n  }",
    "begin_line": 385,
    "end_line": 397,
    "comment": "/** \n * Encodes the property name.\n * @param name the name of the forthcoming value. May not be null.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.writeDeferredName#399",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.writeDeferredName()",
    "snippet": "private void writeDeferredName() throws IOException {\n    if (deferredName !\u003d null) {\n      beforeName();\n      string(deferredName);\n      deferredName \u003d null;\n    }\n  }",
    "begin_line": 399,
    "end_line": 405,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#413",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(java.lang.String)",
    "snippet": "public JsonWriter value(String value) throws IOException {\n    if (value \u003d\u003d null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }",
    "begin_line": 413,
    "end_line": 421,
    "comment": "/** \n * Encodes  {@code value}.\n * @param value the literal string value, or null to encode a null literal.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.jsonValue#430",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.jsonValue(java.lang.String)",
    "snippet": "public JsonWriter jsonValue(String value) throws IOException {\n    if (value \u003d\u003d null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(value);\n    return this;\n  }",
    "begin_line": 430,
    "end_line": 438,
    "comment": "/** \n * Writes  {@code value} directly to the writer without quoting orescaping.\n * @param value the literal string value, or null to encode a null literal.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.nullValue#445",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.nullValue()",
    "snippet": "public JsonWriter nullValue() throws IOException {\n    if (deferredName !\u003d null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName \u003d null;\n        return this; // skip the name and the value\n      }\n    }\n    beforeValue();\n    out.write(\"null\");\n    return this;\n  }",
    "begin_line": 445,
    "end_line": 457,
    "comment": "/** \n * Encodes  {@code null}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#464",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(boolean)",
    "snippet": "public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }",
    "begin_line": 464,
    "end_line": 469,
    "comment": "/** \n * Encodes  {@code value}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#478",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(double)",
    "snippet": "public JsonWriter value(double value) throws IOException {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }",
    "begin_line": 478,
    "end_line": 486,
    "comment": "/** \n * Encodes  {@code value}.\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or{@link Double#isInfinite() infinities}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#493",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(long)",
    "snippet": "public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }",
    "begin_line": 493,
    "end_line": 498,
    "comment": "/** \n * Encodes  {@code value}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#507",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(java.lang.Number)",
    "snippet": "public JsonWriter value(Number value) throws IOException {\n    if (value \u003d\u003d null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string \u003d value.toString();\n    if (!lenient\n        \u0026\u0026 (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }",
    "begin_line": 507,
    "end_line": 521,
    "comment": "/** \n * Encodes  {@code value}.\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or{@link Double#isInfinite() infinities}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.flush#527",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.flush()",
    "snippet": "public void flush() throws IOException {\n    if (stackSize \u003d\u003d 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    out.flush();\n  }",
    "begin_line": 527,
    "end_line": 532,
    "comment": "/** \n * Ensures all buffered data is written to the underlying  {@link Writer}and flushes that writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.close#539",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.close()",
    "snippet": "public void close() throws IOException {\n    out.close();\n\n    int size \u003d stackSize;\n    if (size \u003e 1 || size \u003d\u003d 1 \u0026\u0026 stack[size - 1] !\u003d NONEMPTY_DOCUMENT) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stackSize \u003d 0;\n  }",
    "begin_line": 539,
    "end_line": 547,
    "comment": "/** \n * Flushes and closes this writer and the underlying  {@link Writer}.\n * @throws IOException if the JSON document is incomplete.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.string#549",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.string(java.lang.String)",
    "snippet": "private void string(String value) throws IOException {\n    String[] replacements \u003d htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n    out.write(\"\\\"\");\n    int last \u003d 0;\n    int length \u003d value.length();\n    for (int i \u003d 0; i \u003c length; i++) {\n      char c \u003d value.charAt(i);\n      String replacement;\n      if (c \u003c 128) {\n        replacement \u003d replacements[c];\n        if (replacement \u003d\u003d null) {\n          continue;\n        }\n      } else if (c \u003d\u003d \u0027\\u2028\u0027) {\n        replacement \u003d \"\\\\u2028\";\n      } else if (c \u003d\u003d \u0027\\u2029\u0027) {\n        replacement \u003d \"\\\\u2029\";\n      } else {\n        continue;\n      }\n      if (last \u003c i) {\n        out.write(value, last, i - last);\n      }\n      out.write(replacement);\n      last \u003d i + 1;\n    }\n    if (last \u003c length) {\n      out.write(value, last, length - last);\n    }\n    out.write(\"\\\"\");\n  }",
    "begin_line": 549,
    "end_line": 579,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.newline#581",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.newline()",
    "snippet": "private void newline() throws IOException {\n    if (indent \u003d\u003d null) {\n      return;\n    }\n\n    out.write(\"\\n\");\n    for (int i \u003d 1, size \u003d stackSize; i \u003c size; i++) {\n      out.write(indent);\n    }\n  }",
    "begin_line": 581,
    "end_line": 590,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.beforeName#596",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.beforeName()",
    "snippet": "private void beforeName() throws IOException {\n    int context \u003d peek();\n    if (context \u003d\u003d NONEMPTY_OBJECT) { // first in object\n      out.write(\u0027,\u0027);\n    } else if (context !\u003d EMPTY_OBJECT) { // not in an object!\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    newline();\n    replaceTop(DANGLING_NAME);\n  }",
    "begin_line": 596,
    "end_line": 605,
    "comment": "/** \n * Inserts any necessary separators and whitespace before a name. Also adjusts the stack to expect the name\u0027s value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.beforeValue#613",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.beforeValue()",
    "snippet": "@SuppressWarnings(\"fallthrough\")\n  private void beforeValue() throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(\u0027,\u0027);\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }",
    "begin_line": 613,
    "end_line": 643,
    "comment": "/** \n * Inserts any necessary separators and whitespace before a literal value, inline array, or inline object. Also adjusts the stack to expect either a closing bracket or another element.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]