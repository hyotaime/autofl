[
  {
    "name": "IntervalsSet.IntervalsSet#36",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet()",
    "snippet": "public IntervalsSet() {\n        super();\n    }",
    "begin_line": 36,
    "end_line": 38,
    "comment": "/** \n * Build an intervals set representing the whole real line.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.IntervalsSet#46",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(double, double)",
    "snippet": "public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }",
    "begin_line": 46,
    "end_line": 48,
    "comment": "/** \n * Build an intervals set corresponding to a single interval.\n * @param lower lower bound of the interval, must be lesser or equalto  {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n * @param upper upper bound of the interval, must be greater or equalto  {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.IntervalsSet#59",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(org.apache.commons.math3.geometry.partitioning.BSPTree\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public IntervalsSet(final BSPTree\u003cEuclidean1D\u003e tree) {\n        super(tree);\n    }",
    "begin_line": 59,
    "end_line": 61,
    "comment": "/** \n * Build an intervals set from an inside/outside BSP tree. \u003cp\u003eThe leaf nodes of the BSP tree \u003cem\u003emust\u003c/em\u003e have a {@code Boolean} attribute representing the inside status ofthe corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants {@code Boolean.TRUE} and {@code Boolean.FALSE}\u003c/p\u003e\n * @param tree inside/outside BSP tree representing the intervals set\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.IntervalsSet#82",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(java.util.Collection\u003corg.apache.commons.math3.geometry.partitioning.SubHyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e\u003e)",
    "snippet": "public IntervalsSet(final Collection\u003cSubHyperplane\u003cEuclidean1D\u003e\u003e boundary) {\n        super(boundary);\n    }",
    "begin_line": 82,
    "end_line": 84,
    "comment": "/** \n * Build an intervals set from a Boundary REPresentation (B-rep). \u003cp\u003eThe boundary is provided as a collection of  {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side.\u003c/p\u003e \u003cp\u003eThe boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the  {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector) checkPoint} method will not be meaningful anymore.\u003c/p\u003e\u003cp\u003eIf the boundary is empty, the region will represent the whole space.\u003c/p\u003e\n * @param boundary collection of boundary elements\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.buildTree#93",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.buildTree(double, double)",
    "snippet": "private static BSPTree\u003cEuclidean1D\u003e buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) \u0026\u0026 (lower \u003c 0)) {\n            if (Double.isInfinite(upper) \u0026\u0026 (upper \u003e 0)) {\n                // the tree must cover the whole real line\n                return new BSPTree\u003cEuclidean1D\u003e(Boolean.TRUE);\n            }\n            // the tree must be open on the negative infinity side\n            final SubHyperplane\u003cEuclidean1D\u003e upperCut \u003d\n                new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree\u003cEuclidean1D\u003e(upperCut,\n                               new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),\n                               new BSPTree\u003cEuclidean1D\u003e(Boolean.TRUE),\n                               null);\n        }\n        final SubHyperplane\u003cEuclidean1D\u003e lowerCut \u003d\n            new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n        if (Double.isInfinite(upper) \u0026\u0026 (upper \u003e 0)) {\n            // the tree must be open on the positive infinity side\n            return new BSPTree\u003cEuclidean1D\u003e(lowerCut,\n                                            new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),\n                                            new BSPTree\u003cEuclidean1D\u003e(Boolean.TRUE),\n                                            null);\n        }\n\n        // the tree must be bounded on the two sides\n        final SubHyperplane\u003cEuclidean1D\u003e upperCut \u003d\n            new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n        return new BSPTree\u003cEuclidean1D\u003e(lowerCut,\n                                        new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),\n                                        new BSPTree\u003cEuclidean1D\u003e(upperCut,\n                                                                 new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),\n                                                                 new BSPTree\u003cEuclidean1D\u003e(Boolean.TRUE),\n                                                                 null),\n                                        null);\n\n    }",
    "begin_line": 93,
    "end_line": 128,
    "comment": "/** \n * Build an inside/outside tree representing a single interval.\n * @param lower lower bound of the interval, must be lesser or equalto  {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n * @param upper upper bound of the interval, must be greater or equalto  {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n * @return the built tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.buildNew#132",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.buildNew(org.apache.commons.math3.geometry.partitioning.BSPTree\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override\n    public IntervalsSet buildNew(final BSPTree\u003cEuclidean1D\u003e tree) {\n        return new IntervalsSet(tree);\n    }",
    "begin_line": 132,
    "end_line": 134,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.computeGeometricalProperties#138",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.computeGeometricalProperties()",
    "snippet": "@Override\n    protected void computeGeometricalProperties() {\n        if (getTree(false).getCut() \u003d\u003d null) {\n            setBarycenter(Vector1D.NaN);\n            setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n        } else {\n            double size \u003d 0.0;\n            double sum \u003d 0.0;\n            for (final Interval interval : asList()) {\n                size +\u003d interval.getSize();\n                sum  +\u003d interval.getSize() * interval.getBarycenter();\n            }\n            setSize(size);\n            if (Double.isInfinite(size)) {\n                setBarycenter(Vector1D.NaN);\n            } else if (size \u003e\u003d Precision.SAFE_MIN) {\n                setBarycenter(new Vector1D(sum / size));\n            } else {\n                setBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n            }\n        }\n    }",
    "begin_line": 138,
    "end_line": 158,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.getInf#166",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.getInf()",
    "snippet": "public double getInf() {\n        BSPTree\u003cEuclidean1D\u003e node \u003d getTree(false);\n        double  inf  \u003d Double.POSITIVE_INFINITY;\n        while (node.getCut() !\u003d null) {\n            final OrientedPoint op \u003d (OrientedPoint) node.getCut().getHyperplane();\n            inf  \u003d op.getLocation().getX();\n            node \u003d op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
    "begin_line": 166,
    "end_line": 175,
    "comment": "/** \n * Get the lowest value belonging to the instance.\n * @return lowest value belonging to the instance( {@code Double.NEGATIVE_INFINITY} if the instance doesn\u0027thave any low bound,  {@code Double.POSITIVE_INFINITY} if theinstance is empty)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.getSup#183",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.getSup()",
    "snippet": "public double getSup() {\n        BSPTree\u003cEuclidean1D\u003e node \u003d getTree(false);\n        double  sup  \u003d Double.NEGATIVE_INFINITY;\n        while (node.getCut() !\u003d null) {\n            final OrientedPoint op \u003d (OrientedPoint) node.getCut().getHyperplane();\n            sup  \u003d op.getLocation().getX();\n            node \u003d op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
    "begin_line": 183,
    "end_line": 192,
    "comment": "/** \n * Get the highest value belonging to the instance.\n * @return highest value belonging to the instance( {@code Double.POSITIVE_INFINITY} if the instance doesn\u0027thave any high bound,  {@code Double.NEGATIVE_INFINITY} if theinstance is empty)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.asList#207",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.asList()",
    "snippet": "public List\u003cInterval\u003e asList() {\n        final List\u003cInterval\u003e list \u003d new ArrayList\u003cInterval\u003e();\n        recurseList(getTree(false), list,\n                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n        return list;\n    }",
    "begin_line": 207,
    "end_line": 212,
    "comment": "/** \n * Build an ordered list of intervals representing the instance. \u003cp\u003eThis method builds this intervals set as an ordered list of {@link Interval Interval} elements. If the intervals set has nolower limit, the first interval will have its low bound equal to {@code Double.NEGATIVE_INFINITY}. If the intervals set has no upper limit, the last interval will have its upper bound equal to  {@code Double.POSITIVE_INFINITY}. An empty tree will build an empty list while a tree representing the whole real line will build a one element list with both bounds beeing infinite.\u003c/p\u003e\n * @return a new ordered list containing {@link Interval Interval}elements\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.recurseList#220",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.recurseList(org.apache.commons.math3.geometry.partitioning.BSPTree\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e, java.util.List\u003corg.apache.commons.math3.geometry.euclidean.oned.Interval\u003e, double, double)",
    "snippet": "private void recurseList(final BSPTree\u003cEuclidean1D\u003e node,\n                             final List\u003cInterval\u003e list,\n                             final double lower, final double upper) {\n\n        if (node.getCut() \u003d\u003d null) {\n            if ((Boolean) node.getAttribute()) {\n                // this leaf cell is an inside cell: an interval\n                list.add(new Interval(lower, upper));\n            }\n        } else {\n            final OrientedPoint op  \u003d (OrientedPoint) node.getCut().getHyperplane();\n            final Vector1D       loc \u003d op.getLocation();\n            double              x   \u003d loc.getX();\n\n            // make sure we explore the tree in increasing order\n            final BSPTree\u003cEuclidean1D\u003e low  \u003d\n                op.isDirect() ? node.getMinus() : node.getPlus();\n            final BSPTree\u003cEuclidean1D\u003e high \u003d\n                op.isDirect() ? node.getPlus()  : node.getMinus();\n\n            recurseList(low, list, lower, x);\n            if ((checkPoint(low,  loc) \u003d\u003d Location.INSIDE) \u0026\u0026\n                (checkPoint(high, loc) \u003d\u003d Location.INSIDE)) {\n                // merge the last interval added and the first one of the high sub-tree\n                x \u003d list.remove(list.size() - 1).getInf();\n            }\n            recurseList(high, list, x, upper);\n\n        }\n\n    }",
    "begin_line": 220,
    "end_line": 250,
    "comment": "/** \n * Update an intervals list.\n * @param node current node\n * @param list list to update\n * @param lower lower bound of the current convex cell\n * @param upper upper bound of the current convex cell\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.OrientedPoint#42",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.OrientedPoint(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, boolean)",
    "snippet": "public OrientedPoint(final Vector1D location, final boolean direct) {\n        this.location \u003d location;\n        this.direct   \u003d direct;\n    }",
    "begin_line": 42,
    "end_line": 45,
    "comment": "/** \n * Simple constructor.\n * @param location location of the hyperplane\n * @param direct if true, the plus side of the hyperplane is towardsabscissas greater than  {@code location}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.copySelf#52",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.copySelf()",
    "snippet": "public OrientedPoint copySelf() {\n        return this;\n    }",
    "begin_line": 52,
    "end_line": 54,
    "comment": "/** \n * Copy the instance. \u003cp\u003eSince instances are immutable, this method directly returns the instance.\u003c/p\u003e\n * @return the instance itself\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.getOffset#57",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.getOffset(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double getOffset(final Vector\u003cEuclidean1D\u003e point) {\n        final double delta \u003d ((Vector1D) point).getX() - location.getX();\n        return direct ? delta : -delta;\n    }",
    "begin_line": 57,
    "end_line": 60,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.wholeHyperplane#73",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.wholeHyperplane()",
    "snippet": "public SubOrientedPoint wholeHyperplane() {\n        return new SubOrientedPoint(this, null);\n    }",
    "begin_line": 73,
    "end_line": 75,
    "comment": "/** \n * Build a region covering the whole hyperplane. \u003cp\u003eSince this class represent zero dimension spaces which does not have lower dimension sub-spaces, this method returns a dummy implementation of a  {@link org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane}. This implementation is only used to allow the  {@link org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane} class implementation to work properly, it should\u003cem\u003enot\u003c/em\u003e be used otherwise.\u003c/p\u003e\n * @return a dummy sub hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.wholeSpace#81",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.wholeSpace()",
    "snippet": "public IntervalsSet wholeSpace() {\n        return new IntervalsSet();\n    }",
    "begin_line": 81,
    "end_line": 83,
    "comment": "/** \n * Build a region covering the whole space.\n * @return a region containing the instance (really an {@link IntervalsSet IntervalsSet} instance)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.sameOrientationAs#86",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.sameOrientationAs(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public boolean sameOrientationAs(final Hyperplane\u003cEuclidean1D\u003e other) {\n        return !(direct ^ ((OrientedPoint) other).direct);\n    }",
    "begin_line": 86,
    "end_line": 88,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.getLocation#93",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.getLocation()",
    "snippet": "public Vector1D getLocation() {\n        return location;\n    }",
    "begin_line": 93,
    "end_line": 95,
    "comment": "/** \n * Get the hyperplane location on the real line.\n * @return the hyperplane location\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.isDirect#101",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.isDirect()",
    "snippet": "public boolean isDirect() {\n        return direct;\n    }",
    "begin_line": 101,
    "end_line": 103,
    "comment": "/** \n * Check if the hyperplane orientation is direct.\n * @return true if the plus side of the hyperplane is towardsabscissae greater than hyperplane location\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.revertSelf#107",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.revertSelf()",
    "snippet": "public void revertSelf() {\n        direct \u003d !direct;\n    }",
    "begin_line": 107,
    "end_line": 109,
    "comment": "/** \n * Revert the instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.SubOrientedPoint#37",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.SubOrientedPoint(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public SubOrientedPoint(final Hyperplane\u003cEuclidean1D\u003e hyperplane,\n                            final Region\u003cEuclidean1D\u003e remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }",
    "begin_line": 37,
    "end_line": 40,
    "comment": "/** \n * Simple constructor.\n * @param hyperplane underlying hyperplane\n * @param remainingRegion remaining region of the hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.getSize#44",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.getSize()",
    "snippet": "@Override\n    public double getSize() {\n        return 0;\n    }",
    "begin_line": 44,
    "end_line": 46,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.buildNew#50",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.buildNew(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override\n    protected AbstractSubHyperplane\u003cEuclidean1D, Euclidean1D\u003e buildNew(final Hyperplane\u003cEuclidean1D\u003e hyperplane,\n                                                                       final Region\u003cEuclidean1D\u003e remainingRegion) {\n        return new SubOrientedPoint(hyperplane, remainingRegion);\n    }",
    "begin_line": 50,
    "end_line": 53,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.side#57",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.side(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override\n    public Side side(final Hyperplane\u003cEuclidean1D\u003e hyperplane) {\n        final double global \u003d hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n        return (global \u003c -1.0e-10) ? Side.MINUS : ((global \u003e 1.0e-10) ? Side.PLUS : Side.HYPER);\n    }",
    "begin_line": 57,
    "end_line": 60,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.split#64",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.split(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override\n    public SplitSubHyperplane\u003cEuclidean1D\u003e split(final Hyperplane\u003cEuclidean1D\u003e hyperplane) {\n        final double global \u003d hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n        return (global \u003c -1.0e-10) ?\n                                    new SplitSubHyperplane\u003cEuclidean1D\u003e(null, this) :\n                                        new SplitSubHyperplane\u003cEuclidean1D\u003e(this, null);\n    }",
    "begin_line": 64,
    "end_line": 69,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#65",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double)",
    "snippet": "public Vector1D(double x) {\n        this.x \u003d x;\n    }",
    "begin_line": 65,
    "end_line": 67,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param x abscissa\n * @see #getX()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#75",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public Vector1D(double a, Vector1D u) {\n        this.x \u003d a * u.x;\n    }",
    "begin_line": 75,
    "end_line": 77,
    "comment": "/** \n * Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u\n * @param a scale factor\n * @param u base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#87",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public Vector1D(double a1, Vector1D u1, double a2, Vector1D u2) {\n        this.x \u003d a1 * u1.x + a2 * u2.x;\n    }",
    "begin_line": 87,
    "end_line": 89,
    "comment": "/** \n * Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#101",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public Vector1D(double a1, Vector1D u1, double a2, Vector1D u2,\n                   double a3, Vector1D u3) {\n        this.x \u003d a1 * u1.x + a2 * u2.x + a3 * u3.x;\n    }",
    "begin_line": 101,
    "end_line": 104,
    "comment": "/** \n * Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#118",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public Vector1D(double a1, Vector1D u1, double a2, Vector1D u2,\n                   double a3, Vector1D u3, double a4, Vector1D u4) {\n        this.x \u003d a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n    }",
    "begin_line": 118,
    "end_line": 121,
    "comment": "/** \n * Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n * @param a4 fourth scale factor\n * @param u4 fourth base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getX#127",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getX()",
    "snippet": "public double getX() {\n        return x;\n    }",
    "begin_line": 127,
    "end_line": 129,
    "comment": "/** \n * Get the abscissa of the vector.\n * @return abscissa of the vector\n * @see #Vector1D(double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getSpace#132",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getSpace()",
    "snippet": "public Space getSpace() {\n        return Euclidean1D.getInstance();\n    }",
    "begin_line": 132,
    "end_line": 134,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getZero#137",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getZero()",
    "snippet": "public Vector1D getZero() {\n        return ZERO;\n    }",
    "begin_line": 137,
    "end_line": 139,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getNorm1#142",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getNorm1()",
    "snippet": "public double getNorm1() {\n        return FastMath.abs(x);\n    }",
    "begin_line": 142,
    "end_line": 144,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getNorm#147",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getNorm()",
    "snippet": "public double getNorm() {\n        return FastMath.abs(x);\n    }",
    "begin_line": 147,
    "end_line": 149,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getNormSq#152",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getNormSq()",
    "snippet": "public double getNormSq() {\n        return x * x;\n    }",
    "begin_line": 152,
    "end_line": 154,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getNormInf#157",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getNormInf()",
    "snippet": "public double getNormInf() {\n        return FastMath.abs(x);\n    }",
    "begin_line": 157,
    "end_line": 159,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.add#162",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.add(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector1D add(Vector\u003cEuclidean1D\u003e v) {\n        Vector1D v1 \u003d (Vector1D) v;\n        return new Vector1D(x + v1.getX());\n    }",
    "begin_line": 162,
    "end_line": 165,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.add#168",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.add(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector1D add(double factor, Vector\u003cEuclidean1D\u003e v) {\n        Vector1D v1 \u003d (Vector1D) v;\n        return new Vector1D(x + factor * v1.getX());\n    }",
    "begin_line": 168,
    "end_line": 171,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.subtract#174",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.subtract(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector1D subtract(Vector\u003cEuclidean1D\u003e p) {\n        Vector1D p3 \u003d (Vector1D) p;\n        return new Vector1D(x - p3.x);\n    }",
    "begin_line": 174,
    "end_line": 177,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.subtract#180",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.subtract(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector1D subtract(double factor, Vector\u003cEuclidean1D\u003e v) {\n        Vector1D v1 \u003d (Vector1D) v;\n        return new Vector1D(x - factor * v1.getX());\n    }",
    "begin_line": 180,
    "end_line": 183,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.normalize#186",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.normalize()",
    "snippet": "public Vector1D normalize() throws MathArithmeticException {\n        double s \u003d getNorm();\n        if (s \u003d\u003d 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n        }\n        return scalarMultiply(1 / s);\n    }",
    "begin_line": 186,
    "end_line": 192,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.negate#194",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.negate()",
    "snippet": "public Vector1D negate() {\n        return new Vector1D(-x);\n    }",
    "begin_line": 194,
    "end_line": 196,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.scalarMultiply#199",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.scalarMultiply(double)",
    "snippet": "public Vector1D scalarMultiply(double a) {\n        return new Vector1D(a * x);\n    }",
    "begin_line": 199,
    "end_line": 201,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.isNaN#204",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.isNaN()",
    "snippet": "public boolean isNaN() {\n        return Double.isNaN(x);\n    }",
    "begin_line": 204,
    "end_line": 206,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.isInfinite#209",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.isInfinite()",
    "snippet": "public boolean isInfinite() {\n        return !isNaN() \u0026\u0026 Double.isInfinite(x);\n    }",
    "begin_line": 209,
    "end_line": 211,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distance1#214",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distance1(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double distance1(Vector\u003cEuclidean1D\u003e p) {\n        Vector1D p3 \u003d (Vector1D) p;\n        final double dx \u003d FastMath.abs(p3.x - x);\n        return dx;\n    }",
    "begin_line": 214,
    "end_line": 218,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distance#221",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distance(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double distance(Vector\u003cEuclidean1D\u003e p) {\n        Vector1D p3 \u003d (Vector1D) p;\n        final double dx \u003d p3.x - x;\n        return FastMath.abs(dx);\n    }",
    "begin_line": 221,
    "end_line": 225,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distanceInf#228",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distanceInf(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double distanceInf(Vector\u003cEuclidean1D\u003e p) {\n        Vector1D p3 \u003d (Vector1D) p;\n        final double dx \u003d FastMath.abs(p3.x - x);\n        return dx;\n    }",
    "begin_line": 228,
    "end_line": 232,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distanceSq#235",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distanceSq(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double distanceSq(Vector\u003cEuclidean1D\u003e p) {\n        Vector1D p3 \u003d (Vector1D) p;\n        final double dx \u003d p3.x - x;\n        return dx * dx;\n    }",
    "begin_line": 235,
    "end_line": 239,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.dotProduct#242",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.dotProduct(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double dotProduct(final Vector\u003cEuclidean1D\u003e v) {\n        final Vector1D v1 \u003d (Vector1D) v;\n        return x * v1.x;\n    }",
    "begin_line": 242,
    "end_line": 245,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distance#255",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distance(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public static double distance(Vector1D p1, Vector1D p2) {\n        return p1.distance(p2);\n    }",
    "begin_line": 255,
    "end_line": 257,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e2\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNorm()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L\u003csub\u003e2\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distanceInf#267",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distanceInf(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public static double distanceInf(Vector1D p1, Vector1D p2) {\n        return p1.distanceInf(p2);\n    }",
    "begin_line": 267,
    "end_line": 269,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNormInf()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distanceSq#279",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distanceSq(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public static double distanceSq(Vector1D p1, Vector1D p2) {\n        return p1.distanceSq(p2);\n    }",
    "begin_line": 279,
    "end_line": 281,
    "comment": "/** \n * Compute the square of the distance between two vectors. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNormSq()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.equals#303",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.equals(java.lang.Object)",
    "snippet": "@Override\n    public boolean equals(Object other) {\n\n        if (this \u003d\u003d other) {\n            return true;\n        }\n\n        if (other instanceof Vector1D) {\n            final Vector1D rhs \u003d (Vector1D)other;\n            if (rhs.isNaN()) {\n                return this.isNaN();\n            }\n\n            return x \u003d\u003d rhs.x;\n        }\n        return false;\n    }",
    "begin_line": 303,
    "end_line": 318,
    "comment": "/** \n * Test for the equality of two 1D vectors. \u003cp\u003e If all coordinates of two 1D vectors are exactly the same, and none are \u003ccode\u003eDouble.NaN\u003c/code\u003e, the two 1D vectors are considered to be equal. \u003c/p\u003e \u003cp\u003e \u003ccode\u003eNaN\u003c/code\u003e coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 1D vector are equal to \u003ccode\u003eDouble.NaN\u003c/code\u003e, the 1D vector is equal to {@link #NaN}. \u003c/p\u003e\n * @param other Object to test for equality to this\n * @return true if two 1D vector objects are equal, false ifobject is null, not an instance of Vector1D, or not equal to this Vector1D instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.hashCode#328",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.hashCode()",
    "snippet": "@Override\n    public int hashCode() {\n        if (isNaN()) {\n            return 7785;\n        }\n        return 997 * MathUtils.hash(x);\n    }",
    "begin_line": 328,
    "end_line": 333,
    "comment": "/** \n * Get a hashCode for the 1D vector. \u003cp\u003e All NaN values have the same hash code.\u003c/p\u003e\n * @return a hash code value for this object\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.toString#339",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.toString()",
    "snippet": "@Override\n    public String toString() {\n        return Vector1DFormat.getInstance().format(this);\n    }",
    "begin_line": 339,
    "end_line": 341,
    "comment": "/** \n * Get a string representation of this vector.\n * @return a string representation of this vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.toString#344",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.toString(java.text.NumberFormat)",
    "snippet": "public String toString(final NumberFormat format) {\n        return new Vector1DFormat(format).format(this);\n    }",
    "begin_line": 344,
    "end_line": 346,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#54",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.Line(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Line(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n        reset(p1, p2);\n    }",
    "begin_line": 54,
    "end_line": 56,
    "comment": "/** \n * Build a line from two points.\n * @param p1 first point belonging to the line (this can be any point)\n * @param p2 second point belonging to the line (this can be any point, different from p1)\n * @exception MathIllegalArgumentException if the points are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#63",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.Line(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public Line(final Line line) {\n        this.direction \u003d line.direction;\n        this.zero      \u003d line.zero;\n    }",
    "begin_line": 63,
    "end_line": 66,
    "comment": "/** \n * Copy constructor. \u003cp\u003eThe created instance is completely independent from the original instance, it is a deep copy.\u003c/p\u003e\n * @param line line to copy\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.reset#73",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.reset(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n        final Vector3D delta \u003d p2.subtract(p1);\n        final double norm2 \u003d delta.getNormSq();\n        if (norm2 \u003d\u003d 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n        }\n        this.direction \u003d new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n        zero \u003d new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n    }",
    "begin_line": 73,
    "end_line": 81,
    "comment": "/** \n * Reset the instance as if built from two points.\n * @param p1 first point belonging to the line (this can be any point)\n * @param p2 second point belonging to the line (this can be any point, different from p1)\n * @exception MathIllegalArgumentException if the points are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.revert#86",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.revert()",
    "snippet": "public Line revert() {\n        final Line reverted \u003d new Line(this);\n        reverted.direction \u003d reverted.direction.negate();\n        return reverted;\n    }",
    "begin_line": 86,
    "end_line": 90,
    "comment": "/** \n * Get a line with reversed direction.\n * @return a new instance, with reversed direction\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getDirection#95",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getDirection()",
    "snippet": "public Vector3D getDirection() {\n        return direction;\n    }",
    "begin_line": 95,
    "end_line": 97,
    "comment": "/** \n * Get the normalized direction vector.\n * @return normalized direction vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getOrigin#102",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getOrigin()",
    "snippet": "public Vector3D getOrigin() {\n        return zero;\n    }",
    "begin_line": 102,
    "end_line": 104,
    "comment": "/** \n * Get the line point closest to the origin.\n * @return line point closest to the origin\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getAbscissa#113",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getAbscissa(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public double getAbscissa(final Vector3D point) {\n        return point.subtract(zero).dotProduct(direction);\n    }",
    "begin_line": 113,
    "end_line": 115,
    "comment": "/** \n * Get the abscissa of a point with respect to the line. \u003cp\u003eThe abscissa is 0 if the projection of the point and the projection of the frame origin on the line are the same point.\u003c/p\u003e\n * @param point point to check\n * @return abscissa of the point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.pointAt#121",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.pointAt(double)",
    "snippet": "public Vector3D pointAt(final double abscissa) {\n        return new Vector3D(1.0, zero, abscissa, direction);\n    }",
    "begin_line": 121,
    "end_line": 123,
    "comment": "/** \n * Get one point from the line.\n * @param abscissa desired abscissa for the point\n * @return one point belonging to the line, at specified abscissa\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.toSubSpace#128",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSubSpace(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector1D toSubSpace(final Vector\u003cEuclidean3D\u003e point) {\n        return new Vector1D(getAbscissa((Vector3D) point));\n    }",
    "begin_line": 128,
    "end_line": 130,
    "comment": "/** \n * {@inheritDoc}\n * @see #getAbscissa(Vector3D)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.toSpace#135",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSpace(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector3D toSpace(final Vector\u003cEuclidean1D\u003e point) {\n        return pointAt(((Vector1D) point).getX());\n    }",
    "begin_line": 135,
    "end_line": 137,
    "comment": "/** \n * {@inheritDoc}\n * @see #pointAt(double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.isSimilarTo#146",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.isSimilarTo(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public boolean isSimilarTo(final Line line) {\n        final double angle \u003d Vector3D.angle(direction, line.direction);\n        return ((angle \u003c 1.0e-10) || (angle \u003e (FastMath.PI - 1.0e-10))) \u0026\u0026 contains(line.zero);\n    }",
    "begin_line": 146,
    "end_line": 149,
    "comment": "/** \n * Check if the instance is similar to another line. \u003cp\u003eLines are considered similar if they contain the same points. This does not mean they are equal since they can have opposite directions.\u003c/p\u003e\n * @param line line to which instance should be compared\n * @return true if the lines are similar\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.contains#155",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.contains(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public boolean contains(final Vector3D p) {\n        return distance(p) \u003c 1.0e-10;\n    }",
    "begin_line": 155,
    "end_line": 157,
    "comment": "/** \n * Check if the instance contains a point.\n * @param p point to check\n * @return true if p belongs to the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.distance#163",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.distance(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public double distance(final Vector3D p) {\n        final Vector3D d \u003d p.subtract(zero);\n        final Vector3D n \u003d new Vector3D(1.0, d, -d.dotProduct(direction), direction);\n        return n.getNorm();\n    }",
    "begin_line": 163,
    "end_line": 167,
    "comment": "/** \n * Compute the distance between the instance and a point.\n * @param p to check\n * @return distance between the instance and the point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.distance#173",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.distance(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public double distance(final Line line) {\n\n        final Vector3D normal \u003d Vector3D.crossProduct(direction, line.direction);\n        final double n \u003d normal.getNorm();\n        if (n \u003c Precision.SAFE_MIN) {\n            // lines are parallel\n            return distance(line.zero);\n        }\n\n        // signed separation of the two parallel planes that contains the lines\n        final double offset \u003d line.zero.subtract(zero).dotProduct(normal) / n;\n\n        return FastMath.abs(offset);\n\n    }",
    "begin_line": 173,
    "end_line": 187,
    "comment": "/** \n * Compute the shortest distance between the instance and another line.\n * @param line line to check against the instance\n * @return shortest distance between the instance and the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.closestPoint#193",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.closestPoint(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public Vector3D closestPoint(final Line line) {\n\n        final double cos \u003d direction.dotProduct(line.direction);\n        final double n \u003d 1 - cos * cos;\n        if (n \u003c Precision.EPSILON) {\n            // the lines are parallel\n            return zero;\n        }\n\n        final Vector3D delta0 \u003d line.zero.subtract(zero);\n        final double a        \u003d delta0.dotProduct(direction);\n        final double b        \u003d delta0.dotProduct(line.direction);\n\n        return new Vector3D(1, zero, (a - b * cos) / n, direction);\n\n    }",
    "begin_line": 193,
    "end_line": 208,
    "comment": "/** \n * Compute the point of the instance closest to another line.\n * @param line line to check against the instance\n * @return point of the instance closest to another line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.intersection#215",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.intersection(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public Vector3D intersection(final Line line) {\n        final Vector3D closest \u003d closestPoint(line);\n        return line.contains(closest) ? closest : null;\n    }",
    "begin_line": 215,
    "end_line": 218,
    "comment": "/** \n * Get the intersection point of the instance and another line.\n * @param line other line\n * @return intersection point of the instance and the other lineor null if there are no intersection points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.wholeLine#223",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.wholeLine()",
    "snippet": "public SubLine wholeLine() {\n        return new SubLine(this, new IntervalsSet());\n    }",
    "begin_line": 223,
    "end_line": 225,
    "comment": "/** \n * Build a sub-line covering the whole line.\n * @return a sub-line covering the whole line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#44",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.threed.Line, org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet)",
    "snippet": "public SubLine(final Line line, final IntervalsSet remainingRegion) {\n        this.line            \u003d line;\n        this.remainingRegion \u003d remainingRegion;\n    }",
    "begin_line": 44,
    "end_line": 47,
    "comment": "/** \n * Simple constructor.\n * @param line underlying line\n * @param remainingRegion remaining region of the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#54",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public SubLine(final Vector3D start, final Vector3D end)\n        throws MathIllegalArgumentException {\n        this(new Line(start, end), buildIntervalSet(start, end));\n    }",
    "begin_line": 54,
    "end_line": 57,
    "comment": "/** \n * Create a sub-line from two endpoints.\n * @param start start point\n * @param end end point\n * @exception MathIllegalArgumentException if the points are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#63",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.threed.Segment)",
    "snippet": "public SubLine(final Segment segment) throws MathIllegalArgumentException {\n        this(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));\n    }",
    "begin_line": 63,
    "end_line": 65,
    "comment": "/** \n * Create a sub-line from a segment.\n * @param segment single segment forming the sub-line\n * @exception MathIllegalArgumentException if the segment endpoints are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.getSegments#81",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.getSegments()",
    "snippet": "public List\u003cSegment\u003e getSegments() {\n\n        final List\u003cInterval\u003e list \u003d remainingRegion.asList();\n        final List\u003cSegment\u003e segments \u003d new ArrayList\u003cSegment\u003e();\n\n        for (final Interval interval : list) {\n            final Vector3D start \u003d line.toSpace(new Vector1D(interval.getInf()));\n            final Vector3D end   \u003d line.toSpace(new Vector1D(interval.getSup()));\n            segments.add(new Segment(start, end, line));\n        }\n\n        return segments;\n\n    }",
    "begin_line": 81,
    "end_line": 94,
    "comment": "/** \n * Get the endpoints of the sub-line. \u003cp\u003e A subline may be any arbitrary number of disjoints segments, so the endpoints are provided as a list of endpoint pairs. Each element of the list represents one segment, and each segment contains a start point at index 0 and an end point at index 1. If the sub-line is unbounded in the negative infinity direction, the start point of the first segment will have infinite coordinates. If the sub-line is unbounded in the positive infinity direction, the end point of the last segment will have infinite coordinates. So a sub-line covering the whole line will contain just one row and both elements of this row will have infinite coordinates. If the sub-line is empty, the returned list will contain 0 segments. \u003c/p\u003e\n * @return list of segments endpoints\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.intersection#110",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine, boolean)",
    "snippet": "public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // compute the intersection on infinite line\n        Vector3D v1D \u003d line.intersection(subLine.line);\n\n        // check location of point with respect to first sub-line\n        Location loc1 \u003d remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 \u003d subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n        if (includeEndPoints) {\n            return ((loc1 !\u003d Location.OUTSIDE) \u0026\u0026 (loc2 !\u003d Location.OUTSIDE)) ? v1D : null;\n        } else {\n            return ((loc1 \u003d\u003d Location.INSIDE) \u0026\u0026 (loc2 \u003d\u003d Location.INSIDE)) ? v1D : null;\n        }\n\n    }",
    "begin_line": 110,
    "end_line": 127,
    "comment": "/** \n * Get the intersection of the instance and another sub-line. \u003cp\u003e This method is related to the  {@link Line#intersection(Line) intersection} method in the {@link Line Line} class, but in additionto compute the point along infinite lines, it also checks the point lies on both sub-line ranges. \u003c/p\u003e\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong toinstance (i.e. they are closed sets) and may be returned, otherwise endpoints are considered to not belong to instance (i.e. they are open sets) and intersection occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don\u0027t intersect\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.buildIntervalSet#135",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.buildIntervalSet(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end)\n        throws MathIllegalArgumentException {\n        final Line line \u003d new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }",
    "begin_line": 135,
    "end_line": 140,
    "comment": "/** \n * Build an interval set from two points.\n * @param start start point\n * @param end end point\n * @return an interval set\n * @exception MathIllegalArgumentException if the points are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#95",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, double, double)",
    "snippet": "public Vector3D(double x, double y, double z) {\n        this.x \u003d x;\n        this.y \u003d y;\n        this.z \u003d z;\n    }",
    "begin_line": 95,
    "end_line": 99,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param x abscissa\n * @param y ordinate\n * @param z height\n * @see #getX()\n * @see #getY()\n * @see #getZ()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#107",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double[])",
    "snippet": "public Vector3D(double[] v) throws DimensionMismatchException {\n        if (v.length !\u003d 3) {\n            throw new DimensionMismatchException(v.length, 3);\n        }\n        this.x \u003d v[0];\n        this.y \u003d v[1];\n        this.z \u003d v[2];\n    }",
    "begin_line": 107,
    "end_line": 114,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param v coordinates array\n * @exception DimensionMismatchException if array does not have 3 elements\n * @see #toArray()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#124",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, double)",
    "snippet": "public Vector3D(double alpha, double delta) {\n        double cosDelta \u003d FastMath.cos(delta);\n        this.x \u003d FastMath.cos(alpha) * cosDelta;\n        this.y \u003d FastMath.sin(alpha) * cosDelta;\n        this.z \u003d FastMath.sin(delta);\n    }",
    "begin_line": 124,
    "end_line": 129,
    "comment": "/** \n * Simple constructor. Build a vector from its azimuthal coordinates\n * @param alpha azimuth (\u0026alpha;) around Z(0 is +X, \u0026pi;/2 is +Y, \u0026pi; is -X and 3\u0026pi;/2 is -Y)\n * @param delta elevation (\u0026delta;) above (XY) plane, from -\u0026pi;/2 to +\u0026pi;/2\n * @see #getAlpha()\n * @see #getDelta()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#137",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Vector3D(double a, Vector3D u) {\n        this.x \u003d a * u.x;\n        this.y \u003d a * u.y;\n        this.z \u003d a * u.z;\n    }",
    "begin_line": 137,
    "end_line": 141,
    "comment": "/** \n * Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u\n * @param a scale factor\n * @param u base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#151",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n        this.x \u003d MathArrays.linearCombination(a1, u1.x, a2, u2.x);\n        this.y \u003d MathArrays.linearCombination(a1, u1.y, a2, u2.y);\n        this.z \u003d MathArrays.linearCombination(a1, u1.z, a2, u2.z);\n    }",
    "begin_line": 151,
    "end_line": 155,
    "comment": "/** \n * Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#167",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                    double a3, Vector3D u3) {\n        this.x \u003d MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);\n        this.y \u003d MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);\n        this.z \u003d MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);\n    }",
    "begin_line": 167,
    "end_line": 172,
    "comment": "/** \n * Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#186",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                    double a3, Vector3D u3, double a4, Vector3D u4) {\n        this.x \u003d MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x, a4, u4.x);\n        this.y \u003d MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y, a4, u4.y);\n        this.z \u003d MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z, a4, u4.z);\n    }",
    "begin_line": 186,
    "end_line": 191,
    "comment": "/** \n * Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n * @param a4 fourth scale factor\n * @param u4 fourth base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getX#197",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getX()",
    "snippet": "public double getX() {\n        return x;\n    }",
    "begin_line": 197,
    "end_line": 199,
    "comment": "/** \n * Get the abscissa of the vector.\n * @return abscissa of the vector\n * @see #Vector3D(double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getY#205",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getY()",
    "snippet": "public double getY() {\n        return y;\n    }",
    "begin_line": 205,
    "end_line": 207,
    "comment": "/** \n * Get the ordinate of the vector.\n * @return ordinate of the vector\n * @see #Vector3D(double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getZ#213",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getZ()",
    "snippet": "public double getZ() {\n        return z;\n    }",
    "begin_line": 213,
    "end_line": 215,
    "comment": "/** \n * Get the height of the vector.\n * @return height of the vector\n * @see #Vector3D(double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.toArray#221",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.toArray()",
    "snippet": "public double[] toArray() {\n        return new double[] { x, y, z };\n    }",
    "begin_line": 221,
    "end_line": 223,
    "comment": "/** \n * Get the vector coordinates as a dimension 3 array.\n * @return vector coordinates\n * @see #Vector3D(double[])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getSpace#226",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getSpace()",
    "snippet": "public Space getSpace() {\n        return Euclidean3D.getInstance();\n    }",
    "begin_line": 226,
    "end_line": 228,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getZero#231",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getZero()",
    "snippet": "public Vector3D getZero() {\n        return ZERO;\n    }",
    "begin_line": 231,
    "end_line": 233,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getNorm1#236",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNorm1()",
    "snippet": "public double getNorm1() {\n        return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n    }",
    "begin_line": 236,
    "end_line": 238,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getNorm#241",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNorm()",
    "snippet": "public double getNorm() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return FastMath.sqrt (x * x + y * y + z * z);\n    }",
    "begin_line": 241,
    "end_line": 244,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getNormSq#247",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNormSq()",
    "snippet": "public double getNormSq() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return x * x + y * y + z * z;\n    }",
    "begin_line": 247,
    "end_line": 250,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getNormInf#253",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNormInf()",
    "snippet": "public double getNormInf() {\n        return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n    }",
    "begin_line": 253,
    "end_line": 255,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getAlpha#261",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getAlpha()",
    "snippet": "public double getAlpha() {\n        return FastMath.atan2(y, x);\n    }",
    "begin_line": 261,
    "end_line": 263,
    "comment": "/** \n * Get the azimuth of the vector.\n * @return azimuth (\u0026alpha;) of the vector, between -\u0026pi; and +\u0026pi;\n * @see #Vector3D(double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getDelta#269",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getDelta()",
    "snippet": "public double getDelta() {\n        return FastMath.asin(z / getNorm());\n    }",
    "begin_line": 269,
    "end_line": 271,
    "comment": "/** \n * Get the elevation of the vector.\n * @return elevation (\u0026delta;) of the vector, between -\u0026pi;/2 and +\u0026pi;/2\n * @see #Vector3D(double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.add#274",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.add(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D add(final Vector\u003cEuclidean3D\u003e v) {\n        final Vector3D v3 \u003d (Vector3D) v;\n        return new Vector3D(x + v3.x, y + v3.y, z + v3.z);\n    }",
    "begin_line": 274,
    "end_line": 277,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.add#280",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.add(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D add(double factor, final Vector\u003cEuclidean3D\u003e v) {\n        return new Vector3D(1, this, factor, (Vector3D) v);\n    }",
    "begin_line": 280,
    "end_line": 282,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.subtract#285",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.subtract(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D subtract(final Vector\u003cEuclidean3D\u003e v) {\n        final Vector3D v3 \u003d (Vector3D) v;\n        return new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n    }",
    "begin_line": 285,
    "end_line": 288,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.subtract#291",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.subtract(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D subtract(final double factor, final Vector\u003cEuclidean3D\u003e v) {\n        return new Vector3D(1, this, -factor, (Vector3D) v);\n    }",
    "begin_line": 291,
    "end_line": 293,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.normalize#296",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.normalize()",
    "snippet": "public Vector3D normalize() throws MathArithmeticException {\n        double s \u003d getNorm();\n        if (s \u003d\u003d 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n        }\n        return scalarMultiply(1 / s);\n    }",
    "begin_line": 296,
    "end_line": 302,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.orthogonal#319",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.orthogonal()",
    "snippet": "public Vector3D orthogonal() throws MathArithmeticException {\n\n        double threshold \u003d 0.6 * getNorm();\n        if (threshold \u003d\u003d 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) \u003c\u003d threshold) {\n            double inverse  \u003d 1 / FastMath.sqrt(y * y + z * z);\n            return new Vector3D(0, inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) \u003c\u003d threshold) {\n            double inverse  \u003d 1 / FastMath.sqrt(x * x + z * z);\n            return new Vector3D(-inverse * z, 0, inverse * x);\n        }\n        double inverse  \u003d 1 / FastMath.sqrt(x * x + y * y);\n        return new Vector3D(inverse * y, -inverse * x, 0);\n\n    }",
    "begin_line": 319,
    "end_line": 336,
    "comment": "/** \n * Get a vector orthogonal to the instance. \u003cp\u003eThere are an infinite number of normalized vectors orthogonal to the instance. This method picks up one of them almost arbitrarily. It is useful when one needs to compute a reference frame with one of the axes in a predefined direction. The following example shows how to build a frame having the k axis aligned with the known vector u : \u003cpre\u003e\u003ccode\u003e Vector3D k \u003d u.normalize(); Vector3D i \u003d k.orthogonal(); Vector3D j \u003d Vector3D.crossProduct(k, i); \u003c/code\u003e\u003c/pre\u003e\u003c/p\u003e\n * @return a new normalized vector orthogonal to the instance\n * @exception MathArithmeticException if the norm of the instance is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.angle#349",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.angle(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException {\n\n        double normProduct \u003d v1.getNorm() * v2.getNorm();\n        if (normProduct \u003d\u003d 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        double dot \u003d v1.dotProduct(v2);\n        double threshold \u003d normProduct * 0.9999;\n        if ((dot \u003c -threshold) || (dot \u003e threshold)) {\n            // the vectors are almost aligned, compute using the sine\n            Vector3D v3 \u003d crossProduct(v1, v2);\n            if (dot \u003e\u003d 0) {\n                return FastMath.asin(v3.getNorm() / normProduct);\n            }\n            return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n        }\n\n        // the vectors are sufficiently separated to use the cosine\n        return FastMath.acos(dot / normProduct);\n\n    }",
    "begin_line": 349,
    "end_line": 370,
    "comment": "/** \n * Compute the angular separation between two vectors. \u003cp\u003eThis method computes the angular separation between two vectors using the dot product for well separated vectors and the cross product for almost aligned vectors. This allows to have a good accuracy in all cases, even for vectors very close to each other.\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.negate#373",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.negate()",
    "snippet": "public Vector3D negate() {\n        return new Vector3D(-x, -y, -z);\n    }",
    "begin_line": 373,
    "end_line": 375,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.scalarMultiply#378",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.scalarMultiply(double)",
    "snippet": "public Vector3D scalarMultiply(double a) {\n        return new Vector3D(a * x, a * y, a * z);\n    }",
    "begin_line": 378,
    "end_line": 380,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.isNaN#383",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.isNaN()",
    "snippet": "public boolean isNaN() {\n        return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n    }",
    "begin_line": 383,
    "end_line": 385,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.isInfinite#388",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.isInfinite()",
    "snippet": "public boolean isInfinite() {\n        return !isNaN() \u0026\u0026 (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n    }",
    "begin_line": 388,
    "end_line": 390,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.equals#412",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.equals(java.lang.Object)",
    "snippet": "@Override\n    public boolean equals(Object other) {\n\n        if (this \u003d\u003d other) {\n            return true;\n        }\n\n        if (other instanceof Vector3D) {\n            final Vector3D rhs \u003d (Vector3D)other;\n            if (rhs.isNaN()) {\n                return this.isNaN();\n            }\n\n            return (x \u003d\u003d rhs.x) \u0026\u0026 (y \u003d\u003d rhs.y) \u0026\u0026 (z \u003d\u003d rhs.z);\n        }\n        return false;\n    }",
    "begin_line": 412,
    "end_line": 427,
    "comment": "/** \n * Test for the equality of two 3D vectors. \u003cp\u003e If all coordinates of two 3D vectors are exactly the same, and none are \u003ccode\u003eDouble.NaN\u003c/code\u003e, the two 3D vectors are considered to be equal. \u003c/p\u003e \u003cp\u003e \u003ccode\u003eNaN\u003c/code\u003e coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 3D vector are equal to \u003ccode\u003eDouble.NaN\u003c/code\u003e, the 3D vector is equal to {@link #NaN}. \u003c/p\u003e\n * @param other Object to test for equality to this\n * @return true if two 3D vector objects are equal, false ifobject is null, not an instance of Vector3D, or not equal to this Vector3D instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.hashCode#437",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.hashCode()",
    "snippet": "@Override\n    public int hashCode() {\n        if (isNaN()) {\n            return 642;\n        }\n        return 643 * (164 * MathUtils.hash(x) +  3 * MathUtils.hash(y) +  MathUtils.hash(z));\n    }",
    "begin_line": 437,
    "end_line": 442,
    "comment": "/** \n * Get a hashCode for the 3D vector. \u003cp\u003e All NaN values have the same hash code.\u003c/p\u003e\n * @return a hash code value for this object\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.dotProduct#452",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.dotProduct(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double dotProduct(final Vector\u003cEuclidean3D\u003e v) {\n        final Vector3D v3 \u003d (Vector3D) v;\n        return MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n    }",
    "begin_line": 452,
    "end_line": 455,
    "comment": "/** \n * {@inheritDoc}\u003cp\u003e The implementation uses specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It should be very accurate even for nearly orthogonal vectors. \u003c/p\u003e\n * @see MathArrays#linearCombination(double,double,double,double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.crossProduct#461",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.crossProduct(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D crossProduct(final Vector\u003cEuclidean3D\u003e v) {\n        final Vector3D v3 \u003d (Vector3D) v;\n        return new Vector3D(MathArrays.linearCombination(y, v3.z, -z, v3.y),\n                            MathArrays.linearCombination(z, v3.x, -x, v3.z),\n                            MathArrays.linearCombination(x, v3.y, -y, v3.x));\n    }",
    "begin_line": 461,
    "end_line": 466,
    "comment": "/** \n * Compute the cross-product of the instance with another vector.\n * @param v other vector\n * @return the cross product this ^ v as a new Vector3D\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distance1#469",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distance1(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double distance1(Vector\u003cEuclidean3D\u003e v) {\n        final Vector3D v3 \u003d (Vector3D) v;\n        final double dx \u003d FastMath.abs(v3.x - x);\n        final double dy \u003d FastMath.abs(v3.y - y);\n        final double dz \u003d FastMath.abs(v3.z - z);\n        return dx + dy + dz;\n    }",
    "begin_line": 469,
    "end_line": 475,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distance#478",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distance(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double distance(Vector\u003cEuclidean3D\u003e v) {\n        final Vector3D v3 \u003d (Vector3D) v;\n        final double dx \u003d v3.x - x;\n        final double dy \u003d v3.y - y;\n        final double dz \u003d v3.z - z;\n        return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n    }",
    "begin_line": 478,
    "end_line": 484,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distanceInf#487",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distanceInf(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double distanceInf(Vector\u003cEuclidean3D\u003e v) {\n        final Vector3D v3 \u003d (Vector3D) v;\n        final double dx \u003d FastMath.abs(v3.x - x);\n        final double dy \u003d FastMath.abs(v3.y - y);\n        final double dz \u003d FastMath.abs(v3.z - z);\n        return FastMath.max(FastMath.max(dx, dy), dz);\n    }",
    "begin_line": 487,
    "end_line": 493,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distanceSq#496",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distanceSq(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double distanceSq(Vector\u003cEuclidean3D\u003e v) {\n        final Vector3D v3 \u003d (Vector3D) v;\n        final double dx \u003d v3.x - x;\n        final double dy \u003d v3.y - y;\n        final double dz \u003d v3.z - z;\n        return dx * dx + dy * dy + dz * dz;\n    }",
    "begin_line": 496,
    "end_line": 502,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.dotProduct#509",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.dotProduct(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double dotProduct(Vector3D v1, Vector3D v2) {\n        return v1.dotProduct(v2);\n    }",
    "begin_line": 509,
    "end_line": 511,
    "comment": "/** \n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the dot product v1.v2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.crossProduct#518",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.crossProduct(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n        return v1.crossProduct(v2);\n    }",
    "begin_line": 518,
    "end_line": 520,
    "comment": "/** \n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distance1#530",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distance1(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double distance1(Vector3D v1, Vector3D v2) {\n        return v1.distance1(v2);\n    }",
    "begin_line": 530,
    "end_line": 532,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e1\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ev1.subtract(v2).getNorm1()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L\u003csub\u003e1\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distance#542",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distance(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double distance(Vector3D v1, Vector3D v2) {\n        return v1.distance(v2);\n    }",
    "begin_line": 542,
    "end_line": 544,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e2\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ev1.subtract(v2).getNorm()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L\u003csub\u003e2\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distanceInf#554",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distanceInf(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double distanceInf(Vector3D v1, Vector3D v2) {\n        return v1.distanceInf(v2);\n    }",
    "begin_line": 554,
    "end_line": 556,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ev1.subtract(v2).getNormInf()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distanceSq#566",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distanceSq(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double distanceSq(Vector3D v1, Vector3D v2) {\n        return v1.distanceSq(v2);\n    }",
    "begin_line": 566,
    "end_line": 568,
    "comment": "/** \n * Compute the square of the distance between two vectors. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ev1.subtract(v2).getNormSq()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return the square of the distance between v1 and v2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.toString#574",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.toString()",
    "snippet": "@Override\n    public String toString() {\n        return Vector3DFormat.getInstance().format(this);\n    }",
    "begin_line": 574,
    "end_line": 576,
    "comment": "/** \n * Get a string representation of this vector.\n * @return a string representation of this vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.toString#579",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.toString(java.text.NumberFormat)",
    "snippet": "public String toString(final NumberFormat format) {\n        return new Vector3DFormat(format).format(this);\n    }",
    "begin_line": 579,
    "end_line": 581,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#81",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Line(final Vector2D p1, final Vector2D p2) {\n        reset(p1, p2);\n    }",
    "begin_line": 81,
    "end_line": 83,
    "comment": "/** \n * Build a line from two points. \u003cp\u003eThe line is oriented from p1 to p2\u003c/p\u003e\n * @param p1 first point\n * @param p2 second point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#89",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double)",
    "snippet": "public Line(final Vector2D p, final double angle) {\n        reset(p, angle);\n    }",
    "begin_line": 89,
    "end_line": 91,
    "comment": "/** \n * Build a line from a point and an angle.\n * @param p point belonging to the line\n * @param angle angle of the line with respect to abscissa axis\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#99",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(double, double, double, double)",
    "snippet": "private Line(final double angle, final double cos, final double sin, final double originOffset) {\n        this.angle        \u003d angle;\n        this.cos          \u003d cos;\n        this.sin          \u003d sin;\n        this.originOffset \u003d originOffset;\n    }",
    "begin_line": 99,
    "end_line": 104,
    "comment": "/** \n * Build a line from its internal characteristics.\n * @param angle angle of the line with respect to abscissa axis\n * @param cos cosine of the angle\n * @param sin sine of the angle\n * @param originOffset offset of the origin\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#111",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(org.apache.commons.math3.geometry.euclidean.twod.Line)",
    "snippet": "public Line(final Line line) {\n        angle        \u003d MathUtils.normalizeAngle(line.angle, FastMath.PI);\n        cos          \u003d FastMath.cos(angle);\n        sin          \u003d FastMath.sin(angle);\n        originOffset \u003d line.originOffset;\n    }",
    "begin_line": 111,
    "end_line": 116,
    "comment": "/** \n * Copy constructor. \u003cp\u003eThe created instance is completely independent from the original instance, it is a deep copy.\u003c/p\u003e\n * @param line line to copy\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.copySelf#119",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.copySelf()",
    "snippet": "public Line copySelf() {\n        return new Line(this);\n    }",
    "begin_line": 119,
    "end_line": 121,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.reset#128",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.reset(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public void reset(final Vector2D p1, final Vector2D p2) {\n        final double dx \u003d p2.getX() - p1.getX();\n        final double dy \u003d p2.getY() - p1.getY();\n        final double d \u003d FastMath.hypot(dx, dy);\n        if (d \u003d\u003d 0.0) {\n            angle        \u003d 0.0;\n            cos          \u003d 1.0;\n            sin          \u003d 0.0;\n            originOffset \u003d p1.getY();\n        } else {\n            angle        \u003d FastMath.PI + FastMath.atan2(-dy, -dx);\n            cos          \u003d FastMath.cos(angle);\n            sin          \u003d FastMath.sin(angle);\n            originOffset \u003d (p2.getX() * p1.getY() - p1.getX() * p2.getY()) / d;\n        }\n    }",
    "begin_line": 128,
    "end_line": 143,
    "comment": "/** \n * Reset the instance as if built from two points. \u003cp\u003eThe line is oriented from p1 to p2\u003c/p\u003e\n * @param p1 first point\n * @param p2 second point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.reset#149",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.reset(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double)",
    "snippet": "public void reset(final Vector2D p, final double alpha) {\n        this.angle   \u003d MathUtils.normalizeAngle(alpha, FastMath.PI);\n        cos          \u003d FastMath.cos(this.angle);\n        sin          \u003d FastMath.sin(this.angle);\n        originOffset \u003d cos * p.getY() - sin * p.getX();\n    }",
    "begin_line": 149,
    "end_line": 154,
    "comment": "/** \n * Reset the instance as if built from a line and an angle.\n * @param p point belonging to the line\n * @param alpha angle of the line with respect to abscissa axis\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.revertSelf#158",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.revertSelf()",
    "snippet": "public void revertSelf() {\n        if (angle \u003c FastMath.PI) {\n            angle +\u003d FastMath.PI;\n        } else {\n            angle -\u003d FastMath.PI;\n        }\n        cos          \u003d -cos;\n        sin          \u003d -sin;\n        originOffset \u003d -originOffset;\n    }",
    "begin_line": 158,
    "end_line": 167,
    "comment": "/** \n * Revert the instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getReverse#174",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getReverse()",
    "snippet": "public Line getReverse() {\n        return new Line((angle \u003c FastMath.PI) ? (angle + FastMath.PI) : (angle - FastMath.PI),\n                        -cos, -sin, -originOffset);\n    }",
    "begin_line": 174,
    "end_line": 177,
    "comment": "/** \n * Get the reverse of the instance. \u003cp\u003eGet a line with reversed orientation with respect to the instance. A new object is built, the instance is untouched.\u003c/p\u003e\n * @return a new line, with orientation opposite to the instance orientation\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.toSubSpace#180",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.toSubSpace(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector1D toSubSpace(final Vector\u003cEuclidean2D\u003e point) {\n        Vector2D p2 \u003d (Vector2D) point;\n        return new Vector1D(cos * p2.getX() + sin * p2.getY());\n    }",
    "begin_line": 180,
    "end_line": 183,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.toSpace#186",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.toSpace(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector2D toSpace(final Vector\u003cEuclidean1D\u003e point) {\n        final double abscissa \u003d ((Vector1D) point).getX();\n        return new Vector2D(abscissa * cos - originOffset * sin,\n                            abscissa * sin + originOffset * cos);\n    }",
    "begin_line": 186,
    "end_line": 190,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.intersection#197",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.intersection(org.apache.commons.math3.geometry.euclidean.twod.Line)",
    "snippet": "public Vector2D intersection(final Line other) {\n        final double d \u003d sin * other.cos - other.sin * cos;\n        if (FastMath.abs(d) \u003c 1.0e-10) {\n            return null;\n        }\n        return new Vector2D((cos * other.originOffset - other.cos * originOffset) / d,\n                            (sin * other.originOffset - other.sin * originOffset) / d);\n    }",
    "begin_line": 197,
    "end_line": 204,
    "comment": "/** \n * Get the intersection point of the instance and another line.\n * @param other other line\n * @return intersection point of the instance and the other lineor null if there are no intersection points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.wholeHyperplane#207",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.wholeHyperplane()",
    "snippet": "public SubLine wholeHyperplane() {\n        return new SubLine(this, new IntervalsSet());\n    }",
    "begin_line": 207,
    "end_line": 209,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.wholeSpace#215",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.wholeSpace()",
    "snippet": "public PolygonsSet wholeSpace() {\n        return new PolygonsSet();\n    }",
    "begin_line": 215,
    "end_line": 217,
    "comment": "/** \n * Build a region covering the whole space.\n * @return a region containing the instance (really a {@link PolygonsSet PolygonsSet} instance)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getOffset#229",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getOffset(org.apache.commons.math3.geometry.euclidean.twod.Line)",
    "snippet": "public double getOffset(final Line line) {\n        return originOffset +\n               ((cos * line.cos + sin * line.sin \u003e 0) ? -line.originOffset : line.originOffset);\n    }",
    "begin_line": 229,
    "end_line": 232,
    "comment": "/** \n * Get the offset (oriented distance) of a parallel line. \u003cp\u003eThis method should be called only for parallel lines otherwise the result is not meaningful.\u003c/p\u003e \u003cp\u003eThe offset is 0 if both lines are the same, it is positive if the line is on the right side of the instance and negative if it is on the left side, according to its natural orientation.\u003c/p\u003e\n * @param line line to check\n * @return offset of the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getOffset#235",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getOffset(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double getOffset(final Vector\u003cEuclidean2D\u003e point) {\n        Vector2D p2 \u003d (Vector2D) point;\n        return sin * p2.getX() - cos * p2.getY() + originOffset;\n    }",
    "begin_line": 235,
    "end_line": 238,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.sameOrientationAs#241",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.sameOrientationAs(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public boolean sameOrientationAs(final Hyperplane\u003cEuclidean2D\u003e other) {\n        final Line otherL \u003d (Line) other;\n        return (sin * otherL.sin + cos * otherL.cos) \u003e\u003d 0.0;\n    }",
    "begin_line": 241,
    "end_line": 244,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getPointAt#252",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getPointAt(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double)",
    "snippet": "public Vector2D getPointAt(final Vector1D abscissa, final double offset) {\n        final double x       \u003d abscissa.getX();\n        final double dOffset \u003d offset - originOffset;\n        return new Vector2D(x * cos + dOffset * sin, x * sin - dOffset * cos);\n    }",
    "begin_line": 252,
    "end_line": 256,
    "comment": "/** \n * Get one point from the plane.\n * @param abscissa desired abscissa for the point\n * @param offset desired offset for the point\n * @return one point in the plane, with given abscissa and offsetrelative to the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.contains#262",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.contains(org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public boolean contains(final Vector2D p) {\n        return FastMath.abs(getOffset(p)) \u003c 1.0e-10;\n    }",
    "begin_line": 262,
    "end_line": 264,
    "comment": "/** \n * Check if the line contains a point.\n * @param p point to check\n * @return true if p belongs to the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.distance#275",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.distance(org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public double distance(final Vector2D p) {\n        return FastMath.abs(getOffset(p));\n    }",
    "begin_line": 275,
    "end_line": 277,
    "comment": "/** \n * Compute the distance between the instance and a point. \u003cp\u003eThis is a shortcut for invoking FastMath.abs(getOffset(p)), and provides consistency with what is in the org.apache.commons.math3.geometry.euclidean.threed.Line class.\u003c/p\u003e\n * @param p to check\n * @return distance between the instance and the point\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.isParallelTo#284",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.isParallelTo(org.apache.commons.math3.geometry.euclidean.twod.Line)",
    "snippet": "public boolean isParallelTo(final Line line) {\n        return FastMath.abs(sin * line.cos - cos * line.sin) \u003c 1.0e-10;\n    }",
    "begin_line": 284,
    "end_line": 286,
    "comment": "/** \n * Check the instance is parallel to another line.\n * @param line other line to check\n * @return true if the instance is parallel to the other line(they can have either the same or opposite orientations)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.translateToPoint#291",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.translateToPoint(org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public void translateToPoint(final Vector2D p) {\n        originOffset \u003d cos * p.getY() - sin * p.getX();\n    }",
    "begin_line": 291,
    "end_line": 293,
    "comment": "/** \n * Translate the line to force it passing by a point.\n * @param p point by which the line should pass\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getAngle#298",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getAngle()",
    "snippet": "public double getAngle() {\n        return MathUtils.normalizeAngle(angle, FastMath.PI);\n    }",
    "begin_line": 298,
    "end_line": 300,
    "comment": "/** \n * Get the angle of the line.\n * @return the angle of the line with respect to the abscissa axis\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.setAngle#305",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.setAngle(double)",
    "snippet": "public void setAngle(final double angle) {\n        this.angle \u003d MathUtils.normalizeAngle(angle, FastMath.PI);\n        cos        \u003d FastMath.cos(this.angle);\n        sin        \u003d FastMath.sin(this.angle);\n    }",
    "begin_line": 305,
    "end_line": 309,
    "comment": "/** \n * Set the angle of the line.\n * @param angle new angle of the line with respect to the abscissa axis\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getOriginOffset#314",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getOriginOffset()",
    "snippet": "public double getOriginOffset() {\n        return originOffset;\n    }",
    "begin_line": 314,
    "end_line": 316,
    "comment": "/** \n * Get the offset of the origin.\n * @return the offset of the origin\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.setOriginOffset#321",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.setOriginOffset(double)",
    "snippet": "public void setOriginOffset(final double offset) {\n        originOffset \u003d offset;\n    }",
    "begin_line": 321,
    "end_line": 323,
    "comment": "/** \n * Set the offset of the origin.\n * @param offset offset of the origin\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getTransform#338",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(java.awt.geom.AffineTransform)",
    "snippet": "public static Transform\u003cEuclidean2D, Euclidean1D\u003e getTransform(final AffineTransform transform)\n        throws MathIllegalArgumentException {\n        return new LineTransform(transform);\n    }",
    "begin_line": 338,
    "end_line": 341,
    "comment": "/** \n * Get a  {@link org.apache.commons.math3.geometry.partitioning.Transform Transform} embedding an affine transform.\n * @param transform affine transform to embed (must be inversibleotherwise the  {@link org.apache.commons.math3.geometry.partitioning.Transform#apply(Hyperplane) apply(Hyperplane)} method would work only for some lines, andfail for other ones)\n * @return a new transform that can be applied to either {@link Vector2D Vector2D},  {@link Line Line} or {@link org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LineTransform.LineTransform#371",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.LineTransform(java.awt.geom.AffineTransform)",
    "snippet": "public LineTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n\n            final double[] m \u003d new double[6];\n            transform.getMatrix(m);\n            cXX \u003d m[0];\n            cXY \u003d m[2];\n            cX1 \u003d m[4];\n            cYX \u003d m[1];\n            cYY \u003d m[3];\n            cY1 \u003d m[5];\n\n            c1Y \u003d cXY * cY1 - cYY * cX1;\n            c1X \u003d cXX * cY1 - cYX * cX1;\n            c11 \u003d cXX * cYY - cYX * cXY;\n\n            if (FastMath.abs(c11) \u003c 1.0e-20) {\n                throw new MathIllegalArgumentException(LocalizedFormats.NON_INVERTIBLE_TRANSFORM);\n            }\n\n        }",
    "begin_line": 371,
    "end_line": 390,
    "comment": "/** \n * Build an affine line transform from a n  {@code AffineTransform}.\n * @param transform transform to use (must be invertible otherwisethe  {@link LineTransform#apply(Hyperplane)} method would workonly for some lines, and fail for other ones)\n * @exception MathIllegalArgumentException if the transform is non invertible\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LineTransform.apply#393",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.apply(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D apply(final Vector\u003cEuclidean2D\u003e point) {\n            final Vector2D p2D \u003d (Vector2D) point;\n            final double  x   \u003d p2D.getX();\n            final double  y   \u003d p2D.getY();\n            return new Vector2D(cXX * x + cXY * y + cX1,\n                               cYX * x + cYY * y + cY1);\n        }",
    "begin_line": 393,
    "end_line": 399,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LineTransform.apply#402",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.apply(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Line apply(final Hyperplane\u003cEuclidean2D\u003e hyperplane) {\n            final Line   line    \u003d (Line) hyperplane;\n            final double rOffset \u003d c1X * line.cos + c1Y * line.sin + c11 * line.originOffset;\n            final double rCos    \u003d cXX * line.cos + cXY * line.sin;\n            final double rSin    \u003d cYX * line.cos + cYY * line.sin;\n            final double inv     \u003d 1.0 / FastMath.sqrt(rSin * rSin + rCos * rCos);\n            return new Line(FastMath.PI + FastMath.atan2(-rSin, -rCos),\n                            inv * rCos, inv * rSin,\n                            inv * rOffset);\n        }",
    "begin_line": 402,
    "end_line": 411,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LineTransform.apply#414",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.apply(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e, org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e, org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public SubHyperplane\u003cEuclidean1D\u003e apply(final SubHyperplane\u003cEuclidean1D\u003e sub,\n                                                final Hyperplane\u003cEuclidean2D\u003e original,\n                                                final Hyperplane\u003cEuclidean2D\u003e transformed) {\n            final OrientedPoint op     \u003d (OrientedPoint) sub.getHyperplane();\n            final Line originalLine    \u003d (Line) original;\n            final Line transformedLine \u003d (Line) transformed;\n            final Vector1D newLoc \u003d\n                transformedLine.toSubSpace(apply(originalLine.toSpace(op.getLocation())));\n            return new OrientedPoint(newLoc, op.isDirect()).wholeHyperplane();\n        }",
    "begin_line": 414,
    "end_line": 423,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#46",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public SubLine(final Hyperplane\u003cEuclidean2D\u003e hyperplane,\n                   final Region\u003cEuclidean1D\u003e remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }",
    "begin_line": 46,
    "end_line": 49,
    "comment": "/** \n * Simple constructor.\n * @param hyperplane underlying hyperplane\n * @param remainingRegion remaining region of the hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#55",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public SubLine(final Vector2D start, final Vector2D end) {\n        super(new Line(start, end), buildIntervalSet(start, end));\n    }",
    "begin_line": 55,
    "end_line": 57,
    "comment": "/** \n * Create a sub-line from two endpoints.\n * @param start start point\n * @param end end point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#62",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.twod.Segment)",
    "snippet": "public SubLine(final Segment segment) {\n        super(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));\n    }",
    "begin_line": 62,
    "end_line": 64,
    "comment": "/** \n * Create a sub-line from a segment.\n * @param segment single segment forming the sub-line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.getSegments#80",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.getSegments()",
    "snippet": "public List\u003cSegment\u003e getSegments() {\n\n        final Line line \u003d (Line) getHyperplane();\n        final List\u003cInterval\u003e list \u003d ((IntervalsSet) getRemainingRegion()).asList();\n        final List\u003cSegment\u003e segments \u003d new ArrayList\u003cSegment\u003e();\n\n        for (final Interval interval : list) {\n            final Vector2D start \u003d line.toSpace(new Vector1D(interval.getInf()));\n            final Vector2D end   \u003d line.toSpace(new Vector1D(interval.getSup()));\n            segments.add(new Segment(start, end, line));\n        }\n\n        return segments;\n\n    }",
    "begin_line": 80,
    "end_line": 94,
    "comment": "/** \n * Get the endpoints of the sub-line. \u003cp\u003e A subline may be any arbitrary number of disjoints segments, so the endpoints are provided as a list of endpoint pairs. Each element of the list represents one segment, and each segment contains a start point at index 0 and an end point at index 1. If the sub-line is unbounded in the negative infinity direction, the start point of the first segment will have infinite coordinates. If the sub-line is unbounded in the positive infinity direction, the end point of the last segment will have infinite coordinates. So a sub-line covering the whole line will contain just one row and both elements of this row will have infinite coordinates. If the sub-line is empty, the returned list will contain 0 segments. \u003c/p\u003e\n * @return list of segments endpoints\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.intersection#110",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine, boolean)",
    "snippet": "public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // retrieve the underlying lines\n        Line line1 \u003d (Line) getHyperplane();\n        Line line2 \u003d (Line) subLine.getHyperplane();\n\n        // compute the intersection on infinite line\n        Vector2D v2D \u003d line1.intersection(line2);\n\n        // check location of point with respect to first sub-line\n        Location loc1 \u003d getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 \u003d subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n\n        if (includeEndPoints) {\n            return ((loc1 !\u003d Location.OUTSIDE) \u0026\u0026 (loc2 !\u003d Location.OUTSIDE)) ? v2D : null;\n        } else {\n            return ((loc1 \u003d\u003d Location.INSIDE) \u0026\u0026 (loc2 \u003d\u003d Location.INSIDE)) ? v2D : null;\n        }\n\n    }",
    "begin_line": 110,
    "end_line": 131,
    "comment": "/** \n * Get the intersection of the instance and another sub-line. \u003cp\u003e This method is related to the  {@link Line#intersection(Line) intersection} method in the {@link Line Line} class, but in additionto compute the point along infinite lines, it also checks the point lies on both sub-line ranges. \u003c/p\u003e\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong toinstance (i.e. they are closed sets) and may be returned, otherwise endpoints are considered to not belong to instance (i.e. they are open sets) and intersection occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don\u0027t intersect\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.buildIntervalSet#138",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.buildIntervalSet(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end) {\n        final Line line \u003d new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }",
    "begin_line": 138,
    "end_line": 142,
    "comment": "/** \n * Build an interval set from two points.\n * @param start start point\n * @param end end point\n * @return an interval set\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.buildNew#146",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.buildNew(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override\n    protected AbstractSubHyperplane\u003cEuclidean2D, Euclidean1D\u003e buildNew(final Hyperplane\u003cEuclidean2D\u003e hyperplane,\n                                                                       final Region\u003cEuclidean1D\u003e remainingRegion) {\n        return new SubLine(hyperplane, remainingRegion);\n    }",
    "begin_line": 146,
    "end_line": 149,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.side#153",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.side(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "@Override\n    public Side side(final Hyperplane\u003cEuclidean2D\u003e hyperplane) {\n\n        final Line    thisLine  \u003d (Line) getHyperplane();\n        final Line    otherLine \u003d (Line) hyperplane;\n        final Vector2D crossing  \u003d thisLine.intersection(otherLine);\n\n        if (crossing \u003d\u003d null) {\n            // the lines are parallel,\n            final double global \u003d otherLine.getOffset(thisLine);\n            return (global \u003c -1.0e-10) ? Side.MINUS : ((global \u003e 1.0e-10) ? Side.PLUS : Side.HYPER);\n        }\n\n        // the lines do intersect\n        final boolean direct \u003d FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) \u003c 0;\n        final Vector1D x \u003d thisLine.toSubSpace(crossing);\n        return getRemainingRegion().side(new OrientedPoint(x, direct));\n\n    }",
    "begin_line": 153,
    "end_line": 170,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.split#174",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.split(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "@Override\n    public SplitSubHyperplane\u003cEuclidean2D\u003e split(final Hyperplane\u003cEuclidean2D\u003e hyperplane) {\n\n        final Line    thisLine  \u003d (Line) getHyperplane();\n        final Line    otherLine \u003d (Line) hyperplane;\n        final Vector2D crossing  \u003d thisLine.intersection(otherLine);\n\n        if (crossing \u003d\u003d null) {\n            // the lines are parallel\n            final double global \u003d otherLine.getOffset(thisLine);\n            return (global \u003c -1.0e-10) ?\n                   new SplitSubHyperplane\u003cEuclidean2D\u003e(null, this) :\n                   new SplitSubHyperplane\u003cEuclidean2D\u003e(this, null);\n        }\n\n        // the lines do intersect\n        final boolean direct \u003d FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) \u003c 0;\n        final Vector1D x      \u003d thisLine.toSubSpace(crossing);\n        final SubHyperplane\u003cEuclidean1D\u003e subPlus  \u003d new OrientedPoint(x, !direct).wholeHyperplane();\n        final SubHyperplane\u003cEuclidean1D\u003e subMinus \u003d new OrientedPoint(x,  direct).wholeHyperplane();\n\n        final BSPTree\u003cEuclidean1D\u003e splitTree \u003d getRemainingRegion().getTree(false).split(subMinus);\n        final BSPTree\u003cEuclidean1D\u003e plusTree  \u003d getRemainingRegion().isEmpty(splitTree.getPlus()) ?\n                                               new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE) :\n                                               new BSPTree\u003cEuclidean1D\u003e(subPlus, new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),\n                                                                        splitTree.getPlus(), null);\n        final BSPTree\u003cEuclidean1D\u003e minusTree \u003d getRemainingRegion().isEmpty(splitTree.getMinus()) ?\n                                               new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE) :\n                                               new BSPTree\u003cEuclidean1D\u003e(subMinus, new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),\n                                                                        splitTree.getMinus(), null);\n\n        return new SplitSubHyperplane\u003cEuclidean2D\u003e(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)),\n                                                   new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));\n\n    }",
    "begin_line": 174,
    "end_line": 207,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#68",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, double)",
    "snippet": "public Vector2D(double x, double y) {\n        this.x \u003d x;\n        this.y \u003d y;\n    }",
    "begin_line": 68,
    "end_line": 71,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param x abscissa\n * @param y ordinate\n * @see #getX()\n * @see #getY()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#79",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double[])",
    "snippet": "public Vector2D(double[] v) throws DimensionMismatchException {\n        if (v.length !\u003d 2) {\n            throw new DimensionMismatchException(v.length, 2);\n        }\n        this.x \u003d v[0];\n        this.y \u003d v[1];\n    }",
    "begin_line": 79,
    "end_line": 85,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param v coordinates array\n * @exception DimensionMismatchException if array does not have 2 elements\n * @see #toArray()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#93",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Vector2D(double a, Vector2D u) {\n        this.x \u003d a * u.x;\n        this.y \u003d a * u.y;\n    }",
    "begin_line": 93,
    "end_line": 96,
    "comment": "/** \n * Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u\n * @param a scale factor\n * @param u base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#106",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Vector2D(double a1, Vector2D u1, double a2, Vector2D u2) {\n        this.x \u003d a1 * u1.x + a2 * u2.x;\n        this.y \u003d a1 * u1.y + a2 * u2.y;\n    }",
    "begin_line": 106,
    "end_line": 109,
    "comment": "/** \n * Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#121",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Vector2D(double a1, Vector2D u1, double a2, Vector2D u2,\n                   double a3, Vector2D u3) {\n        this.x \u003d a1 * u1.x + a2 * u2.x + a3 * u3.x;\n        this.y \u003d a1 * u1.y + a2 * u2.y + a3 * u3.y;\n    }",
    "begin_line": 121,
    "end_line": 125,
    "comment": "/** \n * Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#139",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Vector2D(double a1, Vector2D u1, double a2, Vector2D u2,\n                   double a3, Vector2D u3, double a4, Vector2D u4) {\n        this.x \u003d a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n        this.y \u003d a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n    }",
    "begin_line": 139,
    "end_line": 143,
    "comment": "/** \n * Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n * @param a4 fourth scale factor\n * @param u4 fourth base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getX#149",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getX()",
    "snippet": "public double getX() {\n        return x;\n    }",
    "begin_line": 149,
    "end_line": 151,
    "comment": "/** \n * Get the abscissa of the vector.\n * @return abscissa of the vector\n * @see #Vector2D(double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getY#157",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getY()",
    "snippet": "public double getY() {\n        return y;\n    }",
    "begin_line": 157,
    "end_line": 159,
    "comment": "/** \n * Get the ordinate of the vector.\n * @return ordinate of the vector\n * @see #Vector2D(double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.toArray#165",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.toArray()",
    "snippet": "public double[] toArray() {\n        return new double[] { x, y };\n    }",
    "begin_line": 165,
    "end_line": 167,
    "comment": "/** \n * Get the vector coordinates as a dimension 2 array.\n * @return vector coordinates\n * @see #Vector2D(double[])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getSpace#170",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getSpace()",
    "snippet": "public Space getSpace() {\n        return Euclidean2D.getInstance();\n    }",
    "begin_line": 170,
    "end_line": 172,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getZero#175",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getZero()",
    "snippet": "public Vector2D getZero() {\n        return ZERO;\n    }",
    "begin_line": 175,
    "end_line": 177,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getNorm1#180",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getNorm1()",
    "snippet": "public double getNorm1() {\n        return FastMath.abs(x) + FastMath.abs(y);\n    }",
    "begin_line": 180,
    "end_line": 182,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getNorm#185",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getNorm()",
    "snippet": "public double getNorm() {\n        return FastMath.sqrt (x * x + y * y);\n    }",
    "begin_line": 185,
    "end_line": 187,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getNormSq#190",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getNormSq()",
    "snippet": "public double getNormSq() {\n        return x * x + y * y;\n    }",
    "begin_line": 190,
    "end_line": 192,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getNormInf#195",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getNormInf()",
    "snippet": "public double getNormInf() {\n        return FastMath.max(FastMath.abs(x), FastMath.abs(y));\n    }",
    "begin_line": 195,
    "end_line": 197,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.add#200",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.add(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D add(Vector\u003cEuclidean2D\u003e v) {\n        Vector2D v2 \u003d (Vector2D) v;\n        return new Vector2D(x + v2.getX(), y + v2.getY());\n    }",
    "begin_line": 200,
    "end_line": 203,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.add#206",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.add(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D add(double factor, Vector\u003cEuclidean2D\u003e v) {\n        Vector2D v2 \u003d (Vector2D) v;\n        return new Vector2D(x + factor * v2.getX(), y + factor * v2.getY());\n    }",
    "begin_line": 206,
    "end_line": 209,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.subtract#212",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.subtract(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D subtract(Vector\u003cEuclidean2D\u003e p) {\n        Vector2D p3 \u003d (Vector2D) p;\n        return new Vector2D(x - p3.x, y - p3.y);\n    }",
    "begin_line": 212,
    "end_line": 215,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.subtract#218",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.subtract(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D subtract(double factor, Vector\u003cEuclidean2D\u003e v) {\n        Vector2D v2 \u003d (Vector2D) v;\n        return new Vector2D(x - factor * v2.getX(), y - factor * v2.getY());\n    }",
    "begin_line": 218,
    "end_line": 221,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.normalize#224",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.normalize()",
    "snippet": "public Vector2D normalize() throws MathArithmeticException {\n        double s \u003d getNorm();\n        if (s \u003d\u003d 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n        }\n        return scalarMultiply(1 / s);\n    }",
    "begin_line": 224,
    "end_line": 230,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.negate#232",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.negate()",
    "snippet": "public Vector2D negate() {\n        return new Vector2D(-x, -y);\n    }",
    "begin_line": 232,
    "end_line": 234,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.scalarMultiply#237",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.scalarMultiply(double)",
    "snippet": "public Vector2D scalarMultiply(double a) {\n        return new Vector2D(a * x, a * y);\n    }",
    "begin_line": 237,
    "end_line": 239,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.isNaN#242",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.isNaN()",
    "snippet": "public boolean isNaN() {\n        return Double.isNaN(x) || Double.isNaN(y);\n    }",
    "begin_line": 242,
    "end_line": 244,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.isInfinite#247",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.isInfinite()",
    "snippet": "public boolean isInfinite() {\n        return !isNaN() \u0026\u0026 (Double.isInfinite(x) || Double.isInfinite(y));\n    }",
    "begin_line": 247,
    "end_line": 249,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distance1#252",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distance1(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double distance1(Vector\u003cEuclidean2D\u003e p) {\n        Vector2D p3 \u003d (Vector2D) p;\n        final double dx \u003d FastMath.abs(p3.x - x);\n        final double dy \u003d FastMath.abs(p3.y - y);\n        return dx + dy;\n    }",
    "begin_line": 252,
    "end_line": 257,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distance#260",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distance(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double distance(Vector\u003cEuclidean2D\u003e p) {\n        Vector2D p3 \u003d (Vector2D) p;\n        final double dx \u003d p3.x - x;\n        final double dy \u003d p3.y - y;\n        return FastMath.sqrt(dx * dx + dy * dy);\n    }",
    "begin_line": 260,
    "end_line": 265,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distanceInf#268",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distanceInf(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double distanceInf(Vector\u003cEuclidean2D\u003e p) {\n        Vector2D p3 \u003d (Vector2D) p;\n        final double dx \u003d FastMath.abs(p3.x - x);\n        final double dy \u003d FastMath.abs(p3.y - y);\n        return FastMath.max(dx, dy);\n    }",
    "begin_line": 268,
    "end_line": 273,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distanceSq#276",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distanceSq(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double distanceSq(Vector\u003cEuclidean2D\u003e p) {\n        Vector2D p3 \u003d (Vector2D) p;\n        final double dx \u003d p3.x - x;\n        final double dy \u003d p3.y - y;\n        return dx * dx + dy * dy;\n    }",
    "begin_line": 276,
    "end_line": 281,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.dotProduct#284",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.dotProduct(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double dotProduct(final Vector\u003cEuclidean2D\u003e v) {\n        final Vector2D v2 \u003d (Vector2D) v;\n        return x * v2.x + y * v2.y;\n    }",
    "begin_line": 284,
    "end_line": 287,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distance#297",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distance(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public static double distance(Vector2D p1, Vector2D p2) {\n        return p1.distance(p2);\n    }",
    "begin_line": 297,
    "end_line": 299,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e2\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNorm()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L\u003csub\u003e2\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distanceInf#309",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distanceInf(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public static double distanceInf(Vector2D p1, Vector2D p2) {\n        return p1.distanceInf(p2);\n    }",
    "begin_line": 309,
    "end_line": 311,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNormInf()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distanceSq#321",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distanceSq(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public static double distanceSq(Vector2D p1, Vector2D p2) {\n        return p1.distanceSq(p2);\n    }",
    "begin_line": 321,
    "end_line": 323,
    "comment": "/** \n * Compute the square of the distance between two vectors. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNormSq()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.equals#345",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.equals(java.lang.Object)",
    "snippet": "@Override\n    public boolean equals(Object other) {\n\n        if (this \u003d\u003d other) {\n            return true;\n        }\n\n        if (other instanceof Vector2D) {\n            final Vector2D rhs \u003d (Vector2D)other;\n            if (rhs.isNaN()) {\n                return this.isNaN();\n            }\n\n            return (x \u003d\u003d rhs.x) \u0026\u0026 (y \u003d\u003d rhs.y);\n        }\n        return false;\n    }",
    "begin_line": 345,
    "end_line": 360,
    "comment": "/** \n * Test for the equality of two 2D vectors. \u003cp\u003e If all coordinates of two 2D vectors are exactly the same, and none are \u003ccode\u003eDouble.NaN\u003c/code\u003e, the two 2D vectors are considered to be equal. \u003c/p\u003e \u003cp\u003e \u003ccode\u003eNaN\u003c/code\u003e coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 2D vector are equal to \u003ccode\u003eDouble.NaN\u003c/code\u003e, the 2D vector is equal to {@link #NaN}. \u003c/p\u003e\n * @param other Object to test for equality to this\n * @return true if two 2D vector objects are equal, false ifobject is null, not an instance of Vector2D, or not equal to this Vector2D instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.hashCode#370",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.hashCode()",
    "snippet": "@Override\n    public int hashCode() {\n        if (isNaN()) {\n            return 542;\n        }\n        return 122 * (76 * MathUtils.hash(x) +  MathUtils.hash(y));\n    }",
    "begin_line": 370,
    "end_line": 375,
    "comment": "/** \n * Get a hashCode for the 2D vector. \u003cp\u003e All NaN values have the same hash code.\u003c/p\u003e\n * @return a hash code value for this object\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.toString#381",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.toString()",
    "snippet": "@Override\n    public String toString() {\n        return Vector2DFormat.getInstance().format(this);\n    }",
    "begin_line": 381,
    "end_line": 383,
    "comment": "/** \n * Get a string representation of this vector.\n * @return a string representation of this vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.toString#386",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.toString(java.text.NumberFormat)",
    "snippet": "public String toString(final NumberFormat format) {\n        return new Vector2DFormat(format).format(this);\n    }",
    "begin_line": 386,
    "end_line": 388,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.AbstractRegion#51",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion()",
    "snippet": "protected AbstractRegion() {\n        tree \u003d new BSPTree\u003cS\u003e(Boolean.TRUE);\n    }",
    "begin_line": 51,
    "end_line": 53,
    "comment": "/** \n * Build a region representing the whole space.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.AbstractRegion#67",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "protected AbstractRegion(final BSPTree\u003cS\u003e tree) {\n        this.tree \u003d tree;\n    }",
    "begin_line": 67,
    "end_line": 69,
    "comment": "/** \n * Build a region from an inside/outside BSP tree. \u003cp\u003eThe leaf nodes of the BSP tree \u003cem\u003emust\u003c/em\u003e have a {@code Boolean} attribute representing the inside status ofthe corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants {@code Boolean.TRUE} and {@code Boolean.FALSE}. The tree also \u003cem\u003emust\u003c/em\u003e have either null internal nodes or internal nodes representing the boundary as specified in the {@link #getTree getTree} method).\u003c/p\u003e\n * @param tree inside/outside BSP tree representing the region\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.AbstractRegion#90",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(java.util.Collection\u003corg.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e\u003e)",
    "snippet": "protected AbstractRegion(final Collection\u003cSubHyperplane\u003cS\u003e\u003e boundary) {\n\n        if (boundary.size() \u003d\u003d 0) {\n\n            // the tree represents the whole space\n            tree \u003d new BSPTree\u003cS\u003e(Boolean.TRUE);\n\n        } else {\n\n            // sort the boundary elements in decreasing size order\n            // (we don\u0027t want equal size elements to be removed, so\n            // we use a trick to fool the TreeSet)\n            final TreeSet\u003cSubHyperplane\u003cS\u003e\u003e ordered \u003d new TreeSet\u003cSubHyperplane\u003cS\u003e\u003e(new Comparator\u003cSubHyperplane\u003cS\u003e\u003e() {\n                public int compare(final SubHyperplane\u003cS\u003e o1, final SubHyperplane\u003cS\u003e o2) {\n                    final double size1 \u003d o1.getSize();\n                    final double size2 \u003d o2.getSize();\n                    return (size2 \u003c size1) ? -1 : ((o1 \u003d\u003d o2) ? 0 : +1);\n                }\n            });\n            ordered.addAll(boundary);\n\n            // build the tree top-down\n            tree \u003d new BSPTree\u003cS\u003e();\n            insertCuts(tree, ordered);\n\n            // set up the inside/outside flags\n            tree.visit(new BSPTreeVisitor\u003cS\u003e() {\n\n                /** {@inheritDoc} */\n                public Order visitOrder(final BSPTree\u003cS\u003e node) {\n                    return Order.PLUS_SUB_MINUS;\n                }\n\n                /** {@inheritDoc} */\n                public void visitInternalNode(final BSPTree\u003cS\u003e node) {\n                }\n\n                /** {@inheritDoc} */\n                public void visitLeafNode(final BSPTree\u003cS\u003e node) {\n                    node.setAttribute((node \u003d\u003d node.getParent().getPlus()) ?\n                                                                            Boolean.FALSE : Boolean.TRUE);\n                }\n            });\n\n        }\n\n    }",
    "begin_line": 90,
    "end_line": 136,
    "comment": "/** \n * Build a Region from a Boundary REPresentation (B-rep). \u003cp\u003eThe boundary is provided as a collection of  {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side.\u003c/p\u003e \u003cp\u003eThe boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the  {@link #checkPoint(Vector) checkPoint} method will not bemeaningful anymore.\u003c/p\u003e \u003cp\u003eIf the boundary is empty, the region will represent the whole space.\u003c/p\u003e\n * @param boundary collection of boundary elements, as acollection of  {@link SubHyperplane SubHyperplane} objects\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.compare#103",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.compare(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "public int compare(final SubHyperplane\u003cS\u003e o1, final SubHyperplane\u003cS\u003e o2) {\n                    final double size1 \u003d o1.getSize();\n                    final double size2 \u003d o2.getSize();\n                    return (size2 \u003c size1) ? -1 : ((o1 \u003d\u003d o2) ? 0 : +1);\n                }",
    "begin_line": 103,
    "end_line": 107,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.visitOrder#119",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitOrder(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public Order visitOrder(final BSPTree\u003cS\u003e node) {\n                    return Order.PLUS_SUB_MINUS;\n                }",
    "begin_line": 119,
    "end_line": 121,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.visitInternalNode#124",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitInternalNode(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public void visitInternalNode(final BSPTree\u003cS\u003e node) {\n                }",
    "begin_line": 124,
    "end_line": 125,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.visitLeafNode#128",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitLeafNode(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public void visitLeafNode(final BSPTree\u003cS\u003e node) {\n                    node.setAttribute((node \u003d\u003d node.getParent().getPlus()) ?\n                                                                            Boolean.FALSE : Boolean.TRUE);\n                }",
    "begin_line": 128,
    "end_line": 131,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.AbstractRegion#142",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e[])",
    "snippet": "public AbstractRegion(final Hyperplane\u003cS\u003e[] hyperplanes) {\n        if ((hyperplanes \u003d\u003d null) || (hyperplanes.length \u003d\u003d 0)) {\n            tree \u003d new BSPTree\u003cS\u003e(Boolean.FALSE);\n        } else {\n\n            // use the first hyperplane to build the right class\n            tree \u003d hyperplanes[0].wholeSpace().getTree(false);\n\n            // chop off parts of the space\n            BSPTree\u003cS\u003e node \u003d tree;\n            node.setAttribute(Boolean.TRUE);\n            for (final Hyperplane\u003cS\u003e hyperplane : hyperplanes) {\n                if (node.insertCut(hyperplane)) {\n                    node.setAttribute(null);\n                    node.getPlus().setAttribute(Boolean.FALSE);\n                    node \u003d node.getMinus();\n                    node.setAttribute(Boolean.TRUE);\n                }\n            }\n\n        }\n\n    }",
    "begin_line": 142,
    "end_line": 164,
    "comment": "/** \n * Build a convex region from an array of bounding hyperplanes.\n * @param hyperplanes array of bounding hyperplanes (if null, anempty region will be built)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.buildNew#167",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.buildNew(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public abstract AbstractRegion\u003cS, T\u003e buildNew(BSPTree\u003cS\u003e newTree);",
    "begin_line": 167,
    "end_line": 167,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.insertCuts#175",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.insertCuts(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, java.util.Collection\u003corg.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e\u003e)",
    "snippet": "private void insertCuts(final BSPTree\u003cS\u003e node, final Collection\u003cSubHyperplane\u003cS\u003e\u003e boundary) {\n\n        final Iterator\u003cSubHyperplane\u003cS\u003e\u003e iterator \u003d boundary.iterator();\n\n        // build the current level\n        Hyperplane\u003cS\u003e inserted \u003d null;\n        while ((inserted \u003d\u003d null) \u0026\u0026 iterator.hasNext()) {\n            inserted \u003d iterator.next().getHyperplane();\n            if (!node.insertCut(inserted.copySelf())) {\n                inserted \u003d null;\n            }\n        }\n\n        if (!iterator.hasNext()) {\n            return;\n        }\n\n        // distribute the remaining edges in the two sub-trees\n        final ArrayList\u003cSubHyperplane\u003cS\u003e\u003e plusList  \u003d new ArrayList\u003cSubHyperplane\u003cS\u003e\u003e();\n        final ArrayList\u003cSubHyperplane\u003cS\u003e\u003e minusList \u003d new ArrayList\u003cSubHyperplane\u003cS\u003e\u003e();\n        while (iterator.hasNext()) {\n            final SubHyperplane\u003cS\u003e other \u003d iterator.next();\n            switch (other.side(inserted)) {\n            case PLUS:\n                plusList.add(other);\n                break;\n            case MINUS:\n                minusList.add(other);\n                break;\n            case BOTH:\n                final SubHyperplane.SplitSubHyperplane\u003cS\u003e split \u003d other.split(inserted);\n                plusList.add(split.getPlus());\n                minusList.add(split.getMinus());\n                break;\n            default:\n                // ignore the sub-hyperplanes belonging to the cut hyperplane\n            }\n        }\n\n        // recurse through lower levels\n        insertCuts(node.getPlus(),  plusList);\n        insertCuts(node.getMinus(), minusList);\n\n    }",
    "begin_line": 175,
    "end_line": 218,
    "comment": "/** \n * Recursively build a tree by inserting cut sub-hyperplanes.\n * @param node current tree node (it is a leaf node at the beginningof the call)\n * @param boundary collection of edges belonging to the cell definedby the node\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.copySelf#221",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.copySelf()",
    "snippet": "public AbstractRegion\u003cS, T\u003e copySelf() {\n        return buildNew(tree.copySelf());\n    }",
    "begin_line": 221,
    "end_line": 223,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.isEmpty#226",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.isEmpty()",
    "snippet": "public boolean isEmpty() {\n        return isEmpty(tree);\n    }",
    "begin_line": 226,
    "end_line": 228,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.isEmpty#231",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.isEmpty(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public boolean isEmpty(final BSPTree\u003cS\u003e node) {\n\n        // we use a recursive function rather than the BSPTreeVisitor\n        // interface because we can stop visiting the tree as soon as we\n        // have found an inside cell\n\n        if (node.getCut() \u003d\u003d null) {\n            // if we find an inside node, the region is not empty\n            return !((Boolean) node.getAttribute());\n        }\n\n        // check both sides of the sub-tree\n        return isEmpty(node.getMinus()) \u0026\u0026 isEmpty(node.getPlus());\n\n    }",
    "begin_line": 231,
    "end_line": 245,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.contains#248",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.contains(org.apache.commons.math3.geometry.partitioning.Region\u003cS\u003e)",
    "snippet": "public boolean contains(final Region\u003cS\u003e region) {\n        return new RegionFactory\u003cS\u003e().difference(region, this).isEmpty();\n    }",
    "begin_line": 248,
    "end_line": 250,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.checkPoint#253",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.checkPoint(org.apache.commons.math3.geometry.Vector\u003cS\u003e)",
    "snippet": "public Location checkPoint(final Vector\u003cS\u003e point) {\n        return checkPoint(tree, point);\n    }",
    "begin_line": 253,
    "end_line": 255,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.checkPoint#264",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.checkPoint(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.Vector\u003cS\u003e)",
    "snippet": "protected Location checkPoint(final BSPTree\u003cS\u003e node, final Vector\u003cS\u003e point) {\n        final BSPTree\u003cS\u003e cell \u003d node.getCell(point);\n        if (cell.getCut() \u003d\u003d null) {\n            // the point is in the interior of a cell, just check the attribute\n            return ((Boolean) cell.getAttribute()) ? Location.INSIDE : Location.OUTSIDE;\n        }\n\n        // the point is on a cut-sub-hyperplane, is it on a boundary ?\n        final Location minusCode \u003d checkPoint(cell.getMinus(), point);\n        final Location plusCode  \u003d checkPoint(cell.getPlus(),  point);\n        return (minusCode \u003d\u003d plusCode) ? minusCode : Location.BOUNDARY;\n\n    }",
    "begin_line": 264,
    "end_line": 276,
    "comment": "/** \n * Check a point with respect to the region starting at a given node.\n * @param node root node of the region\n * @param point point to check\n * @return a code representing the point status: either {@link Region.Location#INSIDE INSIDE},  {@link Region.Location#OUTSIDE OUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.getTree#279",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getTree(boolean)",
    "snippet": "public BSPTree\u003cS\u003e getTree(final boolean includeBoundaryAttributes) {\n        if (includeBoundaryAttributes \u0026\u0026 (tree.getCut() !\u003d null) \u0026\u0026 (tree.getAttribute() \u003d\u003d null)) {\n            // we need to compute the boundary attributes\n            tree.visit(new BoundaryBuilder\u003cS\u003e());\n        }\n        return tree;\n    }",
    "begin_line": 279,
    "end_line": 285,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.visitOrder#296",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitOrder(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public Order visitOrder(BSPTree\u003cS\u003e node) {\n            return Order.PLUS_MINUS_SUB;\n        }",
    "begin_line": 296,
    "end_line": 298,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.visitInternalNode#301",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitInternalNode(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public void visitInternalNode(BSPTree\u003cS\u003e node) {\n\n            SubHyperplane\u003cS\u003e plusOutside \u003d null;\n            SubHyperplane\u003cS\u003e plusInside  \u003d null;\n\n            // characterize the cut sub-hyperplane,\n            // first with respect to the plus sub-tree\n            @SuppressWarnings(\"unchecked\")\n            final SubHyperplane\u003cS\u003e[] plusChar \u003d (SubHyperplane\u003cS\u003e[]) Array.newInstance(SubHyperplane.class, 2);\n            characterize(node.getPlus(), node.getCut().copySelf(), plusChar);\n\n            if (plusChar[0] !\u003d null \u0026\u0026 !plusChar[0].isEmpty()) {\n                // plusChar[0] corresponds to a subset of the cut sub-hyperplane known to have\n                // outside cells on its plus side, we want to check if parts of this subset\n                // do have inside cells on their minus side\n                @SuppressWarnings(\"unchecked\")\n                final SubHyperplane\u003cS\u003e[] minusChar \u003d (SubHyperplane\u003cS\u003e[]) Array.newInstance(SubHyperplane.class, 2);\n                characterize(node.getMinus(), plusChar[0], minusChar);\n                if (minusChar[1] !\u003d null \u0026\u0026 !minusChar[1].isEmpty()) {\n                    // this part belongs to the boundary,\n                    // it has the outside on its plus side and the inside on its minus side\n                    plusOutside \u003d minusChar[1];\n                }\n            }\n\n            if (plusChar[1] !\u003d null \u0026\u0026 !plusChar[1].isEmpty()) {\n                // plusChar[1] corresponds to a subset of the cut sub-hyperplane known to have\n                // inside cells on its plus side, we want to check if parts of this subset\n                // do have outside cells on their minus side\n                @SuppressWarnings(\"unchecked\")\n                final SubHyperplane\u003cS\u003e[] minusChar \u003d (SubHyperplane\u003cS\u003e[]) Array.newInstance(SubHyperplane.class, 2);\n                characterize(node.getMinus(), plusChar[1], minusChar);\n                if (minusChar[0] !\u003d null \u0026\u0026 !minusChar[0].isEmpty()) {\n                    // this part belongs to the boundary,\n                    // it has the inside on its plus side and the outside on its minus side\n                    plusInside \u003d minusChar[0];\n                }\n            }\n\n            // set the boundary attribute at non-leaf nodes\n            node.setAttribute(new BoundaryAttribute\u003cS\u003e(plusOutside, plusInside));\n\n        }",
    "begin_line": 301,
    "end_line": 343,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.visitLeafNode#346",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitLeafNode(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public void visitLeafNode(BSPTree\u003cS\u003e node) {\n        }",
    "begin_line": 346,
    "end_line": 347,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.characterize#362",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.characterize(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e[])",
    "snippet": "private void characterize(final BSPTree\u003cS\u003e node, final SubHyperplane\u003cS\u003e sub,\n                                  final SubHyperplane\u003cS\u003e[] characterization) {\n            if (node.getCut() \u003d\u003d null) {\n                // we have reached a leaf node\n                final boolean inside \u003d (Boolean) node.getAttribute();\n                if (inside) {\n                    if (characterization[1] \u003d\u003d null) {\n                        characterization[1] \u003d sub;\n                    } else {\n                        characterization[1] \u003d characterization[1].reunite(sub);\n                    }\n                } else {\n                    if (characterization[0] \u003d\u003d null) {\n                        characterization[0] \u003d sub;\n                    } else {\n                        characterization[0] \u003d characterization[0].reunite(sub);\n                    }\n                }\n            } else {\n                final Hyperplane\u003cS\u003e hyperplane \u003d node.getCut().getHyperplane();\n                switch (sub.side(hyperplane)) {\n                case PLUS:\n                    characterize(node.getPlus(), sub, characterization);\n                    break;\n                case MINUS:\n                    characterize(node.getMinus(), sub, characterization);\n                    break;\n                case BOTH:\n                    final SubHyperplane.SplitSubHyperplane\u003cS\u003e split \u003d sub.split(hyperplane);\n                    characterize(node.getPlus(),  split.getPlus(),  characterization);\n                    characterize(node.getMinus(), split.getMinus(), characterization);\n                    break;\n                default:\n                    // this should not happen\n                    throw new MathInternalError();\n                }\n            }\n        }",
    "begin_line": 362,
    "end_line": 399,
    "comment": "/** \n * Filter the parts of an hyperplane belonging to the boundary. \u003cp\u003eThe filtering consist in splitting the specified sub-hyperplane into several parts lying in inside and outside cells of the tree. The principle is to call this method twice for each cut sub-hyperplane in the tree, once one the plus node and once on the minus node. The parts that have the same flag (inside/inside or outside/outside) do not belong to the boundary while parts that have different flags (inside/outside or outside/inside) do belong to the boundary.\u003c/p\u003e\n * @param node current BSP tree node\n * @param sub sub-hyperplane to characterize\n * @param characterization placeholder where to put the characterized parts\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.getBoundarySize#404",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getBoundarySize()",
    "snippet": "public double getBoundarySize() {\n        final BoundarySizeVisitor\u003cS\u003e visitor \u003d new BoundarySizeVisitor\u003cS\u003e();\n        getTree(true).visit(visitor);\n        return visitor.getSize();\n    }",
    "begin_line": 404,
    "end_line": 408,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.getSize#411",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize()",
    "snippet": "public double getSize() {\n        if (barycenter \u003d\u003d null) {\n            computeGeometricalProperties();\n        }\n        return size;\n    }",
    "begin_line": 411,
    "end_line": 416,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.setSize#421",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.setSize(double)",
    "snippet": "protected void setSize(final double size) {\n        this.size \u003d size;\n    }",
    "begin_line": 421,
    "end_line": 423,
    "comment": "/** \n * Set the size of the instance.\n * @param size size of the instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.getBarycenter#426",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getBarycenter()",
    "snippet": "public Vector\u003cS\u003e getBarycenter() {\n        if (barycenter \u003d\u003d null) {\n            computeGeometricalProperties();\n        }\n        return barycenter;\n    }",
    "begin_line": 426,
    "end_line": 431,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.setBarycenter#436",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.setBarycenter(org.apache.commons.math3.geometry.Vector\u003cS\u003e)",
    "snippet": "protected void setBarycenter(final Vector\u003cS\u003e barycenter) {\n        this.barycenter \u003d barycenter;\n    }",
    "begin_line": 436,
    "end_line": 438,
    "comment": "/** \n * Set the barycenter of the instance.\n * @param barycenter barycenter of the instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.computeGeometricalProperties#443",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.computeGeometricalProperties()",
    "snippet": "protected abstract void computeGeometricalProperties();",
    "begin_line": 443,
    "end_line": 443,
    "comment": "/** \n * Compute some geometrical properties. \u003cp\u003eThe properties to compute are the barycenter and the size.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.side#446",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.side(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "public Side side(final Hyperplane\u003cS\u003e hyperplane) {\n        final Sides sides \u003d new Sides();\n        recurseSides(tree, hyperplane.wholeHyperplane(), sides);\n        return sides.plusFound() ?\n              (sides.minusFound() ? Side.BOTH  : Side.PLUS) :\n              (sides.minusFound() ? Side.MINUS : Side.HYPER);\n    }",
    "begin_line": 446,
    "end_line": 452,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.recurseSides#469",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseSides(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides)",
    "snippet": "private void recurseSides(final BSPTree\u003cS\u003e node, final SubHyperplane\u003cS\u003e sub, final Sides sides) {\n\n        if (node.getCut() \u003d\u003d null) {\n            if ((Boolean) node.getAttribute()) {\n                // this is an inside cell expanding across the hyperplane\n                sides.rememberPlusFound();\n                sides.rememberMinusFound();\n            }\n            return;\n        }\n\n        final Hyperplane\u003cS\u003e hyperplane \u003d node.getCut().getHyperplane();\n        switch (sub.side(hyperplane)) {\n        case PLUS :\n            // the sub-hyperplane is entirely in the plus sub-tree\n            if (node.getCut().side(sub.getHyperplane()) \u003d\u003d Side.PLUS) {\n                if (!isEmpty(node.getMinus())) {\n                    sides.rememberPlusFound();\n                }\n            } else {\n                if (!isEmpty(node.getMinus())) {\n                    sides.rememberMinusFound();\n                }\n            }\n            if (!(sides.plusFound() \u0026\u0026 sides.minusFound())) {\n                recurseSides(node.getPlus(), sub, sides);\n            }\n            break;\n        case MINUS :\n            // the sub-hyperplane is entirely in the minus sub-tree\n            if (node.getCut().side(sub.getHyperplane()) \u003d\u003d Side.PLUS) {\n                if (!isEmpty(node.getPlus())) {\n                    sides.rememberPlusFound();\n                }\n            } else {\n                if (!isEmpty(node.getPlus())) {\n                    sides.rememberMinusFound();\n                }\n            }\n            if (!(sides.plusFound() \u0026\u0026 sides.minusFound())) {\n                recurseSides(node.getMinus(), sub, sides);\n            }\n            break;\n        case BOTH :\n            // the sub-hyperplane extends in both sub-trees\n            final SubHyperplane.SplitSubHyperplane\u003cS\u003e split \u003d sub.split(hyperplane);\n\n            // explore first the plus sub-tree\n            recurseSides(node.getPlus(), split.getPlus(), sides);\n\n            // if needed, explore the minus sub-tree\n            if (!(sides.plusFound() \u0026\u0026 sides.minusFound())) {\n                recurseSides(node.getMinus(), split.getMinus(), sides);\n            }\n            break;\n        default :\n            // the sub-hyperplane and the cut sub-hyperplane share the same hyperplane\n            if (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {\n                if ((node.getPlus().getCut() !\u003d null) || ((Boolean) node.getPlus().getAttribute())) {\n                    sides.rememberPlusFound();\n                }\n                if ((node.getMinus().getCut() !\u003d null) || ((Boolean) node.getMinus().getAttribute())) {\n                    sides.rememberMinusFound();\n                }\n            } else {\n                if ((node.getPlus().getCut() !\u003d null) || ((Boolean) node.getPlus().getAttribute())) {\n                    sides.rememberMinusFound();\n                }\n                if ((node.getMinus().getCut() !\u003d null) || ((Boolean) node.getMinus().getAttribute())) {\n                    sides.rememberPlusFound();\n                }\n            }\n        }\n\n    }",
    "begin_line": 469,
    "end_line": 543,
    "comment": "/** \n * Search recursively for inside leaf nodes on each side of the given hyperplane. \u003cp\u003eThe algorithm used here is directly derived from the one described in section III (\u003ci\u003eBinary Partitioning of a BSP Tree\u003c/i\u003e) of the Bruce Naylor, John Amanatides and William Thibault paper \u003ca href\u003d\"http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf\"\u003eMerging BSP Trees Yields Polyhedral Set Operations\u003c/a\u003e Proc. Siggraph \u002790, Computer Graphics 24(4), August 1990, pp 115-124, published by the Association for Computing Machinery (ACM)..\u003c/p\u003e\n * @param node current BSP tree node\n * @param sub sub-hyperplane\n * @param sides object holding the sides found\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.Sides#556",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides()",
    "snippet": "public Sides() {\n            plusFound  \u003d false;\n            minusFound \u003d false;\n        }",
    "begin_line": 556,
    "end_line": 559,
    "comment": "/** \n * Simple constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.rememberPlusFound#563",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.rememberPlusFound()",
    "snippet": "public void rememberPlusFound() {\n            plusFound \u003d true;\n        }",
    "begin_line": 563,
    "end_line": 565,
    "comment": "/** \n * Remember the fact that inside leaf nodes have been found on the plus side.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.plusFound#570",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.plusFound()",
    "snippet": "public boolean plusFound() {\n            return plusFound;\n        }",
    "begin_line": 570,
    "end_line": 572,
    "comment": "/** \n * Check if inside leaf nodes have been found on the plus side.\n * @return true if inside leaf nodes have been found on the plus side\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.rememberMinusFound#576",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.rememberMinusFound()",
    "snippet": "public void rememberMinusFound() {\n            minusFound \u003d true;\n        }",
    "begin_line": 576,
    "end_line": 578,
    "comment": "/** \n * Remember the fact that inside leaf nodes have been found on the minus side.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.minusFound#583",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.minusFound()",
    "snippet": "public boolean minusFound() {\n            return minusFound;\n        }",
    "begin_line": 583,
    "end_line": 585,
    "comment": "/** \n * Check if inside leaf nodes have been found on the minus side.\n * @return true if inside leaf nodes have been found on the minus side\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.intersection#590",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.intersection(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "public SubHyperplane\u003cS\u003e intersection(final SubHyperplane\u003cS\u003e sub) {\n        return recurseIntersection(tree, sub);\n    }",
    "begin_line": 590,
    "end_line": 592,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.recurseIntersection#600",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseIntersection(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "private SubHyperplane\u003cS\u003e recurseIntersection(final BSPTree\u003cS\u003e node, final SubHyperplane\u003cS\u003e sub) {\n\n        if (node.getCut() \u003d\u003d null) {\n            return (Boolean) node.getAttribute() ? sub.copySelf() : null;\n        }\n\n        final Hyperplane\u003cS\u003e hyperplane \u003d node.getCut().getHyperplane();\n        switch (sub.side(hyperplane)) {\n        case PLUS :\n            return recurseIntersection(node.getPlus(), sub);\n        case MINUS :\n            return recurseIntersection(node.getMinus(), sub);\n        case BOTH :\n            final SubHyperplane.SplitSubHyperplane\u003cS\u003e split \u003d sub.split(hyperplane);\n            final SubHyperplane\u003cS\u003e plus  \u003d recurseIntersection(node.getPlus(),  split.getPlus());\n            final SubHyperplane\u003cS\u003e minus \u003d recurseIntersection(node.getMinus(), split.getMinus());\n            if (plus \u003d\u003d null) {\n                return minus;\n            } else if (minus \u003d\u003d null) {\n                return plus;\n            } else {\n                return plus.reunite(minus);\n            }\n        default :\n            return recurseIntersection(node.getPlus(),\n                                       recurseIntersection(node.getMinus(), sub));\n        }\n\n    }",
    "begin_line": 600,
    "end_line": 628,
    "comment": "/** \n * Recursively compute the parts of a sub-hyperplane that are contained in the region.\n * @param node current BSP tree node\n * @param sub sub-hyperplane traversing the region\n * @return filtered sub-hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.applyTransform#640",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.applyTransform(org.apache.commons.math3.geometry.partitioning.Transform\u003cS,T\u003e)",
    "snippet": "public AbstractRegion\u003cS, T\u003e applyTransform(final Transform\u003cS, T\u003e transform) {\n        return buildNew(recurseTransform(getTree(false), transform));\n    }",
    "begin_line": 640,
    "end_line": 642,
    "comment": "/** \n * Transform a region. \u003cp\u003eApplying a transform to a region consist in applying the transform to all the hyperplanes of the underlying BSP tree and of the boundary (and also to the sub-hyperplanes embedded in these hyperplanes) and to the barycenter. The instance is not modified, a new instance is built.\u003c/p\u003e\n * @param transform transform to apply\n * @return a new region, resulting from the application of thetransform to the instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.recurseTransform#650",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseTransform(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.Transform\u003cS,T\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n    private BSPTree\u003cS\u003e recurseTransform(final BSPTree\u003cS\u003e node, final Transform\u003cS, T\u003e transform) {\n\n        if (node.getCut() \u003d\u003d null) {\n            return new BSPTree\u003cS\u003e(node.getAttribute());\n        }\n\n        final SubHyperplane\u003cS\u003e  sub \u003d node.getCut();\n        final SubHyperplane\u003cS\u003e tSub \u003d ((AbstractSubHyperplane\u003cS, T\u003e) sub).applyTransform(transform);\n        BoundaryAttribute\u003cS\u003e attribute \u003d (BoundaryAttribute\u003cS\u003e) node.getAttribute();\n        if (attribute !\u003d null) {\n            final SubHyperplane\u003cS\u003e tPO \u003d (attribute.getPlusOutside() \u003d\u003d null) ?\n                null : ((AbstractSubHyperplane\u003cS, T\u003e) attribute.getPlusOutside()).applyTransform(transform);\n            final SubHyperplane\u003cS\u003e tPI \u003d (attribute.getPlusInside()  \u003d\u003d null) ?\n                null  : ((AbstractSubHyperplane\u003cS, T\u003e) attribute.getPlusInside()).applyTransform(transform);\n            attribute \u003d new BoundaryAttribute\u003cS\u003e(tPO, tPI);\n        }\n\n        return new BSPTree\u003cS\u003e(tSub,\n                                    recurseTransform(node.getPlus(),  transform),\n                                    recurseTransform(node.getMinus(), transform),\n                                    attribute);\n\n    }",
    "begin_line": 650,
    "end_line": 672,
    "comment": "/** \n * Recursively transform an inside/outside BSP-tree.\n * @param node current BSP tree node\n * @param transform transform to apply\n * @return a new tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.AbstractSubHyperplane#49",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.AbstractSubHyperplane(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003cT\u003e)",
    "snippet": "protected AbstractSubHyperplane(final Hyperplane\u003cS\u003e hyperplane,\n                                    final Region\u003cT\u003e remainingRegion) {\n        this.hyperplane      \u003d hyperplane;\n        this.remainingRegion \u003d remainingRegion;\n    }",
    "begin_line": 49,
    "end_line": 53,
    "comment": "/** \n * Build a sub-hyperplane from an hyperplane and a region.\n * @param hyperplane underlying hyperplane\n * @param remainingRegion remaining region of the hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.buildNew#60",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.buildNew(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003cT\u003e)",
    "snippet": "protected abstract AbstractSubHyperplane\u003cS, T\u003e buildNew(final Hyperplane\u003cS\u003e hyper,\n                                                            final Region\u003cT\u003e remaining);",
    "begin_line": 60,
    "end_line": 61,
    "comment": "/** \n * Build a sub-hyperplane from an hyperplane and a region.\n * @param hyper underlying hyperplane\n * @param remaining remaining region of the hyperplane\n * @return a new sub-hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.copySelf#64",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.copySelf()",
    "snippet": "public AbstractSubHyperplane\u003cS, T\u003e copySelf() {\n        return buildNew(hyperplane, remainingRegion);\n    }",
    "begin_line": 64,
    "end_line": 66,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.getHyperplane#71",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getHyperplane()",
    "snippet": "public Hyperplane\u003cS\u003e getHyperplane() {\n        return hyperplane;\n    }",
    "begin_line": 71,
    "end_line": 73,
    "comment": "/** \n * Get the underlying hyperplane.\n * @return underlying hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.getRemainingRegion#82",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getRemainingRegion()",
    "snippet": "public Region\u003cT\u003e getRemainingRegion() {\n        return remainingRegion;\n    }",
    "begin_line": 82,
    "end_line": 84,
    "comment": "/** \n * Get the remaining region of the hyperplane. \u003cp\u003eThe returned region is expressed in the canonical hyperplane frame and has the hyperplane dimension. For example a chopped hyperplane in the 3D euclidean is a 2D plane and the corresponding region is a convex 2D polygon.\u003c/p\u003e\n * @return remaining region of the hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.getSize#87",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getSize()",
    "snippet": "public double getSize() {\n        return remainingRegion.getSize();\n    }",
    "begin_line": 87,
    "end_line": 89,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.reunite#92",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.reunite(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "public AbstractSubHyperplane\u003cS, T\u003e reunite(final SubHyperplane\u003cS\u003e other) {\n        @SuppressWarnings(\"unchecked\")\n        AbstractSubHyperplane\u003cS, T\u003e o \u003d (AbstractSubHyperplane\u003cS, T\u003e) other;\n        return buildNew(hyperplane,\n                        new RegionFactory\u003cT\u003e().union(remainingRegion, o.remainingRegion));\n    }",
    "begin_line": 92,
    "end_line": 97,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.applyTransform#109",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.applyTransform(org.apache.commons.math3.geometry.partitioning.Transform\u003cS,T\u003e)",
    "snippet": "public AbstractSubHyperplane\u003cS, T\u003e applyTransform(final Transform\u003cS, T\u003e transform) {\n        final Hyperplane\u003cS\u003e tHyperplane \u003d transform.apply(hyperplane);\n        final BSPTree\u003cT\u003e tTree \u003d\n            recurseTransform(remainingRegion.getTree(false), tHyperplane, transform);\n        return buildNew(tHyperplane, remainingRegion.buildNew(tTree));\n    }",
    "begin_line": 109,
    "end_line": 114,
    "comment": "/** \n * Apply a transform to the instance. \u003cp\u003eThe instance must be a (D-1)-dimension sub-hyperplane with respect to the transform \u003cem\u003enot\u003c/em\u003e a (D-2)-dimension sub-hyperplane the transform knows how to transform by itself. The transform will consist in transforming first the hyperplane and then the all region using the various methods provided by the transform.\u003c/p\u003e\n * @param transform D-dimension transform to apply\n * @return the transformed instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.recurseTransform#122",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.recurseTransform(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cT\u003e, org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.Transform\u003cS,T\u003e)",
    "snippet": "private BSPTree\u003cT\u003e recurseTransform(final BSPTree\u003cT\u003e node,\n                                        final Hyperplane\u003cS\u003e transformed,\n                                        final Transform\u003cS, T\u003e transform) {\n        if (node.getCut() \u003d\u003d null) {\n            return new BSPTree\u003cT\u003e(node.getAttribute());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        BoundaryAttribute\u003cT\u003e attribute \u003d\n            (BoundaryAttribute\u003cT\u003e) node.getAttribute();\n        if (attribute !\u003d null) {\n            final SubHyperplane\u003cT\u003e tPO \u003d (attribute.getPlusOutside() \u003d\u003d null) ?\n                null : transform.apply(attribute.getPlusOutside(), hyperplane, transformed);\n            final SubHyperplane\u003cT\u003e tPI \u003d (attribute.getPlusInside() \u003d\u003d null) ?\n                null : transform.apply(attribute.getPlusInside(), hyperplane, transformed);\n            attribute \u003d new BoundaryAttribute\u003cT\u003e(tPO, tPI);\n        }\n\n        return new BSPTree\u003cT\u003e(transform.apply(node.getCut(), hyperplane, transformed),\n                              recurseTransform(node.getPlus(), transformed, transform),\n                              recurseTransform(node.getMinus(), transformed, transform),\n                              attribute);\n\n    }",
    "begin_line": 122,
    "end_line": 145,
    "comment": "/** \n * Recursively transform a BSP-tree from a sub-hyperplane.\n * @param node current BSP tree node\n * @param transformed image of the instance hyperplane by the transform\n * @param transform transform to apply\n * @return a new tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.side#148",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.side(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "public abstract Side side(Hyperplane\u003cS\u003e hyper);",
    "begin_line": 148,
    "end_line": 148,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.split#151",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.split(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "public abstract SplitSubHyperplane\u003cS\u003e split(Hyperplane\u003cS\u003e hyper);",
    "begin_line": 151,
    "end_line": 151,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.isEmpty#154",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.isEmpty()",
    "snippet": "public boolean isEmpty() {\n        return remainingRegion.isEmpty();\n    }",
    "begin_line": 154,
    "end_line": 156,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.BSPTree#82",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree()",
    "snippet": "public BSPTree() {\n        cut       \u003d null;\n        plus      \u003d null;\n        minus     \u003d null;\n        parent    \u003d null;\n        attribute \u003d null;\n    }",
    "begin_line": 82,
    "end_line": 88,
    "comment": "/** \n * Build a tree having only one root cell representing the whole space.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.BSPTree#93",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(java.lang.Object)",
    "snippet": "public BSPTree(final Object attribute) {\n        cut    \u003d null;\n        plus   \u003d null;\n        minus  \u003d null;\n        parent \u003d null;\n        this.attribute \u003d attribute;\n    }",
    "begin_line": 93,
    "end_line": 99,
    "comment": "/** \n * Build a tree having only one root cell representing the whole space.\n * @param attribute attribute of the tree (may be null)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.BSPTree#114",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, java.lang.Object)",
    "snippet": "public BSPTree(final SubHyperplane\u003cS\u003e cut, final BSPTree\u003cS\u003e plus, final BSPTree\u003cS\u003e minus,\n                   final Object attribute) {\n        this.cut       \u003d cut;\n        this.plus      \u003d plus;\n        this.minus     \u003d minus;\n        this.parent    \u003d null;\n        this.attribute \u003d attribute;\n        plus.parent    \u003d this;\n        minus.parent   \u003d this;\n    }",
    "begin_line": 114,
    "end_line": 123,
    "comment": "/** \n * Build a BSPTree from its underlying elements. \u003cp\u003eThis method does \u003cem\u003enot\u003c/em\u003e perform any verification on consistency of its arguments, it should therefore be used only when then caller knows what it is doing.\u003c/p\u003e \u003cp\u003eThis method is mainly useful kto build trees bottom-up. Building trees top-down is realized with the help of method  {@link #insertCut insertCut}.\u003c/p\u003e\n * @param cut cut sub-hyperplane for the tree\n * @param plus plus side sub-tree\n * @param minus minus side sub-tree\n * @param attribute attribute associated with the node (may be null)\n * @see #insertCut\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.insertCut#148",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "public boolean insertCut(final Hyperplane\u003cS\u003e hyperplane) {\n\n        if (cut !\u003d null) {\n            plus.parent  \u003d null;\n            minus.parent \u003d null;\n        }\n\n        final SubHyperplane\u003cS\u003e chopped \u003d fitToCell(hyperplane.wholeHyperplane());\n        if (chopped \u003d\u003d null || chopped.isEmpty()) {\n            cut          \u003d null;\n            plus         \u003d null;\n            minus        \u003d null;\n            return false;\n        }\n\n        cut          \u003d chopped;\n        plus         \u003d new BSPTree\u003cS\u003e();\n        plus.parent  \u003d this;\n        minus        \u003d new BSPTree\u003cS\u003e();\n        minus.parent \u003d this;\n        return true;\n\n    }",
    "begin_line": 148,
    "end_line": 170,
    "comment": "/** \n * Insert a cut sub-hyperplane in a node. \u003cp\u003eThe sub-tree starting at this node will be completely overwritten. The new cut sub-hyperplane will be built from the intersection of the provided hyperplane with the cell. If the hyperplane does intersect the cell, the cell will have two children cells with  {@code null} attributes on each side ofthe inserted cut sub-hyperplane. If the hyperplane does not intersect the cell then \u003cem\u003eno\u003c/em\u003e cut hyperplane will be inserted and the cell will be changed to a leaf cell. The attribute of the node is never changed.\u003c/p\u003e \u003cp\u003eThis method is mainly useful when called on leaf nodes (i.e. nodes for which  {@link #getCut getCut} returns{@code null}), in this case it provides a way to build a tree top-down (whereas the  {@link #BSPTree(SubHyperplane,BSPTree,BSPTree,Object) 4 arguments constructor} is devoted tobuild trees bottom-up).\u003c/p\u003e\n * @param hyperplane hyperplane to insert, it will be chopped inorder to fit in the cell defined by the parent nodes of the instance\n * @return true if a cut sub-hyperplane has been inserted (i.e. ifthe cell now has two leaf child nodes)\n * @see #BSPTree(SubHyperplane,BSPTree,BSPTree,Object)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.copySelf#179",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.copySelf()",
    "snippet": "public BSPTree\u003cS\u003e copySelf() {\n\n        if (cut \u003d\u003d null) {\n            return new BSPTree\u003cS\u003e(attribute);\n        }\n\n        return new BSPTree\u003cS\u003e(cut.copySelf(), plus.copySelf(), minus.copySelf(),\n                           attribute);\n\n    }",
    "begin_line": 179,
    "end_line": 188,
    "comment": "/** \n * Copy the instance. \u003cp\u003eThe instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for the nodes attributes and immutable objects).\u003c/p\u003e\n * @return a new tree, copy of the instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getCut#193",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getCut()",
    "snippet": "public SubHyperplane\u003cS\u003e getCut() {\n        return cut;\n    }",
    "begin_line": 193,
    "end_line": 195,
    "comment": "/** \n * Get the cut sub-hyperplane.\n * @return cut sub-hyperplane, null if this is a leaf tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getPlus#201",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getPlus()",
    "snippet": "public BSPTree\u003cS\u003e getPlus() {\n        return plus;\n    }",
    "begin_line": 201,
    "end_line": 203,
    "comment": "/** \n * Get the tree on the plus side of the cut hyperplane.\n * @return tree on the plus side of the cut hyperplane, null if thisis a leaf tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getMinus#209",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getMinus()",
    "snippet": "public BSPTree\u003cS\u003e getMinus() {\n        return minus;\n    }",
    "begin_line": 209,
    "end_line": 211,
    "comment": "/** \n * Get the tree on the minus side of the cut hyperplane.\n * @return tree on the minus side of the cut hyperplane, null if thisis a leaf tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getParent#216",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getParent()",
    "snippet": "public BSPTree\u003cS\u003e getParent() {\n        return parent;\n    }",
    "begin_line": 216,
    "end_line": 218,
    "comment": "/** \n * Get the parent node.\n * @return parent node, null if the node has no parents\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.setAttribute#224",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.setAttribute(java.lang.Object)",
    "snippet": "public void setAttribute(final Object attribute) {\n        this.attribute \u003d attribute;\n    }",
    "begin_line": 224,
    "end_line": 226,
    "comment": "/** \n * Associate an attribute with the instance.\n * @param attribute attribute to associate with the node\n * @see #getAttribute\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getAttribute#234",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getAttribute()",
    "snippet": "public Object getAttribute() {\n        return attribute;\n    }",
    "begin_line": 234,
    "end_line": 236,
    "comment": "/** \n * Get the attribute associated with the instance.\n * @return attribute associated with the node or null if noattribute has been explicitly set using the  {@link #setAttribute setAttribute} method\n * @see #setAttribute\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.visit#241",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.visit(org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor\u003cS\u003e)",
    "snippet": "public void visit(final BSPTreeVisitor\u003cS\u003e visitor) {\n        if (cut \u003d\u003d null) {\n            visitor.visitLeafNode(this);\n        } else {\n            switch (visitor.visitOrder(this)) {\n            case PLUS_MINUS_SUB:\n                plus.visit(visitor);\n                minus.visit(visitor);\n                visitor.visitInternalNode(this);\n                break;\n            case PLUS_SUB_MINUS:\n                plus.visit(visitor);\n                visitor.visitInternalNode(this);\n                minus.visit(visitor);\n                break;\n            case MINUS_PLUS_SUB:\n                minus.visit(visitor);\n                plus.visit(visitor);\n                visitor.visitInternalNode(this);\n                break;\n            case MINUS_SUB_PLUS:\n                minus.visit(visitor);\n                visitor.visitInternalNode(this);\n                plus.visit(visitor);\n                break;\n            case SUB_PLUS_MINUS:\n                visitor.visitInternalNode(this);\n                plus.visit(visitor);\n                minus.visit(visitor);\n                break;\n            case SUB_MINUS_PLUS:\n                visitor.visitInternalNode(this);\n                minus.visit(visitor);\n                plus.visit(visitor);\n                break;\n            default:\n                throw new MathInternalError();\n            }\n\n        }\n    }",
    "begin_line": 241,
    "end_line": 281,
    "comment": "/** \n * Visit the BSP tree nodes.\n * @param visitor object visiting the tree nodes\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.fitToCell#291",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "private SubHyperplane\u003cS\u003e fitToCell(final SubHyperplane\u003cS\u003e sub) {\n        SubHyperplane\u003cS\u003e s \u003d sub;\n        for (BSPTree\u003cS\u003e tree \u003d this; tree.parent !\u003d null; tree \u003d tree.parent) {\n            if (tree \u003d\u003d tree.parent.plus) {\n                s \u003d s.split(tree.parent.cut.getHyperplane()).getPlus();\n            } else {\n                s \u003d s.split(tree.parent.cut.getHyperplane()).getMinus();\n            }\n        }\n        return s;\n    }",
    "begin_line": 291,
    "end_line": 301,
    "comment": "/** \n * Fit a sub-hyperplane inside the cell defined by the instance. \u003cp\u003eFitting is done by chopping off the parts of the sub-hyperplane that lie outside of the cell using the cut-hyperplanes of the parent nodes of the instance.\u003c/p\u003e\n * @param sub sub-hyperplane to fit\n * @return a new sub-hyperplane, guaranteed to have no part outsideof the instance cell\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getCell#310",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getCell(org.apache.commons.math3.geometry.Vector\u003cS\u003e)",
    "snippet": "public BSPTree\u003cS\u003e getCell(final Vector\u003cS\u003e point) {\n\n        if (cut \u003d\u003d null) {\n            return this;\n        }\n\n        // position of the point with respect to the cut hyperplane\n        final double offset \u003d cut.getHyperplane().getOffset(point);\n\n        if (FastMath.abs(offset) \u003c 1.0e-10) {\n            return this;\n        } else if (offset \u003c\u003d 0) {\n            // point is on the minus side of the cut hyperplane\n            return minus.getCell(point);\n        } else {\n            // point is on the plus side of the cut hyperplane\n            return plus.getCell(point);\n        }\n\n    }",
    "begin_line": 310,
    "end_line": 329,
    "comment": "/** \n * Get the cell to which a point belongs. \u003cp\u003eIf the returned cell is a leaf node the points belongs to the interior of the node, if the cell is an internal node the points belongs to the node cut sub-hyperplane.\u003c/p\u003e\n * @param point point to check\n * @return the tree cell to which the point belongs (can be\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.condense#335",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.condense()",
    "snippet": "private void condense() {\n        if ((cut !\u003d null) \u0026\u0026 (plus.cut \u003d\u003d null) \u0026\u0026 (minus.cut \u003d\u003d null) \u0026\u0026\n            (((plus.attribute \u003d\u003d null) \u0026\u0026 (minus.attribute \u003d\u003d null)) ||\n             ((plus.attribute !\u003d null) \u0026\u0026 plus.attribute.equals(minus.attribute)))) {\n            attribute \u003d (plus.attribute \u003d\u003d null) ? minus.attribute : plus.attribute;\n            cut       \u003d null;\n            plus      \u003d null;\n            minus     \u003d null;\n        }\n    }",
    "begin_line": 335,
    "end_line": 344,
    "comment": "/** \n * Perform condensation on a tree. \u003cp\u003eThe condensation operation is not recursive, it must be called explicitely from leaves to root.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.merge#364",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree.LeafMerger\u003cS\u003e)",
    "snippet": "public BSPTree\u003cS\u003e merge(final BSPTree\u003cS\u003e tree, final LeafMerger\u003cS\u003e leafMerger) {\n        return merge(tree, leafMerger, null, false);\n    }",
    "begin_line": 364,
    "end_line": 366,
    "comment": "/** \n * Merge a BSP tree with the instance. \u003cp\u003eAll trees are modified (parts of them are reused in the new tree), it is the responsibility of the caller to ensure a copy has been done before if any of the former tree should be preserved, \u003cem\u003eno\u003c/em\u003e such copy is done here!\u003c/p\u003e \u003cp\u003eThe algorithm used here is directly derived from the one described in the Naylor, Amanatides and Thibault paper (section III, Binary Partitioning of a BSP Tree).\u003c/p\u003e\n * @param tree other tree to merge with the instance (will be\u003cem\u003eunusable\u003c/em\u003e after the operation, as well as the instance itself)\n * @param leafMerger object implementing the final merging phase(this is where the semantic of the operation occurs, generally depending on the attribute of the leaf node)\n * @return a new tree, result of \u003ccode\u003einstance \u0026lt;op\u0026gt;tree\u003c/code\u003e, this value can be ignored if parentTree is not null since all connections have already been established\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.merge#383",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree.LeafMerger\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, boolean)",
    "snippet": "private BSPTree\u003cS\u003e merge(final BSPTree\u003cS\u003e tree, final LeafMerger\u003cS\u003e leafMerger,\n                             final BSPTree\u003cS\u003e parentTree, final boolean isPlusChild) {\n        if (cut \u003d\u003d null) {\n            // cell/tree operation\n            return leafMerger.merge(this, tree, parentTree, isPlusChild, true);\n        } else if (tree.cut \u003d\u003d null) {\n            // tree/cell operation\n            return leafMerger.merge(tree, this, parentTree, isPlusChild, false);\n        } else {\n            // tree/tree operation\n            final BSPTree\u003cS\u003e merged \u003d tree.split(cut);\n            if (parentTree !\u003d null) {\n                merged.parent \u003d parentTree;\n                if (isPlusChild) {\n                    parentTree.plus \u003d merged;\n                } else {\n                    parentTree.minus \u003d merged;\n                }\n            }\n\n            // merging phase\n            plus.merge(merged.plus, leafMerger, merged, true);\n            minus.merge(merged.minus, leafMerger, merged, false);\n            merged.condense();\n            if (merged.cut !\u003d null) {\n                merged.cut \u003d\n                    merged.fitToCell(merged.cut.getHyperplane().wholeHyperplane());\n            }\n\n            return merged;\n\n        }\n    }",
    "begin_line": 383,
    "end_line": 415,
    "comment": "/** \n * Merge a BSP tree with the instance.\n * @param tree other tree to merge with the instance (will be\u003cem\u003eunusable\u003c/em\u003e after the operation, as well as the instance itself)\n * @param leafMerger object implementing the final merging phase(this is where the semantic of the operation occurs, generally depending on the attribute of the leaf node)\n * @param parentTree parent tree to connect to (may be null)\n * @param isPlusChild if true and if parentTree is not null, theresulting tree should be the plus child of its parent, ignored if parentTree is null\n * @return a new tree, result of \u003ccode\u003einstance \u0026lt;op\u0026gt;tree\u003c/code\u003e, this value can be ignored if parentTree is not null since all connections have already been established\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.merge#464",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, boolean, boolean)",
    "snippet": "BSPTree\u003cS\u003e merge(BSPTree\u003cS\u003e leaf, BSPTree\u003cS\u003e tree, BSPTree\u003cS\u003e parentTree,\n                         boolean isPlusChild, boolean leafFromInstance);",
    "begin_line": 464,
    "end_line": 465,
    "comment": "/** \n * Merge a leaf node and a tree node. \u003cp\u003eThis method is called at the end of a recursive merging resulting from a  {@code tree1.merge(tree2, leafMerger)}call, when one of the sub-trees involved is a leaf (i.e. when its cut-hyperplane is null). This is the only place where the precise semantics of the operation are required. For all upper level nodes in the tree, the merging operation is only a generic partitioning algorithm.\u003c/p\u003e \u003cp\u003eSince the final operation may be non-commutative, it is important to know if the leaf node comes from the instance tree ( {@code tree1}) or the argument tree ( {@code tree2}). The third argument of the method is devoted to this. It can be ignored for commutative operations.\u003c/p\u003e \u003cp\u003eThe  {@link BSPTree#insertInTree BSPTree.insertInTree} methodmay be useful to implement this method.\u003c/p\u003e\n * @param leaf leaf node (its cut hyperplane is guaranteed to benull)\n * @param tree tree node (its cut hyperplane may be null or not)\n * @param parentTree parent tree to connect to (may be null)\n * @param isPlusChild if true and if parentTree is not null, theresulting tree should be the plus child of its parent, ignored if parentTree is null\n * @param leafFromInstance if true, the leaf node comes from theinstance tree ( {@code tree1}) and the tree node comes from the argument tree ( {@code tree2})\n * @return the BSP tree resulting from the merging (may be one ofthe arguments)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.split#487",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.split(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "public BSPTree\u003cS\u003e split(final SubHyperplane\u003cS\u003e sub) {\n\n        if (cut \u003d\u003d null) {\n            return new BSPTree\u003cS\u003e(sub, copySelf(),\n                    new BSPTree\u003cS\u003e(attribute), null);\n        }\n\n        final Hyperplane\u003cS\u003e cHyperplane \u003d cut.getHyperplane();\n        final Hyperplane\u003cS\u003e sHyperplane \u003d sub.getHyperplane();\n        switch (sub.side(cHyperplane)) {\n        case PLUS :\n        { // the partitioning sub-hyperplane is entirely in the plus sub-tree\n            final BSPTree\u003cS\u003e split \u003d plus.split(sub);\n            if (cut.side(sHyperplane) \u003d\u003d Side.PLUS) {\n                split.plus \u003d\n                    new BSPTree\u003cS\u003e(cut.copySelf(), split.plus, minus.copySelf(), attribute);\n                split.plus.condense();\n                split.plus.parent \u003d split;\n            } else {\n                split.minus \u003d\n                    new BSPTree\u003cS\u003e(cut.copySelf(), split.minus, minus.copySelf(), attribute);\n                split.minus.condense();\n                split.minus.parent \u003d split;\n            }\n            return split;\n        }\n        case MINUS :\n        { // the partitioning sub-hyperplane is entirely in the minus sub-tree\n            final BSPTree\u003cS\u003e split \u003d minus.split(sub);\n            if (cut.side(sHyperplane) \u003d\u003d Side.PLUS) {\n                split.plus \u003d\n                    new BSPTree\u003cS\u003e(cut.copySelf(), plus.copySelf(), split.plus, attribute);\n                split.plus.condense();\n                split.plus.parent \u003d split;\n            } else {\n                split.minus \u003d\n                    new BSPTree\u003cS\u003e(cut.copySelf(), plus.copySelf(), split.minus, attribute);\n                split.minus.condense();\n                split.minus.parent \u003d split;\n            }\n            return split;\n        }\n        case BOTH :\n        {\n            final SubHyperplane.SplitSubHyperplane\u003cS\u003e cutParts \u003d cut.split(sHyperplane);\n            final SubHyperplane.SplitSubHyperplane\u003cS\u003e subParts \u003d sub.split(cHyperplane);\n            final BSPTree\u003cS\u003e split \u003d\n                new BSPTree\u003cS\u003e(sub, plus.split(subParts.getPlus()), minus.split(subParts.getMinus()),\n                               null);\n            split.plus.cut          \u003d cutParts.getPlus();\n            split.minus.cut         \u003d cutParts.getMinus();\n            final BSPTree\u003cS\u003e tmp    \u003d split.plus.minus;\n            split.plus.minus        \u003d split.minus.plus;\n            split.plus.minus.parent \u003d split.plus;\n            split.minus.plus        \u003d tmp;\n            split.minus.plus.parent \u003d split.minus;\n            split.plus.condense();\n            split.minus.condense();\n            return split;\n        }\n        default :\n            return cHyperplane.sameOrientationAs(sHyperplane) ?\n                   new BSPTree\u003cS\u003e(sub, plus.copySelf(),  minus.copySelf(), attribute) :\n                   new BSPTree\u003cS\u003e(sub, minus.copySelf(), plus.copySelf(),  attribute);\n        }\n\n    }",
    "begin_line": 487,
    "end_line": 553,
    "comment": "/** \n * Split a BSP tree by an external sub-hyperplane. \u003cp\u003eSplit a tree in two halves, on each side of the sub-hyperplane. The instance is not modified.\u003c/p\u003e \u003cp\u003eThe tree returned is not upward-consistent: despite all of its sub-trees cut sub-hyperplanes (including its own cut sub-hyperplane) are bounded to the current cell, it is \u003cem\u003enot\u003c/em\u003e attached to any parent tree yet. This tree is intended to be later inserted into an higher level tree.\u003c/p\u003e \u003cp\u003eThe algorithm used here is the one given in Naylor, Amanatides and Thibault paper (section III, Binary Partitioning of a BSP Tree).\u003c/p\u003e\n * @param sub partitioning sub-hyperplane, must be already clippedto the convex region represented by the instance, will be used as the cut sub-hyperplane of the returned tree\n * @return a tree having the specified sub-hyperplane as its cutsub-hyperplane, the two parts of the split instance as its two sub-trees and a null parent\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.insertInTree#564",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.insertInTree(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, boolean)",
    "snippet": "public void insertInTree(final BSPTree\u003cS\u003e parentTree, final boolean isPlusChild) {\n\n        // set up parent/child links\n        parent \u003d parentTree;\n        if (parentTree !\u003d null) {\n            if (isPlusChild) {\n                parentTree.plus \u003d this;\n            } else {\n                parentTree.minus \u003d this;\n            }\n        }\n\n        // make sure the inserted tree lies in the cell defined by its parent nodes\n        if (cut !\u003d null) {\n\n            // explore the parent nodes from here towards tree root\n            for (BSPTree\u003cS\u003e tree \u003d this; tree.parent !\u003d null; tree \u003d tree.parent) {\n\n                // this is an hyperplane of some parent node\n                final Hyperplane\u003cS\u003e hyperplane \u003d tree.parent.cut.getHyperplane();\n\n                // chop off the parts of the inserted tree that extend\n                // on the wrong side of this parent hyperplane\n                if (tree \u003d\u003d tree.parent.plus) {\n                    cut \u003d cut.split(hyperplane).getPlus();\n                    plus.chopOffMinus(hyperplane);\n                    minus.chopOffMinus(hyperplane);\n                } else {\n                    cut \u003d cut.split(hyperplane).getMinus();\n                    plus.chopOffPlus(hyperplane);\n                    minus.chopOffPlus(hyperplane);\n                }\n\n            }\n\n            // since we may have drop some parts of the inserted tree,\n            // perform a condensation pass to keep the tree structure simple\n            condense();\n\n        }\n\n    }",
    "begin_line": 564,
    "end_line": 605,
    "comment": "/** \n * Insert the instance into another tree. \u003cp\u003eThe instance itself is modified so its former parent should not be used anymore.\u003c/p\u003e\n * @param parentTree parent tree to connect to (may be null)\n * @param isPlusChild if true and if parentTree is not null, theresulting tree should be the plus child of its parent, ignored if parentTree is null\n * @see LeafMerger\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.chopOffMinus#613",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.chopOffMinus(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "private void chopOffMinus(final Hyperplane\u003cS\u003e hyperplane) {\n        if (cut !\u003d null) {\n            cut \u003d cut.split(hyperplane).getPlus();\n            plus.chopOffMinus(hyperplane);\n            minus.chopOffMinus(hyperplane);\n        }\n    }",
    "begin_line": 613,
    "end_line": 619,
    "comment": "/** \n * Chop off parts of the tree. \u003cp\u003eThe instance is modified in place, all the parts that are on the minus side of the chopping hyperplane are discarded, only the parts on the plus side remain.\u003c/p\u003e\n * @param hyperplane chopping hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.chopOffPlus#627",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.chopOffPlus(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "private void chopOffPlus(final Hyperplane\u003cS\u003e hyperplane) {\n        if (cut !\u003d null) {\n            cut \u003d cut.split(hyperplane).getMinus();\n            plus.chopOffPlus(hyperplane);\n            minus.chopOffPlus(hyperplane);\n        }\n    }",
    "begin_line": 627,
    "end_line": 633,
    "comment": "/** \n * Chop off parts of the tree. \u003cp\u003eThe instance is modified in place, all the parts that are on the plus side of the chopping hyperplane are discarded, only the parts on the minus side remain.\u003c/p\u003e\n * @param hyperplane chopping hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.FastMath#359",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.FastMath()",
    "snippet": "private FastMath() {}",
    "begin_line": 359,
    "end_line": 359,
    "comment": "/** \n * Private Constructor\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.doubleHighPart#370",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.doubleHighPart(double)",
    "snippet": "private static double doubleHighPart(double d) {\n        if (d \u003e -Precision.SAFE_MIN \u0026\u0026 d \u003c Precision.SAFE_MIN){\n            return d; // These are un-normalised - don\u0027t try to convert\n        }\n        long xl \u003d Double.doubleToRawLongBits(d); // can take raw bits because just gonna convert it back\n        xl \u003d xl \u0026 MASK_30BITS; // Drop low order bits\n        return Double.longBitsToDouble(xl);\n    }",
    "begin_line": 370,
    "end_line": 377,
    "comment": "/** \n * Get the high order bits from the mantissa. Equivalent to adding and subtracting HEX_40000 but also works for very large numbers\n * @param d the value to split\n * @return the high order part of the mantissa\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sqrt#384",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
    "snippet": "public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "begin_line": 384,
    "end_line": 386,
    "comment": "/** \n * Compute the square root of a number. \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e this implementation currently delegates to  {@link Math#sqrt}\n * @param a number on which evaluation is done\n * @return square root of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cosh#392",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cosh(double)",
    "snippet": "public static double cosh(double x) {\n      if (x !\u003d x) {\n          return x;\n      }\n\n      // cosh[z] \u003d (exp(z) + exp(-z))/2\n\n      // for numbers with magnitude 20 or so,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x \u003e 20) {\n          if (x \u003e\u003d LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t \u003d exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x \u003c -20) {\n          if (x \u003c\u003d -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t \u003d exp(-0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(-x);\n          }\n      }\n\n      final double hiPrec[] \u003d new double[2];\n      if (x \u003c 0.0) {\n          x \u003d -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya \u003d hiPrec[0] + hiPrec[1];\n      double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp \u003d ya * HEX_40000000;\n      double yaa \u003d ya + temp - temp;\n      double yab \u003d ya - yaa;\n\n      // recip \u003d 1/y\n      double recip \u003d 1.0/ya;\n      temp \u003d recip * HEX_40000000;\n      double recipa \u003d recip + temp - temp;\n      double recipb \u003d recip - recipa;\n\n      // Correct for rounding in division\n      recipb +\u003d (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      // Account for yb\n      recipb +\u003d -yb * recip * recip;\n\n      // y \u003d y + 1/y\n      temp \u003d ya + recipa;\n      yb +\u003d -(temp - ya - recipa);\n      ya \u003d temp;\n      temp \u003d ya + recipb;\n      yb +\u003d -(temp - ya - recipb);\n      ya \u003d temp;\n\n      double result \u003d ya + yb;\n      result *\u003d 0.5;\n      return result;\n    }",
    "begin_line": 392,
    "end_line": 455,
    "comment": "/** \n * Compute the hyperbolic cosine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic cosine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sinh#461",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sinh(double)",
    "snippet": "public static double sinh(double x) {\n      boolean negate \u003d false;\n      if (x !\u003d x) {\n          return x;\n      }\n\n      // sinh[z] \u003d (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x \u003e 20) {\n          if (x \u003e\u003d LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t \u003d exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x \u003c -20) {\n          if (x \u003c\u003d -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t \u003d exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x \u003d\u003d 0) {\n          return x;\n      }\n\n      if (x \u003c 0.0) {\n          x \u003d -x;\n          negate \u003d true;\n      }\n\n      double result;\n\n      if (x \u003e 0.25) {\n          double hiPrec[] \u003d new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya \u003d hiPrec[0] + hiPrec[1];\n          double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp \u003d ya * HEX_40000000;\n          double yaa \u003d ya + temp - temp;\n          double yab \u003d ya - yaa;\n\n          // recip \u003d 1/y\n          double recip \u003d 1.0/ya;\n          temp \u003d recip * HEX_40000000;\n          double recipa \u003d recip + temp - temp;\n          double recipb \u003d recip - recipa;\n\n          // Correct for rounding in division\n          recipb +\u003d (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb +\u003d -yb * recip * recip;\n\n          recipa \u003d -recipa;\n          recipb \u003d -recipb;\n\n          // y \u003d y + 1/y\n          temp \u003d ya + recipa;\n          yb +\u003d -(temp - ya - recipa);\n          ya \u003d temp;\n          temp \u003d ya + recipb;\n          yb +\u003d -(temp - ya - recipb);\n          ya \u003d temp;\n\n          result \u003d ya + yb;\n          result *\u003d 0.5;\n      }\n      else {\n          double hiPrec[] \u003d new double[2];\n          expm1(x, hiPrec);\n\n          double ya \u003d hiPrec[0] + hiPrec[1];\n          double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) \u003d -expm1(x) / (expm1(x) + 1) */\n          double denom \u003d 1.0 + ya;\n          double denomr \u003d 1.0 / denom;\n          double denomb \u003d -(denom - 1.0 - ya) + yb;\n          double ratio \u003d ya * denomr;\n          double temp \u003d ratio * HEX_40000000;\n          double ra \u003d ratio + temp - temp;\n          double rb \u003d ratio - ra;\n\n          temp \u003d denom * HEX_40000000;\n          double za \u003d denom + temp - temp;\n          double zb \u003d denom - za;\n\n          rb +\u003d (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb +\u003d yb*denomr;                        // numerator\n          rb +\u003d -ya * denomb * denomr * denomr;   // denominator\n\n          // y \u003d y - 1/y\n          temp \u003d ya + ra;\n          yb +\u003d -(temp - ya - ra);\n          ya \u003d temp;\n          temp \u003d ya + rb;\n          yb +\u003d -(temp - ya - rb);\n          ya \u003d temp;\n\n          result \u003d ya + yb;\n          result *\u003d 0.5;\n      }\n\n      if (negate) {\n          result \u003d -result;\n      }\n\n      return result;\n    }",
    "begin_line": 461,
    "end_line": 580,
    "comment": "/** \n * Compute the hyperbolic sine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic sine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.tanh#586",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.tanh(double)",
    "snippet": "public static double tanh(double x) {\n      boolean negate \u003d false;\n\n      if (x !\u003d x) {\n          return x;\n      }\n\n      // tanh[z] \u003d sinh[z] / cosh[z]\n      // \u003d (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // \u003d (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude \u003e 20, sinh[z] \u003d\u003d cosh[z] in double precision\n\n      if (x \u003e 20.0) {\n          return 1.0;\n      }\n\n      if (x \u003c -20) {\n          return -1.0;\n      }\n\n      if (x \u003d\u003d 0) {\n          return x;\n      }\n\n      if (x \u003c 0.0) {\n          x \u003d -x;\n          negate \u003d true;\n      }\n\n      double result;\n      if (x \u003e\u003d 0.5) {\n          double hiPrec[] \u003d new double[2];\n          // tanh(x) \u003d (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya \u003d hiPrec[0] + hiPrec[1];\n          double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na \u003d -1.0 + ya;\n          double nb \u003d -(na + 1.0 - ya);\n          double temp \u003d na + yb;\n          nb +\u003d -(temp - na - yb);\n          na \u003d temp;\n\n          /* Denominator */\n          double da \u003d 1.0 + ya;\n          double db \u003d -(da - 1.0 - ya);\n          temp \u003d da + yb;\n          db +\u003d -(temp - da - yb);\n          da \u003d temp;\n\n          temp \u003d da * HEX_40000000;\n          double daa \u003d da + temp - temp;\n          double dab \u003d da - daa;\n\n          // ratio \u003d na/da\n          double ratio \u003d na/da;\n          temp \u003d ratio * HEX_40000000;\n          double ratioa \u003d ratio + temp - temp;\n          double ratiob \u003d ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob +\u003d (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob +\u003d nb / da;\n          // Account for db\n          ratiob +\u003d -db * na / da / da;\n\n          result \u003d ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] \u003d new double[2];\n          // tanh(x) \u003d expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya \u003d hiPrec[0] + hiPrec[1];\n          double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na \u003d ya;\n          double nb \u003d yb;\n\n          /* Denominator */\n          double da \u003d 2.0 + ya;\n          double db \u003d -(da - 2.0 - ya);\n          double temp \u003d da + yb;\n          db +\u003d -(temp - da - yb);\n          da \u003d temp;\n\n          temp \u003d da * HEX_40000000;\n          double daa \u003d da + temp - temp;\n          double dab \u003d da - daa;\n\n          // ratio \u003d na/da\n          double ratio \u003d na/da;\n          temp \u003d ratio * HEX_40000000;\n          double ratioa \u003d ratio + temp - temp;\n          double ratiob \u003d ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob +\u003d (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob +\u003d nb / da;\n          // Account for db\n          ratiob +\u003d -db * na / da / da;\n\n          result \u003d ratioa + ratiob;\n      }\n\n      if (negate) {\n          result \u003d -result;\n      }\n\n      return result;\n    }",
    "begin_line": 586,
    "end_line": 704,
    "comment": "/** \n * Compute the hyperbolic tangent of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic tangent of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.acosh#710",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.acosh(double)",
    "snippet": "public static double acosh(final double a) {\n        return FastMath.log(a + FastMath.sqrt(a * a - 1));\n    }",
    "begin_line": 710,
    "end_line": 712,
    "comment": "/** \n * Compute the inverse hyperbolic cosine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic cosine of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.asinh#718",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.asinh(double)",
    "snippet": "public static double asinh(double a) {\n        boolean negative \u003d false;\n        if (a \u003c 0) {\n            negative \u003d true;\n            a \u003d -a;\n        }\n\n        double absAsinh;\n        if (a \u003e 0.167) {\n            absAsinh \u003d FastMath.log(FastMath.sqrt(a * a + 1) + a);\n        } else {\n            final double a2 \u003d a * a;\n            if (a \u003e 0.097) {\n                absAsinh \u003d a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else if (a \u003e 0.036) {\n                absAsinh \u003d a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else if (a \u003e 0.0036) {\n                absAsinh \u003d a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else {\n                absAsinh \u003d a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n            }\n        }\n\n        return negative ? -absAsinh : absAsinh;\n    }",
    "begin_line": 718,
    "end_line": 742,
    "comment": "/** \n * Compute the inverse hyperbolic sine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic sine of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atanh#748",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atanh(double)",
    "snippet": "public static double atanh(double a) {\n        boolean negative \u003d false;\n        if (a \u003c 0) {\n            negative \u003d true;\n            a \u003d -a;\n        }\n\n        double absAtanh;\n        if (a \u003e 0.15) {\n            absAtanh \u003d 0.5 * FastMath.log((1 + a) / (1 - a));\n        } else {\n            final double a2 \u003d a * a;\n            if (a \u003e 0.087) {\n                absAtanh \u003d a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n            } else if (a \u003e 0.031) {\n                absAtanh \u003d a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n            } else if (a \u003e 0.003) {\n                absAtanh \u003d a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n            } else {\n                absAtanh \u003d a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n            }\n        }\n\n        return negative ? -absAtanh : absAtanh;\n    }",
    "begin_line": 748,
    "end_line": 772,
    "comment": "/** \n * Compute the inverse hyperbolic tangent of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic tangent of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.signum#779",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.signum(double)",
    "snippet": "public static double signum(final double a) {\n        return (a \u003c 0.0) ? -1.0 : ((a \u003e 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a\n    }",
    "begin_line": 779,
    "end_line": 781,
    "comment": "/** \n * Compute the signum of a number. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.signum#788",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.signum(float)",
    "snippet": "public static float signum(final float a) {\n        return (a \u003c 0.0f) ? -1.0f : ((a \u003e 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a\n    }",
    "begin_line": 788,
    "end_line": 790,
    "comment": "/** \n * Compute the signum of a number. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextUp#796",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextUp(double)",
    "snippet": "public static double nextUp(final double a) {\n        return nextAfter(a, Double.POSITIVE_INFINITY);\n    }",
    "begin_line": 796,
    "end_line": 798,
    "comment": "/** \n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextUp#804",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextUp(float)",
    "snippet": "public static float nextUp(final float a) {\n        return nextAfter(a, Float.POSITIVE_INFINITY);\n    }",
    "begin_line": 804,
    "end_line": 806,
    "comment": "/** \n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.random#812",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.random()",
    "snippet": "public static double random() {\n        return Math.random();\n    }",
    "begin_line": 812,
    "end_line": 814,
    "comment": "/** \n * Returns a pseudo-random number between 0.0 and 1.0. \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e this implementation currently delegates to  {@link Math#random}\n * @return a random number between 0.0 and 1.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.exp#836",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double)",
    "snippet": "public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }",
    "begin_line": 836,
    "end_line": 838,
    "comment": "/** \n * Exponential function. Computes exp(x), function result is nearly rounded.   It will be correctly rounded to the theoretical value for 99.9% of input values, otherwise it will have a 1 UPL error. Method: Lookup intVal \u003d exp(int(x)) Lookup fracVal \u003d exp(int(x-int(x) / 1024.0) * 1024.0 ); Compute z as the exponential of the remaining bits by a polynomial minus one exp(x) \u003d intVal * fracVal * (1 + z) Accuracy: Calculation is done with 63 bits of precision, so result should be correctly rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n * @param x   a double\n * @return double e\u003csup\u003ex\u003c/sup\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.exp#847",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double, double, double[])",
    "snippet": "private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x \u003c 0.0) {\n            intVal \u003d (int) -x;\n\n            if (intVal \u003e 746) {\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] \u003d 0.0;\n                    hiPrec[1] \u003d 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal \u003e 709) {\n                /* This will produce a subnormal output */\n                final double result \u003d exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] /\u003d 285040095144011776.0;\n                    hiPrec[1] /\u003d 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal \u003d\u003d 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result \u003d exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] /\u003d 4.455505956692756620;\n                    hiPrec[1] /\u003d 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA \u003d ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB \u003d ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal \u003d -intVal;\n        } else {\n            intVal \u003d (int) x;\n\n            if (intVal \u003e 709) {\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] \u003d Double.POSITIVE_INFINITY;\n                    hiPrec[1] \u003d 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA \u003d ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB \u003d ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac \u003d (int) ((x - intVal) * 1024.0);\n        final double fracPartA \u003d ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB \u003d ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 \u003c\u003d epsilon \u003c 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon \u003d x - (intVal + intFrac / 1024.0);\n\n        /* Compute z \u003d exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z \u003c 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z \u003d 0.04168701738764507;\n        z \u003d z * epsilon + 0.1666666505023083;\n        z \u003d z * epsilon + 0.5000000000042687;\n        z \u003d z * epsilon + 1.0;\n        z \u003d z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA \u003d intPartA * fracPartA;\n        double tempB \u003d intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC \u003d tempB + tempA;\n        final double result;\n        if (extra !\u003d 0.0) {\n            result \u003d tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result \u003d tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec !\u003d null) {\n            // If requesting high precision\n            hiPrec[0] \u003d tempA;\n            hiPrec[1] \u003d tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }",
    "begin_line": 847,
    "end_line": 962,
    "comment": "/** \n * Internal helper method for exponential function.\n * @param x original argument of the exponential function\n * @param extra extra bits of precision on input (To Be Confirmed)\n * @param hiPrec extra bits of precision on output (To Be Confirmed)\n * @return exp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.expm1#968",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.expm1(double)",
    "snippet": "public static double expm1(double x) {\n      return expm1(x, null);\n    }",
    "begin_line": 968,
    "end_line": 970,
    "comment": "/** \n * Compute exp(x) - 1\n * @param x number to compute shifted exponential\n * @return exp(x) - 1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.expm1#977",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.expm1(double, double)",
    "snippet": "private static double expm1(double x, double hiPrecOut[]) {\n        if (x !\u003d x || x \u003d\u003d 0.0) { // NaN or zero\n            return x;\n        }\n\n        if (x \u003c\u003d -1.0 || x \u003e\u003d 1.0) {\n            // If not between +/- 1.0\n            //return exp(x) - 1.0;\n            double hiPrec[] \u003d new double[2];\n            exp(x, 0.0, hiPrec);\n            if (x \u003e 0.0) {\n                return -1.0 + hiPrec[0] + hiPrec[1];\n            } else {\n                final double ra \u003d -1.0 + hiPrec[0];\n                double rb \u003d -(ra + 1.0 - hiPrec[0]);\n                rb +\u003d hiPrec[1];\n                return ra + rb;\n            }\n        }\n\n        double baseA;\n        double baseB;\n        double epsilon;\n        boolean negative \u003d false;\n\n        if (x \u003c 0.0) {\n            x \u003d -x;\n            negative \u003d true;\n        }\n\n        {\n            int intFrac \u003d (int) (x * 1024.0);\n            double tempA \u003d ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;\n            double tempB \u003d ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n            double temp \u003d tempA + tempB;\n            tempB \u003d -(temp - tempA - tempB);\n            tempA \u003d temp;\n\n            temp \u003d tempA * HEX_40000000;\n            baseA \u003d tempA + temp - temp;\n            baseB \u003d tempB + (tempA - baseA);\n\n            epsilon \u003d x - intFrac/1024.0;\n        }\n\n\n        /* Compute expm1(epsilon) */\n        double zb \u003d 0.008336750013465571;\n        zb \u003d zb * epsilon + 0.041666663879186654;\n        zb \u003d zb * epsilon + 0.16666666666745392;\n        zb \u003d zb * epsilon + 0.49999999999999994;\n        zb \u003d zb * epsilon;\n        zb \u003d zb * epsilon;\n\n        double za \u003d epsilon;\n        double temp \u003d za + zb;\n        zb \u003d -(temp - za - zb);\n        za \u003d temp;\n\n        temp \u003d za * HEX_40000000;\n        temp \u003d za + temp - temp;\n        zb +\u003d za - temp;\n        za \u003d temp;\n\n        /* Combine the parts.   expm1(a+b) \u003d expm1(a) + expm1(b) + expm1(a)*expm1(b) */\n        double ya \u003d za * baseA;\n        //double yb \u003d za*baseB + zb*baseA + zb*baseB;\n        temp \u003d ya + za * baseB;\n        double yb \u003d -(temp - ya - za * baseB);\n        ya \u003d temp;\n\n        temp \u003d ya + zb * baseA;\n        yb +\u003d -(temp - ya - zb * baseA);\n        ya \u003d temp;\n\n        temp \u003d ya + zb * baseB;\n        yb +\u003d -(temp - ya - zb*baseB);\n        ya \u003d temp;\n\n        //ya \u003d ya + za + baseA;\n        //yb \u003d yb + zb + baseB;\n        temp \u003d ya + baseA;\n        yb +\u003d -(temp - baseA - ya);\n        ya \u003d temp;\n\n        temp \u003d ya + za;\n        //yb +\u003d (ya \u003e za) ? -(temp - ya - za) : -(temp - za - ya);\n        yb +\u003d -(temp - ya - za);\n        ya \u003d temp;\n\n        temp \u003d ya + baseB;\n        //yb +\u003d (ya \u003e baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);\n        yb +\u003d -(temp - ya - baseB);\n        ya \u003d temp;\n\n        temp \u003d ya + zb;\n        //yb +\u003d (ya \u003e zb) ? -(temp - ya - zb) : -(temp - zb - ya);\n        yb +\u003d -(temp - ya - zb);\n        ya \u003d temp;\n\n        if (negative) {\n            /* Compute expm1(-x) \u003d -expm1(x) / (expm1(x) + 1) */\n            double denom \u003d 1.0 + ya;\n            double denomr \u003d 1.0 / denom;\n            double denomb \u003d -(denom - 1.0 - ya) + yb;\n            double ratio \u003d ya * denomr;\n            temp \u003d ratio * HEX_40000000;\n            final double ra \u003d ratio + temp - temp;\n            double rb \u003d ratio - ra;\n\n            temp \u003d denom * HEX_40000000;\n            za \u003d denom + temp - temp;\n            zb \u003d denom - za;\n\n            rb +\u003d (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n\n            // f(x) \u003d x/1+x\n            // Compute f\u0027(x)\n            // Product rule:  d(uv) \u003d du*v + u*dv\n            // Chain rule:  d(f(g(x)) \u003d f\u0027(g(x))*f(g\u0027(x))\n            // d(1/x) \u003d -1/(x*x)\n            // d(1/1+x) \u003d -1/( (1+x)^2) *  1 \u003d  -1/((1+x)*(1+x))\n            // d(x/1+x) \u003d -x/((1+x)(1+x)) + 1/1+x \u003d 1 / ((1+x)(1+x))\n\n            // Adjust for yb\n            rb +\u003d yb * denomr;                      // numerator\n            rb +\u003d -ya * denomb * denomr * denomr;   // denominator\n\n            // negate\n            ya \u003d -ra;\n            yb \u003d -rb;\n        }\n\n        if (hiPrecOut !\u003d null) {\n            hiPrecOut[0] \u003d ya;\n            hiPrecOut[1] \u003d yb;\n        }\n\n        return ya + yb;\n    }",
    "begin_line": 977,
    "end_line": 1117,
    "comment": "/** \n * Internal helper method for expm1\n * @param x number to compute shifted exponential\n * @param hiPrecOut receive high precision result for -1.0 \u003c x \u003c 1.0\n * @return exp(x) - 1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log#1125",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double)",
    "snippet": "public static double log(final double x) {\n        return log(x, null);\n    }",
    "begin_line": 1125,
    "end_line": 1127,
    "comment": "/** \n * Natural logarithm.\n * @param x   a double\n * @return log(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log#1135",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double, double[])",
    "snippet": "private static double log(final double x, final double[] hiPrec) {\n        if (x\u003d\u003d0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits \u003d Double.doubleToRawLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if (((bits \u0026 0x8000000000000000L) !\u003d 0 || x !\u003d x) \u0026\u0026 x !\u003d 0.0) {\n            if (hiPrec !\u003d null) {\n                hiPrec[0] \u003d Double.NaN;\n            }\n\n            return Double.NaN;\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (hiPrec !\u003d null) {\n                hiPrec[0] \u003d Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp \u003d (int)(bits \u003e\u003e 52)-1023;\n\n        if ((bits \u0026 0x7ff0000000000000L) \u003d\u003d 0) {\n            // Subnormal!\n            if (x \u003d\u003d 0) {\n                // Zero\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] \u003d Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits \u003c\u003c\u003d 1;\n            while ( (bits \u0026 0x0010000000000000L) \u003d\u003d 0) {\n                --exp;\n                bits \u003c\u003c\u003d 1;\n            }\n        }\n\n\n        if ((exp \u003d\u003d -1 || exp \u003d\u003d 0) \u0026\u0026 x \u003c 1.01 \u0026\u0026 x \u003e 0.99 \u0026\u0026 hiPrec \u003d\u003d null) {\n            /* The normal method doesn\u0027t work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n            /* Compute x - 1.0 and split it */\n            double xa \u003d x - 1.0;\n            double xb \u003d xa - x + 1.0;\n            double tmp \u003d xa * HEX_40000000;\n            double aa \u003d xa + tmp - tmp;\n            double ab \u003d xa - aa;\n            xa \u003d aa;\n            xb \u003d ab;\n\n            final double[] lnCoef_last \u003d LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n            double ya \u003d lnCoef_last[0];\n            double yb \u003d lnCoef_last[1];\n\n            for (int i \u003d LN_QUICK_COEF.length - 2; i \u003e\u003d 0; i--) {\n                /* Multiply a \u003d y * x */\n                aa \u003d ya * xa;\n                ab \u003d ya * xb + yb * xa + yb * xb;\n                /* split, so now y \u003d a */\n                tmp \u003d aa * HEX_40000000;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n\n                /* Add  a \u003d y + lnQuickCoef */\n                final double[] lnCoef_i \u003d LN_QUICK_COEF[i];\n                aa \u003d ya + lnCoef_i[0];\n                ab \u003d yb + lnCoef_i[1];\n                /* Split y \u003d a */\n                tmp \u003d aa * HEX_40000000;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n            }\n\n            /* Multiply a \u003d y * x */\n            aa \u003d ya * xa;\n            ab \u003d ya * xb + yb * xa + yb * xb;\n            /* split, so now y \u003d a */\n            tmp \u003d aa * HEX_40000000;\n            ya \u003d aa + tmp - tmp;\n            yb \u003d aa - ya + ab;\n\n            return ya + yb;\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 \u003c\u003d lnm \u003c ln(2)\n        final double[] lnm \u003d lnMant.LN_MANT[(int)((bits \u0026 0x000ffc0000000000L) \u003e\u003e 42)];\n\n        /*\n    double epsilon \u003d x / Double.longBitsToDouble(bits \u0026 0xfffffc0000000000L);\n\n    epsilon -\u003d 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y \u003d Double.longBitsToDouble(bits \u0026 0xfffffc0000000000L);\n        //double epsilon \u003d (x - y) / y;\n        final double epsilon \u003d (bits \u0026 0x3ffffffffffL) / (TWO_POWER_52 + (bits \u0026 0x000ffc0000000000L));\n\n        double lnza \u003d 0.0;\n        double lnzb \u003d 0.0;\n\n        if (hiPrec !\u003d null) {\n            /* split epsilon -\u003e x */\n            double tmp \u003d epsilon * HEX_40000000;\n            double aa \u003d epsilon + tmp - tmp;\n            double ab \u003d epsilon - aa;\n            double xa \u003d aa;\n            double xb \u003d ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            final double numer \u003d bits \u0026 0x3ffffffffffL;\n            final double denom \u003d TWO_POWER_52 + (bits \u0026 0x000ffc0000000000L);\n            aa \u003d numer - xa*denom - xb * denom;\n            xb +\u003d aa / denom;\n\n            /* Remez polynomial evaluation */\n            final double[] lnCoef_last \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya \u003d lnCoef_last[0];\n            double yb \u003d lnCoef_last[1];\n\n            for (int i \u003d LN_HI_PREC_COEF.length - 2; i \u003e\u003d 0; i--) {\n                /* Multiply a \u003d y * x */\n                aa \u003d ya * xa;\n                ab \u003d ya * xb + yb * xa + yb * xb;\n                /* split, so now y \u003d a */\n                tmp \u003d aa * HEX_40000000;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n\n                /* Add  a \u003d y + lnHiPrecCoef */\n                final double[] lnCoef_i \u003d LN_HI_PREC_COEF[i];\n                aa \u003d ya + lnCoef_i[0];\n                ab \u003d yb + lnCoef_i[1];\n                /* Split y \u003d a */\n                tmp \u003d aa * HEX_40000000;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n            }\n\n            /* Multiply a \u003d y * x */\n            aa \u003d ya * xa;\n            ab \u003d ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz \u003d a */\n            /*\n      tmp \u003d aa * 1073741824.0;\n      lnza \u003d aa + tmp - tmp;\n      lnzb \u003d aa - lnza + ab;\n             */\n            lnza \u003d aa + ab;\n            lnzb \u003d -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza \u003d -0.16624882440418567;\n            lnza \u003d lnza * epsilon + 0.19999954120254515;\n            lnza \u003d lnza * epsilon + -0.2499999997677497;\n            lnza \u003d lnza * epsilon + 0.3333333333332802;\n            lnza \u003d lnza * epsilon + -0.5;\n            lnza \u003d lnza * epsilon + 1.0;\n            lnza \u003d lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a \u003d LN_2_A*exp;\n        double b \u003d 0.0;\n        double c \u003d a+lnm[0];\n        double d \u003d -(c-a-lnm[0]);\n        a \u003d c;\n        b \u003d b + d;\n\n        c \u003d a + lnza;\n        d \u003d -(c - a - lnza);\n        a \u003d c;\n        b \u003d b + d;\n\n        c \u003d a + LN_2_B*exp;\n        d \u003d -(c - a - LN_2_B*exp);\n        a \u003d c;\n        b \u003d b + d;\n\n        c \u003d a + lnm[1];\n        d \u003d -(c - a - lnm[1]);\n        a \u003d c;\n        b \u003d b + d;\n\n        c \u003d a + lnzb;\n        d \u003d -(c - a - lnzb);\n        a \u003d c;\n        b \u003d b + d;\n\n        if (hiPrec !\u003d null) {\n            hiPrec[0] \u003d a;\n            hiPrec[1] \u003d b;\n        }\n\n        return a + b;\n    }",
    "begin_line": 1135,
    "end_line": 1355,
    "comment": "/** \n * Internal helper method for natural logarithm function.\n * @param x original argument of the natural logarithm function\n * @param hiPrec extra bits of precision on output (To Be Confirmed)\n * @return log(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log1p#1363",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log1p(double)",
    "snippet": "public static double log1p(final double x) {\n        if (x \u003d\u003d -1) {\n            return Double.NEGATIVE_INFINITY;\n        }\n\n        if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        if (x \u003e 1e-6 ||\n            x \u003c -1e-6) {\n            final double xpa \u003d 1 + x;\n            final double xpb \u003d -(xpa - 1 - x);\n\n            final double[] hiPrec \u003d new double[2];\n            final double lores \u003d log(xpa, hiPrec);\n            if (Double.isInfinite(lores)) { // Don\u0027t allow this to be converted to NaN\n                return lores;\n            }\n\n            // Do a taylor series expansion around xpa:\n            //   f(x+y) \u003d f(x) + f\u0027(x) y + f\u0027\u0027(x)/2 y^2\n            final double fx1 \u003d xpb / xpa;\n            final double epsilon \u003d 0.5 * fx1 + 1;\n            return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n        } else {\n            // Value is small |x| \u003c 1e6, do a Taylor series centered on 1.\n            final double y \u003d (x * F_1_3 - F_1_2) * x + 1;\n            return y * x;\n        }\n    }",
    "begin_line": 1363,
    "end_line": 1393,
    "comment": "/** \n * Computes log(1 + x).\n * @param x Number.\n * @return {@code log(1 + x)}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log10#1399",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log10(double)",
    "snippet": "public static double log10(final double x) {\n        final double hiPrec[] \u003d new double[2];\n\n        final double lores \u003d log(x, hiPrec);\n        if (Double.isInfinite(lores)){ // don\u0027t allow this to be converted to NaN\n            return lores;\n        }\n\n        final double tmp \u003d hiPrec[0] * HEX_40000000;\n        final double lna \u003d hiPrec[0] + tmp - tmp;\n        final double lnb \u003d hiPrec[0] - lna + hiPrec[1];\n\n        final double rln10a \u003d 0.4342944622039795;\n        final double rln10b \u003d 1.9699272335463627E-8;\n\n        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n    }",
    "begin_line": 1399,
    "end_line": 1415,
    "comment": "/** \n * Compute the base 10 logarithm.\n * @param x a number\n * @return log10(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log#1433",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double, double)",
    "snippet": "public static double log(double base, double x) {\n        return log(x) / log(base);\n    }",
    "begin_line": 1433,
    "end_line": 1435,
    "comment": "/** \n * Computes the \u003ca href\u003d\"http://mathworld.wolfram.com/Logarithm.html\"\u003e logarithm\u003c/a\u003e in a given base. Returns  {@code NaN} if either argument is negative.If  {@code base} is 0 and {@code x} is positive, 0 is returned.If  {@code base} is positive and {@code x} is 0,{@code Double.NEGATIVE_INFINITY} is returned.If both arguments are 0, the result is  {@code NaN}.\n * @param base Base of the logarithm, must be greater than 0.\n * @param x Argument, must be greater than 0.\n * @return the value of the logarithm, i.e. the number {@code y} such that\u003ccode\u003ebase\u003csup\u003ey\u003c/sup\u003e \u003d x\u003c/code\u003e.\n * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.pow#1444",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.pow(double, double)",
    "snippet": "public static double pow(double x, double y) {\n        final double lns[] \u003d new double[2];\n\n        if (y \u003d\u003d 0.0) {\n            return 1.0;\n        }\n\n        if (x !\u003d x) { // X is NaN\n            return x;\n        }\n\n\n        if (x \u003d\u003d 0) {\n            long bits \u003d Double.doubleToRawLongBits(x);\n            if ((bits \u0026 0x8000000000000000L) !\u003d 0) {\n                // -zero\n                long yi \u003d (long) y;\n\n                if (y \u003c 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y \u003e 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y \u003c 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y \u003e 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (y !\u003d y) { // y is NaN\n                return y;\n            }\n            if (y \u003c 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (x * x \u003d\u003d 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x \u003e 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n            if (y !\u003d y) { // y is NaN\n                return y;\n            }\n\n            if (y \u003c 0) {\n                long yi \u003d (long) y;\n                if (y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y \u003e 0)  {\n                long yi \u003d (long) y;\n                if (y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y \u003d\u003d Double.NEGATIVE_INFINITY) {\n\n            if (x * x \u003d\u003d 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x \u003c 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x\u003c0 */\n        if (x \u003c 0) {\n            // y is an even integer in this case\n            if (y \u003e\u003d TWO_POWER_53 || y \u003c\u003d -TWO_POWER_53) {\n                return pow(-x, y);\n            }\n\n            if (y \u003d\u003d (long) y) {\n                // If y is an integer\n                return ((long)y \u0026 1) \u003d\u003d 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y \u003d ya+yb */\n        double ya;\n        double yb;\n        if (y \u003c 8e298 \u0026\u0026 y \u003e -8e298) {\n            double tmp1 \u003d y * HEX_40000000;\n            ya \u003d y + tmp1 - tmp1;\n            yb \u003d y - ya;\n        } else {\n            double tmp1 \u003d y * 9.31322574615478515625E-10;\n            double tmp2 \u003d tmp1 * 9.31322574615478515625E-10;\n            ya \u003d (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb \u003d y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores \u003d log(x, lns);\n        if (Double.isInfinite(lores)){ // don\u0027t allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna \u003d lns[0];\n        double lnb \u003d lns[1];\n\n        /* resplit lns */\n        double tmp1 \u003d lna * HEX_40000000;\n        double tmp2 \u003d lna + tmp1 - tmp1;\n        lnb +\u003d lna - tmp2;\n        lna \u003d tmp2;\n\n        // y*ln(x) \u003d (aa+ab)\n        final double aa \u003d lna * ya;\n        final double ab \u003d lna * yb + lnb * ya + lnb * yb;\n\n        lna \u003d aa+ab;\n        lnb \u003d -(lna - aa - ab);\n\n        double z \u003d 1.0 / 120.0;\n        z \u003d z * lnb + (1.0 / 24.0);\n        z \u003d z * lnb + (1.0 / 6.0);\n        z \u003d z * lnb + 0.5;\n        z \u003d z * lnb + 1.0;\n        z \u003d z * lnb;\n\n        final double result \u003d exp(lna, z, null);\n        //result \u003d result + result * z;\n        return result;\n    }",
    "begin_line": 1444,
    "end_line": 1602,
    "comment": "/** \n * Power function.  Compute x^y.\n * @param x   a double\n * @param y   a double\n * @return double\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.pow#1613",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.pow(double, int)",
    "snippet": "public static double pow(double d, int e) {\n\n        if (e \u003d\u003d 0) {\n            return 1.0;\n        } else if (e \u003c 0) {\n            e \u003d -e;\n            d \u003d 1.0 / d;\n        }\n\n        // split d as two 26 bits numbers\n        // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n        final int splitFactor \u003d 0x8000001;\n        final double cd       \u003d splitFactor * d;\n        final double d1High   \u003d cd - (cd - d);\n        final double d1Low    \u003d d - d1High;\n\n        // prepare result\n        double resultHigh \u003d 1;\n        double resultLow  \u003d 0;\n\n        // d^(2p)\n        double d2p     \u003d d;\n        double d2pHigh \u003d d1High;\n        double d2pLow  \u003d d1Low;\n\n        while (e !\u003d 0) {\n\n            if ((e \u0026 0x1) !\u003d 0) {\n                // accurate multiplication result \u003d result * d^(2p) using Veltkamp TwoProduct algorithm\n                // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n                final double tmpHigh \u003d resultHigh * d2p;\n                final double cRH     \u003d splitFactor * resultHigh;\n                final double rHH     \u003d cRH - (cRH - resultHigh);\n                final double rHL     \u003d resultHigh - rHH;\n                final double tmpLow  \u003d rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\n                resultHigh \u003d tmpHigh;\n                resultLow  \u003d resultLow * d2p + tmpLow;\n            }\n\n            // accurate squaring d^(2(p+1)) \u003d d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm\n            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n            final double tmpHigh \u003d d2pHigh * d2p;\n            final double cD2pH   \u003d splitFactor * d2pHigh;\n            final double d2pHH   \u003d cD2pH - (cD2pH - d2pHigh);\n            final double d2pHL   \u003d d2pHigh - d2pHH;\n            final double tmpLow  \u003d d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\n            final double cTmpH   \u003d splitFactor * tmpHigh;\n            d2pHigh \u003d cTmpH - (cTmpH - tmpHigh);\n            d2pLow  \u003d d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\n            d2p     \u003d d2pHigh + d2pLow;\n\n            e \u003d e \u003e\u003e 1;\n\n        }\n\n        return resultHigh + resultLow;\n\n    }",
    "begin_line": 1613,
    "end_line": 1670,
    "comment": "/** \n * Raise a double to an int power.\n * @param d Number to raise.\n * @param e Exponent.\n * @return d\u003csup\u003ee\u003c/sup\u003e\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.polySine#1678",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
    "snippet": "private static double polySine(final double x)\n    {\n        double x2 \u003d x*x;\n\n        double p \u003d 2.7553817452272217E-6;\n        p \u003d p * x2 + -1.9841269659586505E-4;\n        p \u003d p * x2 + 0.008333333333329196;\n        p \u003d p * x2 + -0.16666666666666666;\n        //p *\u003d x2;\n        //p *\u003d x;\n        p \u003d p * x2 * x;\n\n        return p;\n    }",
    "begin_line": 1678,
    "end_line": 1691,
    "comment": "/** \n * Computes sin(x) - x, where |x| \u003c 1/16. Use a Remez polynomial approximation.\n * @param x a number smaller than 1/16\n * @return sin(x) - x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.polyCosine#1699",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
    "snippet": "private static double polyCosine(double x) {\n        double x2 \u003d x*x;\n\n        double p \u003d 2.479773539153719E-5;\n        p \u003d p * x2 + -0.0013888888689039883;\n        p \u003d p * x2 + 0.041666666666621166;\n        p \u003d p * x2 + -0.49999999999999994;\n        p *\u003d x2;\n\n        return p;\n    }",
    "begin_line": 1699,
    "end_line": 1709,
    "comment": "/** \n * Computes cos(x) - 1, where |x| \u003c 1/16. Use a Remez polynomial approximation.\n * @param x a number smaller than 1/16\n * @return cos(x) - 1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sinQ#1718",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sinQ(double, double)",
    "snippet": "private static double sinQ(double xa, double xb) {\n        int idx \u003d (int) ((xa * 8.0) + 0.5);\n        final double epsilon \u003d xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA \u003d SINE_TABLE_A[idx];\n        final double sintB \u003d SINE_TABLE_B[idx];\n        final double costA \u003d COSINE_TABLE_A[idx];\n        final double costB \u003d COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA \u003d epsilon;\n        double sinEpsB \u003d polySine(epsilon);\n        final double cosEpsA \u003d 1.0;\n        final double cosEpsB \u003d polyCosine(epsilon);\n\n        // Split epsilon   xa + xb \u003d x\n        final double temp \u003d sinEpsA * HEX_40000000;\n        double temp2 \u003d (sinEpsA + temp) - temp;\n        sinEpsB +\u003d  sinEpsA - temp2;\n        sinEpsA \u003d temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result \u003d sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result \u003d sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result \u003d sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result +\u003d costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a \u003d 0;\n        double b \u003d 0;\n\n        double t \u003d sintA;\n        double c \u003d a + t;\n        double d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        t \u003d costA * sinEpsA;\n        c \u003d a + t;\n        d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        b \u003d b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t \u003d sintA*cosEpsB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n\n    t \u003d costA*sinEpsB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n         */\n\n        b \u003d b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t \u003d sintB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n\n    t \u003d costB*sinEpsA;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n\n    t \u003d sintB*cosEpsB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n\n    t \u003d costB*sinEpsB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n         */\n\n        if (xb !\u003d 0.0) {\n            t \u003d ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c \u003d a + t;\n            d \u003d -(c - a - t);\n            a \u003d c;\n            b \u003d b + d;\n        }\n\n        result \u003d a + b;\n\n        return result;\n    }",
    "begin_line": 1718,
    "end_line": 1833,
    "comment": "/** \n * Compute sine over the first quadrant (0 \u003c x \u003c pi/2). Use combination of table lookup and rational polynomial expansion.\n * @param xa number from which sine is requested\n * @param xb extra bits for x (may be 0.0)\n * @return sin(xa + xb)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cosQ#1842",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cosQ(double, double)",
    "snippet": "private static double cosQ(double xa, double xb) {\n        final double pi2a \u003d 1.5707963267948966;\n        final double pi2b \u003d 6.123233995736766E-17;\n\n        final double a \u003d pi2a - xa;\n        double b \u003d -(a - pi2a + xa);\n        b +\u003d pi2b - xb;\n\n        return sinQ(a, b);\n    }",
    "begin_line": 1842,
    "end_line": 1851,
    "comment": "/** \n * Compute cosine in the first quadrant by subtracting input from PI/2 and then calling sinQ.  This is more accurate as the input approaches PI/2.\n * @param xa number from which cosine is requested\n * @param xb extra bits for x (may be 0.0)\n * @return cos(xa + xb)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.tanQ#1861",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.tanQ(double, double, boolean)",
    "snippet": "private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx \u003d (int) ((xa * 8.0) + 0.5);\n        final double epsilon \u003d xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA \u003d SINE_TABLE_A[idx];\n        final double sintB \u003d SINE_TABLE_B[idx];\n        final double costA \u003d COSINE_TABLE_A[idx];\n        final double costB \u003d COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA \u003d epsilon;\n        double sinEpsB \u003d polySine(epsilon);\n        final double cosEpsA \u003d 1.0;\n        final double cosEpsB \u003d polyCosine(epsilon);\n\n        // Split epsilon   xa + xb \u003d x\n        double temp \u003d sinEpsA * HEX_40000000;\n        double temp2 \u003d (sinEpsA + temp) - temp;\n        sinEpsB +\u003d  sinEpsA - temp2;\n        sinEpsA \u003d temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result \u003d sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result \u003d sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result \u003d sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result +\u003d costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a \u003d 0;\n        double b \u003d 0;\n\n        // Compute sine\n        double t \u003d sintA;\n        double c \u003d a + t;\n        double d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        t \u003d costA*sinEpsA;\n        c \u003d a + t;\n        d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        b \u003d b + sintA*cosEpsB + costA*sinEpsB;\n        b \u003d b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina \u003d a + b;\n        double sinb \u003d -(sina - a - b);\n\n        // Compute cosine\n\n        a \u003d b \u003d c \u003d d \u003d 0.0;\n\n        t \u003d costA*cosEpsA;\n        c \u003d a + t;\n        d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        t \u003d -sintA*sinEpsA;\n        c \u003d a + t;\n        d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        b \u003d b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b \u003d b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa \u003d a + b;\n        double cosb \u003d -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp \u003d cosa; cosa \u003d sina; sina \u003d tmp;\n            tmp \u003d cosb; cosb \u003d sinb; sinb \u003d tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est \u003d (sina+sinb)/(cosa+cosb);\n    double err \u003d (sina - cosa*est) + (sinb - cosb*est);\n    est +\u003d err/(cosa+cosb);\n    err \u003d (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) \u003d 1/x,   f\u0027(x) \u003d -1/x^2\n\n        double est \u003d sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp \u003d est * HEX_40000000;\n        double esta \u003d (est + temp) - temp;\n        double estb \u003d  est - esta;\n\n        temp \u003d cosa * HEX_40000000;\n        double cosaa \u003d (cosa + temp) - temp;\n        double cosab \u003d  cosa - cosaa;\n\n        //double err \u003d (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err \u003d (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err +\u003d sinb/cosa;                     // Change in est due to sinb\n        err +\u003d -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb !\u003d 0.0) {\n            // tan\u0027 \u003d 1 + tan^2      cot\u0027 \u003d -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj \u003d xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj \u003d -xbadj;\n            }\n\n            err +\u003d xbadj;\n        }\n\n        return est+err;\n    }",
    "begin_line": 1861,
    "end_line": 1996,
    "comment": "/** \n * Compute tangent (or cotangent) over the first quadrant.   0 \u003c x \u003c pi/2 Use combination of table lookup and rational polynomial expansion.\n * @param xa number from which sine is requested\n * @param xb extra bits for x (may be 0.0)\n * @param cotanFlag if true, compute the cotangent instead of the tangent\n * @return tan(xa+xb) (or cotangent, depending on cotanFlag)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.reducePayneHanek#2009",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.reducePayneHanek(double, double)",
    "snippet": "private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits \u003d Double.doubleToRawLongBits(x);\n        int exponent \u003d (int) ((inbits \u003e\u003e 52) \u0026 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits \u0026\u003d 0x000fffffffffffffL;\n        inbits |\u003d 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits \u003c\u003c\u003d 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx \u003d exponent \u003e\u003e 6;\n        int shift \u003d exponent - (idx \u003c\u003c 6);\n\n        if (shift !\u003d 0) {\n            shpi0 \u003d (idx \u003d\u003d 0) ? 0 : (RECIP_2PI[idx-1] \u003c\u003c shift);\n            shpi0 |\u003d RECIP_2PI[idx] \u003e\u003e\u003e (64-shift);\n            shpiA \u003d (RECIP_2PI[idx] \u003c\u003c shift) | (RECIP_2PI[idx+1] \u003e\u003e\u003e (64-shift));\n            shpiB \u003d (RECIP_2PI[idx+1] \u003c\u003c shift) | (RECIP_2PI[idx+2] \u003e\u003e\u003e (64-shift));\n        } else {\n            shpi0 \u003d (idx \u003d\u003d 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA \u003d RECIP_2PI[idx];\n            shpiB \u003d RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a \u003d inbits \u003e\u003e\u003e 32;\n        long b \u003d inbits \u0026 0xffffffffL;\n\n        long c \u003d shpiA \u003e\u003e\u003e 32;\n        long d \u003d shpiA \u0026 0xffffffffL;\n\n        long ac \u003d a * c;\n        long bd \u003d b * d;\n        long bc \u003d b * c;\n        long ad \u003d a * d;\n\n        long prodB \u003d bd + (ad \u003c\u003c 32);\n        long prodA \u003d ac + (ad \u003e\u003e\u003e 32);\n\n        boolean bita \u003d (bd \u0026 0x8000000000000000L) !\u003d 0;\n        boolean bitb \u003d (ad \u0026 0x80000000L ) !\u003d 0;\n        boolean bitsum \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prodA++;\n        }\n\n        bita \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (bc \u0026 0x80000000L ) !\u003d 0;\n\n        prodB \u003d prodB + (bc \u003c\u003c 32);\n        prodA \u003d prodA + (bc \u003e\u003e\u003e 32);\n\n        bitsum \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c \u003d shpiB \u003e\u003e\u003e 32;\n        d \u003d shpiB \u0026 0xffffffffL;\n        ac \u003d a * c;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        /* Collect terms */\n        ac \u003d ac + ((bc + ad) \u003e\u003e\u003e 32);\n\n        bita \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (ac \u0026 0x8000000000000000L ) !\u003d 0;\n        prodB +\u003d ac;\n        bitsum \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c \u003d shpi0 \u003e\u003e\u003e 32;\n        d \u003d shpi0 \u0026 0xffffffffL;\n\n        bd \u003d b * d;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        prodA +\u003d bd + ((bc + ad) \u003c\u003c 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart \u003d (int)(prodA \u003e\u003e\u003e 62);\n\n        /* Multiply by 4 */\n        prodA \u003c\u003c\u003d 2;\n        prodA |\u003d prodB \u003e\u003e\u003e 62;\n        prodB \u003c\u003c\u003d 2;\n\n        /* Multiply by PI/4 */\n        a \u003d prodA \u003e\u003e\u003e 32;\n        b \u003d prodA \u0026 0xffffffffL;\n\n        c \u003d PI_O_4_BITS[0] \u003e\u003e\u003e 32;\n        d \u003d PI_O_4_BITS[0] \u0026 0xffffffffL;\n\n        ac \u003d a * c;\n        bd \u003d b * d;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        long prod2B \u003d bd + (ad \u003c\u003c 32);\n        long prod2A \u003d ac + (ad \u003e\u003e\u003e 32);\n\n        bita \u003d (bd \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (ad \u0026 0x80000000L ) !\u003d 0;\n        bitsum \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prod2A++;\n        }\n\n        bita \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (bc \u0026 0x80000000L ) !\u003d 0;\n\n        prod2B \u003d prod2B + (bc \u003c\u003c 32);\n        prod2A \u003d prod2A + (bc \u003e\u003e\u003e 32);\n\n        bitsum \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c \u003d PI_O_4_BITS[1] \u003e\u003e\u003e 32;\n        d \u003d PI_O_4_BITS[1] \u0026 0xffffffffL;\n        ac \u003d a * c;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        /* Collect terms */\n        ac \u003d ac + ((bc + ad) \u003e\u003e\u003e 32);\n\n        bita \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (ac \u0026 0x8000000000000000L ) !\u003d 0;\n        prod2B +\u003d ac;\n        bitsum \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a \u003d prodB \u003e\u003e\u003e 32;\n        b \u003d prodB \u0026 0xffffffffL;\n        c \u003d PI_O_4_BITS[0] \u003e\u003e\u003e 32;\n        d \u003d PI_O_4_BITS[0] \u0026 0xffffffffL;\n        ac \u003d a * c;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        /* Collect terms */\n        ac \u003d ac + ((bc + ad) \u003e\u003e\u003e 32);\n\n        bita \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (ac \u0026 0x8000000000000000L ) !\u003d 0;\n        prod2B +\u003d ac;\n        bitsum \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA \u003d (prod2A \u003e\u003e\u003e 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB \u003d (((prod2A \u0026 0xfffL) \u003c\u003c 40) + (prod2B \u003e\u003e\u003e 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA \u003d tmpA + tmpB;\n        double sumB \u003d -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] \u003d intPart;\n        result[1] \u003d sumA * 2.0;\n        result[2] \u003d sumB * 2.0;\n    }",
    "begin_line": 2009,
    "end_line": 2219,
    "comment": "/** \n * Reduce the input argument using the Payne and Hanek method. This is good for all inputs 0.0 \u003c x \u003c inf Output is remainder after dividing by PI/2 The result array should contain 3 numbers. result[0] is the integer portion, so mod 4 this gives the quadrant. result[1] is the upper bits of the remainder result[2] is the lower bits of the remainder\n * @param x number to reduce\n * @param result placeholder where to put the result\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sin#2227",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
    "snippet": "public static double sin(double x) {\n        boolean negative \u003d false;\n        int quadrant \u003d 0;\n        double xa;\n        double xb \u003d 0.0;\n\n        /* Take absolute value of the input */\n        xa \u003d x;\n        if (x \u003c 0) {\n            negative \u003d true;\n            xa \u003d -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa \u003d\u003d 0.0) {\n            long bits \u003d Double.doubleToRawLongBits(x);\n            if (bits \u003c 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa !\u003d xa || xa \u003d\u003d Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa \u003e 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] \u003d new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant \u003d ((int) reduceResults[0]) \u0026 3;\n            xa \u003d reduceResults[1];\n            xb \u003d reduceResults[2];\n        } else if (xa \u003e 1.5707963267948966) {\n            final CodyWaite cw \u003d new CodyWaite(xa);\n            quadrant \u003d cw.getK() \u0026 3;\n            xa \u003d cw.getRemA();\n            xb \u003d cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^\u003d 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "begin_line": 2227,
    "end_line": 2286,
    "comment": "/** \n * Sine function.\n * @param x Argument.\n * @return sin(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cos#2294",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cos(double)",
    "snippet": "public static double cos(double x) {\n        int quadrant \u003d 0;\n\n        /* Take absolute value of the input */\n        double xa \u003d x;\n        if (x \u003c 0) {\n            xa \u003d -xa;\n        }\n\n        if (xa !\u003d xa || xa \u003d\u003d Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb \u003d 0;\n        if (xa \u003e 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] \u003d new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant \u003d ((int) reduceResults[0]) \u0026 3;\n            xa \u003d reduceResults[1];\n            xb \u003d reduceResults[2];\n        } else if (xa \u003e 1.5707963267948966) {\n            final CodyWaite cw \u003d new CodyWaite(xa);\n            quadrant \u003d cw.getK() \u0026 3;\n            xa \u003d cw.getRemA();\n            xb \u003d cw.getRemB();\n        }\n\n        //if (negative)\n        //  quadrant \u003d (quadrant + 2) % 4;\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "begin_line": 2294,
    "end_line": 2340,
    "comment": "/** \n * Cosine function.\n * @param x Argument.\n * @return cos(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.tan#2348",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.tan(double)",
    "snippet": "public static double tan(double x) {\n        boolean negative \u003d false;\n        int quadrant \u003d 0;\n\n        /* Take absolute value of the input */\n        double xa \u003d x;\n        if (x \u003c 0) {\n            negative \u003d true;\n            xa \u003d -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa \u003d\u003d 0.0) {\n            long bits \u003d Double.doubleToRawLongBits(x);\n            if (bits \u003c 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa !\u003d xa || xa \u003d\u003d Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb \u003d 0;\n        if (xa \u003e 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] \u003d new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant \u003d ((int) reduceResults[0]) \u0026 3;\n            xa \u003d reduceResults[1];\n            xb \u003d reduceResults[2];\n        } else if (xa \u003e 1.5707963267948966) {\n            final CodyWaite cw \u003d new CodyWaite(xa);\n            quadrant \u003d cw.getK() \u0026 3;\n            xa \u003d cw.getRemA();\n            xb \u003d cw.getRemB();\n        }\n\n        if (xa \u003e 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a \u003d 1.5707963267948966;\n            final double pi2b \u003d 6.123233995736766E-17;\n\n            final double a \u003d pi2a - xa;\n            double b \u003d -(a - pi2a + xa);\n            b +\u003d pi2b - xb;\n\n            xa \u003d a + b;\n            xb \u003d -(xa - a - b);\n            quadrant ^\u003d 1;\n            negative ^\u003d true;\n        }\n\n        double result;\n        if ((quadrant \u0026 1) \u003d\u003d 0) {\n            result \u003d tanQ(xa, xb, false);\n        } else {\n            result \u003d -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\n            result \u003d -result;\n        }\n\n        return result;\n    }",
    "begin_line": 2348,
    "end_line": 2417,
    "comment": "/** \n * Tangent function.\n * @param x Argument.\n * @return tan(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atan#2424",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atan(double)",
    "snippet": "public static double atan(double x) {\n        return atan(x, 0.0, false);\n    }",
    "begin_line": 2424,
    "end_line": 2426,
    "comment": "/** \n * Arctangent function\n * @param x a number\n * @return atan(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atan#2434",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atan(double, double, boolean)",
    "snippet": "private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate \u003d false;\n        int idx;\n\n        if (xa \u003d\u003d 0.0) { // Matches +/- 0.0; return correct sign\n            return leftPlane ? copySign(Math.PI, xa) : xa;\n        }\n\n        if (xa \u003c 0) {\n            // negative\n            xa \u003d -xa;\n            xb \u003d -xb;\n            negate \u003d true;\n        }\n\n        if (xa \u003e 1.633123935319537E16) { // Very large input\n            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n        }\n\n        /* Estimate the closest tabulated arctan value, compute eps \u003d xa-tangentTable */\n        if (xa \u003c 1) {\n            idx \u003d (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n        } else {\n            final double oneOverXa \u003d 1 / xa;\n            idx \u003d (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n        }\n        double epsA \u003d xa - TANGENT_TABLE_A[idx];\n        double epsB \u003d -(epsA - xa + TANGENT_TABLE_A[idx]);\n        epsB +\u003d xb - TANGENT_TABLE_B[idx];\n\n        double temp \u003d epsA + epsB;\n        epsB \u003d -(temp - epsA - epsB);\n        epsA \u003d temp;\n\n        /* Compute eps \u003d eps / (1.0 + xa*tangent) */\n        temp \u003d xa * HEX_40000000;\n        double ya \u003d xa + temp - temp;\n        double yb \u003d xb + xa - ya;\n        xa \u003d ya;\n        xb +\u003d yb;\n\n        //if (idx \u003e 8 || idx \u003d\u003d 0)\n        if (idx \u003d\u003d 0) {\n            /* If the slope of the arctan is gentle enough (\u003c 0.45), this approximation will suffice */\n            //double denom \u003d 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\n            final double denom \u003d 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n            //double denom \u003d 1.0 / (1.0 + xa*tangentTableA[idx]);\n            ya \u003d epsA * denom;\n            yb \u003d epsB * denom;\n        } else {\n            double temp2 \u003d xa * TANGENT_TABLE_A[idx];\n            double za \u003d 1d + temp2;\n            double zb \u003d -(za - 1d - temp2);\n            temp2 \u003d xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n            temp \u003d za + temp2;\n            zb +\u003d -(temp - za - temp2);\n            za \u003d temp;\n\n            zb +\u003d xb * TANGENT_TABLE_B[idx];\n            ya \u003d epsA / za;\n\n            temp \u003d ya * HEX_40000000;\n            final double yaa \u003d (ya + temp) - temp;\n            final double yab \u003d ya - yaa;\n\n            temp \u003d za * HEX_40000000;\n            final double zaa \u003d (za + temp) - temp;\n            final double zab \u003d za - zaa;\n\n            /* Correct for rounding in division */\n            yb \u003d (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\n            yb +\u003d -epsA * zb / za / za;\n            yb +\u003d epsB / za;\n        }\n\n\n        epsA \u003d ya;\n        epsB \u003d yb;\n\n        /* Evaluate polynomial */\n        final double epsA2 \u003d epsA * epsA;\n\n        /*\n    yb \u003d -0.09001346640161823;\n    yb \u003d yb * epsA2 + 0.11110718400605211;\n    yb \u003d yb * epsA2 + -0.1428571349122913;\n    yb \u003d yb * epsA2 + 0.19999999999273194;\n    yb \u003d yb * epsA2 + -0.33333333333333093;\n    yb \u003d yb * epsA2 * epsA;\n         */\n\n        yb \u003d 0.07490822288864472;\n        yb \u003d yb * epsA2 + -0.09088450866185192;\n        yb \u003d yb * epsA2 + 0.11111095942313305;\n        yb \u003d yb * epsA2 + -0.1428571423679182;\n        yb \u003d yb * epsA2 + 0.19999999999923582;\n        yb \u003d yb * epsA2 + -0.33333333333333287;\n        yb \u003d yb * epsA2 * epsA;\n\n\n        ya \u003d epsA;\n\n        temp \u003d ya + yb;\n        yb \u003d -(temp - ya - yb);\n        ya \u003d temp;\n\n        /* Add in effect of epsB.   atan\u0027(x) \u003d 1/(1+x^2) */\n        yb +\u003d epsB / (1d + epsA * epsA);\n\n        //result \u003d yb + eighths[idx] + ya;\n        double za \u003d EIGHTHS[idx] + ya;\n        double zb \u003d -(za - EIGHTHS[idx] - ya);\n        temp \u003d za + yb;\n        zb +\u003d -(temp - za - yb);\n        za \u003d temp;\n\n        double result \u003d za + zb;\n        double resultb \u003d -(result - za - zb);\n\n        if (leftPlane) {\n            // Result is in the left plane\n            final double pia \u003d 1.5707963267948966 * 2;\n            final double pib \u003d 6.123233995736766E-17 * 2;\n\n            za \u003d pia - result;\n            zb \u003d -(za - pia + result);\n            zb +\u003d pib - resultb;\n\n            result \u003d za + zb;\n            resultb \u003d -(result - za - zb);\n        }\n\n\n        if (negate ^ leftPlane) {\n            result \u003d -result;\n        }\n\n        return result;\n    }",
    "begin_line": 2434,
    "end_line": 2573,
    "comment": "/** \n * Internal helper function to compute arctangent.\n * @param xa number from which arctangent is requested\n * @param xb extra bits for x (may be 0.0)\n * @param leftPlane if true, result angle must be put in the left half plane\n * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atan2#2581",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atan2(double, double)",
    "snippet": "public static double atan2(double y, double x) {\n        if (x !\u003d x || y !\u003d y) {\n            return Double.NaN;\n        }\n\n        if (y \u003d\u003d 0) {\n            final double result \u003d x * y;\n            final double invx \u003d 1d / x;\n            final double invy \u003d 1d / y;\n\n            if (invx \u003d\u003d 0) { // X is infinite\n                if (x \u003e 0) {\n                    return y; // return +/- 0.0\n                } else {\n                    return copySign(Math.PI, y);\n                }\n            }\n\n            if (x \u003c 0 || invx \u003c 0) {\n                if (y \u003c 0 || invy \u003c 0) {\n                    return -Math.PI;\n                } else {\n                    return Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n\n        // y cannot now be zero\n\n        if (y \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n                return Math.PI * F_1_4;\n            }\n\n            if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n                return Math.PI * F_3_4;\n            }\n\n            return Math.PI * F_1_2;\n        }\n\n        if (y \u003d\u003d Double.NEGATIVE_INFINITY) {\n            if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n                return -Math.PI * F_1_4;\n            }\n\n            if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n                return -Math.PI * F_3_4;\n            }\n\n            return -Math.PI * F_1_2;\n        }\n\n        if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (y \u003e 0 || 1 / y \u003e 0) {\n                return 0d;\n            }\n\n            if (y \u003c 0 || 1 / y \u003c 0) {\n                return -0d;\n            }\n        }\n\n        if (x \u003d\u003d Double.NEGATIVE_INFINITY)\n        {\n            if (y \u003e 0.0 || 1 / y \u003e 0.0) {\n                return Math.PI;\n            }\n\n            if (y \u003c 0 || 1 / y \u003c 0) {\n                return -Math.PI;\n            }\n        }\n\n        // Neither y nor x can be infinite or NAN here\n\n        if (x \u003d\u003d 0) {\n            if (y \u003e 0 || 1 / y \u003e 0) {\n                return Math.PI * F_1_2;\n            }\n\n            if (y \u003c 0 || 1 / y \u003c 0) {\n                return -Math.PI * F_1_2;\n            }\n        }\n\n        // Compute ratio r \u003d y/x\n        final double r \u003d y / x;\n        if (Double.isInfinite(r)) { // bypass calculations that can create NaN\n            return atan(r, 0, x \u003c 0);\n        }\n\n        double ra \u003d doubleHighPart(r);\n        double rb \u003d r - ra;\n\n        // Split x\n        final double xa \u003d doubleHighPart(x);\n        final double xb \u003d x - xa;\n\n        rb +\u003d (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\n        final double temp \u003d ra + rb;\n        rb \u003d -(temp - ra - rb);\n        ra \u003d temp;\n\n        if (ra \u003d\u003d 0) { // Fix up the sign so atan works correctly\n            ra \u003d copySign(0d, y);\n        }\n\n        // Call atan\n        final double result \u003d atan(ra, rb, x \u003c 0);\n\n        return result;\n    }",
    "begin_line": 2581,
    "end_line": 2696,
    "comment": "/** \n * Two arguments arctangent function\n * @param y ordinate\n * @param x abscissa\n * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.asin#2702",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.asin(double)",
    "snippet": "public static double asin(double x) {\n      if (x !\u003d x) {\n          return Double.NaN;\n      }\n\n      if (x \u003e 1.0 || x \u003c -1.0) {\n          return Double.NaN;\n      }\n\n      if (x \u003d\u003d 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x \u003d\u003d -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x \u003d\u003d 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) \u003d atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp \u003d x * HEX_40000000;\n      final double xa \u003d x + temp - temp;\n      final double xb \u003d x - xa;\n\n      /* Square it */\n      double ya \u003d xa*xa;\n      double yb \u003d xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya \u003d -ya;\n      yb \u003d -yb;\n\n      double za \u003d 1.0 + ya;\n      double zb \u003d -(za - 1.0 - ya);\n\n      temp \u003d za + yb;\n      zb +\u003d -(temp - za - yb);\n      za \u003d temp;\n\n      /* Square root */\n      double y;\n      y \u003d sqrt(za);\n      temp \u003d y * HEX_40000000;\n      ya \u003d y + temp - temp;\n      yb \u003d y - ya;\n\n      /* Extend precision of sqrt */\n      yb +\u003d (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx \u003d zb / (2.0*y);\n\n      // Compute ratio r \u003d x/y\n      double r \u003d x/y;\n      temp \u003d r * HEX_40000000;\n      double ra \u003d r + temp - temp;\n      double rb \u003d r - ra;\n\n      rb +\u003d (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb +\u003d -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp \u003d ra + rb;\n      rb \u003d -(temp - ra - rb);\n      ra \u003d temp;\n\n      return atan(ra, rb, false);\n    }",
    "begin_line": 2702,
    "end_line": 2772,
    "comment": "/** \n * Compute the arc sine of a number.\n * @param x number on which evaluation is done\n * @return arc sine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.acos#2778",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.acos(double)",
    "snippet": "public static double acos(double x) {\n      if (x !\u003d x) {\n          return Double.NaN;\n      }\n\n      if (x \u003e 1.0 || x \u003c -1.0) {\n          return Double.NaN;\n      }\n\n      if (x \u003d\u003d -1.0) {\n          return Math.PI;\n      }\n\n      if (x \u003d\u003d 1.0) {\n          return 0.0;\n      }\n\n      if (x \u003d\u003d 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) \u003d atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp \u003d x * HEX_40000000;\n      final double xa \u003d x + temp - temp;\n      final double xb \u003d x - xa;\n\n      /* Square it */\n      double ya \u003d xa*xa;\n      double yb \u003d xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya \u003d -ya;\n      yb \u003d -yb;\n\n      double za \u003d 1.0 + ya;\n      double zb \u003d -(za - 1.0 - ya);\n\n      temp \u003d za + yb;\n      zb +\u003d -(temp - za - yb);\n      za \u003d temp;\n\n      /* Square root */\n      double y \u003d sqrt(za);\n      temp \u003d y * HEX_40000000;\n      ya \u003d y + temp - temp;\n      yb \u003d y - ya;\n\n      /* Extend precision of sqrt */\n      yb +\u003d (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb +\u003d zb / (2.0*y);\n      y \u003d ya+yb;\n      yb \u003d -(y - ya - yb);\n\n      // Compute ratio r \u003d y/x\n      double r \u003d y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra \u003d doubleHighPart(r);\n      double rb \u003d r - ra;\n\n      rb +\u003d (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb +\u003d yb / x;  // Add in effect additional bits of sqrt.\n\n      temp \u003d ra + rb;\n      rb \u003d -(temp - ra - rb);\n      ra \u003d temp;\n\n      return atan(ra, rb, x\u003c0);\n    }",
    "begin_line": 2778,
    "end_line": 2854,
    "comment": "/** \n * Compute the arc cosine of a number.\n * @param x number on which evaluation is done\n * @return arc cosine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cbrt#2860",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cbrt(double)",
    "snippet": "public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits \u003d Double.doubleToRawLongBits(x);\n      int exponent \u003d (int) ((inbits \u003e\u003e 52) \u0026 0x7ff) - 1023;\n      boolean subnormal \u003d false;\n\n      if (exponent \u003d\u003d -1023) {\n          if (x \u003d\u003d 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal \u003d true;\n          x *\u003d 1.8014398509481984E16;  // 2^54\n          inbits \u003d Double.doubleToRawLongBits(x);\n          exponent \u003d (int) ((inbits \u003e\u003e 52) \u0026 0x7ff) - 1023;\n      }\n\n      if (exponent \u003d\u003d 1024) {\n          // Nan or infinity.  Don\u0027t care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 \u003d exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n      double p2 \u003d Double.longBitsToDouble((inbits \u0026 0x8000000000000000L) |\n                                          (long)(((exp3 + 1023) \u0026 0x7ff)) \u003c\u003c 52);\n\n      /* This will be a number between 1 and 2 */\n      final double mant \u003d Double.longBitsToDouble((inbits \u0026 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est \u003d -0.010714690733195933;\n      est \u003d est * mant + 0.0875862700108075;\n      est \u003d est * mant + -0.3058015757857271;\n      est \u003d est * mant + 0.7249995199969751;\n      est \u003d est * mant + 0.5039018405998233;\n\n      est *\u003d CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton\u0027s method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs \u003d x / (p2*p2*p2);\n      est +\u003d (xs - est*est*est) / (3*est*est);\n      est +\u003d (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton\u0027s method in extended precision to get the last bit right.\n      double temp \u003d est * HEX_40000000;\n      double ya \u003d est + temp - temp;\n      double yb \u003d est - ya;\n\n      double za \u003d ya * ya;\n      double zb \u003d ya * yb * 2.0 + yb * yb;\n      temp \u003d za * HEX_40000000;\n      double temp2 \u003d za + temp - temp;\n      zb +\u003d za - temp2;\n      za \u003d temp2;\n\n      zb \u003d za * yb + ya * zb + zb * yb;\n      za \u003d za * ya;\n\n      double na \u003d xs - za;\n      double nb \u003d -(na - xs + za);\n      nb -\u003d zb;\n\n      est +\u003d (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *\u003d p2;\n\n      if (subnormal) {\n          est *\u003d 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
    "begin_line": 2860,
    "end_line": 2938,
    "comment": "/** \n * Compute the cubic root of a number.\n * @param x number on which evaluation is done\n * @return cubic root of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.toRadians#2945",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.toRadians(double)",
    "snippet": "public static double toRadians(double x)\n    {\n        if (Double.isInfinite(x) || x \u003d\u003d 0.0) { // Matches +/- 0.0; return correct sign\n            return x;\n        }\n\n        // These are PI/180 split into high and low order bits\n        final double facta \u003d 0.01745329052209854;\n        final double factb \u003d 1.997844754509471E-9;\n\n        double xa \u003d doubleHighPart(x);\n        double xb \u003d x - xa;\n\n        double result \u003d xb * factb + xb * facta + xa * factb + xa * facta;\n        if (result \u003d\u003d 0) {\n            result \u003d result * x; // ensure correct sign if calculation underflows\n        }\n        return result;\n    }",
    "begin_line": 2945,
    "end_line": 2963,
    "comment": "/** \n * Convert degrees to radians, with error of less than 0.5 ULP\n * @param x angle in degrees\n * @return x converted into radians\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.toDegrees#2970",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.toDegrees(double)",
    "snippet": "public static double toDegrees(double x)\n    {\n        if (Double.isInfinite(x) || x \u003d\u003d 0.0) { // Matches +/- 0.0; return correct sign\n            return x;\n        }\n\n        // These are 180/PI split into high and low order bits\n        final double facta \u003d 57.2957763671875;\n        final double factb \u003d 3.145894820876798E-6;\n\n        double xa \u003d doubleHighPart(x);\n        double xb \u003d x - xa;\n\n        return xb * factb + xb * facta + xa * factb + xa * facta;\n    }",
    "begin_line": 2970,
    "end_line": 2984,
    "comment": "/** \n * Convert radians to degrees, with error of less than 0.5 ULP\n * @param x angle in radians\n * @return x converted into degrees\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#2991",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(int)",
    "snippet": "public static int abs(final int x) {\n        final int i \u003d x \u003e\u003e\u003e 31;\n        return (x ^ (~i + 1)) + i;\n    }",
    "begin_line": 2991,
    "end_line": 2994,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3001",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
    "snippet": "public static long abs(final long x) {\n        final long l \u003d x \u003e\u003e\u003e 63;\n        // l is one if x negative zero else\n        // ~l+1 is zero if x is positive, -1 if x is negative\n        // x^(~l+1) is x is x is positive, ~x if x is negative\n        // add around\n        return (x ^ (~l + 1)) + l;\n    }",
    "begin_line": 3001,
    "end_line": 3008,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3015",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(float)",
    "snippet": "public static float abs(final float x) {\n        return Float.intBitsToFloat(MASK_NON_SIGN_INT \u0026 Float.floatToRawIntBits(x));\n    }",
    "begin_line": 3015,
    "end_line": 3017,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3024",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
    "snippet": "public static double abs(double x) {\n        return Double.longBitsToDouble(MASK_NON_SIGN_LONG \u0026 Double.doubleToRawLongBits(x));\n    }",
    "begin_line": 3024,
    "end_line": 3026,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.ulp#3033",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.ulp(double)",
    "snippet": "public static double ulp(double x) {\n        if (Double.isInfinite(x)) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));\n    }",
    "begin_line": 3033,
    "end_line": 3038,
    "comment": "/** \n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.ulp#3045",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.ulp(float)",
    "snippet": "public static float ulp(float x) {\n        if (Float.isInfinite(x)) {\n            return Float.POSITIVE_INFINITY;\n        }\n        return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n    }",
    "begin_line": 3045,
    "end_line": 3050,
    "comment": "/** \n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.scalb#3058",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.scalb(double, int)",
    "snippet": "public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n \u003e -1023) \u0026\u0026 (n \u003c 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) \u003c\u003c 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d \u003d\u003d 0)) {\n            return d;\n        }\n        if (n \u003c -2098) {\n            return (d \u003e 0) ? 0.0 : -0.0;\n        }\n        if (n \u003e 2097) {\n            return (d \u003e 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits \u003d Double.doubleToRawLongBits(d);\n        final long sign \u003d bits \u0026 0x8000000000000000L;\n        int  exponent   \u003d ((int) (bits \u003e\u003e\u003e 52)) \u0026 0x7ff;\n        long mantissa   \u003d bits \u0026 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent \u003d exponent + n;\n\n        if (n \u003c 0) {\n            // we are really in the case n \u003c\u003d -1023\n            if (scaledExponent \u003e 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) \u003c\u003c 52) | mantissa);\n            } else if (scaledExponent \u003e -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa \u003d mantissa | (1L \u003c\u003c 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit \u003d mantissa \u0026 (1L \u003c\u003c (-scaledExponent));\n                mantissa \u003d mantissa \u003e\u003e\u003e (1 - scaledExponent);\n                if (mostSignificantLostBit !\u003d 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign \u003d\u003d 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n \u003e\u003d 1024\n            if (exponent \u003d\u003d 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa \u003e\u003e\u003e 52) !\u003d 1) {\n                    mantissa \u003d mantissa \u003c\u003c 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa \u003d mantissa \u0026 0x000fffffffffffffL;\n\n                if (scaledExponent \u003c 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) \u003c\u003c 52) | mantissa);\n                } else {\n                    return (sign \u003d\u003d 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent \u003c 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) \u003c\u003c 52) | mantissa);\n            } else {\n                return (sign \u003d\u003d 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
    "begin_line": 3058,
    "end_line": 3134,
    "comment": "/** \n * Multiply a double number by a power of 2.\n * @param d number to multiply\n * @param n power of 2\n * @return d \u0026times; 2\u003csup\u003en\u003c/sup\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.scalb#3142",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.scalb(float, int)",
    "snippet": "public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n \u003e -127) \u0026\u0026 (n \u003c 128)) {\n            return f * Float.intBitsToFloat((n + 127) \u003c\u003c 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f \u003d\u003d 0f)) {\n            return f;\n        }\n        if (n \u003c -277) {\n            return (f \u003e 0) ? 0.0f : -0.0f;\n        }\n        if (n \u003e 276) {\n            return (f \u003e 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits \u003d Float.floatToIntBits(f);\n        final int sign \u003d bits \u0026 0x80000000;\n        int  exponent  \u003d (bits \u003e\u003e\u003e 23) \u0026 0xff;\n        int mantissa   \u003d bits \u0026 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent \u003d exponent + n;\n\n        if (n \u003c 0) {\n            // we are really in the case n \u003c\u003d -127\n            if (scaledExponent \u003e 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent \u003c\u003c 23) | mantissa);\n            } else if (scaledExponent \u003e -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa \u003d mantissa | (1 \u003c\u003c 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit \u003d mantissa \u0026 (1 \u003c\u003c (-scaledExponent));\n                mantissa \u003d mantissa \u003e\u003e\u003e (1 - scaledExponent);\n                if (mostSignificantLostBit !\u003d 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign \u003d\u003d 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n \u003e\u003d 128\n            if (exponent \u003d\u003d 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa \u003e\u003e\u003e 23) !\u003d 1) {\n                    mantissa \u003d mantissa \u003c\u003c 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa \u003d mantissa \u0026 0x007fffff;\n\n                if (scaledExponent \u003c 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent \u003c\u003c 23) | mantissa);\n                } else {\n                    return (sign \u003d\u003d 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent \u003c 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent \u003c\u003c 23) | mantissa);\n            } else {\n                return (sign \u003d\u003d 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
    "begin_line": 3142,
    "end_line": 3218,
    "comment": "/** \n * Multiply a float number by a power of 2.\n * @param f number to multiply\n * @param n power of 2\n * @return f \u0026times; 2\u003csup\u003en\u003c/sup\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextAfter#3251",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextAfter(double, double)",
    "snippet": "public static double nextAfter(double d, double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(d) || Double.isNaN(direction)) {\n            return Double.NaN;\n        } else if (d \u003d\u003d direction) {\n            return direction;\n        } else if (Double.isInfinite(d)) {\n            return (d \u003c 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n        } else if (d \u003d\u003d 0) {\n            return (direction \u003c 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n        // can use raw bits since already dealt with infinity and NaN\n        final long bits \u003d Double.doubleToRawLongBits(d);\n        final long sign \u003d bits \u0026 0x8000000000000000L;\n        if ((direction \u003c d) ^ (sign \u003d\u003d 0L)) {\n            return Double.longBitsToDouble(sign | ((bits \u0026 0x7fffffffffffffffL) + 1));\n        } else {\n            return Double.longBitsToDouble(sign | ((bits \u0026 0x7fffffffffffffffL) - 1));\n        }\n\n    }",
    "begin_line": 3251,
    "end_line": 3274,
    "comment": "/** \n * Get the next machine representable number after a number, moving in the direction of another number. \u003cp\u003e The ordering is as follows (increasing): \u003cul\u003e \u003cli\u003e-INFINITY\u003c/li\u003e \u003cli\u003e-MAX_VALUE\u003c/li\u003e \u003cli\u003e-MIN_VALUE\u003c/li\u003e \u003cli\u003e-0.0\u003c/li\u003e \u003cli\u003e+0.0\u003c/li\u003e \u003cli\u003e+MIN_VALUE\u003c/li\u003e \u003cli\u003e+MAX_VALUE\u003c/li\u003e \u003cli\u003e+INFINITY\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cp\u003e If arguments compare equal, then the second argument is returned. \u003cp\u003e If  {@code direction} is greater than {@code d}, the smallest machine representable number strictly greater than {@code d} is returned; if less, then the largest representable numberstrictly less than  {@code d} is returned.\u003c/p\u003e\u003cp\u003e If  {@code d} is infinite and direction does notbring it back to finite numbers, it is returned unchanged.\u003c/p\u003e\n * @param d base number\n * @param direction (the only important thing is whether{@code direction} is greater or smaller than {@code d})\n * @return the next machine representable number in the specified direction\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextAfter#3307",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextAfter(float, double)",
    "snippet": "public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f \u003d\u003d direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f \u003c 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f \u003d\u003d 0f) {\n            return (direction \u003c 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits \u003d Float.floatToIntBits(f);\n        final int sign \u003d bits \u0026 0x80000000;\n        if ((direction \u003c f) ^ (sign \u003d\u003d 0)) {\n            return Float.intBitsToFloat(sign | ((bits \u0026 0x7fffffff) + 1));\n        } else {\n            return Float.intBitsToFloat(sign | ((bits \u0026 0x7fffffff) - 1));\n        }\n\n    }",
    "begin_line": 3307,
    "end_line": 3330,
    "comment": "/** \n * Get the next machine representable number after a number, moving in the direction of another number. \u003cp\u003e The ordering is as follows (increasing): \u003cul\u003e \u003cli\u003e-INFINITY\u003c/li\u003e \u003cli\u003e-MAX_VALUE\u003c/li\u003e \u003cli\u003e-MIN_VALUE\u003c/li\u003e \u003cli\u003e-0.0\u003c/li\u003e \u003cli\u003e+0.0\u003c/li\u003e \u003cli\u003e+MIN_VALUE\u003c/li\u003e \u003cli\u003e+MAX_VALUE\u003c/li\u003e \u003cli\u003e+INFINITY\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cp\u003e If arguments compare equal, then the second argument is returned. \u003cp\u003e If  {@code direction} is greater than {@code f}, the smallest machine representable number strictly greater than {@code f} is returned; if less, then the largest representable numberstrictly less than  {@code f} is returned.\u003c/p\u003e\u003cp\u003e If  {@code f} is infinite and direction does notbring it back to finite numbers, it is returned unchanged.\u003c/p\u003e\n * @param f base number\n * @param direction (the only important thing is whether{@code direction} is greater or smaller than {@code f})\n * @return the next machine representable number in the specified direction\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.floor#3336",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.floor(double)",
    "snippet": "public static double floor(double x) {\n        long y;\n\n        if (x !\u003d x) { // NaN\n            return x;\n        }\n\n        if (x \u003e\u003d TWO_POWER_52 || x \u003c\u003d -TWO_POWER_52) {\n            return x;\n        }\n\n        y \u003d (long) x;\n        if (x \u003c 0 \u0026\u0026 y !\u003d x) {\n            y--;\n        }\n\n        if (y \u003d\u003d 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "begin_line": 3336,
    "end_line": 3357,
    "comment": "/** \n * Get the largest whole number smaller than x.\n * @param x number from which floor is requested\n * @return a double number f such that f is an integer f \u003c\u003d x \u003c f + 1.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.ceil#3363",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.ceil(double)",
    "snippet": "public static double ceil(double x) {\n        double y;\n\n        if (x !\u003d x) { // NaN\n            return x;\n        }\n\n        y \u003d floor(x);\n        if (y \u003d\u003d x) {\n            return y;\n        }\n\n        y +\u003d 1.0;\n\n        if (y \u003d\u003d 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "begin_line": 3363,
    "end_line": 3382,
    "comment": "/** \n * Get the smallest whole number larger than x.\n * @param x number from which ceil is requested\n * @return a double number c such that c is an integer c - 1.0 \u003c x \u003c\u003d c\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.rint#3388",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.rint(double)",
    "snippet": "public static double rint(double x) {\n        double y \u003d floor(x);\n        double d \u003d x - y;\n\n        if (d \u003e 0.5) {\n            if (y \u003d\u003d -1.0) {\n                return -0.0; // Preserve sign of operand\n            }\n            return y+1.0;\n        }\n        if (d \u003c 0.5) {\n            return y;\n        }\n\n        /* half way, round to even */\n        long z \u003d (long) y;\n        return (z \u0026 1) \u003d\u003d 0 ? y : y + 1.0;\n    }",
    "begin_line": 3388,
    "end_line": 3405,
    "comment": "/** \n * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n * @param x number from which nearest whole number is requested\n * @return a double number r such that r is an integer r - 0.5 \u003c\u003d x \u003c\u003d r + 0.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.round#3411",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.round(double)",
    "snippet": "public static long round(double x) {\n        return (long) floor(x + 0.5);\n    }",
    "begin_line": 3411,
    "end_line": 3413,
    "comment": "/** \n * Get the closest long to x.\n * @param x number from which closest long is requested\n * @return closest long to x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.round#3419",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.round(float)",
    "snippet": "public static int round(final float x) {\n        return (int) floor(x + 0.5f);\n    }",
    "begin_line": 3419,
    "end_line": 3421,
    "comment": "/** \n * Get the closest int to x.\n * @param x number from which closest int is requested\n * @return closest int to x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3428",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(int, int)",
    "snippet": "public static int min(final int a, final int b) {\n        return (a \u003c\u003d b) ? a : b;\n    }",
    "begin_line": 3428,
    "end_line": 3430,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3437",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(long, long)",
    "snippet": "public static long min(final long a, final long b) {\n        return (a \u003c\u003d b) ? a : b;\n    }",
    "begin_line": 3437,
    "end_line": 3439,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3446",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(float, float)",
    "snippet": "public static float min(final float a, final float b) {\n        if (a \u003e b) {\n            return b;\n        }\n        if (a \u003c b) {\n            return a;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a !\u003d b) {\n            return Float.NaN;\n        }\n        /* min(+0.0,-0.0) \u003d\u003d -0.0 */\n        /* 0x80000000 \u003d\u003d Float.floatToRawIntBits(-0.0d) */\n        int bits \u003d Float.floatToRawIntBits(a);\n        if (bits \u003d\u003d 0x80000000) {\n            return a;\n        }\n        return b;\n    }",
    "begin_line": 3446,
    "end_line": 3464,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3471",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(double, double)",
    "snippet": "public static double min(final double a, final double b) {\n        if (a \u003e b) {\n            return b;\n        }\n        if (a \u003c b) {\n            return a;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a !\u003d b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) \u003d\u003d -0.0 */\n        /* 0x8000000000000000L \u003d\u003d Double.doubleToRawLongBits(-0.0d) */\n        long bits \u003d Double.doubleToRawLongBits(a);\n        if (bits \u003d\u003d 0x8000000000000000L) {\n            return a;\n        }\n        return b;\n    }",
    "begin_line": 3471,
    "end_line": 3489,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3496",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(int, int)",
    "snippet": "public static int max(final int a, final int b) {\n        return (a \u003c\u003d b) ? b : a;\n    }",
    "begin_line": 3496,
    "end_line": 3498,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3505",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(long, long)",
    "snippet": "public static long max(final long a, final long b) {\n        return (a \u003c\u003d b) ? b : a;\n    }",
    "begin_line": 3505,
    "end_line": 3507,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3514",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(float, float)",
    "snippet": "public static float max(final float a, final float b) {\n        if (a \u003e b) {\n            return a;\n        }\n        if (a \u003c b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a !\u003d b) {\n            return Float.NaN;\n        }\n        /* min(+0.0,-0.0) \u003d\u003d -0.0 */\n        /* 0x80000000 \u003d\u003d Float.floatToRawIntBits(-0.0d) */\n        int bits \u003d Float.floatToRawIntBits(a);\n        if (bits \u003d\u003d 0x80000000) {\n            return b;\n        }\n        return a;\n    }",
    "begin_line": 3514,
    "end_line": 3532,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3539",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(double, double)",
    "snippet": "public static double max(final double a, final double b) {\n        if (a \u003e b) {\n            return a;\n        }\n        if (a \u003c b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a !\u003d b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) \u003d\u003d -0.0 */\n        /* 0x8000000000000000L \u003d\u003d Double.doubleToRawLongBits(-0.0d) */\n        long bits \u003d Double.doubleToRawLongBits(a);\n        if (bits \u003d\u003d 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }",
    "begin_line": 3539,
    "end_line": 3557,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.hypot#3573",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.hypot(double, double)",
    "snippet": "public static double hypot(final double x, final double y) {\n        if (Double.isInfinite(x) || Double.isInfinite(y)) {\n            return Double.POSITIVE_INFINITY;\n        } else if (Double.isNaN(x) || Double.isNaN(y)) {\n            return Double.NaN;\n        } else {\n\n            final int expX \u003d getExponent(x);\n            final int expY \u003d getExponent(y);\n            if (expX \u003e expY + 27) {\n                // y is neglectible with respect to x\n                return abs(x);\n            } else if (expY \u003e expX + 27) {\n                // x is neglectible with respect to y\n                return abs(y);\n            } else {\n\n                // find an intermediate scale to avoid both overflow and underflow\n                final int middleExp \u003d (expX + expY) / 2;\n\n                // scale parameters without losing precision\n                final double scaledX \u003d scalb(x, -middleExp);\n                final double scaledY \u003d scalb(y, -middleExp);\n\n                // compute scaled hypotenuse\n                final double scaledH \u003d sqrt(scaledX * scaledX + scaledY * scaledY);\n\n                // remove scaling\n                return scalb(scaledH, middleExp);\n\n            }\n\n        }\n    }",
    "begin_line": 3573,
    "end_line": 3606,
    "comment": "/** \n * Returns the hypotenuse of a triangle with sides  {@code x} and {@code y}- sqrt(\u003ci\u003ex\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u0026nbsp;+\u003ci\u003ey\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e)\u003cbr/\u003e avoiding intermediate overflow or underflow. \u003cul\u003e \u003cli\u003e If either argument is infinite, then the result is positive infinity.\u003c/li\u003e \u003cli\u003e else, if either argument is NaN then the result is NaN.\u003c/li\u003e \u003c/ul\u003e\n * @param x a value\n * @param y a value\n * @return sqrt(\u003ci\u003ex\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u0026nbsp;+\u003ci\u003ey\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.IEEEremainder#3628",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.IEEEremainder(double, double)",
    "snippet": "public static double IEEEremainder(double dividend, double divisor) {\n        return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation\n    }",
    "begin_line": 3628,
    "end_line": 3630,
    "comment": "/** \n * Computes the remainder as prescribed by the IEEE 754 standard. The remainder value is mathematically equal to  {@code x - y*n}where  {@code n} is the mathematical integer closest to the exact mathematical valueof the quotient  {@code x/y}. If two mathematical integers are equally close to  {@code x/y} then{@code n} is the integer that is even.\u003cp\u003e \u003cul\u003e \u003cli\u003eIf either operand is NaN, the result is NaN.\u003c/li\u003e \u003cli\u003eIf the result is not NaN, the sign of the result equals the sign of the dividend.\u003c/li\u003e \u003cli\u003eIf the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.\u003c/li\u003e \u003cli\u003eIf the dividend is finite and the divisor is an infinity, the result equals the dividend.\u003c/li\u003e \u003cli\u003eIf the dividend is a zero and the divisor is finite, the result equals the dividend.\u003c/li\u003e \u003c/ul\u003e \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e this implementation currently delegates to  {@link StrictMath#IEEEremainder}\n * @param dividend the number to be divided\n * @param divisor the number by which to divide\n * @return the remainder, rounded\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.copySign#3640",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.copySign(double, double)",
    "snippet": "public static double copySign(double magnitude, double sign){\n        // The highest order bit is going to be zero if the\n        // highest order bit of m and s is the same and one otherwise.\n        // So (m^s) will be positive if both m and s have the same sign\n        // and negative otherwise.\n        final long m \u003d Double.doubleToRawLongBits(magnitude); // don\u0027t care about NaN\n        final long s \u003d Double.doubleToRawLongBits(sign);\n        if ((m^s) \u003e\u003d 0) {\n            return magnitude;\n        }\n        return -magnitude; // flip sign\n    }",
    "begin_line": 3640,
    "end_line": 3651,
    "comment": "/** \n * Returns the first argument with the sign of the second argument. A NaN  {@code sign} argument is treated as positive.\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.copySign#3661",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.copySign(float, float)",
    "snippet": "public static float copySign(float magnitude, float sign){\n        // The highest order bit is going to be zero if the\n        // highest order bit of m and s is the same and one otherwise.\n        // So (m^s) will be positive if both m and s have the same sign\n        // and negative otherwise.\n        final int m \u003d Float.floatToRawIntBits(magnitude);\n        final int s \u003d Float.floatToRawIntBits(sign);\n        if ((m^s) \u003e\u003d 0) {\n            return magnitude;\n        }\n        return -magnitude; // flip sign\n    }",
    "begin_line": 3661,
    "end_line": 3672,
    "comment": "/** \n * Returns the first argument with the sign of the second argument. A NaN  {@code sign} argument is treated as positive.\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.getExponent#3683",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getExponent(double)",
    "snippet": "public static int getExponent(final double d) {\n        // NaN and Infinite will return 1024 anywho so can use raw bits\n        return (int) ((Double.doubleToRawLongBits(d) \u003e\u003e\u003e 52) \u0026 0x7ff) - 1023;\n    }",
    "begin_line": 3683,
    "end_line": 3686,
    "comment": "/** \n * Return the exponent of a double number, removing the bias. \u003cp\u003e For double numbers of the form 2\u003csup\u003ex\u003c/sup\u003e, the unbiased exponent is exactly x. \u003c/p\u003e\n * @param d number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.getExponent#3697",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getExponent(float)",
    "snippet": "public static int getExponent(final float f) {\n        // NaN and Infinite will return the same exponent anywho so can use raw bits\n        return ((Float.floatToRawIntBits(f) \u003e\u003e\u003e 23) \u0026 0xff) - 127;\n    }",
    "begin_line": 3697,
    "end_line": 3700,
    "comment": "/** \n * Return the exponent of a float number, removing the bias. \u003cp\u003e For float numbers of the form 2\u003csup\u003ex\u003c/sup\u003e, the unbiased exponent is exactly x. \u003c/p\u003e\n * @param f number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.main#3707",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.main(java.lang.String[])",
    "snippet": "public static void main(String[] a) {\n        PrintStream out \u003d System.out;\n        FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);\n        FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);\n        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n        FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n        FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n        FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n        FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n        FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);\n        FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);\n        FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);\n    }",
    "begin_line": 3707,
    "end_line": 3720,
    "comment": "/** \n * Print out contents of arrays, and check the length. \u003cp\u003eused to generate the preset arrays originally.\u003c/p\u003e\n * @param a unused\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CodyWaite.CodyWaite#3826",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.CodyWaite(double)",
    "snippet": " CodyWaite(double xa) {\n            // Estimate k.\n            //k \u003d (int)(xa / 1.5707963267948966);\n            int k \u003d (int)(xa * 0.6366197723675814);\n\n            // Compute remainder.\n            double remA;\n            double remB;\n            while (true) {\n                double a \u003d -k * 1.570796251296997;\n                remA \u003d xa + a;\n                remB \u003d -(remA - xa - a);\n\n                a \u003d -k * 7.549789948768648E-8;\n                double b \u003d remA;\n                remA \u003d a + b;\n                remB +\u003d -(remA - b - a);\n\n                a \u003d -k * 6.123233995736766E-17;\n                b \u003d remA;\n                remA \u003d a + b;\n                remB +\u003d -(remA - b - a);\n\n                if (remA \u003e 0) {\n                    break;\n                }\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2.\n                --k;\n            }\n\n            this.finalK \u003d k;\n            this.finalRemA \u003d remA;\n            this.finalRemB \u003d remB;\n        }",
    "begin_line": 3826,
    "end_line": 3862,
    "comment": "/** \n * @param xa Argument.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CodyWaite.getK#3867",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getK()",
    "snippet": "int getK() {\n            return finalK;\n        }",
    "begin_line": 3867,
    "end_line": 3869,
    "comment": "/** \n * @return k\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CodyWaite.getRemA#3873",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getRemA()",
    "snippet": "double getRemA() {\n            return finalRemA;\n        }",
    "begin_line": 3873,
    "end_line": 3875,
    "comment": "/** \n * @return remA\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CodyWaite.getRemB#3879",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getRemB()",
    "snippet": "double getRemB() {\n            return finalRemB;\n        }",
    "begin_line": 3879,
    "end_line": 3881,
    "comment": "/** \n * @return remB\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathArrays.MathArrays#52",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.MathArrays()",
    "snippet": "private MathArrays() {}",
    "begin_line": 52,
    "end_line": 52,
    "comment": "/** \n * Private constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.evaluate#65",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.evaluate(double[])",
    "snippet": "double evaluate(double[] array);",
    "begin_line": 65,
    "end_line": 65,
    "comment": "/** \n * Operates on an entire array.\n * @param array Array to operate on.\n * @return the result of the operation.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.evaluate#72",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.evaluate(double[], int, int)",
    "snippet": "double evaluate(double[] array,\n                        int startIndex,\n                        int numElements);",
    "begin_line": 72,
    "end_line": 74,
    "comment": "/** \n * @param array Array to operate on.\n * @param startIndex Index of the first element to take into account.\n * @param numElements Number of elements to take into account.\n * @return the result of the operation.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.scale#85",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.scale(double, double[])",
    "snippet": "public static double[] scale(double val, final double[] arr) {\n        double[] newArr \u003d new double[arr.length];\n        for (int i \u003d 0; i \u003c arr.length; i++) {\n            newArr[i] \u003d arr[i] * val;\n        }\n        return newArr;\n    }",
    "begin_line": 85,
    "end_line": 91,
    "comment": "/** \n * Create a copy of an array scaled by a value.\n * @param arr Array to scale.\n * @param val Scalar.\n * @return scaled copy of array with each entry multiplied by val.\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.scaleInPlace#102",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.scaleInPlace(double, double[])",
    "snippet": "public static void scaleInPlace(double val, final double[] arr) {\n        for (int i \u003d 0; i \u003c arr.length; i++) {\n            arr[i] *\u003d val;\n        }\n    }",
    "begin_line": 102,
    "end_line": 106,
    "comment": "/** \n * \u003cp\u003eMultiply each element of an array by a value.\u003c/p\u003e \u003cp\u003eThe array is modified in place (no copy is created).\u003c/p\u003e\n * @param arr Array to scale\n * @param val Scalar\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.ebeAdd#118",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.ebeAdd(double[], double[])",
    "snippet": "public static double[] ebeAdd(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length !\u003d b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result \u003d a.clone();\n        for (int i \u003d 0; i \u003c a.length; i++) {\n            result[i] +\u003d b[i];\n        }\n        return result;\n    }",
    "begin_line": 118,
    "end_line": 129,
    "comment": "/** \n * Creates an array whose contents will be the element-by-element addition of the arguments.\n * @param a First term of the addition.\n * @param b Second term of the addition.\n * @return a new array {@code r} where {@code r[i] \u003d a[i] + b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.ebeSubtract#140",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.ebeSubtract(double[], double[])",
    "snippet": "public static double[] ebeSubtract(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length !\u003d b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result \u003d a.clone();\n        for (int i \u003d 0; i \u003c a.length; i++) {\n            result[i] -\u003d b[i];\n        }\n        return result;\n    }",
    "begin_line": 140,
    "end_line": 151,
    "comment": "/** \n * Creates an array whose contents will be the element-by-element subtraction of the second argument from the first.\n * @param a First term.\n * @param b Element to be subtracted.\n * @return a new array {@code r} where {@code r[i] \u003d a[i] - b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.ebeMultiply#162",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.ebeMultiply(double[], double[])",
    "snippet": "public static double[] ebeMultiply(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length !\u003d b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result \u003d a.clone();\n        for (int i \u003d 0; i \u003c a.length; i++) {\n            result[i] *\u003d b[i];\n        }\n        return result;\n    }",
    "begin_line": 162,
    "end_line": 173,
    "comment": "/** \n * Creates an array whose contents will be the element-by-element multiplication of the arguments.\n * @param a First factor of the multiplication.\n * @param b Second factor of the multiplication.\n * @return a new array {@code r} where {@code r[i] \u003d a[i] * b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.ebeDivide#184",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.ebeDivide(double[], double[])",
    "snippet": "public static double[] ebeDivide(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length !\u003d b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result \u003d a.clone();\n        for (int i \u003d 0; i \u003c a.length; i++) {\n            result[i] /\u003d b[i];\n        }\n        return result;\n    }",
    "begin_line": 184,
    "end_line": 195,
    "comment": "/** \n * Creates an array whose contents will be the element-by-element division of the first argument by the second.\n * @param a Numerator of the division.\n * @param b Denominator of the division.\n * @return a new array {@code r} where {@code r[i] \u003d a[i] / b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distance1#204",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distance1(double[], double[])",
    "snippet": "public static double distance1(double[] p1, double[] p2) {\n        double sum \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            sum +\u003d FastMath.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }",
    "begin_line": 204,
    "end_line": 210,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distance1#219",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distance1(int[], int[])",
    "snippet": "public static int distance1(int[] p1, int[] p2) {\n      int sum \u003d 0;\n      for (int i \u003d 0; i \u003c p1.length; i++) {\n          sum +\u003d FastMath.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }",
    "begin_line": 219,
    "end_line": 225,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distance#234",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distance(double[], double[])",
    "snippet": "public static double distance(double[] p1, double[] p2) {\n        double sum \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            final double dp \u003d p1[i] - p2[i];\n            sum +\u003d dp * dp;\n        }\n        return FastMath.sqrt(sum);\n    }",
    "begin_line": 234,
    "end_line": 241,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distance#250",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distance(int[], int[])",
    "snippet": "public static double distance(int[] p1, int[] p2) {\n      double sum \u003d 0;\n      for (int i \u003d 0; i \u003c p1.length; i++) {\n          final double dp \u003d p1[i] - p2[i];\n          sum +\u003d dp * dp;\n      }\n      return FastMath.sqrt(sum);\n    }",
    "begin_line": 250,
    "end_line": 257,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distanceInf#266",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distanceInf(double[], double[])",
    "snippet": "public static double distanceInf(double[] p1, double[] p2) {\n        double max \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            max \u003d FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }",
    "begin_line": 266,
    "end_line": 272,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distanceInf#281",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distanceInf(int[], int[])",
    "snippet": "public static int distanceInf(int[] p1, int[] p2) {\n        int max \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            max \u003d FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }",
    "begin_line": 281,
    "end_line": 287,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.isMonotonic#308",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.isMonotonic(T[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean)",
    "snippet": "public static  \u003cT extends Comparable\u003c? super T\u003e\u003e boolean isMonotonic(T[] val,\n                                      OrderDirection dir,\n                                      boolean strict) {\n        T previous \u003d val[0];\n        final int max \u003d val.length;\n        for (int i \u003d 1; i \u003c max; i++) {\n            final int comp;\n            switch (dir) {\n            case INCREASING:\n                comp \u003d previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp \u003e\u003d 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp \u003e 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp \u003d val[i].compareTo(previous);\n                if (strict) {\n                    if (comp \u003e\u003d 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp \u003e 0) {\n                       return false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n\n            previous \u003d val[i];\n        }\n        return true;\n    }",
    "begin_line": 308,
    "end_line": 348,
    "comment": "/** \n * Check that an array is monotonically increasing or decreasing.\n * @param \u003c T \u003e the type of the elements in the specified array\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.isMonotonic#358",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.isMonotonic(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean)",
    "snippet": "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n        return checkOrder(val, dir, strict, false);\n    }",
    "begin_line": 358,
    "end_line": 360,
    "comment": "/** \n * Check that an array is monotonically increasing or decreasing.\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkOrder#373",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean, boolean)",
    "snippet": "public static boolean checkOrder(double[] val, OrderDirection dir,\n                                     boolean strict, boolean abort)\n        throws NonMonotonicSequenceException {\n        double previous \u003d val[0];\n        final int max \u003d val.length;\n\n        int index;\n        ITEM:\n        for (index \u003d 1; index \u003c max; index++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] \u003c\u003d previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] \u003c previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] \u003e\u003d previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] \u003e previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n\n            previous \u003d val[index];\n        }\n\n        if (index \u003d\u003d max) {\n            // Loop completed.\n            return true;\n        }\n\n        // Loop early exit means wrong ordering.\n        if (abort) {\n            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n        } else {\n            return false;\n        }\n    }",
    "begin_line": 373,
    "end_line": 424,
    "comment": "/** \n * Check that the given array is sorted.\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the array is sorted.\n * @throws NonMonotonicSequenceException if the array is not sortedand  {@code abort} is {@code true}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkOrder#435",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean)",
    "snippet": "public static void checkOrder(double[] val, OrderDirection dir,\n                                  boolean strict) throws NonMonotonicSequenceException {\n        checkOrder(val, dir, strict, true);\n    }",
    "begin_line": 435,
    "end_line": 438,
    "comment": "/** \n * Check that the given array is sorted.\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @throws NonMonotonicSequenceException if the array is not sorted.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkOrder#447",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[])",
    "snippet": "public static void checkOrder(double[] val) throws NonMonotonicSequenceException {\n        checkOrder(val, OrderDirection.INCREASING, true);\n    }",
    "begin_line": 447,
    "end_line": 449,
    "comment": "/** \n * Check that the given array is sorted in strictly increasing order.\n * @param val Values.\n * @throws NonMonotonicSequenceException if the array is not sorted.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkRectangular#459",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkRectangular(long[][])",
    "snippet": "public static void checkRectangular(final long[][] in)\n        throws NullArgumentException, DimensionMismatchException {\n        MathUtils.checkNotNull(in);\n        for (int i \u003d 1; i \u003c in.length; i++) {\n            if (in[i].length !\u003d in[0].length) {\n                throw new DimensionMismatchException(\n                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                        in[i].length, in[0].length);\n            }\n        }\n    }",
    "begin_line": 459,
    "end_line": 469,
    "comment": "/** \n * Throws DimensionMismatchException if the input array is not rectangular.\n * @param in array to be tested\n * @throws NullArgumentException if input array is null\n * @throws DimensionMismatchException if input array is not rectangular\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkPositive#479",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkPositive(double[])",
    "snippet": "public static void checkPositive(final double[] in)\n        throws NotStrictlyPositiveException {\n        for (int i \u003d 0; i \u003c in.length; i++) {\n            if (in[i] \u003c\u003d 0) {\n                throw new NotStrictlyPositiveException(in[i]);\n            }\n        }\n    }",
    "begin_line": 479,
    "end_line": 486,
    "comment": "/** \n * Check that all entries of the input array are strictly positive.\n * @param in Array to be tested\n * @throws NotStrictlyPositiveException if any entries of the array are notstrictly positive.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkNonNegative#495",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkNonNegative(long[])",
    "snippet": "public static void checkNonNegative(final long[] in)\n        throws NotPositiveException {\n        for (int i \u003d 0; i \u003c in.length; i++) {\n            if (in[i] \u003c 0) {\n                throw new NotPositiveException(in[i]);\n            }\n        }\n    }",
    "begin_line": 495,
    "end_line": 502,
    "comment": "/** \n * Check that all entries of the input array are \u003e\u003d 0.\n * @param in Array to be tested\n * @throws NotPositiveException if any array entries are less than 0.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkNonNegative#511",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkNonNegative(long[][])",
    "snippet": "public static void checkNonNegative(final long[][] in)\n        throws NotPositiveException {\n        for (int i \u003d 0; i \u003c in.length; i ++) {\n            for (int j \u003d 0; j \u003c in[i].length; j++) {\n                if (in[i][j] \u003c 0) {\n                    throw new NotPositiveException(in[i][j]);\n                }\n            }\n        }\n    }",
    "begin_line": 511,
    "end_line": 520,
    "comment": "/** \n * Check all entries of the input array are \u003e\u003d 0.\n * @param in Array to be tested\n * @throws NotPositiveException if any array entries are less than 0.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.safeNorm#582",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.safeNorm(double[])",
    "snippet": "public static double safeNorm(double[] v) {\n        double rdwarf \u003d 3.834e-20;\n        double rgiant \u003d 1.304e+19;\n        double s1 \u003d 0;\n        double s2 \u003d 0;\n        double s3 \u003d 0;\n        double x1max \u003d 0;\n        double x3max \u003d 0;\n        double floatn \u003d v.length;\n        double agiant \u003d rgiant / floatn;\n        for (int i \u003d 0; i \u003c v.length; i++) {\n            double xabs \u003d Math.abs(v[i]);\n            if (xabs \u003c rdwarf || xabs \u003e agiant) {\n                if (xabs \u003e rdwarf) {\n                    if (xabs \u003e x1max) {\n                        double r \u003d x1max / xabs;\n                        s1\u003d 1 + s1 * r * r;\n                        x1max \u003d xabs;\n                    } else {\n                        double r \u003d xabs / x1max;\n                        s1 +\u003d r * r;\n                    }\n                } else {\n                    if (xabs \u003e x3max) {\n                        double r \u003d x3max / xabs;\n                        s3\u003d 1 + s3 * r * r;\n                        x3max \u003d xabs;\n                    } else {\n                        if (xabs !\u003d 0) {\n                            double r \u003d xabs / x3max;\n                            s3 +\u003d r * r;\n                        }\n                    }\n                }\n            } else {\n                s2 +\u003d xabs * xabs;\n            }\n        }\n        double norm;\n        if (s1 !\u003d 0) {\n            norm \u003d x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n        } else {\n            if (s2 \u003d\u003d 0) {\n                norm \u003d x3max * Math.sqrt(s3);\n            } else {\n                if (s2 \u003e\u003d x3max) {\n                    norm \u003d Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n                } else {\n                    norm \u003d Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n                }\n            }\n        }\n        return norm;\n    }",
    "begin_line": 582,
    "end_line": 635,
    "comment": "/** \n * Returns the Cartesian norm (2-norm), handling both overflow and underflow. Translation of the minpack enorm subroutine. The redistribution policy for MINPACK is available \u003ca href\u003d\"http://www.netlib.org/minpack/disclaimer\"\u003ehere\u003c/a\u003e, for convenience, it is reproduced below.\u003c/p\u003e \u003ctable border\u003d\"0\" width\u003d\"80%\" cellpadding\u003d\"10\" align\u003d\"center\" bgcolor\u003d\"#E0E0E0\"\u003e \u003ctr\u003e\u003ctd\u003e Minpack Copyright Notice (1999) University of Chicago. All rights reserved \u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: \u003col\u003e \u003cli\u003eRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\u003c/li\u003e \u003cli\u003eRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\u003c/li\u003e \u003cli\u003eThe end-user documentation included with the redistribution, if any, must include the following acknowledgment: {@code This product includes software developed by the University ofChicago, as Operator of Argonne National Laboratory.}Alternately, this acknowledgment may appear in the software itself, if and wherever such third-party acknowledgments normally appear.\u003c/li\u003e \u003cli\u003e\u003cstrong\u003eWARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL BE CORRECTED.\u003c/strong\u003e\u003c/li\u003e \u003cli\u003e\u003cstrong\u003eLIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE POSSIBILITY OF SUCH LOSS OR DAMAGES.\u003c/strong\u003e\u003c/li\u003e \u003col\u003e\u003c/td\u003e\u003c/tr\u003e \u003c/table\u003e\n * @param v Vector of doubles.\n * @return the 2-norm of the vector.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.sortInPlace#653",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.sortInPlace(double[], double[])",
    "snippet": "public static void sortInPlace(double[] x, double[] ... yList)\n        throws DimensionMismatchException, NullArgumentException {\n        sortInPlace(x, OrderDirection.INCREASING, yList);\n    }",
    "begin_line": 653,
    "end_line": 656,
    "comment": "/** \n * Sort an array in ascending order in place and perform the same reordering of entries on other arrays. For example, if {@code x \u003d [3, 1, 2], y \u003d [1, 2, 3]} and {@code z \u003d [0, 5, 7]}, then {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]}, {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.\n * @param x Array to be sorted and used as a pattern for permutationof the other arrays.\n * @param yList Set of arrays whose permutations of entries will followthose performed on  {@code x}.\n * @throws DimensionMismatchException if any {@code y} is not the samesize as  {@code x}.\n * @throws NullArgumentException if {@code x} or any {@code y} is null.\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.sortInPlace#675",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.sortInPlace(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, double[])",
    "snippet": "public static void sortInPlace(double[] x,\n                                   final OrderDirection dir,\n                                   double[] ... yList)\n        throws NullArgumentException, DimensionMismatchException {\n        if (x \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n\n        final int len \u003d x.length;\n        final List\u003cPair\u003cDouble, double[]\u003e\u003e list\n            \u003d new ArrayList\u003cPair\u003cDouble, double[]\u003e\u003e(len);\n\n        final int yListLen \u003d yList.length;\n        for (int i \u003d 0; i \u003c len; i++) {\n            final double[] yValues \u003d new double[yListLen];\n            for (int j \u003d 0; j \u003c yListLen; j++) {\n                double[] y \u003d yList[j];\n                if (y \u003d\u003d null) {\n                    throw new NullArgumentException();\n                }\n                if (y.length !\u003d len) {\n                    throw new DimensionMismatchException(y.length, len);\n                }\n                yValues[j] \u003d y[i];\n            }\n            list.add(new Pair\u003cDouble, double[]\u003e(x[i], yValues));\n        }\n\n        final Comparator\u003cPair\u003cDouble, double[]\u003e\u003e comp\n            \u003d new Comparator\u003cPair\u003cDouble, double[]\u003e\u003e() {\n            public int compare(Pair\u003cDouble, double[]\u003e o1,\n                               Pair\u003cDouble, double[]\u003e o2) {\n                int val;\n                switch (dir) {\n                case INCREASING:\n                    val \u003d o1.getKey().compareTo(o2.getKey());\n                break;\n                case DECREASING:\n                    val \u003d o2.getKey().compareTo(o1.getKey());\n                break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n                return val;\n            }\n        };\n\n        Collections.sort(list, comp);\n\n        for (int i \u003d 0; i \u003c len; i++) {\n            final Pair\u003cDouble, double[]\u003e e \u003d list.get(i);\n            x[i] \u003d e.getKey();\n            final double[] yValues \u003d e.getValue();\n            for (int j \u003d 0; j \u003c yListLen; j++) {\n                yList[j][i] \u003d yValues[j];\n            }\n        }\n    }",
    "begin_line": 675,
    "end_line": 733,
    "comment": "/** \n * Sort an array in place and perform the same reordering of entries on other arrays.  This method works the same as the other {@link #sortInPlace(double[],double[][]) sortInPlace} method, butallows the order of the sort to be provided in the  {@code dir}parameter.\n * @param x Array to be sorted and used as a pattern for permutationof the other arrays.\n * @param dir Order direction.\n * @param yList Set of arrays whose permutations of entries will followthose performed on  {@code x}.\n * @throws DimensionMismatchException if any {@code y} is not the samesize as  {@code x}.\n * @throws NullArgumentException if {@code x} or any {@code y} is null\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.compare#705",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.compare(org.apache.commons.math3.util.Pair\u003cjava.lang.Double,double[]\u003e, org.apache.commons.math3.util.Pair\u003cjava.lang.Double,double[]\u003e)",
    "snippet": "public int compare(Pair\u003cDouble, double[]\u003e o1,\n                               Pair\u003cDouble, double[]\u003e o2) {\n                int val;\n                switch (dir) {\n                case INCREASING:\n                    val \u003d o1.getKey().compareTo(o2.getKey());\n                break;\n                case DECREASING:\n                    val \u003d o2.getKey().compareTo(o1.getKey());\n                break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n                return val;\n            }",
    "begin_line": 705,
    "end_line": 720,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.copyOf#741",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(int[])",
    "snippet": "public static int[] copyOf(int[] source) {\n         return copyOf(source, source.length);\n     }",
    "begin_line": 741,
    "end_line": 743,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.copyOf#751",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[])",
    "snippet": "public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }",
    "begin_line": 751,
    "end_line": 753,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.copyOf#764",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(int[], int)",
    "snippet": "public static int[] copyOf(int[] source, int len) {\n         final int[] output \u003d new int[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }",
    "begin_line": 764,
    "end_line": 768,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the sourcelength, the copy will be truncated, if larger it will padded with zeroes.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.copyOf#779",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[], int)",
    "snippet": "public static double[] copyOf(double[] source, int len) {\n         final double[] output \u003d new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }",
    "begin_line": 779,
    "end_line": 783,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the sourcelength, the copy will be truncated, if larger it will padded with zeroes.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.linearCombination#802",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double[], double[])",
    "snippet": "public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len \u003d a.length;\n        if (len !\u003d b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n        final double[] prodHigh \u003d new double[len];\n        double prodLowSum \u003d 0;\n\n        for (int i \u003d 0; i \u003c len; i++) {\n            final double ai \u003d a[i];\n            final double ca \u003d SPLIT_FACTOR * ai;\n            final double aHigh \u003d ca - (ca - ai);\n            final double aLow \u003d ai - aHigh;\n\n            final double bi \u003d b[i];\n            final double cb \u003d SPLIT_FACTOR * bi;\n            final double bHigh \u003d cb - (cb - bi);\n            final double bLow \u003d bi - bHigh;\n            prodHigh[i] \u003d ai * bi;\n            final double prodLow \u003d aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum +\u003d prodLow;\n        }\n\n\n        final double prodHighCur \u003d prodHigh[0];\n        double prodHighNext \u003d prodHigh[1];\n        double sHighPrev \u003d prodHighCur + prodHighNext;\n        double sPrime \u003d sHighPrev - prodHighNext;\n        double sLowSum \u003d (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne \u003d len - 1;\n        for (int i \u003d 1; i \u003c lenMinusOne; i++) {\n            prodHighNext \u003d prodHigh[i + 1];\n            final double sHighCur \u003d sHighPrev + prodHighNext;\n            sPrime \u003d sHighCur - prodHighNext;\n            sLowSum +\u003d (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev \u003d sHighCur;\n        }\n\n        double result \u003d sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result \u003d 0;\n            for (int i \u003d 0; i \u003c len; ++i) {\n                result +\u003d a[i] * b[i];\n            }\n        }\n\n        return result;\n    }",
    "begin_line": 802,
    "end_line": 858,
    "comment": "/** \n * Compute a linear combination accurately. This method computes the sum of the products \u003ccode\u003ea\u003csub\u003ei\u003c/sub\u003e b\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. \u003cbr/\u003e It is based on the 2005 paper \u003ca href\u003d\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi\u003d10.1.1.2.1547\"\u003e Accurate Sum and Dot Product\u003c/a\u003e by Takeshi Ogita, Siegfried M. Rump, and Shin\u0027ichi Oishi published in SIAM J. Sci. Comput.\n * @param a Factors.\n * @param b Factors.\n * @return \u003ccode\u003e\u0026Sigma;\u003csub\u003ei\u003c/sub\u003e a\u003csub\u003ei\u003c/sub\u003e b\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e.\n * @throws DimensionMismatchException if arrays dimensions don\u0027t match\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.linearCombination#881",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double)",
    "snippet": "public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variable naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        \u003d SPLIT_FACTOR * a1;\n        final double a1High     \u003d ca1 - (ca1 - a1);\n        final double a1Low      \u003d a1 - a1High;\n        final double cb1        \u003d SPLIT_FACTOR * b1;\n        final double b1High     \u003d cb1 - (cb1 - b1);\n        final double b1Low      \u003d b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  \u003d a1 * b1;\n        final double prod1Low   \u003d a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        \u003d SPLIT_FACTOR * a2;\n        final double a2High     \u003d ca2 - (ca2 - a2);\n        final double a2Low      \u003d a2 - a2High;\n        final double cb2        \u003d SPLIT_FACTOR * b2;\n        final double b2High     \u003d cb2 - (cb2 - b2);\n        final double b2Low      \u003d b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  \u003d a2 * b2;\n        final double prod2Low   \u003d a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    \u003d prod1High + prod2High;\n        final double s12Prime   \u003d s12High - prod2High;\n        final double s12Low     \u003d (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // final rounding, s12 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result \u003d s12High + (prod1Low + prod2Low + s12Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result \u003d a1 * b1 + a2 * b2;\n        }\n\n        return result;\n    }",
    "begin_line": 881,
    "end_line": 935,
    "comment": "/** \n * Compute a linear combination accurately. \u003cp\u003e This method computes a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e + a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper \u003ca href\u003d\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi\u003d10.1.1.2.1547\"\u003e Accurate Sum and Dot Product\u003c/a\u003e by Takeshi Ogita, Siegfried M. Rump, and Shin\u0027ichi Oishi published in SIAM J. Sci. Comput. \u003c/p\u003e\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @return a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e +a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e\n * @see #linearCombination(double,double,double,double,double,double)\n * @see #linearCombination(double,double,double,double,double,double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.linearCombination#960",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double, double, double)",
    "snippet": "public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // do use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        \u003d SPLIT_FACTOR * a1;\n        final double a1High     \u003d ca1 - (ca1 - a1);\n        final double a1Low      \u003d a1 - a1High;\n        final double cb1        \u003d SPLIT_FACTOR * b1;\n        final double b1High     \u003d cb1 - (cb1 - b1);\n        final double b1Low      \u003d b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  \u003d a1 * b1;\n        final double prod1Low   \u003d a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        \u003d SPLIT_FACTOR * a2;\n        final double a2High     \u003d ca2 - (ca2 - a2);\n        final double a2Low      \u003d a2 - a2High;\n        final double cb2        \u003d SPLIT_FACTOR * b2;\n        final double b2High     \u003d cb2 - (cb2 - b2);\n        final double b2Low      \u003d b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  \u003d a2 * b2;\n        final double prod2Low   \u003d a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        \u003d SPLIT_FACTOR * a3;\n        final double a3High     \u003d ca3 - (ca3 - a3);\n        final double a3Low      \u003d a3 - a3High;\n        final double cb3        \u003d SPLIT_FACTOR * b3;\n        final double b3High     \u003d cb3 - (cb3 - b3);\n        final double b3Low      \u003d b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  \u003d a3 * b3;\n        final double prod3Low   \u003d a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    \u003d prod1High + prod2High;\n        final double s12Prime   \u003d s12High - prod2High;\n        final double s12Low     \u003d (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   \u003d s12High + prod3High;\n        final double s123Prime  \u003d s123High - prod3High;\n        final double s123Low    \u003d (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // final rounding, s123 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result \u003d s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result \u003d a1 * b1 + a2 * b2 + a3 * b3;\n        }\n\n        return result;\n    }",
    "begin_line": 960,
    "end_line": 1032,
    "comment": "/** \n * Compute a linear combination accurately. \u003cp\u003e This method computes a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e + a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e + a\u003csub\u003e3\u003c/sub\u003e\u0026times;b\u003csub\u003e3\u003c/sub\u003e to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper \u003ca href\u003d\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi\u003d10.1.1.2.1547\"\u003e Accurate Sum and Dot Product\u003c/a\u003e by Takeshi Ogita, Siegfried M. Rump, and Shin\u0027ichi Oishi published in SIAM J. Sci. Comput. \u003c/p\u003e\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @return a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e +a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e + a\u003csub\u003e3\u003c/sub\u003e\u0026times;b\u003csub\u003e3\u003c/sub\u003e\n * @see #linearCombination(double,double,double,double)\n * @see #linearCombination(double,double,double,double,double,double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.linearCombination#1061",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double, double, double, double, double)",
    "snippet": "public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3,\n                                           final double a4, final double b4) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // do use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        \u003d SPLIT_FACTOR * a1;\n        final double a1High     \u003d ca1 - (ca1 - a1);\n        final double a1Low      \u003d a1 - a1High;\n        final double cb1        \u003d SPLIT_FACTOR * b1;\n        final double b1High     \u003d cb1 - (cb1 - b1);\n        final double b1Low      \u003d b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  \u003d a1 * b1;\n        final double prod1Low   \u003d a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        \u003d SPLIT_FACTOR * a2;\n        final double a2High     \u003d ca2 - (ca2 - a2);\n        final double a2Low      \u003d a2 - a2High;\n        final double cb2        \u003d SPLIT_FACTOR * b2;\n        final double b2High     \u003d cb2 - (cb2 - b2);\n        final double b2Low      \u003d b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  \u003d a2 * b2;\n        final double prod2Low   \u003d a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        \u003d SPLIT_FACTOR * a3;\n        final double a3High     \u003d ca3 - (ca3 - a3);\n        final double a3Low      \u003d a3 - a3High;\n        final double cb3        \u003d SPLIT_FACTOR * b3;\n        final double b3High     \u003d cb3 - (cb3 - b3);\n        final double b3Low      \u003d b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  \u003d a3 * b3;\n        final double prod3Low   \u003d a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // split a4 and b4 as two 26 bits numbers\n        final double ca4        \u003d SPLIT_FACTOR * a4;\n        final double a4High     \u003d ca4 - (ca4 - a4);\n        final double a4Low      \u003d a4 - a4High;\n        final double cb4        \u003d SPLIT_FACTOR * b4;\n        final double b4High     \u003d cb4 - (cb4 - b4);\n        final double b4Low      \u003d b4 - b4High;\n\n        // accurate multiplication a4 * b4\n        final double prod4High  \u003d a4 * b4;\n        final double prod4Low   \u003d a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    \u003d prod1High + prod2High;\n        final double s12Prime   \u003d s12High - prod2High;\n        final double s12Low     \u003d (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   \u003d s12High + prod3High;\n        final double s123Prime  \u003d s123High - prod3High;\n        final double s123Low    \u003d (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n        final double s1234High  \u003d s123High + prod4High;\n        final double s1234Prime \u003d s1234High - prod4High;\n        final double s1234Low   \u003d (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n\n        // final rounding, s1234 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result \u003d s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result \u003d a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n        }\n\n        return result;\n    }",
    "begin_line": 1061,
    "end_line": 1151,
    "comment": "/** \n * Compute a linear combination accurately. \u003cp\u003e This method computes a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e + a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e + a\u003csub\u003e3\u003c/sub\u003e\u0026times;b\u003csub\u003e3\u003c/sub\u003e + a\u003csub\u003e4\u003c/sub\u003e\u0026times;b\u003csub\u003e4\u003c/sub\u003e to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper \u003ca href\u003d\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi\u003d10.1.1.2.1547\"\u003e Accurate Sum and Dot Product\u003c/a\u003e by Takeshi Ogita, Siegfried M. Rump, and Shin\u0027ichi Oishi published in SIAM J. Sci. Comput. \u003c/p\u003e\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @param a4 first factor of the third term\n * @param b4 second factor of the third term\n * @return a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e +a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e + a\u003csub\u003e3\u003c/sub\u003e\u0026times;b\u003csub\u003e3\u003c/sub\u003e + a\u003csub\u003e4\u003c/sub\u003e\u0026times;b\u003csub\u003e4\u003c/sub\u003e\n * @see #linearCombination(double,double,double,double)\n * @see #linearCombination(double,double,double,double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.equals#1163",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.equals(float[], float[])",
    "snippet": "public static boolean equals(float[] x, float[] y) {\n        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n        }\n        if (x.length !\u003d y.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 1163,
    "end_line": 1176,
    "comment": "/** \n * Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by {@link Precision#equals(float,float)}.\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimensionand equal elements.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.equalsIncludingNaN#1189",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.equalsIncludingNaN(float[], float[])",
    "snippet": "public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n        }\n        if (x.length !\u003d y.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 1189,
    "end_line": 1202,
    "comment": "/** \n * Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by {@link Precision#equalsIncludingNaN(double,double) this method}.\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension andequal elements\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.equals#1214",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.equals(double[], double[])",
    "snippet": "public static boolean equals(double[] x, double[] y) {\n        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n        }\n        if (x.length !\u003d y.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 1214,
    "end_line": 1227,
    "comment": "/** \n * Returns  {@code true} iff both arguments are {@code null} or have samedimensions and all their elements are equal as defined by {@link Precision#equals(double,double)}.\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have samedimension and equal elements.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.equalsIncludingNaN#1240",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.equalsIncludingNaN(double[], double[])",
    "snippet": "public static boolean equalsIncludingNaN(double[] x, double[] y) {\n        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n        }\n        if (x.length !\u003d y.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 1240,
    "end_line": 1253,
    "comment": "/** \n * Returns  {@code true} iff both arguments are {@code null} or have samedimensions and all their elements are equal as defined by {@link Precision#equalsIncludingNaN(double,double) this method}.\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have samedimension and equal elements.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.normalizeArray#1277",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.normalizeArray(double[], double)",
    "snippet": "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum \u003d 0d;\n         final int len \u003d values.length;\n         double[] out \u003d new double[len];\n         for (int i \u003d 0; i \u003c len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum +\u003d values[i];\n             }\n         }\n         if (sum \u003d\u003d 0) {\n             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i \u003d 0; i \u003c len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] \u003d Double.NaN;\n             } else {\n                 out[i] \u003d values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }",
    "begin_line": 1277,
    "end_line": 1307,
    "comment": "/** \n * Normalizes an array to make it sum to a specified value. Returns the result of the transformation \u003cpre\u003e x |-\u003e x * normalizedSum / sum \u003c/pre\u003e applied to each non-NaN element x of the input array, where sum is the sum of the non-NaN entries in the input array.\u003c/p\u003e \u003cp\u003eThrows IllegalArgumentException if  {@code normalizedSum} is infiniteor NaN and ArithmeticException if the input array contains any infinite elements or sums to 0.\u003c/p\u003e \u003cp\u003eIgnores (i.e., copies unchanged to the output array) NaNs in the input array.\u003c/p\u003e\n * @param values Input array to be normalized\n * @param normalizedSum Target sum for the normalized array\n * @return the normalized array.\n * @throws MathArithmeticException if the input array contains infiniteelements or sums to zero.\n * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.buildArray#1319",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.buildArray(org.apache.commons.math3.Field\u003cT\u003e, int)",
    "snippet": "public static \u003cT\u003e T[] buildArray(final Field\u003cT\u003e field, final int length) {\n         @SuppressWarnings(\"unchecked\") // OK because field must be correct class\n         T[] array \u003d (T[]) Array.newInstance(field.getRuntimeClass(), length);\n         Arrays.fill(array, field.getZero());\n         return array;\n     }",
    "begin_line": 1319,
    "end_line": 1324,
    "comment": "/** \n * Build an array of elements. \u003cp\u003e Arrays are filled with field.getZero() \u003c/p\u003e\n * @param \u003c T \u003e the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.buildArray#1339",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.buildArray(org.apache.commons.math3.Field\u003cT\u003e, int, int)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n    public static \u003cT\u003e T[][] buildArray(final Field\u003cT\u003e field, final int rows, final int columns) {\n         final T[][] array;\n         if (columns \u003c 0) {\n             T[] dummyRow \u003d buildArray(field, 0);\n             array \u003d (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n         } else {\n             array \u003d (T[][]) Array.newInstance(field.getRuntimeClass(),\n                                               new int[] {\n                                                   rows, columns\n                                               });\n             for (int i \u003d 0; i \u003c rows; ++i) {\n                 Arrays.fill(array[i], field.getZero());\n             }\n         }\n         return array;\n     }",
    "begin_line": 1339,
    "end_line": 1354,
    "comment": "/** \n * Build a double dimension  array of elements. \u003cp\u003e Arrays are filled with field.getZero() \u003c/p\u003e\n * @param \u003c T \u003e the type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows in the array\n * @param columns number of columns (may be negative to build partialarrays in the same way \u003ccode\u003enew Field[rows][]\u003c/code\u003e works)\n * @return a new array\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.convolve#1373",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.convolve(double[], double[])",
    "snippet": "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {\n         MathUtils.checkNotNull(x);\n         MathUtils.checkNotNull(h);\n\n         final int N \u003d x.length;\n         final int M \u003d h.length;\n\n         if (N \u003d\u003d 0 || M \u003d\u003d 0) {\n             throw new NoDataException();\n         }\n\n         // initialize the output array\n         final int totalLength \u003d N + M - 1;\n         final double[] y \u003d new double[totalLength];\n\n         // straightforward implementation of the convolution sum\n         for (int n \u003d 0; n \u003c totalLength; n++) {\n             double yn \u003d 0;\n             for (int k \u003d 0; k \u003c M; k++) {\n                 final int j \u003d n - k;\n                 if ((j \u003e -1) \u0026\u0026 (j \u003c N) ) {\n                     yn \u003d yn + x[j] * h[k];\n                 }\n             }\n             y[n] \u003d yn;\n         }\n\n         return y;\n     }",
    "begin_line": 1373,
    "end_line": 1401,
    "comment": "/** \n * Calculates the convolution between two sequences. \u003cp\u003e The solution is obtained via straightforward computation of the convolution sum (and not via FFT; for longer sequences, the performance of this method might be inferior to an FFT-based implementation).\n * @param x the first sequence (double array of length {@code N}); the sequence is assumed to be zero elsewhere (i.e. {x[i]}\u003d0 for i\u003c0 and i\u003e\u003d {@code N}). Typically, this sequence will represent an input signal to a system.\n * @param h the second sequence (double array of length {@code M}); the sequence is assumed to be zero elsewhere (i.e. {h[i]}\u003d0 for i\u003c0 and i\u003e\u003d {@code M}). Typically, this sequence will represent the impulse response of the system.\n * @return the convolution of {@code x} and {@code h} (double array of length {@code N} + {@code M} -1)\n * @throws NullArgumentException if either {@code x} or {@code h} is null\n * @throws NoDataException if either {@code x} or {@code h} is empty\n * @see \u003ca href\u003d\"http://en.wikipedia.org/wiki/Convolution\"\u003eConvolution (Wikipedia)\u003c/a\u003e\n * @since 4.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.Precision#83",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.Precision()",
    "snippet": "private Precision() {}",
    "begin_line": 83,
    "end_line": 83,
    "comment": "/** \n * Private constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.compareTo#95",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.compareTo(double, double, double)",
    "snippet": "public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x \u003c y) {\n            return -1;\n        }\n        return 1;\n    }",
    "begin_line": 95,
    "end_line": 102,
    "comment": "/** \n * Compares two numbers given some amount of allowed error.\n * @param x the first number\n * @param y the second number\n * @param eps the amount of error to allow when checking for equality\n * @return \u003cul\u003e\u003cli\u003e0 if  {@link #equals(double,double,double) equals(x, y, eps)}\u003c/li\u003e \u003cli\u003e\u0026lt; 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u0026lt; y\u003c/li\u003e\u003cli\u003e\u003e 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u003e y\u003c/li\u003e\u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.compareTo#121",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.compareTo(double, double, int)",
    "snippet": "public static int compareTo(final double x, final double y, final int maxUlps) {\n        if (equals(x, y, maxUlps)) {\n            return 0;\n        } else if (x \u003c y) {\n            return -1;\n        }\n        return 1;\n    }",
    "begin_line": 121,
    "end_line": 128,
    "comment": "/** \n * Compares two numbers given some amount of allowed error. Two float numbers are considered equal if there are  {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return \u003cul\u003e\u003cli\u003e0 if  {@link #equals(double,double,int) equals(x, y, maxUlps)}\u003c/li\u003e \u003cli\u003e\u0026lt; 0 if ! {@link #equals(double,double,int) equals(x, y, maxUlps)} \u0026amp;\u0026amp; x \u0026lt; y\u003c/li\u003e\u003cli\u003e\u003e 0 if ! {@link #equals(double,double,int) equals(x, y, maxUlps)} \u0026amp;\u0026amp; x \u003e y\u003c/li\u003e\u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#138",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(float, float)",
    "snippet": "public static boolean equals(float x, float y) {\n        return equals(x, y, 1);\n    }",
    "begin_line": 138,
    "end_line": 140,
    "comment": "/** \n * Returns true iff they are equal as defined by {@link #equals(float,float,int) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#151",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(float, float)",
    "snippet": "public static boolean equalsIncludingNaN(float x, float y) {\n        return (Float.isNaN(x) \u0026\u0026 Float.isNaN(y)) || equals(x, y, 1);\n    }",
    "begin_line": 151,
    "end_line": 153,
    "comment": "/** \n * Returns true if both arguments are NaN or neither is NaN and they are equal as defined by  {@link #equals(float,float) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#165",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(float, float, float)",
    "snippet": "public static boolean equals(float x, float y, float eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) \u003c\u003d eps;\n    }",
    "begin_line": 165,
    "end_line": 167,
    "comment": "/** \n * Returns true if both arguments are equal or within the range of allowed error (inclusive).\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#180",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(float, float, float)",
    "snippet": "public static boolean equalsIncludingNaN(float x, float y, float eps) {\n        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) \u003c\u003d eps);\n    }",
    "begin_line": 180,
    "end_line": 182,
    "comment": "/** \n * Returns true if both arguments are NaN or are equal or within the range of allowed error (inclusive).\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#202",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(float, float, int)",
    "snippet": "public static boolean equals(float x, float y, int maxUlps) {\n        int xInt \u003d Float.floatToIntBits(x);\n        int yInt \u003d Float.floatToIntBits(y);\n\n        // Make lexicographically ordered as a two\u0027s-complement integer.\n        if (xInt \u003c 0) {\n            xInt \u003d SGN_MASK_FLOAT - xInt;\n        }\n        if (yInt \u003c 0) {\n            yInt \u003d SGN_MASK_FLOAT - yInt;\n        }\n\n        final boolean isEqual \u003d FastMath.abs(xInt - yInt) \u003c\u003d maxUlps;\n\n        return isEqual \u0026\u0026 !Float.isNaN(x) \u0026\u0026 !Float.isNaN(y);\n    }",
    "begin_line": 202,
    "end_line": 217,
    "comment": "/** \n * Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are  {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floatingpoint values between  {@code x} and {@code y}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#231",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(float, float, int)",
    "snippet": "public static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n        return (Float.isNaN(x) \u0026\u0026 Float.isNaN(y)) || equals(x, y, maxUlps);\n    }",
    "begin_line": 231,
    "end_line": 233,
    "comment": "/** \n * Returns true if both arguments are NaN or if they are equal as defined by  {@link #equals(float,float,int) equals(x, y, maxUlps)}.\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#243",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double, double)",
    "snippet": "public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }",
    "begin_line": 243,
    "end_line": 245,
    "comment": "/** \n * Returns true iff they are equal as defined by {@link #equals(double,double,int) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#256",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(double, double)",
    "snippet": "public static boolean equalsIncludingNaN(double x, double y) {\n        return (Double.isNaN(x) \u0026\u0026 Double.isNaN(y)) || equals(x, y, 1);\n    }",
    "begin_line": 256,
    "end_line": 258,
    "comment": "/** \n * Returns true if both arguments are NaN or neither is NaN and they are equal as defined by  {@link #equals(double,double) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#271",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double, double, double)",
    "snippet": "public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) \u003c\u003d eps;\n    }",
    "begin_line": 271,
    "end_line": 273,
    "comment": "/** \n * Returns  {@code true} if there is no double value strictly between thearguments or the difference between them is within the range of allowed error (inclusive).\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating pointnumbers or they are within range of each other.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsWithRelativeTolerance#287",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsWithRelativeTolerance(double, double, double)",
    "snippet": "public static boolean equalsWithRelativeTolerance(double x, double y, double eps) {\n        if (equals(x, y, 1)) {\n            return true;\n        }\n\n        final double absoluteMax \u003d FastMath.max(FastMath.abs(x), FastMath.abs(y));\n        final double relativeDifference \u003d FastMath.abs((x - y) / absoluteMax);\n\n        return relativeDifference \u003c\u003d eps;\n    }",
    "begin_line": 287,
    "end_line": 296,
    "comment": "/** \n * Returns  {@code true} if there is no double value strictly between thearguments or the reltaive difference between them is smaller or equal to the given tolerance.\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating pointnumbers or they are within range of each other.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#309",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(double, double, double)",
    "snippet": "public static boolean equalsIncludingNaN(double x, double y, double eps) {\n        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) \u003c\u003d eps);\n    }",
    "begin_line": 309,
    "end_line": 311,
    "comment": "/** \n * Returns true if both arguments are NaN or are equal or within the range of allowed error (inclusive).\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#330",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double, double, int)",
    "snippet": "public static boolean equals(double x, double y, int maxUlps) {\n        long xInt \u003d Double.doubleToLongBits(x);\n        long yInt \u003d Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two\u0027s-complement integer.\n        if (xInt \u003c 0) {\n            xInt \u003d SGN_MASK - xInt;\n        }\n        if (yInt \u003c 0) {\n            yInt \u003d SGN_MASK - yInt;\n        }\n\n        final boolean isEqual \u003d FastMath.abs(xInt - yInt) \u003c\u003d maxUlps;\n\n        return isEqual \u0026\u0026 !Double.isNaN(x) \u0026\u0026 !Double.isNaN(y);\n    }",
    "begin_line": 330,
    "end_line": 345,
    "comment": "/** \n * Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are  {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floatingpoint values between  {@code x} and {@code y}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#359",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(double, double, int)",
    "snippet": "public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n        return (Double.isNaN(x) \u0026\u0026 Double.isNaN(y)) || equals(x, y, maxUlps);\n    }",
    "begin_line": 359,
    "end_line": 361,
    "comment": "/** \n * Returns true if both arguments are NaN or if they are equal as defined by  {@link #equals(double,double,int) equals(x, y, maxUlps)}.\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.round#372",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.round(double, int)",
    "snippet": "public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }",
    "begin_line": 372,
    "end_line": 374,
    "comment": "/** \n * Rounds the given value to the specified number of decimal places. The value is rounded using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.round#393",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.round(double, int, int)",
    "snippet": "public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;\n            } else {\n                return Double.NaN;\n            }\n        }\n    }",
    "begin_line": 393,
    "end_line": 406,
    "comment": "/** \n * Rounds the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in  {@link BigDecimal}. If  {@code x} is infinite or {@code NaN}, then the value of  {@code x} isreturned unchanged, regardless of the other parameters.\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod \u003d\u003d ROUND_UNNECESSARY}and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does notrepresent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.round#417",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.round(float, int)",
    "snippet": "public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }",
    "begin_line": 417,
    "end_line": 419,
    "comment": "/** \n * Rounds the given value to the specified number of decimal places. The value is rounded using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.round#434",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.round(float, int, int)",
    "snippet": "public static float round(float x, int scale, int roundingMethod)\n        throws MathArithmeticException, MathIllegalArgumentException {\n        final float sign \u003d FastMath.copySign(1f, x);\n        final float factor \u003d (float) FastMath.pow(10.0f, scale) * sign;\n        return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }",
    "begin_line": 434,
    "end_line": 439,
    "comment": "/** \n * Rounds the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in  {@link BigDecimal}.\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n * @throws MathArithmeticException if an exact operation is required but result is not exact\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.roundUnscaled#454",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.roundUnscaled(double, double, int)",
    "snippet": "private static double roundUnscaled(double unscaled,\n                                        double sign,\n                                        int roundingMethod)\n        throws MathArithmeticException, MathIllegalArgumentException {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign \u003d\u003d -1) {\n                unscaled \u003d FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled \u003d FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled \u003d FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign \u003d\u003d -1) {\n                unscaled \u003d FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled \u003d FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled \u003d FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction \u003d unscaled - FastMath.floor(unscaled);\n            if (fraction \u003e 0.5) {\n                unscaled \u003d FastMath.ceil(unscaled);\n            } else {\n                unscaled \u003d FastMath.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction \u003d unscaled - FastMath.floor(unscaled);\n            if (fraction \u003e 0.5) {\n                unscaled \u003d FastMath.ceil(unscaled);\n            } else if (fraction \u003c 0.5) {\n                unscaled \u003d FastMath.floor(unscaled);\n            } else {\n                // The following equality test is intentional and needed for rounding purposes\n                if (FastMath.floor(unscaled) / 2.0 \u003d\u003d FastMath.floor(Math\n                    .floor(unscaled) / 2.0)) { // even\n                    unscaled \u003d FastMath.floor(unscaled);\n                } else { // odd\n                    unscaled \u003d FastMath.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled \u003d FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction \u003d unscaled - FastMath.floor(unscaled);\n            if (fraction \u003e\u003d 0.5) {\n                unscaled \u003d FastMath.ceil(unscaled);\n            } else {\n                unscaled \u003d FastMath.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled !\u003d FastMath.floor(unscaled)) {\n                throw new MathArithmeticException();\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled \u003d FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD,\n                                                   roundingMethod,\n                                                   \"ROUND_CEILING\", BigDecimal.ROUND_CEILING,\n                                                   \"ROUND_DOWN\", BigDecimal.ROUND_DOWN,\n                                                   \"ROUND_FLOOR\", BigDecimal.ROUND_FLOOR,\n                                                   \"ROUND_HALF_DOWN\", BigDecimal.ROUND_HALF_DOWN,\n                                                   \"ROUND_HALF_EVEN\", BigDecimal.ROUND_HALF_EVEN,\n                                                   \"ROUND_HALF_UP\", BigDecimal.ROUND_HALF_UP,\n                                                   \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n                                                   \"ROUND_UP\", BigDecimal.ROUND_UP);\n        }\n        return unscaled;\n    }",
    "begin_line": 454,
    "end_line": 534,
    "comment": "/** \n * Rounds the given non-negative value to the \"nearest\" integer. Nearest is determined by the rounding method specified. Rounding methods are defined in  {@link BigDecimal}.\n * @param unscaled Value to round.\n * @param sign Sign of the original, scaled value.\n * @param roundingMethod Rounding method, as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws MathArithmeticException if an exact operation is required but result is not exact\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.representableDelta#551",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.representableDelta(double, double)",
    "snippet": "public static double representableDelta(double x,\n                                            double originalDelta) {\n        return x + originalDelta - x;\n    }",
    "begin_line": 551,
    "end_line": 554,
    "comment": "/** \n * Computes a number  {@code delta} close to {@code originalDelta} withthe property that \u003cpre\u003e\u003ccode\u003e x + delta - x \u003c/code\u003e\u003c/pre\u003e is exactly machine-representable. This is useful when computing numerical derivatives, in order to reduce roundoff errors.\n * @param x Value.\n * @param originalDelta Offset value.\n * @return a number {@code delta} so that {@code x + delta} and {@code x}differ by a representable floating number.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]