[
  {
    "name": "MathIllegalArgumentException.MathIllegalArgumentException#43",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/MathIllegalArgumentException.java",
    "class_name": "org.apache.commons.math.exception.MathIllegalArgumentException",
    "signature": "org.apache.commons.math.exception.MathIllegalArgumentException.MathIllegalArgumentException(org.apache.commons.math.exception.util.Localizable, java.lang.Object)",
    "snippet": "public MathIllegalArgumentException(Localizable pattern,\n                                        Object ... args) {\n        context.addMessage(pattern, args);\n    }",
    "begin_line": 43,
    "end_line": 46,
    "comment": "/** \n * @param pattern Message pattern explaining the cause of the error.\n * @param args Arguments.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathIllegalArgumentException.getContext#49",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/MathIllegalArgumentException.java",
    "class_name": "org.apache.commons.math.exception.MathIllegalArgumentException",
    "signature": "org.apache.commons.math.exception.MathIllegalArgumentException.getContext()",
    "snippet": "public ExceptionContext getContext() {\n        return context;\n    }",
    "begin_line": 49,
    "end_line": 51,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathIllegalArgumentException.getMessage#55",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/MathIllegalArgumentException.java",
    "class_name": "org.apache.commons.math.exception.MathIllegalArgumentException",
    "signature": "org.apache.commons.math.exception.MathIllegalArgumentException.getMessage()",
    "snippet": "@Override\n    public String getMessage() {\n        return context.getMessage();\n    }",
    "begin_line": 55,
    "end_line": 57,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathIllegalArgumentException.getLocalizedMessage#61",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/MathIllegalArgumentException.java",
    "class_name": "org.apache.commons.math.exception.MathIllegalArgumentException",
    "signature": "org.apache.commons.math.exception.MathIllegalArgumentException.getLocalizedMessage()",
    "snippet": "@Override\n    public String getLocalizedMessage() {\n        return context.getLocalizedMessage();\n    }",
    "begin_line": 61,
    "end_line": 63,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathIllegalNumberException.MathIllegalNumberException#43",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/MathIllegalNumberException.java",
    "class_name": "org.apache.commons.math.exception.MathIllegalNumberException",
    "signature": "org.apache.commons.math.exception.MathIllegalNumberException.MathIllegalNumberException(org.apache.commons.math.exception.util.Localizable, java.lang.Number, java.lang.Object)",
    "snippet": "protected MathIllegalNumberException(Localizable pattern,\n                                         Number wrong,\n                                         Object ... arguments) {\n        super(pattern, wrong, arguments);\n        argument \u003d wrong;\n    }",
    "begin_line": 43,
    "end_line": 48,
    "comment": "/** \n * Construct an exception.\n * @param pattern Localizable pattern.\n * @param wrong Wrong number.\n * @param arguments Arguments.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathIllegalNumberException.getArgument#53",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/MathIllegalNumberException.java",
    "class_name": "org.apache.commons.math.exception.MathIllegalNumberException",
    "signature": "org.apache.commons.math.exception.MathIllegalNumberException.getArgument()",
    "snippet": "public Number getArgument() {\n        return argument;\n    }",
    "begin_line": 53,
    "end_line": 55,
    "comment": "/** \n * @return the requested value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OutOfRangeException.OutOfRangeException#43",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/OutOfRangeException.java",
    "class_name": "org.apache.commons.math.exception.OutOfRangeException",
    "signature": "org.apache.commons.math.exception.OutOfRangeException.OutOfRangeException(java.lang.Number, java.lang.Number, java.lang.Number)",
    "snippet": "public OutOfRangeException(Number wrong,\n                               Number lo,\n                               Number hi) {\n        this(LocalizedFormats.OUT_OF_RANGE_SIMPLE, wrong, lo, hi);\n    }",
    "begin_line": 43,
    "end_line": 47,
    "comment": "/** \n * Construct an exception from the mismatched dimensions.\n * @param wrong Requested value.\n * @param lo Lower bound.\n * @param hi Higher bound.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OutOfRangeException.OutOfRangeException#58",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/OutOfRangeException.java",
    "class_name": "org.apache.commons.math.exception.OutOfRangeException",
    "signature": "org.apache.commons.math.exception.OutOfRangeException.OutOfRangeException(org.apache.commons.math.exception.util.Localizable, java.lang.Number, java.lang.Number, java.lang.Number)",
    "snippet": "public OutOfRangeException(Localizable specific,\n                               Number wrong,\n                               Number lo,\n                               Number hi) {\n        super(specific, wrong, lo, hi);\n        this.lo \u003d lo;\n        this.hi \u003d hi;\n    }",
    "begin_line": 58,
    "end_line": 65,
    "comment": "/** \n * Construct an exception from the mismatched dimensions with a specific context information.\n * @param specific Context information.\n * @param wrong Requested value.\n * @param lo Lower bound.\n * @param hi Higher bound.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OutOfRangeException.getLo#70",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/OutOfRangeException.java",
    "class_name": "org.apache.commons.math.exception.OutOfRangeException",
    "signature": "org.apache.commons.math.exception.OutOfRangeException.getLo()",
    "snippet": "public Number getLo() {\n        return lo;\n    }",
    "begin_line": 70,
    "end_line": 72,
    "comment": "/** \n * @return the lower bound.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OutOfRangeException.getHi#76",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/OutOfRangeException.java",
    "class_name": "org.apache.commons.math.exception.OutOfRangeException",
    "signature": "org.apache.commons.math.exception.OutOfRangeException.getHi()",
    "snippet": "public Number getHi() {\n        return hi;\n    }",
    "begin_line": 76,
    "end_line": 78,
    "comment": "/** \n * @return the higher bound.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgUtils.ArgUtils#32",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ArgUtils.java",
    "class_name": "org.apache.commons.math.exception.util.ArgUtils",
    "signature": "org.apache.commons.math.exception.util.ArgUtils.ArgUtils()",
    "snippet": "private ArgUtils() {}",
    "begin_line": 32,
    "end_line": 32,
    "comment": "/** \n * Class contains only static methods.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArgUtils.flatten#41",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ArgUtils.java",
    "class_name": "org.apache.commons.math.exception.util.ArgUtils",
    "signature": "org.apache.commons.math.exception.util.ArgUtils.flatten(java.lang.Object[])",
    "snippet": "public static Object[] flatten(Object[] array) {\n        final List\u003cObject\u003e list \u003d new ArrayList\u003cObject\u003e();\n        if (array !\u003d null) {\n            for (Object o : array) {\n                if (o instanceof Object[]) {\n                    for (Object oR : flatten((Object[]) o)) {\n                        list.add(oR);\n                    }\n                } else {\n                    list.add(o);\n                }\n            }\n        }\n        return list.toArray();\n    }",
    "begin_line": 41,
    "end_line": 55,
    "comment": "/** \n * Transform a multidimensional array into a one-dimensional list.\n * @param array Array (possibly multidimensional).\n * @return a list of all the {@code Object} instances contained in{@code array}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.addMessage#64",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.addMessage(org.apache.commons.math.exception.util.Localizable, java.lang.Object)",
    "snippet": "public void addMessage(Localizable pattern,\n                           Object ... arguments) {\n        msgPatterns.add(pattern);\n        msgArguments.add(ArgUtils.flatten(arguments));\n    }",
    "begin_line": 64,
    "end_line": 68,
    "comment": "/** \n * Sets a message.\n * @param pattern Message pattern.\n * @param arguments Values for replacing the placeholders in the messagepattern.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.setValue#78",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.setValue(java.lang.String, java.lang.Object)",
    "snippet": "public void setValue(String key, Object value) {\n        context.put(key, value);\n    }",
    "begin_line": 78,
    "end_line": 80,
    "comment": "/** \n * Sets the context (key, value) pair. Keys are assumed to be unique within an instance. If the same key is assigned a new value, the previous one will be lost.\n * @param key Context key (not null).\n * @param value Context value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.getValue#88",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.getValue(java.lang.String)",
    "snippet": "public Object getValue(String key) {\n        return context.get(key);\n    }",
    "begin_line": 88,
    "end_line": 90,
    "comment": "/** \n * Gets the value associated to the given context key.\n * @param key Context key.\n * @return the context value or {@code null} if the key does not exist.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.getKeys#97",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.getKeys()",
    "snippet": "public Set\u003cString\u003e getKeys() {\n        return context.keySet();\n    }",
    "begin_line": 97,
    "end_line": 99,
    "comment": "/** \n * Gets all the keys stored in the exception\n * @return the set of keys.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.getMessage#106",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.getMessage()",
    "snippet": "public String getMessage() {\n        return getMessage(Locale.US);\n    }",
    "begin_line": 106,
    "end_line": 108,
    "comment": "/** \n * Gets the default message.\n * @return the message.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.getLocalizedMessage#115",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.getLocalizedMessage()",
    "snippet": "public String getLocalizedMessage() {\n        return getMessage(Locale.getDefault());\n    }",
    "begin_line": 115,
    "end_line": 117,
    "comment": "/** \n * Gets the message in the default locale.\n * @return the localized message.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.getMessage#125",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.getMessage(java.util.Locale)",
    "snippet": "public String getMessage(final Locale locale) {\n        return buildMessage(locale, \": \");\n    }",
    "begin_line": 125,
    "end_line": 127,
    "comment": "/** \n * Gets the message in a specified locale.\n * @param locale Locale in which the message should be translated.\n * @return the localized message.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.getMessage#136",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.getMessage(java.util.Locale, java.lang.String)",
    "snippet": "public String getMessage(final Locale locale,\n                             final String separator) {\n        return buildMessage(locale, separator);\n    }",
    "begin_line": 136,
    "end_line": 139,
    "comment": "/** \n * Gets the message in a specified locale.\n * @param locale Locale in which the message should be translated.\n * @param separator Separator inserted between the message parts.\n * @return the localized message.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.buildMessage#148",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.buildMessage(java.util.Locale, java.lang.String)",
    "snippet": "private String buildMessage(Locale locale,\n                                String separator) {\n        final StringBuilder sb \u003d new StringBuilder();\n        int count \u003d 0;\n        final int len \u003d msgPatterns.size();\n        for (int i \u003d 0; i \u003c len; i++) {\n            final Localizable pat \u003d msgPatterns.get(i);\n            final Object[] args \u003d msgArguments.get(i);\n            final MessageFormat fmt \u003d new MessageFormat(pat.getLocalizedString(locale),\n                                                        locale);\n            sb.append(fmt.format(args));\n            if (++count \u003c len) {\n                // Add a separator if there are other messages.\n                sb.append(separator);\n            }\n        }\n\n        return sb.toString();\n    }",
    "begin_line": 148,
    "end_line": 166,
    "comment": "/** \n * Builds a message string.\n * @param locale Locale in which the message should be translated.\n * @param separator Message separator.\n * @return a localized message string.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.writeObject#174",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.writeObject(java.io.ObjectOutputStream)",
    "snippet": "private void writeObject(ObjectOutputStream out)\n        throws IOException {\n        serializeMessages(out);\n        serializeContext(out);\n    }",
    "begin_line": 174,
    "end_line": 178,
    "comment": "/** \n * Serialize this object to the given stream.\n * @param out Stream.\n * @throws IOException This should never happen.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.readObject#186",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.readObject(java.io.ObjectInputStream)",
    "snippet": "private void readObject(ObjectInputStream in)\n        throws IOException,\n               ClassNotFoundException {\n        deSerializeMessages(in);\n        deSerializeContext(in);\n    }",
    "begin_line": 186,
    "end_line": 191,
    "comment": "/** \n * Deserialize this object from the given stream.\n * @param in Stream.\n * @throws IOException This should never happen.\n * @throws ClassNotFoundException This should never happen.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.serializeMessages#199",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.serializeMessages(java.io.ObjectOutputStream)",
    "snippet": "private void serializeMessages(ObjectOutputStream out)\n        throws IOException {\n        // Step 1.\n        final int len \u003d msgPatterns.size();\n        out.writeInt(len);\n        // Step 2.\n        for (int i \u003d 0; i \u003c len; i++) {\n            final Localizable pat \u003d msgPatterns.get(i);\n            // Step 3.\n            out.writeObject(pat);\n            final Object[] args \u003d msgArguments.get(i);\n            final int aLen \u003d args.length;\n            // Step 4.\n            out.writeInt(aLen);\n            for (int j \u003d 0; j \u003c aLen; j++) {\n                if (args[j] instanceof Serializable) {\n                    // Step 5a.\n                    out.writeObject(args[j]);\n                } else {\n                    // Step 5b.\n                    out.writeObject(nonSerializableReplacement(args[j]));\n                }\n            }\n        }\n    }",
    "begin_line": 199,
    "end_line": 223,
    "comment": "/** \n * Serialize   {@link #msgPatterns} and {@link #msgArguments}.\n * @param out Stream.\n * @throws IOException This should never happen.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.deSerializeMessages#232",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.deSerializeMessages(java.io.ObjectInputStream)",
    "snippet": "private void deSerializeMessages(ObjectInputStream in)\n        throws IOException,\n               ClassNotFoundException {\n        // Step 1.\n        final int len \u003d in.readInt();\n        msgPatterns \u003d new ArrayList\u003cLocalizable\u003e(len);\n        msgArguments \u003d new ArrayList\u003cObject[]\u003e(len);\n        // Step 2.\n        for (int i \u003d 0; i \u003c len; i++) {\n            // Step 3.\n            final Localizable pat \u003d (Localizable) in.readObject();\n            msgPatterns.add(pat);\n            // Step 4.\n            final int aLen \u003d in.readInt();\n            final Object[] args \u003d new Object[aLen];\n            for (int j \u003d 0; j \u003c aLen; j++) {\n                // Step 5.\n                args[j] \u003d in.readObject();\n            }\n            msgArguments.add(args);\n        }\n    }",
    "begin_line": 232,
    "end_line": 253,
    "comment": "/** \n * Deserialize  {@link #msgPatterns} and {@link #msgArguments}.\n * @param in Stream.\n * @throws IOException This should never happen.\n * @throws ClassNotFoundException This should never happen.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.serializeContext#261",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.serializeContext(java.io.ObjectOutputStream)",
    "snippet": "private void serializeContext(ObjectOutputStream out)\n        throws IOException {\n        // Step 1.\n        final int len \u003d context.keySet().size();\n        out.writeInt(len);\n        for (String key : context.keySet()) {\n            // Step 2.\n            out.writeObject(key);\n            final Object value \u003d context.get(key);\n            if (value instanceof Serializable) {\n                // Step 3a.\n                out.writeObject(value);\n            } else {\n                // Step 3b.\n                out.writeObject(nonSerializableReplacement(value));\n            }\n        }\n    }",
    "begin_line": 261,
    "end_line": 278,
    "comment": "/** \n * Serialize  {@link #context}.\n * @param out Stream.\n * @throws IOException This should never happen.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.deSerializeContext#287",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.deSerializeContext(java.io.ObjectInputStream)",
    "snippet": "private void deSerializeContext(ObjectInputStream in)\n        throws IOException,\n               ClassNotFoundException {\n        // Step 1.\n        final int len \u003d in.readInt();\n        context \u003d new HashMap\u003cString, Object\u003e();\n        for (int i \u003d 0; i \u003c len; i++) {\n            // Step 2.\n            final String key \u003d (String) in.readObject();\n            // Step 3.\n            final Object value \u003d in.readObject();\n            context.put(key, value);\n        }\n    }",
    "begin_line": 287,
    "end_line": 300,
    "comment": "/** \n * Deserialize  {@link #context}.\n * @param in Stream.\n * @throws IOException This should never happen.\n * @throws ClassNotFoundException This should never happen.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ExceptionContext.nonSerializableReplacement#309",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/ExceptionContext.java",
    "class_name": "org.apache.commons.math.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math.exception.util.ExceptionContext.nonSerializableReplacement(java.lang.Object)",
    "snippet": "private String nonSerializableReplacement(Object obj) {\n        return \"[Object could not be serialized: \" + obj.getClass().getName() + \"]\";\n    }",
    "begin_line": 309,
    "end_line": 311,
    "comment": "/** \n * Replaces a non-serializable object with an error message string.\n * @param obj Object that does not implement the {@code Serializableinterface.}return a string that mentions which class could not be serialized.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.LocalizedFormats#344",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/LocalizedFormats.java",
    "class_name": "org.apache.commons.math.exception.util.LocalizedFormats",
    "signature": "org.apache.commons.math.exception.util.LocalizedFormats.LocalizedFormats(java.lang.String)",
    "snippet": "private LocalizedFormats(final String sourceFormat) {\n        this.sourceFormat \u003d sourceFormat;\n    }",
    "begin_line": 344,
    "end_line": 346,
    "comment": "/** \n * Simple constructor.\n * @param sourceFormat source English format to use when nolocalized version is available\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getSourceString#349",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/LocalizedFormats.java",
    "class_name": "org.apache.commons.math.exception.util.LocalizedFormats",
    "signature": "org.apache.commons.math.exception.util.LocalizedFormats.getSourceString()",
    "snippet": "public String getSourceString() {\n        return sourceFormat;\n    }",
    "begin_line": 349,
    "end_line": 351,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.getLocalizedString#354",
    "is_bug": true,
    "src_path": "org/apache/commons/math/exception/util/LocalizedFormats.java",
    "class_name": "org.apache.commons.math.exception.util.LocalizedFormats",
    "signature": "org.apache.commons.math.exception.util.LocalizedFormats.getLocalizedString(java.util.Locale)",
    "snippet": "public String getLocalizedString(final Locale locale) {\n        try {\n            ResourceBundle bundle \u003d\n                    ResourceBundle.getBundle(\"META-INF/localization/LocalizedFormats\", locale);\n            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n                // the value of the resource is the translated format\n                return bundle.getString(toString());\n            }\n\n        } catch (MissingResourceException mre) {\n            // do nothing here\n        }\n\n        // either the locale is not supported or the resource is unknown\n        // don\u0027t translate and fall back to using the source format\n        return sourceFormat;\n\n    }",
    "begin_line": 354,
    "end_line": 371,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.Fraction#98",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.Fraction(double)",
    "snippet": "public Fraction(double value) throws FractionConversionException {\n        this(value, 1.0e-5, 100);\n    }",
    "begin_line": 98,
    "end_line": 100,
    "comment": "/** \n * Create a fraction given the double value.\n * @param value the double value to convert to a fraction.\n * @throws FractionConversionException if the continued fraction failed toconverge.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.Fraction#118",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.Fraction(double, double, int)",
    "snippet": "public Fraction(double value, double epsilon, int maxIterations)\n        throws FractionConversionException\n    {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }",
    "begin_line": 118,
    "end_line": 122,
    "comment": "/** \n * Create a fraction given the double value and maximum error allowed. \u003cp\u003e References: \u003cul\u003e \u003cli\u003e\u003ca href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e Continued Fraction\u003c/a\u003e equations (11) and (22)-(26)\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e\n * @param value the double value to convert to a fraction.\n * @param epsilon maximum error allowed.  The resulting fraction is within{@code epsilon} of {@code value}, in absolute terms.\n * @param maxIterations maximum number of convergents\n * @throws FractionConversionException if the continued fraction failed toconverge.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.Fraction#138",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.Fraction(double, int)",
    "snippet": "public Fraction(double value, int maxDenominator)\n        throws FractionConversionException\n    {\n       this(value, 0, maxDenominator, 100);\n    }",
    "begin_line": 138,
    "end_line": 142,
    "comment": "/** \n * Create a fraction given the double value and maximum denominator. \u003cp\u003e References: \u003cul\u003e \u003cli\u003e\u003ca href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e Continued Fraction\u003c/a\u003e equations (11) and (22)-(26)\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e\n * @param value the double value to convert to a fraction.\n * @param maxDenominator The maximum allowed value for denominator\n * @throws FractionConversionException if the continued fraction failed toconverge\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.Fraction#175",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.Fraction(double, double, int, int)",
    "snippet": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow \u003d Integer.MAX_VALUE;\n        double r0 \u003d value;\n        long a0 \u003d (long)FastMath.floor(r0);\n        if (a0 \u003e overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) \u003c epsilon) {\n            this.numerator \u003d (int) a0;\n            this.denominator \u003d 1;\n            return;\n        }\n\n        long p0 \u003d 1;\n        long q0 \u003d 0;\n        long p1 \u003d a0;\n        long q1 \u003d 1;\n\n        long p2 \u003d 0;\n        long q2 \u003d 1;\n\n        int n \u003d 0;\n        boolean stop \u003d false;\n        do {\n            ++n;\n            double r1 \u003d 1.0 / (r0 - a0);\n            long a1 \u003d (long)FastMath.floor(r1);\n            p2 \u003d (a1 * p1) + p0;\n            q2 \u003d (a1 * q1) + q0;\n            if ((p2 \u003e overflow) || (q2 \u003e overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent \u003d (double)p2 / (double)q2;\n            if (n \u003c maxIterations \u0026\u0026 FastMath.abs(convergent - value) \u003e epsilon \u0026\u0026 q2 \u003c maxDenominator) {\n                p0 \u003d p1;\n                p1 \u003d p2;\n                q0 \u003d q1;\n                q1 \u003d q2;\n                a0 \u003d a1;\n                r0 \u003d r1;\n            } else {\n                stop \u003d true;\n            }\n        } while (!stop);\n\n        if (n \u003e\u003d maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 \u003c maxDenominator) {\n            this.numerator \u003d (int) p2;\n            this.denominator \u003d (int) q2;\n        } else {\n            this.numerator \u003d (int) p1;\n            this.denominator \u003d (int) q1;\n        }\n\n    }",
    "begin_line": 175,
    "end_line": 238,
    "comment": "/** \n * Create a fraction given the double value and either the maximum error allowed or the maximum number of denominator digits. \u003cp\u003e NOTE: This constructor is called with EITHER - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator has no effect). OR - a valid maxDenominator value and the epsilon value set to zero (that way epsilon only has effect if there is an exact match before the maxDenominator value is reached). \u003c/p\u003e\u003cp\u003e It has been done this way so that the same code can be (re)used for both scenarios. However this could be confusing to users if it were part of the public API and this constructor should therefore remain PRIVATE. \u003c/p\u003e See JIRA issue ticket MATH-181 for more details: https://issues.apache.org/jira/browse/MATH-181\n * @param value the double value to convert to a fraction.\n * @param epsilon maximum error allowed.  The resulting fraction is within{@code epsilon} of {@code value}, in absolute terms.\n * @param maxDenominator maximum denominator value allowed.\n * @param maxIterations maximum number of convergents\n * @throws FractionConversionException if the continued fraction failed toconverge.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.Fraction#245",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.Fraction(int)",
    "snippet": "public Fraction(int num) {\n        this(num, 1);\n    }",
    "begin_line": 245,
    "end_line": 247,
    "comment": "/** \n * Create a fraction from an int. The fraction is num / 1.\n * @param num the numerator.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.Fraction#256",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.Fraction(int, int)",
    "snippet": "public Fraction(int num, int den) {\n        if (den \u003d\u003d 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              num, den);\n        }\n        if (den \u003c 0) {\n            if (num \u003d\u003d Integer.MIN_VALUE ||\n                den \u003d\u003d Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  num, den);\n            }\n            num \u003d -num;\n            den \u003d -den;\n        }\n        // reduce numerator and denominator by greatest common denominator.\n        final int d \u003d MathUtils.gcd(num, den);\n        if (d \u003e 1) {\n            num /\u003d d;\n            den /\u003d d;\n        }\n\n        // move sign to numerator.\n        if (den \u003c 0) {\n            num \u003d -num;\n            den \u003d -den;\n        }\n        this.numerator   \u003d num;\n        this.denominator \u003d den;\n    }",
    "begin_line": 256,
    "end_line": 284,
    "comment": "/** \n * Create a fraction given the numerator and denominator.  The fraction is reduced to lowest terms.\n * @param num the numerator.\n * @param den the denominator.\n * @throws MathArithmeticException if the denominator is {@code zero}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.abs#290",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.abs()",
    "snippet": "public Fraction abs() {\n        Fraction ret;\n        if (numerator \u003e\u003d 0) {\n            ret \u003d this;\n        } else {\n            ret \u003d negate();\n        }\n        return ret;\n    }",
    "begin_line": 290,
    "end_line": 298,
    "comment": "/** \n * Returns the absolute value of this fraction.\n * @return the absolute value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.compareTo#306",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.compareTo(org.apache.commons.math.fraction.Fraction)",
    "snippet": "public int compareTo(Fraction object) {\n        long nOd \u003d ((long) numerator) * object.denominator;\n        long dOn \u003d ((long) denominator) * object.numerator;\n        return (nOd \u003c dOn) ? -1 : ((nOd \u003e dOn) ? +1 : 0);\n    }",
    "begin_line": 306,
    "end_line": 310,
    "comment": "/** \n * Compares this object to another based on size.\n * @param object the object to compare to\n * @return -1 if this is less than \u003ctt\u003eobject\u003c/tt\u003e, +1 if this is greaterthan \u003ctt\u003eobject\u003c/tt\u003e, 0 if they are equal.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.doubleValue#318",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.doubleValue()",
    "snippet": "@Override\n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }",
    "begin_line": 318,
    "end_line": 320,
    "comment": "/** \n * Gets the fraction as a \u003ctt\u003edouble\u003c/tt\u003e. This calculates the fraction as the numerator divided by denominator.\n * @return the fraction as a \u003ctt\u003edouble\u003c/tt\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.equals#332",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.equals(java.lang.Object)",
    "snippet": "@Override\n    public boolean equals(Object other) {\n        if (this \u003d\u003d other) {\n            return true;\n        }\n        if (other instanceof Fraction) {\n            // since fractions are always in lowest terms, numerators and\n            // denominators can be compared directly for equality.\n            Fraction rhs \u003d (Fraction)other;\n            return (numerator \u003d\u003d rhs.numerator) \u0026\u0026\n                (denominator \u003d\u003d rhs.denominator);\n        }\n        return false;\n    }",
    "begin_line": 332,
    "end_line": 344,
    "comment": "/** \n * Test for the equality of two fractions.  If the lowest term numerator and denominators are the same for both fractions, the two fractions are considered to be equal.\n * @param other fraction to test for equality to this fraction\n * @return true if two fractions are equal, false if object is\u003ctt\u003enull\u003c/tt\u003e, not an instance of  {@link Fraction}, or not equal to this fraction instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.floatValue#352",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.floatValue()",
    "snippet": "@Override\n    public float floatValue() {\n        return (float)doubleValue();\n    }",
    "begin_line": 352,
    "end_line": 354,
    "comment": "/** \n * Gets the fraction as a \u003ctt\u003efloat\u003c/tt\u003e. This calculates the fraction as the numerator divided by denominator.\n * @return the fraction as a \u003ctt\u003efloat\u003c/tt\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.getDenominator#360",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.getDenominator()",
    "snippet": "public int getDenominator() {\n        return denominator;\n    }",
    "begin_line": 360,
    "end_line": 362,
    "comment": "/** \n * Access the denominator.\n * @return the denominator.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.getNumerator#368",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.getNumerator()",
    "snippet": "public int getNumerator() {\n        return numerator;\n    }",
    "begin_line": 368,
    "end_line": 370,
    "comment": "/** \n * Access the numerator.\n * @return the numerator.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.hashCode#377",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.hashCode()",
    "snippet": "@Override\n    public int hashCode() {\n        return 37 * (37 * 17 + numerator) + denominator;\n    }",
    "begin_line": 377,
    "end_line": 379,
    "comment": "/** \n * Gets a hashCode for the fraction.\n * @return a hash code value for this object\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.intValue#387",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.intValue()",
    "snippet": "@Override\n    public int intValue() {\n        return (int)doubleValue();\n    }",
    "begin_line": 387,
    "end_line": 389,
    "comment": "/** \n * Gets the fraction as an \u003ctt\u003eint\u003c/tt\u003e. This returns the whole number part of the fraction.\n * @return the whole number fraction part\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.longValue#397",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.longValue()",
    "snippet": "@Override\n    public long longValue() {\n        return (long)doubleValue();\n    }",
    "begin_line": 397,
    "end_line": 399,
    "comment": "/** \n * Gets the fraction as a \u003ctt\u003elong\u003c/tt\u003e. This returns the whole number part of the fraction.\n * @return the whole number fraction part\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.negate#405",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.negate()",
    "snippet": "public Fraction negate() {\n        if (numerator\u003d\u003dInteger.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }",
    "begin_line": 405,
    "end_line": 410,
    "comment": "/** \n * Return the additive inverse of this fraction.\n * @return the negation of this fraction.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.reciprocal#416",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.reciprocal()",
    "snippet": "public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }",
    "begin_line": 416,
    "end_line": 418,
    "comment": "/** \n * Return the multiplicative inverse of this fraction.\n * @return the reciprocal fraction\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.add#430",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.add(org.apache.commons.math.fraction.Fraction)",
    "snippet": "public Fraction add(Fraction fraction) {\n        return addSub(fraction, true /* add */);\n    }",
    "begin_line": 430,
    "end_line": 432,
    "comment": "/** \n * \u003cp\u003eAdds the value of this fraction to another, returning the result in reduced form. The algorithm follows Knuth, 4.5.1.\u003c/p\u003e\n * @param fraction  the fraction to add, must not be {@code null}\n * @return a {@code Fraction} instance with the resulting values\n * @throws NullArgumentException if the fraction is {@code null}\n * @throws MathArithmeticException if the resulting numerator or denominator exceeds{@code Integer.MAX_VALUE}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.add#439",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.add(int)",
    "snippet": "public Fraction add(final int i) {\n        return new Fraction(numerator + i * denominator, denominator);\n    }",
    "begin_line": 439,
    "end_line": 441,
    "comment": "/** \n * Add an integer to the fraction.\n * @param i the \u003ctt\u003einteger\u003c/tt\u003e to add.\n * @return this + i\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.subtract#453",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.subtract(org.apache.commons.math.fraction.Fraction)",
    "snippet": "public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false /* subtract */);\n    }",
    "begin_line": 453,
    "end_line": 455,
    "comment": "/** \n * \u003cp\u003eSubtracts the value of another fraction from the value of this one, returning the result in reduced form.\u003c/p\u003e\n * @param fraction  the fraction to subtract, must not be {@code null}\n * @return a {@code Fraction} instance with the resulting values\n * @throws NullArgumentException if the fraction is {@code null}\n * @throws MathArithmeticException if the resulting numerator or denominatorcannot be represented in an  {@code int}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.subtract#462",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.subtract(int)",
    "snippet": "public Fraction subtract(final int i) {\n        return new Fraction(numerator - i * denominator, denominator);\n    }",
    "begin_line": 462,
    "end_line": 464,
    "comment": "/** \n * Subtract an integer from the fraction.\n * @param i the \u003ctt\u003einteger\u003c/tt\u003e to subtract.\n * @return this - i\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.addSub#476",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.addSub(org.apache.commons.math.fraction.Fraction, boolean)",
    "snippet": "private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction \u003d\u003d null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        // zero is identity for addition.\n        if (numerator \u003d\u003d 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator \u003d\u003d 0) {\n            return this;\n        }\n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        int d1 \u003d MathUtils.gcd(denominator, fraction.denominator);\n        if (d1\u003d\u003d1) {\n            // result is ( (u*v\u0027 +/- u\u0027v) / u\u0027v\u0027)\n            int uvp \u003d MathUtils.mulAndCheck(numerator, fraction.denominator);\n            int upv \u003d MathUtils.mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? MathUtils.addAndCheck(uvp, upv) :\n                 MathUtils.subAndCheck(uvp, upv),\n                 MathUtils.mulAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity \u0027t\u0027 requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we\u0027re going to use a BigInteger.\n        // t \u003d u(v\u0027/d1) +/- v(u\u0027/d1)\n        BigInteger uvp \u003d BigInteger.valueOf(numerator)\n        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv \u003d BigInteger.valueOf(fraction.numerator)\n        .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t \u003d isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        // but d2 doesn\u0027t need extra precision because\n        // d2 \u003d gcd(t,d1) \u003d gcd(t mod d1, d1)\n        int tmodd1 \u003d t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 \u003d (tmodd1\u003d\u003d0)?d1:MathUtils.gcd(tmodd1, d1);\n\n        // result is (t/d2) / (u\u0027/d1)(v\u0027/d2)\n        BigInteger w \u003d t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() \u003e 31) {\n            throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n                                              w);\n        }\n        return new Fraction (w.intValue(),\n                MathUtils.mulAndCheck(denominator/d1,\n                        fraction.denominator/d2));\n    }",
    "begin_line": 476,
    "end_line": 521,
    "comment": "/** \n * Implement add and subtract using algorithm described in Knuth 4.5.1.\n * @param fraction the fraction to subtract, must not be {@code null}\n * @param isAdd true to add, false to subtract\n * @return a {@code Fraction} instance with the resulting values\n * @throws NullArgumentException if the fraction is {@code null}\n * @throws MathArithmeticException if the resulting numerator or denominatorcannot be represented in an  {@code int}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.multiply#533",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.multiply(org.apache.commons.math.fraction.Fraction)",
    "snippet": "public Fraction multiply(Fraction fraction) {\n        if (fraction \u003d\u003d null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (numerator \u003d\u003d 0 || fraction.numerator \u003d\u003d 0) {\n            return ZERO;\n        }\n        // knuth 4.5.1\n        // make sure we don\u0027t overflow unless the result *must* overflow.\n        int d1 \u003d MathUtils.gcd(numerator, fraction.denominator);\n        int d2 \u003d MathUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }",
    "begin_line": 533,
    "end_line": 547,
    "comment": "/** \n * \u003cp\u003eMultiplies the value of this fraction by another, returning the result in reduced form.\u003c/p\u003e\n * @param fraction  the fraction to multiply by, must not be {@code null}\n * @return a {@code Fraction} instance with the resulting values\n * @throws NullArgumentException if the fraction is {@code null}\n * @throws MathArithmeticException if the resulting numerator or denominator exceeds{@code Integer.MAX_VALUE}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.multiply#554",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.multiply(int)",
    "snippet": "public Fraction multiply(final int i) {\n        return new Fraction(numerator * i, denominator);\n    }",
    "begin_line": 554,
    "end_line": 556,
    "comment": "/** \n * Multiply the fraction by an integer.\n * @param i the \u003ctt\u003einteger\u003c/tt\u003e to multiply by.\n * @return this * i\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.divide#568",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.divide(org.apache.commons.math.fraction.Fraction)",
    "snippet": "public Fraction divide(Fraction fraction) {\n        if (fraction \u003d\u003d null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (fraction.numerator \u003d\u003d 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n                                              fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }",
    "begin_line": 568,
    "end_line": 577,
    "comment": "/** \n * \u003cp\u003eDivide the value of this fraction by another.\u003c/p\u003e\n * @param fraction  the fraction to divide by, must not be {@code null}\n * @return a {@code Fraction} instance with the resulting values\n * @throws IllegalArgumentException if the fraction is {@code null}\n * @throws MathArithmeticException if the fraction to divide by is zero\n * @throws MathArithmeticException if the resulting numerator or denominator exceeds{@code Integer.MAX_VALUE}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.divide#584",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.divide(int)",
    "snippet": "public Fraction divide(final int i) {\n        return new Fraction(numerator, denominator * i);\n    }",
    "begin_line": 584,
    "end_line": 586,
    "comment": "/** \n * Divide the fraction by an integer.\n * @param i the \u003ctt\u003einteger\u003c/tt\u003e to divide by.\n * @return this * i\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.getReducedFraction#599",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.getReducedFraction(int, int)",
    "snippet": "public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator \u003d\u003d 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              numerator, denominator);\n        }\n        if (numerator\u003d\u003d0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k\u003e0)\n        if (denominator\u003d\u003dInteger.MIN_VALUE \u0026\u0026 (numerator\u00261)\u003d\u003d0) {\n            numerator/\u003d2; denominator/\u003d2;\n        }\n        if (denominator \u003c 0) {\n            if (numerator\u003d\u003dInteger.MIN_VALUE ||\n                    denominator\u003d\u003dInteger.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  numerator, denominator);\n            }\n            numerator \u003d -numerator;\n            denominator \u003d -denominator;\n        }\n        // simplify fraction.\n        int gcd \u003d MathUtils.gcd(numerator, denominator);\n        numerator /\u003d gcd;\n        denominator /\u003d gcd;\n        return new Fraction(numerator, denominator);\n    }",
    "begin_line": 599,
    "end_line": 625,
    "comment": "/** \n * \u003cp\u003eCreates a  {@code Fraction} instance with the 2 partsof a fraction Y/Z.\u003c/p\u003e \u003cp\u003eAny negative signs are resolved to be on the numerator.\u003c/p\u003e\n * @param numerator  the numerator, for example the three in \u0027three sevenths\u0027\n * @param denominator  the denominator, for example the seven in \u0027three sevenths\u0027\n * @return a new fraction instance, with the numerator and denominator reduced\n * @throws MathArithmeticException if the denominator is {@code zero}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.toString#637",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.toString()",
    "snippet": "@Override\n    public String toString() {\n        String str \u003d null;\n        if (denominator \u003d\u003d 1) {\n            str \u003d Integer.toString(numerator);\n        } else if (numerator \u003d\u003d 0) {\n            str \u003d \"0\";\n        } else {\n            str \u003d numerator + \" / \" + denominator;\n        }\n        return str;\n    }",
    "begin_line": 637,
    "end_line": 647,
    "comment": "/** \n * \u003cp\u003e Returns the  {@code String} representing this fraction, ie\"num / dem\" or just \"num\" if the denominator is one. \u003c/p\u003e\n * @return a string representation of the fraction.\n * @see java.lang.Object#toString()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Fraction.getField#650",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/Fraction.java",
    "class_name": "org.apache.commons.math.fraction.Fraction",
    "signature": "org.apache.commons.math.fraction.Fraction.getField()",
    "snippet": "public FractionField getField() {\n        return FractionField.getInstance();\n    }",
    "begin_line": 650,
    "end_line": 652,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FractionField.FractionField#40",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/FractionField.java",
    "class_name": "org.apache.commons.math.fraction.FractionField",
    "signature": "org.apache.commons.math.fraction.FractionField.FractionField()",
    "snippet": "private FractionField() {\n    }",
    "begin_line": 40,
    "end_line": 41,
    "comment": "/** \n * Private constructor for the singleton.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FractionField.getInstance#46",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/FractionField.java",
    "class_name": "org.apache.commons.math.fraction.FractionField",
    "signature": "org.apache.commons.math.fraction.FractionField.getInstance()",
    "snippet": "public static FractionField getInstance() {\n        return LazyHolder.INSTANCE;\n    }",
    "begin_line": 46,
    "end_line": 48,
    "comment": "/** \n * Get the unique instance.\n * @return the unique instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FractionField.getOne#51",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/FractionField.java",
    "class_name": "org.apache.commons.math.fraction.FractionField",
    "signature": "org.apache.commons.math.fraction.FractionField.getOne()",
    "snippet": "public Fraction getOne() {\n        return Fraction.ONE;\n    }",
    "begin_line": 51,
    "end_line": 53,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FractionField.getZero#56",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/FractionField.java",
    "class_name": "org.apache.commons.math.fraction.FractionField",
    "signature": "org.apache.commons.math.fraction.FractionField.getZero()",
    "snippet": "public Fraction getZero() {\n        return Fraction.ZERO;\n    }",
    "begin_line": 56,
    "end_line": 58,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LazyHolder.readResolve#73",
    "is_bug": true,
    "src_path": "org/apache/commons/math/fraction/FractionField.java",
    "class_name": "org.apache.commons.math.fraction.FractionField",
    "signature": "org.apache.commons.math.fraction.FractionField.readResolve()",
    "snippet": "private Object readResolve() {\n        // return the singleton instance\n        return LazyHolder.INSTANCE;\n    }",
    "begin_line": 73,
    "end_line": 76,
    "comment": "/** \n * Handle deserialization of the singleton.\n * @return the singleton instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.AbstractFieldMatrix#52",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.AbstractFieldMatrix()",
    "snippet": "protected AbstractFieldMatrix() {\n        field \u003d null;\n    }",
    "begin_line": 52,
    "end_line": 54,
    "comment": "/** \n * Constructor for use with Serializable\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.AbstractFieldMatrix#60",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.AbstractFieldMatrix(org.apache.commons.math.Field\u003cT\u003e)",
    "snippet": "protected AbstractFieldMatrix(final Field\u003cT\u003e field) {\n        this.field \u003d field;\n    }",
    "begin_line": 60,
    "end_line": 62,
    "comment": "/** \n * Creates a matrix with no data\n * @param field field to which the elements belong\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.AbstractFieldMatrix#73",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.AbstractFieldMatrix(org.apache.commons.math.Field\u003cT\u003e, int, int)",
    "snippet": "protected AbstractFieldMatrix(final Field\u003cT\u003e field,\n                                  final int rowDimension,\n                                  final int columnDimension) {\n        if (rowDimension \u003c\u003d 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION,\n                                                   rowDimension);\n        }\n        if (columnDimension \u003c\u003d 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION,\n                                                   columnDimension);\n        }\n        this.field \u003d field;\n    }",
    "begin_line": 73,
    "end_line": 85,
    "comment": "/** \n * Create a new FieldMatrix\u003cT\u003e with the supplied row and column dimensions.\n * @param field Field to which the elements belong.\n * @param rowDimension Number of rows in the new matrix.\n * @param columnDimension Number of columns in the new matrix.\n * @throws NotStrictlyPositiveException if row or column dimension is notpositive.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.extractField#96",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.extractField(T[][])",
    "snippet": "protected static \u003cT extends FieldElement\u003cT\u003e\u003e Field\u003cT\u003e extractField(final T[][] d) {\n        if (d \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        if (d.length \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        if (d[0].length \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n        return d[0][0].getField();\n    }",
    "begin_line": 96,
    "end_line": 107,
    "comment": "/** \n * Get the elements type from an array.\n * @param \u003c T \u003e Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NullArgumentException if the array is {@code null}.\n * @throws NoDataException if the array is empty.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.extractField#117",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.extractField(T[])",
    "snippet": "protected static \u003cT extends FieldElement\u003cT\u003e\u003e Field\u003cT\u003e extractField(final T[] d) {\n        if (d.length \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        return d[0].getField();\n    }",
    "begin_line": 117,
    "end_line": 122,
    "comment": "/** \n * Get the elements type from an array.\n * @param \u003c T \u003e Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NoDataException if array is empty.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.buildArray#136",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.buildArray(org.apache.commons.math.Field\u003cT\u003e, int, int)",
    "snippet": "@SuppressWarnings(\"unchecked\")\n    protected static \u003cT extends FieldElement\u003cT\u003e\u003e T[][] buildArray(final Field\u003cT\u003e field,\n                                                                  final int rows,\n                                                                  final int columns) {\n        if (columns \u003c 0) {\n            T[] dummyRow \u003d (T[]) Array.newInstance(field.getZero().getClass(), 0);\n            return (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n        }\n        T[][] array \u003d\n            (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { rows, columns });\n        for (int i \u003d 0; i \u003c array.length; ++i) {\n            Arrays.fill(array[i], field.getZero());\n        }\n        return array;\n    }",
    "begin_line": 136,
    "end_line": 149,
    "comment": "/** \n * Build an array of elements. \u003cp\u003e Complete arrays are filled with field.getZero() \u003c/p\u003e\n * @param \u003c T \u003e Type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows\n * @param columns number of columns (may be negative to build partialarrays in the same way \u003ccode\u003enew Field[rows][]\u003c/code\u003e works)\n * @return a new array\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.buildArray#160",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.buildArray(org.apache.commons.math.Field\u003cT\u003e, int)",
    "snippet": "protected static \u003cT extends FieldElement\u003cT\u003e\u003e T[] buildArray(final Field\u003cT\u003e field,\n                                                                final int length) {\n        @SuppressWarnings(\"unchecked\") // OK because field must be correct class\n        T[] array \u003d (T[]) Array.newInstance(field.getZero().getClass(), length);\n        Arrays.fill(array, field.getZero());\n        return array;\n    }",
    "begin_line": 160,
    "end_line": 166,
    "comment": "/** \n * Build an array of elements. \u003cp\u003e Arrays are filled with field.getZero() \u003c/p\u003e\n * @param \u003c T \u003e the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getField#169",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getField()",
    "snippet": "public Field\u003cT\u003e getField() {\n        return field;\n    }",
    "begin_line": 169,
    "end_line": 171,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.createMatrix#174",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.createMatrix(int, int)",
    "snippet": "public abstract FieldMatrix\u003cT\u003e createMatrix(final int rowDimension, final int columnDimension);",
    "begin_line": 174,
    "end_line": 174,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.copy#177",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.copy()",
    "snippet": "public abstract FieldMatrix\u003cT\u003e copy();",
    "begin_line": 177,
    "end_line": 177,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.add#180",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.add(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "public FieldMatrix\u003cT\u003e add(FieldMatrix\u003cT\u003e m) {\n        // safety check\n        checkAdditionCompatible(m);\n\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final FieldMatrix\u003cT\u003e out \u003d createMatrix(rowCount, columnCount);\n        for (int row \u003d 0; row \u003c rowCount; ++row) {\n            for (int col \u003d 0; col \u003c columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col).add(m.getEntry(row, col)));\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 180,
    "end_line": 194,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.subtract#197",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.subtract(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "public FieldMatrix\u003cT\u003e subtract(final FieldMatrix\u003cT\u003e m) {\n        // safety check\n        checkSubtractionCompatible(m);\n\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final FieldMatrix\u003cT\u003e out \u003d createMatrix(rowCount, columnCount);\n        for (int row \u003d 0; row \u003c rowCount; ++row) {\n            for (int col \u003d 0; col \u003c columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col).subtract(m.getEntry(row, col)));\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 197,
    "end_line": 211,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.scalarAdd#214",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.scalarAdd(T)",
    "snippet": "public FieldMatrix\u003cT\u003e scalarAdd(final T d) {\n\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final FieldMatrix\u003cT\u003e out \u003d createMatrix(rowCount, columnCount);\n        for (int row \u003d 0; row \u003c rowCount; ++row) {\n            for (int col \u003d 0; col \u003c columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col).add(d));\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 214,
    "end_line": 226,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.scalarMultiply#229",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.scalarMultiply(T)",
    "snippet": "public FieldMatrix\u003cT\u003e scalarMultiply(final T d) {\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final FieldMatrix\u003cT\u003e out \u003d createMatrix(rowCount, columnCount);\n        for (int row \u003d 0; row \u003c rowCount; ++row) {\n            for (int col \u003d 0; col \u003c columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col).multiply(d));\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 229,
    "end_line": 240,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.multiply#243",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.multiply(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "public FieldMatrix\u003cT\u003e multiply(final FieldMatrix\u003cT\u003e m) {\n        // safety check\n        checkMultiplicationCompatible(m);\n\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d m.getColumnDimension();\n        final int nSum  \u003d getColumnDimension();\n        final FieldMatrix\u003cT\u003e out \u003d createMatrix(nRows, nCols);\n        for (int row \u003d 0; row \u003c nRows; ++row) {\n            for (int col \u003d 0; col \u003c nCols; ++col) {\n                T sum \u003d field.getZero();\n                for (int i \u003d 0; i \u003c nSum; ++i) {\n                    sum \u003d sum.add(getEntry(row, i).multiply(m.getEntry(i, col)));\n                }\n                out.setEntry(row, col, sum);\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 243,
    "end_line": 262,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.preMultiply#265",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.preMultiply(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "public FieldMatrix\u003cT\u003e preMultiply(final FieldMatrix\u003cT\u003e m) {\n        return m.multiply(this);\n    }",
    "begin_line": 265,
    "end_line": 267,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.power#270",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.power(int)",
    "snippet": "public FieldMatrix\u003cT\u003e power(final int p) {\n        if (p \u003c 0) {\n            throw new IllegalArgumentException(\"p must be \u003e\u003d 0\");\n        }\n\n        if (!isSquare()) {\n            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n        }\n\n        if (p \u003d\u003d 0) {\n            return MatrixUtils.createFieldIdentityMatrix(this.getField(), this.getRowDimension());\n        }\n\n        if (p \u003d\u003d 1) {\n            return this.copy();\n        }\n\n        final int power \u003d p - 1;\n\n        /*\n         * Only log_2(p) operations is used by doing as follows:\n         * 5^214 \u003d 5^128 * 5^64 * 5^16 * 5^4 * 5^2\n         *\n         * In general, the same approach is used for A^p.\n         */\n\n        final char[] binaryRepresentation \u003d Integer.toBinaryString(power)\n                .toCharArray();\n        final ArrayList\u003cInteger\u003e nonZeroPositions \u003d new ArrayList\u003cInteger\u003e();\n\n        for (int i \u003d 0; i \u003c binaryRepresentation.length; ++i) {\n            if (binaryRepresentation[i] \u003d\u003d \u00271\u0027) {\n                final int pos \u003d binaryRepresentation.length - i - 1;\n                nonZeroPositions.add(pos);\n            }\n        }\n\n        ArrayList\u003cFieldMatrix\u003cT\u003e\u003e results \u003d new ArrayList\u003cFieldMatrix\u003cT\u003e\u003e(\n                binaryRepresentation.length);\n\n        results.add(0, this.copy());\n\n        for (int i \u003d 1; i \u003c binaryRepresentation.length; ++i) {\n            final FieldMatrix\u003cT\u003e s \u003d results.get(i - 1);\n            final FieldMatrix\u003cT\u003e r \u003d s.multiply(s);\n            results.add(i, r);\n        }\n\n        FieldMatrix\u003cT\u003e result \u003d this.copy();\n\n        for (Integer i : nonZeroPositions) {\n            result \u003d result.multiply(results.get(i));\n        }\n\n        return result;\n    }",
    "begin_line": 270,
    "end_line": 325,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getData#328",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getData()",
    "snippet": "public T[][] getData() {\n        final T[][] data \u003d buildArray(field, getRowDimension(), getColumnDimension());\n\n        for (int i \u003d 0; i \u003c data.length; ++i) {\n            final T[] dataI \u003d data[i];\n            for (int j \u003d 0; j \u003c dataI.length; ++j) {\n                dataI[j] \u003d getEntry(i, j);\n            }\n        }\n\n        return data;\n    }",
    "begin_line": 328,
    "end_line": 339,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getSubMatrix#342",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getSubMatrix(int, int, int, int)",
    "snippet": "public FieldMatrix\u003cT\u003e getSubMatrix(final int startRow, final int endRow,\n                                       final int startColumn, final int endColumn) {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n\n        final FieldMatrix\u003cT\u003e subMatrix \u003d\n            createMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n        for (int i \u003d startRow; i \u003c\u003d endRow; ++i) {\n            for (int j \u003d startColumn; j \u003c\u003d endColumn; ++j) {\n                subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));\n            }\n        }\n\n        return subMatrix;\n\n    }",
    "begin_line": 342,
    "end_line": 356,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getSubMatrix#359",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getSubMatrix(int[], int[])",
    "snippet": "public FieldMatrix\u003cT\u003e getSubMatrix(final int[] selectedRows,\n                                       final int[] selectedColumns) {\n\n        // safety checks\n        checkSubMatrixIndex(selectedRows, selectedColumns);\n\n        // copy entries\n        final FieldMatrix\u003cT\u003e subMatrix \u003d\n            createMatrix(selectedRows.length, selectedColumns.length);\n        subMatrix.walkInOptimizedOrder(new DefaultFieldMatrixChangingVisitor\u003cT\u003e(field.getZero()) {\n\n            /** {@inheritDoc} */\n            @Override\n            public T visit(final int row, final int column, final T value) {\n                return getEntry(selectedRows[row], selectedColumns[column]);\n            }\n\n        });\n\n        return subMatrix;\n\n    }",
    "begin_line": 359,
    "end_line": 380,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.visit#372",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.visit(int, int, T)",
    "snippet": "@Override\n            public T visit(final int row, final int column, final T value) {\n                return getEntry(selectedRows[row], selectedColumns[column]);\n            }",
    "begin_line": 372,
    "end_line": 374,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.copySubMatrix#383",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.copySubMatrix(int, int, int, int, T[][])",
    "snippet": "public void copySubMatrix(final int startRow, final int endRow,\n                              final int startColumn, final int endColumn,\n                              final T[][] destination) {\n        // safety checks\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        final int rowsCount    \u003d endRow + 1 - startRow;\n        final int columnsCount \u003d endColumn + 1 - startColumn;\n        if ((destination.length \u003c rowsCount) || (destination[0].length \u003c columnsCount)) {\n            throw new MatrixDimensionMismatchException(destination.length,\n                                                       destination[0].length,\n                                                       rowsCount,\n                                                       columnsCount);\n        }\n\n        // copy entries\n        walkInOptimizedOrder(new DefaultFieldMatrixPreservingVisitor\u003cT\u003e(field.getZero()) {\n\n            /** Initial row index. */\n            private int startRow;\n\n            /** Initial column index. */\n            private int startColumn;\n\n            /** {@inheritDoc} */\n            @Override\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                this.startRow    \u003d startRow;\n                this.startColumn \u003d startColumn;\n            }\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final T value) {\n                destination[row - startRow][column - startColumn] \u003d value;\n            }\n\n        }, startRow, endRow, startColumn, endColumn);\n\n    }",
    "begin_line": 383,
    "end_line": 423,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.start#408",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.start(int, int, int, int, int, int)",
    "snippet": "@Override\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                this.startRow    \u003d startRow;\n                this.startColumn \u003d startColumn;\n            }",
    "begin_line": 408,
    "end_line": 413,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.visit#417",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.visit(int, int, T)",
    "snippet": "@Override\n            public void visit(final int row, final int column, final T value) {\n                destination[row - startRow][column - startColumn] \u003d value;\n            }",
    "begin_line": 417,
    "end_line": 419,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.copySubMatrix#426",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.copySubMatrix(int[], int[], T[][])",
    "snippet": "public void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination) {\n        // safety checks\n        checkSubMatrixIndex(selectedRows, selectedColumns);\n        if ((destination.length \u003c selectedRows.length) ||\n            (destination[0].length \u003c selectedColumns.length)) {\n            throw new MatrixDimensionMismatchException(destination.length,\n                                                       destination[0].length,\n                                                       selectedRows.length,\n                                                       selectedColumns.length);\n        }\n\n        // copy entries\n        for (int i \u003d 0; i \u003c selectedRows.length; i++) {\n            final T[] destinationI \u003d destination[i];\n            for (int j \u003d 0; j \u003c selectedColumns.length; j++) {\n                destinationI[j] \u003d getEntry(selectedRows[i], selectedColumns[j]);\n            }\n        }\n\n    }",
    "begin_line": 426,
    "end_line": 445,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.setSubMatrix#448",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.setSubMatrix(T[][], int, int)",
    "snippet": "public void setSubMatrix(final T[][] subMatrix, final int row, final int column) {\n        if (subMatrix \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        final int nRows \u003d subMatrix.length;\n        if (nRows \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n\n        final int nCols \u003d subMatrix[0].length;\n        if (nCols \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n\n        for (int r \u003d 1; r \u003c nRows; ++r) {\n            if (subMatrix[r].length !\u003d nCols) {\n                throw new DimensionMismatchException(nCols, subMatrix[r].length);\n            }\n        }\n\n        checkRowIndex(row);\n        checkColumnIndex(column);\n        checkRowIndex(nRows + row - 1);\n        checkColumnIndex(nCols + column - 1);\n\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            for (int j \u003d 0; j \u003c nCols; ++j) {\n                setEntry(row + i, column + j, subMatrix[i][j]);\n            }\n        }\n    }",
    "begin_line": 448,
    "end_line": 478,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getRowMatrix#481",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getRowMatrix(int)",
    "snippet": "public FieldMatrix\u003cT\u003e getRowMatrix(final int row) {\n        checkRowIndex(row);\n        final int nCols \u003d getColumnDimension();\n        final FieldMatrix\u003cT\u003e out \u003d createMatrix(1, nCols);\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            out.setEntry(0, i, getEntry(row, i));\n        }\n\n        return out;\n\n    }",
    "begin_line": 481,
    "end_line": 491,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.setRowMatrix#494",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.setRowMatrix(int, org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "public void setRowMatrix(final int row, final FieldMatrix\u003cT\u003e matrix) {\n        checkRowIndex(row);\n        final int nCols \u003d getColumnDimension();\n        if ((matrix.getRowDimension() !\u003d 1) ||\n            (matrix.getColumnDimension() !\u003d nCols)) {\n            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n                                                       matrix.getColumnDimension(),\n                                                       1, nCols);\n        }\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            setEntry(row, i, matrix.getEntry(0, i));\n        }\n\n    }",
    "begin_line": 494,
    "end_line": 507,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getColumnMatrix#510",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getColumnMatrix(int)",
    "snippet": "public FieldMatrix\u003cT\u003e getColumnMatrix(final int column) {\n\n        checkColumnIndex(column);\n        final int nRows \u003d getRowDimension();\n        final FieldMatrix\u003cT\u003e out \u003d createMatrix(nRows, 1);\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            out.setEntry(i, 0, getEntry(i, column));\n        }\n\n        return out;\n\n    }",
    "begin_line": 510,
    "end_line": 521,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.setColumnMatrix#524",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.setColumnMatrix(int, org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "public void setColumnMatrix(final int column, final FieldMatrix\u003cT\u003e matrix) {\n        checkColumnIndex(column);\n        final int nRows \u003d getRowDimension();\n        if ((matrix.getRowDimension() !\u003d nRows) ||\n            (matrix.getColumnDimension() !\u003d 1)) {\n            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n                                                       matrix.getColumnDimension(),\n                                                       nRows, 1);\n        }\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            setEntry(i, column, matrix.getEntry(i, 0));\n        }\n\n    }",
    "begin_line": 524,
    "end_line": 537,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getRowVector#540",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getRowVector(int)",
    "snippet": "public FieldVector\u003cT\u003e getRowVector(final int row) {\n        return new ArrayFieldVector\u003cT\u003e(field, getRow(row), false);\n    }",
    "begin_line": 540,
    "end_line": 542,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.setRowVector#545",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.setRowVector(int, org.apache.commons.math.linear.FieldVector\u003cT\u003e)",
    "snippet": "public void setRowVector(final int row, final FieldVector\u003cT\u003e vector) {\n        checkRowIndex(row);\n        final int nCols \u003d getColumnDimension();\n        if (vector.getDimension() !\u003d nCols) {\n            throw new MatrixDimensionMismatchException(1, vector.getDimension(),\n                                                       1, nCols);\n        }\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            setEntry(row, i, vector.getEntry(i));\n        }\n\n    }",
    "begin_line": 545,
    "end_line": 556,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getColumnVector#559",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getColumnVector(int)",
    "snippet": "public FieldVector\u003cT\u003e getColumnVector(final int column) {\n        return new ArrayFieldVector\u003cT\u003e(field, getColumn(column), false);\n    }",
    "begin_line": 559,
    "end_line": 561,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.setColumnVector#564",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.setColumnVector(int, org.apache.commons.math.linear.FieldVector\u003cT\u003e)",
    "snippet": "public void setColumnVector(final int column, final FieldVector\u003cT\u003e vector) {\n        checkColumnIndex(column);\n        final int nRows \u003d getRowDimension();\n        if (vector.getDimension() !\u003d nRows) {\n            throw new MatrixDimensionMismatchException(vector.getDimension(), 1,\n                                                       nRows, 1);\n        }\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            setEntry(i, column, vector.getEntry(i));\n        }\n\n    }",
    "begin_line": 564,
    "end_line": 575,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getRow#578",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getRow(int)",
    "snippet": "public T[] getRow(final int row) {\n        checkRowIndex(row);\n        final int nCols \u003d getColumnDimension();\n        final T[] out \u003d buildArray(field, nCols);\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            out[i] \u003d getEntry(row, i);\n        }\n\n        return out;\n\n    }",
    "begin_line": 578,
    "end_line": 588,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.setRow#591",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.setRow(int, T[])",
    "snippet": "public void setRow(final int row, final T[] array) {\n        checkRowIndex(row);\n        final int nCols \u003d getColumnDimension();\n        if (array.length !\u003d nCols) {\n            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);\n        }\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            setEntry(row, i, array[i]);\n        }\n\n    }",
    "begin_line": 591,
    "end_line": 601,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getColumn#604",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getColumn(int)",
    "snippet": "public T[] getColumn(final int column) {\n        checkColumnIndex(column);\n        final int nRows \u003d getRowDimension();\n        final T[] out \u003d buildArray(field, nRows);\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            out[i] \u003d getEntry(i, column);\n        }\n\n        return out;\n\n    }",
    "begin_line": 604,
    "end_line": 614,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.setColumn#617",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.setColumn(int, T[])",
    "snippet": "public void setColumn(final int column, final T[] array) {\n        checkColumnIndex(column);\n        final int nRows \u003d getRowDimension();\n        if (array.length !\u003d nRows) {\n            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n        }\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            setEntry(i, column, array[i]);\n        }\n    }",
    "begin_line": 617,
    "end_line": 626,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getEntry#629",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getEntry(int, int)",
    "snippet": "public abstract T getEntry(int row, int column);",
    "begin_line": 629,
    "end_line": 629,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.setEntry#632",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.setEntry(int, int, T)",
    "snippet": "public abstract void setEntry(int row, int column, T value);",
    "begin_line": 632,
    "end_line": 632,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.addToEntry#635",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.addToEntry(int, int, T)",
    "snippet": "public abstract void addToEntry(int row, int column, T increment);",
    "begin_line": 635,
    "end_line": 635,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.multiplyEntry#638",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.multiplyEntry(int, int, T)",
    "snippet": "public abstract void multiplyEntry(int row, int column, T factor);",
    "begin_line": 638,
    "end_line": 638,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.transpose#641",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.transpose()",
    "snippet": "public FieldMatrix\u003cT\u003e transpose() {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        final FieldMatrix\u003cT\u003e out \u003d createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultFieldMatrixPreservingVisitor\u003cT\u003e(field.getZero()) {\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final T value) {\n                out.setEntry(column, row, value);\n            }\n        });\n\n        return out;\n    }",
    "begin_line": 641,
    "end_line": 654,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.visit#648",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.visit(int, int, T)",
    "snippet": "@Override\n            public void visit(final int row, final int column, final T value) {\n                out.setEntry(column, row, value);\n            }",
    "begin_line": 648,
    "end_line": 650,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.isSquare#657",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.isSquare()",
    "snippet": "public boolean isSquare() {\n        return getColumnDimension() \u003d\u003d getRowDimension();\n    }",
    "begin_line": 657,
    "end_line": 659,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getRowDimension#662",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getRowDimension()",
    "snippet": "public abstract int getRowDimension();",
    "begin_line": 662,
    "end_line": 662,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getColumnDimension#665",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getColumnDimension()",
    "snippet": "public abstract int getColumnDimension();",
    "begin_line": 665,
    "end_line": 665,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.getTrace#668",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getTrace()",
    "snippet": "public T getTrace() {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        if (nRows !\u003d nCols) {\n            throw new NonSquareMatrixException(nRows, nCols);\n       }\n        T trace \u003d field.getZero();\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            trace \u003d trace.add(getEntry(i, i));\n        }\n        return trace;\n    }",
    "begin_line": 668,
    "end_line": 679,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.operate#682",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.operate(T[])",
    "snippet": "public T[] operate(final T[] v) {\n\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        if (v.length !\u003d nCols) {\n            throw new DimensionMismatchException(v.length, nCols);\n        }\n\n        final T[] out \u003d buildArray(field, nRows);\n        for (int row \u003d 0; row \u003c nRows; ++row) {\n            T sum \u003d field.getZero();\n            for (int i \u003d 0; i \u003c nCols; ++i) {\n                sum \u003d sum.add(getEntry(row, i).multiply(v[i]));\n            }\n            out[row] \u003d sum;\n        }\n\n        return out;\n    }",
    "begin_line": 682,
    "end_line": 700,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.operate#703",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.operate(org.apache.commons.math.linear.FieldVector\u003cT\u003e)",
    "snippet": "public FieldVector\u003cT\u003e operate(final FieldVector\u003cT\u003e v) {\n        try {\n            return new ArrayFieldVector\u003cT\u003e(field, operate(((ArrayFieldVector\u003cT\u003e) v).getDataRef()), false);\n        } catch (ClassCastException cce) {\n            final int nRows \u003d getRowDimension();\n            final int nCols \u003d getColumnDimension();\n            if (v.getDimension() !\u003d nCols) {\n                throw new DimensionMismatchException(v.getDimension(), nCols);\n            }\n\n            final T[] out \u003d buildArray(field, nRows);\n            for (int row \u003d 0; row \u003c nRows; ++row) {\n                T sum \u003d field.getZero();\n                for (int i \u003d 0; i \u003c nCols; ++i) {\n                    sum \u003d sum.add(getEntry(row, i).multiply(v.getEntry(i)));\n                }\n                out[row] \u003d sum;\n            }\n\n            return new ArrayFieldVector\u003cT\u003e(field, out, false);\n        }\n    }",
    "begin_line": 703,
    "end_line": 724,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.preMultiply#727",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.preMultiply(T[])",
    "snippet": "public T[] preMultiply(final T[] v) {\n\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        if (v.length !\u003d nRows) {\n            throw new DimensionMismatchException(v.length, nRows);\n        }\n\n        final T[] out \u003d buildArray(field, nCols);\n        for (int col \u003d 0; col \u003c nCols; ++col) {\n            T sum \u003d field.getZero();\n            for (int i \u003d 0; i \u003c nRows; ++i) {\n                sum \u003d sum.add(getEntry(i, col).multiply(v[i]));\n            }\n            out[col] \u003d sum;\n        }\n\n        return out;\n    }",
    "begin_line": 727,
    "end_line": 745,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.preMultiply#748",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.preMultiply(org.apache.commons.math.linear.FieldVector\u003cT\u003e)",
    "snippet": "public FieldVector\u003cT\u003e preMultiply(final FieldVector\u003cT\u003e v) {\n        try {\n            return new ArrayFieldVector\u003cT\u003e(field, preMultiply(((ArrayFieldVector\u003cT\u003e) v).getDataRef()), false);\n        } catch (ClassCastException cce) {\n            final int nRows \u003d getRowDimension();\n            final int nCols \u003d getColumnDimension();\n            if (v.getDimension() !\u003d nRows) {\n                throw new DimensionMismatchException(v.getDimension(), nRows);\n            }\n\n            final T[] out \u003d buildArray(field, nCols);\n            for (int col \u003d 0; col \u003c nCols; ++col) {\n                T sum \u003d field.getZero();\n                for (int i \u003d 0; i \u003c nRows; ++i) {\n                    sum \u003d sum.add(getEntry(i, col).multiply(v.getEntry(i)));\n                }\n                out[col] \u003d sum;\n            }\n\n            return new ArrayFieldVector\u003cT\u003e(field, out, false);\n        }\n    }",
    "begin_line": 748,
    "end_line": 769,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInRowOrder#772",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e)",
    "snippet": "public T walkInRowOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int row \u003d 0; row \u003c rows; ++row) {\n            for (int column \u003d 0; column \u003c columns; ++column) {\n                final T oldValue \u003d getEntry(row, column);\n                final T newValue \u003d visitor.visit(row, column, oldValue);\n                setEntry(row, column, newValue);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 772,
    "end_line": 784,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInRowOrder#787",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e)",
    "snippet": "public T walkInRowOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int row \u003d 0; row \u003c rows; ++row) {\n            for (int column \u003d 0; column \u003c columns; ++column) {\n                visitor.visit(row, column, getEntry(row, column));\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 787,
    "end_line": 797,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInRowOrder#800",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "public T walkInRowOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn) {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int row \u003d startRow; row \u003c\u003d endRow; ++row) {\n            for (int column \u003d startColumn; column \u003c\u003d endColumn; ++column) {\n                final T oldValue \u003d getEntry(row, column);\n                final T newValue \u003d visitor.visit(row, column, oldValue);\n                setEntry(row, column, newValue);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 800,
    "end_line": 814,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInRowOrder#817",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "public T walkInRowOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn) {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int row \u003d startRow; row \u003c\u003d endRow; ++row) {\n            for (int column \u003d startColumn; column \u003c\u003d endColumn; ++column) {\n                visitor.visit(row, column, getEntry(row, column));\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 817,
    "end_line": 829,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInColumnOrder#832",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInColumnOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e)",
    "snippet": "public T walkInColumnOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int column \u003d 0; column \u003c columns; ++column) {\n            for (int row \u003d 0; row \u003c rows; ++row) {\n                final T oldValue \u003d getEntry(row, column);\n                final T newValue \u003d visitor.visit(row, column, oldValue);\n                setEntry(row, column, newValue);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 832,
    "end_line": 844,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInColumnOrder#847",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInColumnOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e)",
    "snippet": "public T walkInColumnOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int column \u003d 0; column \u003c columns; ++column) {\n            for (int row \u003d 0; row \u003c rows; ++row) {\n                visitor.visit(row, column, getEntry(row, column));\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 847,
    "end_line": 857,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInColumnOrder#860",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInColumnOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "public T walkInColumnOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor,\n                               final int startRow, final int endRow,\n                               final int startColumn, final int endColumn) {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int column \u003d startColumn; column \u003c\u003d endColumn; ++column) {\n            for (int row \u003d startRow; row \u003c\u003d endRow; ++row) {\n                final T oldValue \u003d getEntry(row, column);\n                final T newValue \u003d visitor.visit(row, column, oldValue);\n                setEntry(row, column, newValue);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 860,
    "end_line": 874,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInColumnOrder#877",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInColumnOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "public T walkInColumnOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor,\n                               final int startRow, final int endRow,\n                               final int startColumn, final int endColumn) {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int column \u003d startColumn; column \u003c\u003d endColumn; ++column) {\n            for (int row \u003d startRow; row \u003c\u003d endRow; ++row) {\n                visitor.visit(row, column, getEntry(row, column));\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 877,
    "end_line": 889,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInOptimizedOrder#892",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e)",
    "snippet": "public T walkInOptimizedOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor) {\n        return walkInRowOrder(visitor);\n    }",
    "begin_line": 892,
    "end_line": 894,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInOptimizedOrder#897",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e)",
    "snippet": "public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor) {\n        return walkInRowOrder(visitor);\n    }",
    "begin_line": 897,
    "end_line": 899,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInOptimizedOrder#902",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "public T walkInOptimizedOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn) {\n        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n    }",
    "begin_line": 902,
    "end_line": 906,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.walkInOptimizedOrder#909",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn) {\n        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n    }",
    "begin_line": 909,
    "end_line": 913,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.toString#920",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.toString()",
    "snippet": "@Override\n    public String toString() {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        final StringBuffer res \u003d new StringBuffer();\n        String fullClassName \u003d getClass().getName();\n        String shortClassName \u003d fullClassName.substring(fullClassName.lastIndexOf(\u0027.\u0027) + 1);\n        res.append(shortClassName).append(\"{\");\n\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            if (i \u003e 0) {\n                res.append(\",\");\n            }\n            res.append(\"{\");\n            for (int j \u003d 0; j \u003c nCols; ++j) {\n                if (j \u003e 0) {\n                    res.append(\",\");\n                }\n                res.append(getEntry(i, j));\n            }\n            res.append(\"}\");\n        }\n\n        res.append(\"}\");\n        return res.toString();\n    }",
    "begin_line": 920,
    "end_line": 944,
    "comment": "/** \n * Get a string representation for this matrix.\n * @return a string representation for this matrix\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.equals#955",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.equals(java.lang.Object)",
    "snippet": "@Override\n    public boolean equals(final Object object) {\n        if (object \u003d\u003d this ) {\n            return true;\n        }\n        if (object instanceof FieldMatrix\u003c?\u003e \u003d\u003d false) {\n            return false;\n        }\n        FieldMatrix\u003c?\u003e m \u003d (FieldMatrix\u003c?\u003e) object;\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        if (m.getColumnDimension() !\u003d nCols || m.getRowDimension() !\u003d nRows) {\n            return false;\n        }\n        for (int row \u003d 0; row \u003c nRows; ++row) {\n            for (int col \u003d 0; col \u003c nCols; ++col) {\n                if (!getEntry(row, col).equals(m.getEntry(row, col))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
    "begin_line": 955,
    "end_line": 976,
    "comment": "/** \n * Returns true iff \u003ccode\u003eobject\u003c/code\u003e is a \u003ccode\u003eFieldMatrix\u003c/code\u003e instance with the same dimensions as this and all corresponding matrix entries are equal.\n * @param object the object to test equality against.\n * @return true if object equals this\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.hashCode#984",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.hashCode()",
    "snippet": "@Override\n    public int hashCode() {\n        int ret \u003d 322562;\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        ret \u003d ret * 31 + nRows;\n        ret \u003d ret * 31 + nCols;\n        for (int row \u003d 0; row \u003c nRows; ++row) {\n            for (int col \u003d 0; col \u003c nCols; ++col) {\n               ret \u003d ret * 31 + (11 * (row+1) + 17 * (col+1)) * getEntry(row, col).hashCode();\n           }\n        }\n        return ret;\n    }",
    "begin_line": 984,
    "end_line": 996,
    "comment": "/** \n * Computes a hashcode for the matrix.\n * @return hashcode for matrix\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.checkRowIndex#1004",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.checkRowIndex(int)",
    "snippet": "protected void checkRowIndex(final int row) {\n        if (row \u003c 0 || row \u003e\u003d getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, getRowDimension() - 1);\n        }\n    }",
    "begin_line": 1004,
    "end_line": 1009,
    "comment": "/** \n * Check if a row index is valid.\n * @param row Row index to check.\n * @throws OutOfRangeException if {@code index} is not valid.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.checkColumnIndex#1017",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.checkColumnIndex(int)",
    "snippet": "protected void checkColumnIndex(final int column) {\n        if (column \u003c 0 || column \u003e\u003d getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                          column, 0, getColumnDimension() - 1);\n        }\n    }",
    "begin_line": 1017,
    "end_line": 1022,
    "comment": "/** \n * Check if a column index is valid.\n * @param column Column index to check.\n * @throws OutOfRangeException if {@code index} is not valid.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.checkSubMatrixIndex#1036",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.checkSubMatrixIndex(int, int, int, int)",
    "snippet": "protected void checkSubMatrixIndex(final int startRow, final int endRow,\n                                       final int startColumn, final int endColumn) {\n        checkRowIndex(startRow);\n        checkRowIndex(endRow);\n        if (endRow \u003c startRow) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n                                                endRow, startRow, true);\n        }\n\n        checkColumnIndex(startColumn);\n        checkColumnIndex(endColumn);\n        if (endColumn \u003c startColumn) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n                                                endColumn, startColumn, true);\n        }\n    }",
    "begin_line": 1036,
    "end_line": 1051,
    "comment": "/** \n * Check if submatrix ranges indices are valid. Rows and columns are indicated counting from 0 to n-1.\n * @param startRow Initial row index.\n * @param endRow Final row index.\n * @param startColumn Initial column index.\n * @param endColumn Final column index.\n * @throws OutOfRangeException if the indices are not valid.\n * @throws NumberIsTooSmallException if {@code endRow \u003c startRow} or{@code endColumn \u003c startColumn}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.checkSubMatrixIndex#1063",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.checkSubMatrixIndex(int[], int[])",
    "snippet": "protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) {\n        if (selectedRows \u003d\u003d null ||\n            selectedColumns \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        if (selectedRows.length \u003d\u003d 0 ||\n            selectedColumns.length \u003d\u003d 0) {\n            throw new NoDataException();\n        }\n\n        for (final int row : selectedRows) {\n            checkRowIndex(row);\n        }\n        for (final int column : selectedColumns) {\n            checkColumnIndex(column);\n        }\n    }",
    "begin_line": 1063,
    "end_line": 1079,
    "comment": "/** \n * Check if submatrix ranges indices are valid. Rows and columns are indicated counting from 0 to n-1.\n * @param selectedRows Array of row indices.\n * @param selectedColumns Array of column indices.\n * @throws NullArgumentException if the arrays are {@code null}.\n * @throws NoDataException if the arrays have zero length.\n * @throws OutOfRangeException if row or column selections are not valid.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.checkAdditionCompatible#1088",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.checkAdditionCompatible(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "protected void checkAdditionCompatible(final FieldMatrix\u003cT\u003e m) {\n        if ((getRowDimension() !\u003d m.getRowDimension()) ||\n            (getColumnDimension() !\u003d m.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(),\n                                                       getRowDimension(), getColumnDimension());\n        }\n    }",
    "begin_line": 1088,
    "end_line": 1094,
    "comment": "/** \n * Check if a matrix is addition compatible with the instance.\n * @param m Matrix to check.\n * @throws MatrixDimensionMismatchException if the matrix is notaddition-compatible with instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.checkSubtractionCompatible#1103",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.checkSubtractionCompatible(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "protected void checkSubtractionCompatible(final FieldMatrix\u003cT\u003e m) {\n        if ((getRowDimension() !\u003d m.getRowDimension()) ||\n            (getColumnDimension() !\u003d m.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(),\n                                                       getRowDimension(), getColumnDimension());\n        }\n    }",
    "begin_line": 1103,
    "end_line": 1109,
    "comment": "/** \n * Check if a matrix is subtraction compatible with the instance.\n * @param m Matrix to check.\n * @throws MatrixDimensionMismatchException if the matrix is notsubtraction-compatible with instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractFieldMatrix.checkMultiplicationCompatible#1118",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.checkMultiplicationCompatible(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "protected void checkMultiplicationCompatible(final FieldMatrix\u003cT\u003e m) {\n        if (getColumnDimension() !\u003d m.getRowDimension()) {\n            throw new DimensionMismatchException(m.getRowDimension(), getColumnDimension());\n        }\n    }",
    "begin_line": 1118,
    "end_line": 1122,
    "comment": "/** \n * Check if a matrix is multiplication compatible with the instance.\n * @param m Matrix to check.\n * @throws DimensionMismatchException if the matrix is notmultiplication-compatible with instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix#41",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix()",
    "snippet": "protected AbstractRealMatrix() {}",
    "begin_line": 41,
    "end_line": 41,
    "comment": "/** \n * Creates a matrix with no data\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix#50",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int, int)",
    "snippet": "protected AbstractRealMatrix(final int rowDimension, final int columnDimension) {\n        if (rowDimension \u003c 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension \u003c 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }",
    "begin_line": 50,
    "end_line": 57,
    "comment": "/** \n * Create a new RealMatrix with the supplied row and column dimensions.\n * @param rowDimension  the number of rows in the new matrix\n * @param columnDimension  the number of columns in the new matrix\n * @throws NotStrictlyPositiveException if row or column dimension is not positive\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.createMatrix#60",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.createMatrix(int, int)",
    "snippet": "public abstract RealMatrix createMatrix(final int rowDimension, final int columnDimension);",
    "begin_line": 60,
    "end_line": 60,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.copy#63",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.copy()",
    "snippet": "public abstract RealMatrix copy();",
    "begin_line": 63,
    "end_line": 63,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.add#66",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.add(org.apache.commons.math.linear.RealMatrix)",
    "snippet": "public RealMatrix add(RealMatrix m) {\n        // Safety check.\n        MatrixUtils.checkAdditionCompatible(this, m);\n\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final RealMatrix out \u003d createMatrix(rowCount, columnCount);\n        for (int row \u003d 0; row \u003c rowCount; ++row) {\n            for (int col \u003d 0; col \u003c columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) + m.getEntry(row, col));\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 66,
    "end_line": 80,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.subtract#83",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.subtract(org.apache.commons.math.linear.RealMatrix)",
    "snippet": "public RealMatrix subtract(final RealMatrix m) {\n        // Safety check.\n        MatrixUtils.checkSubtractionCompatible(this, m);\n\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final RealMatrix out \u003d createMatrix(rowCount, columnCount);\n        for (int row \u003d 0; row \u003c rowCount; ++row) {\n            for (int col \u003d 0; col \u003c columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 83,
    "end_line": 97,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.scalarAdd#100",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.scalarAdd(double)",
    "snippet": "public RealMatrix scalarAdd(final double d) {\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final RealMatrix out \u003d createMatrix(rowCount, columnCount);\n        for (int row \u003d 0; row \u003c rowCount; ++row) {\n            for (int col \u003d 0; col \u003c columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) + d);\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 100,
    "end_line": 111,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.scalarMultiply#114",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.scalarMultiply(double)",
    "snippet": "public RealMatrix scalarMultiply(final double d) {\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final RealMatrix out \u003d createMatrix(rowCount, columnCount);\n        for (int row \u003d 0; row \u003c rowCount; ++row) {\n            for (int col \u003d 0; col \u003c columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) * d);\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 114,
    "end_line": 125,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.multiply#128",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.multiply(org.apache.commons.math.linear.RealMatrix)",
    "snippet": "public RealMatrix multiply(final RealMatrix m) {\n        // Safety check.\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d m.getColumnDimension();\n        final int nSum  \u003d getColumnDimension();\n        final RealMatrix out \u003d createMatrix(nRows, nCols);\n        for (int row \u003d 0; row \u003c nRows; ++row) {\n            for (int col \u003d 0; col \u003c nCols; ++col) {\n                double sum \u003d 0;\n                for (int i \u003d 0; i \u003c nSum; ++i) {\n                    sum +\u003d getEntry(row, i) * m.getEntry(i, col);\n                }\n                out.setEntry(row, col, sum);\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 128,
    "end_line": 147,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.preMultiply#150",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.preMultiply(org.apache.commons.math.linear.RealMatrix)",
    "snippet": "public RealMatrix preMultiply(final RealMatrix m) {\n        return m.multiply(this);\n    }",
    "begin_line": 150,
    "end_line": 152,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.power#155",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.power(int)",
    "snippet": "public RealMatrix power(final int p) {\n        if (p \u003c 0) {\n            throw new IllegalArgumentException(\"p must be \u003e\u003d 0\");\n        }\n\n        if (!isSquare()) {\n            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n        }\n\n        if (p \u003d\u003d 0) {\n            return MatrixUtils.createRealIdentityMatrix(this.getRowDimension());\n        }\n\n        if (p \u003d\u003d 1) {\n            return this.copy();\n        }\n\n        final int power \u003d p - 1;\n\n        /*\n         * Only log_2(p) operations is used by doing as follows:\n         * 5^214 \u003d 5^128 * 5^64 * 5^16 * 5^4 * 5^2\n         *\n         * In general, the same approach is used for A^p.\n         */\n\n        final char[] binaryRepresentation \u003d Integer.toBinaryString(power).toCharArray();\n        final ArrayList\u003cInteger\u003e nonZeroPositions \u003d new ArrayList\u003cInteger\u003e();\n        int maxI \u003d -1;\n\n        for (int i \u003d 0; i \u003c binaryRepresentation.length; ++i) {\n            if (binaryRepresentation[i] \u003d\u003d \u00271\u0027) {\n                final int pos \u003d binaryRepresentation.length - i - 1;\n                nonZeroPositions.add(pos);\n\n                // The positions are taken in turn, so maxI is only changed once\n                if (maxI \u003d\u003d -1) {\n                    maxI \u003d pos;\n                }\n            }\n        }\n\n        RealMatrix[] results \u003d new RealMatrix[maxI + 1];\n        results[0] \u003d this.copy();\n\n        for (int i \u003d 1; i \u003c\u003d maxI; ++i) {\n            results[i] \u003d results[i-1].multiply(results[i-1]);\n        }\n\n        RealMatrix result \u003d this.copy();\n\n        for (Integer i : nonZeroPositions) {\n            result \u003d result.multiply(results[i]);\n        }\n\n        return result;\n    }",
    "begin_line": 155,
    "end_line": 211,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getData#214",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getData()",
    "snippet": "public double[][] getData() {\n        final double[][] data \u003d new double[getRowDimension()][getColumnDimension()];\n\n        for (int i \u003d 0; i \u003c data.length; ++i) {\n            final double[] dataI \u003d data[i];\n            for (int j \u003d 0; j \u003c dataI.length; ++j) {\n                dataI[j] \u003d getEntry(i, j);\n            }\n        }\n\n        return data;\n    }",
    "begin_line": 214,
    "end_line": 225,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getNorm#228",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getNorm()",
    "snippet": "public double getNorm() {\n        return walkInColumnOrder(new RealMatrixPreservingVisitor() {\n\n            /** Last row index. */\n            private double endRow;\n\n            /** Sum of absolute values on one column. */\n            private double columnSum;\n\n            /** Maximal sum across all columns. */\n            private double maxColSum;\n\n            /** {@inheritDoc} */\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                this.endRow \u003d endRow;\n                columnSum   \u003d 0;\n                maxColSum   \u003d 0;\n            }\n\n            /** {@inheritDoc} */\n            public void visit(final int row, final int column, final double value) {\n                columnSum +\u003d FastMath.abs(value);\n                if (row \u003d\u003d endRow) {\n                    maxColSum \u003d FastMath.max(maxColSum, columnSum);\n                    columnSum \u003d 0;\n                }\n            }\n\n            /** {@inheritDoc} */\n            public double end() {\n                return maxColSum;\n            }\n        });\n    }",
    "begin_line": 228,
    "end_line": 263,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.start#241",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.start(int, int, int, int, int, int)",
    "snippet": "public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                this.endRow \u003d endRow;\n                columnSum   \u003d 0;\n                maxColSum   \u003d 0;\n            }",
    "begin_line": 241,
    "end_line": 247,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.visit#250",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.visit(int, int, double)",
    "snippet": "public void visit(final int row, final int column, final double value) {\n                columnSum +\u003d FastMath.abs(value);\n                if (row \u003d\u003d endRow) {\n                    maxColSum \u003d FastMath.max(maxColSum, columnSum);\n                    columnSum \u003d 0;\n                }\n            }",
    "begin_line": 250,
    "end_line": 256,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.end#259",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.end()",
    "snippet": "public double end() {\n                return maxColSum;\n            }",
    "begin_line": 259,
    "end_line": 261,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getFrobeniusNorm#266",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getFrobeniusNorm()",
    "snippet": "public double getFrobeniusNorm() {\n        return walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n\n            /** Sum of squared entries. */\n            private double sum;\n\n            /** {@inheritDoc} */\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                sum \u003d 0;\n            }\n\n            /** {@inheritDoc} */\n            public void visit(final int row, final int column, final double value) {\n                sum +\u003d value * value;\n            }\n\n            /** {@inheritDoc} */\n            public double end() {\n                return FastMath.sqrt(sum);\n            }\n        });\n    }",
    "begin_line": 266,
    "end_line": 289,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.start#273",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.start(int, int, int, int, int, int)",
    "snippet": "public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                sum \u003d 0;\n            }",
    "begin_line": 273,
    "end_line": 277,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.visit#280",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.visit(int, int, double)",
    "snippet": "public void visit(final int row, final int column, final double value) {\n                sum +\u003d value * value;\n            }",
    "begin_line": 280,
    "end_line": 282,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.end#285",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.end()",
    "snippet": "public double end() {\n                return FastMath.sqrt(sum);\n            }",
    "begin_line": 285,
    "end_line": 287,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getSubMatrix#292",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getSubMatrix(int, int, int, int)",
    "snippet": "public RealMatrix getSubMatrix(final int startRow, final int endRow,\n                                   final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        final RealMatrix subMatrix \u003d\n            createMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n        for (int i \u003d startRow; i \u003c\u003d endRow; ++i) {\n            for (int j \u003d startColumn; j \u003c\u003d endColumn; ++j) {\n                subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));\n            }\n        }\n\n        return subMatrix;\n    }",
    "begin_line": 292,
    "end_line": 305,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getSubMatrix#308",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getSubMatrix(int[], int[])",
    "snippet": "public RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n\n        // copy entries\n        final RealMatrix subMatrix \u003d\n            createMatrix(selectedRows.length, selectedColumns.length);\n        subMatrix.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public double visit(final int row, final int column, final double value) {\n                return getEntry(selectedRows[row], selectedColumns[column]);\n            }\n\n        });\n\n        return subMatrix;\n    }",
    "begin_line": 308,
    "end_line": 326,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.visit#319",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.visit(int, int, double)",
    "snippet": "@Override\n            public double visit(final int row, final int column, final double value) {\n                return getEntry(selectedRows[row], selectedColumns[column]);\n            }",
    "begin_line": 319,
    "end_line": 321,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.copySubMatrix#329",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.copySubMatrix(int, int, int, int, double[][])",
    "snippet": "public void copySubMatrix(final int startRow, final int endRow,\n                              final int startColumn, final int endColumn,\n                              final double[][] destination) {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        final int rowsCount    \u003d endRow + 1 - startRow;\n        final int columnsCount \u003d endColumn + 1 - startColumn;\n        if ((destination.length \u003c rowsCount) || (destination[0].length \u003c columnsCount)) {\n            throw new MatrixDimensionMismatchException(destination.length, destination[0].length,\n                                                       rowsCount, columnsCount);\n        }\n\n        // copy entries\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** Initial row index. */\n            private int startRow;\n\n            /** Initial column index. */\n            private int startColumn;\n\n            /** {@inheritDoc} */\n            @Override\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                this.startRow    \u003d startRow;\n                this.startColumn \u003d startColumn;\n            }\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                destination[row - startRow][column - startColumn] \u003d value;\n            }\n\n        }, startRow, endRow, startColumn, endColumn);\n    }",
    "begin_line": 329,
    "end_line": 366,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.start#352",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.start(int, int, int, int, int, int)",
    "snippet": "@Override\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                this.startRow    \u003d startRow;\n                this.startColumn \u003d startColumn;\n            }",
    "begin_line": 352,
    "end_line": 357,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.visit#361",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.visit(int, int, double)",
    "snippet": "@Override\n            public void visit(final int row, final int column, final double value) {\n                destination[row - startRow][column - startColumn] \u003d value;\n            }",
    "begin_line": 361,
    "end_line": 363,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.copySubMatrix#369",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.copySubMatrix(int[], int[], double[][])",
    "snippet": "public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n        if ((destination.length \u003c selectedRows.length) ||\n            (destination[0].length \u003c selectedColumns.length)) {\n            throw new MatrixDimensionMismatchException(destination.length, destination[0].length,\n                                                       selectedRows.length, selectedColumns.length);\n        }\n\n        // copy entries\n        for (int i \u003d 0; i \u003c selectedRows.length; i++) {\n            final double[] destinationI \u003d destination[i];\n            for (int j \u003d 0; j \u003c selectedColumns.length; j++) {\n                destinationI[j] \u003d getEntry(selectedRows[i], selectedColumns[j]);\n            }\n        }\n    }",
    "begin_line": 369,
    "end_line": 385,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.setSubMatrix#388",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setSubMatrix(double[][], int, int)",
    "snippet": "public void setSubMatrix(final double[][] subMatrix, final int row, final int column) {\n        final int nRows \u003d subMatrix.length;\n        if (nRows \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n\n        final int nCols \u003d subMatrix[0].length;\n        if (nCols \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n\n        for (int r \u003d 1; r \u003c nRows; ++r) {\n            if (subMatrix[r].length !\u003d nCols) {\n                throw new DimensionMismatchException(nCols, subMatrix[r].length);\n            }\n        }\n\n        MatrixUtils.checkRowIndex(this, row);\n        MatrixUtils.checkColumnIndex(this, column);\n        MatrixUtils.checkRowIndex(this, nRows + row - 1);\n        MatrixUtils.checkColumnIndex(this, nCols + column - 1);\n\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            for (int j \u003d 0; j \u003c nCols; ++j) {\n                setEntry(row + i, column + j, subMatrix[i][j]);\n            }\n        }\n    }",
    "begin_line": 388,
    "end_line": 415,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getRowMatrix#418",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getRowMatrix(int)",
    "snippet": "public RealMatrix getRowMatrix(final int row) {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols \u003d getColumnDimension();\n        final RealMatrix out \u003d createMatrix(1, nCols);\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            out.setEntry(0, i, getEntry(row, i));\n        }\n\n        return out;\n    }",
    "begin_line": 418,
    "end_line": 427,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.setRowMatrix#430",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setRowMatrix(int, org.apache.commons.math.linear.RealMatrix)",
    "snippet": "public void setRowMatrix(final int row, final RealMatrix matrix) {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols \u003d getColumnDimension();\n        if ((matrix.getRowDimension() !\u003d 1) ||\n            (matrix.getColumnDimension() !\u003d nCols)) {\n            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n                                                       matrix.getColumnDimension(),\n                                                       1, nCols);\n        }\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            setEntry(row, i, matrix.getEntry(0, i));\n        }\n    }",
    "begin_line": 430,
    "end_line": 442,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getColumnMatrix#445",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getColumnMatrix(int)",
    "snippet": "public RealMatrix getColumnMatrix(final int column) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows \u003d getRowDimension();\n        final RealMatrix out \u003d createMatrix(nRows, 1);\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            out.setEntry(i, 0, getEntry(i, column));\n        }\n\n        return out;\n    }",
    "begin_line": 445,
    "end_line": 454,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.setColumnMatrix#457",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setColumnMatrix(int, org.apache.commons.math.linear.RealMatrix)",
    "snippet": "public void setColumnMatrix(final int column, final RealMatrix matrix) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows \u003d getRowDimension();\n        if ((matrix.getRowDimension() !\u003d nRows) ||\n            (matrix.getColumnDimension() !\u003d 1)) {\n            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n                                                       matrix.getColumnDimension(),\n                                                       nRows, 1);\n        }\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            setEntry(i, column, matrix.getEntry(i, 0));\n        }\n    }",
    "begin_line": 457,
    "end_line": 469,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getRowVector#472",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getRowVector(int)",
    "snippet": "public RealVector getRowVector(final int row) {\n        return new ArrayRealVector(getRow(row), false);\n    }",
    "begin_line": 472,
    "end_line": 474,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.setRowVector#477",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setRowVector(int, org.apache.commons.math.linear.RealVector)",
    "snippet": "public void setRowVector(final int row, final RealVector vector) {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols \u003d getColumnDimension();\n        if (vector.getDimension() !\u003d nCols) {\n            throw new MatrixDimensionMismatchException(1, vector.getDimension(),\n                                                       1, nCols);\n        }\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            setEntry(row, i, vector.getEntry(i));\n        }\n    }",
    "begin_line": 477,
    "end_line": 487,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getColumnVector#490",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getColumnVector(int)",
    "snippet": "public RealVector getColumnVector(final int column) {\n        return new ArrayRealVector(getColumn(column), false);\n    }",
    "begin_line": 490,
    "end_line": 492,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.setColumnVector#495",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setColumnVector(int, org.apache.commons.math.linear.RealVector)",
    "snippet": "public void setColumnVector(final int column, final RealVector vector) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows \u003d getRowDimension();\n        if (vector.getDimension() !\u003d nRows) {\n            throw new MatrixDimensionMismatchException(vector.getDimension(), 1,\n                                                       nRows, 1);\n        }\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            setEntry(i, column, vector.getEntry(i));\n        }\n    }",
    "begin_line": 495,
    "end_line": 505,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getRow#508",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getRow(int)",
    "snippet": "public double[] getRow(final int row) {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols \u003d getColumnDimension();\n        final double[] out \u003d new double[nCols];\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            out[i] \u003d getEntry(row, i);\n        }\n\n        return out;\n    }",
    "begin_line": 508,
    "end_line": 517,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.setRow#520",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setRow(int, double[])",
    "snippet": "public void setRow(final int row, final double[] array) {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols \u003d getColumnDimension();\n        if (array.length !\u003d nCols) {\n            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);\n        }\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            setEntry(row, i, array[i]);\n        }\n    }",
    "begin_line": 520,
    "end_line": 529,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getColumn#532",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getColumn(int)",
    "snippet": "public double[] getColumn(final int column) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows \u003d getRowDimension();\n        final double[] out \u003d new double[nRows];\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            out[i] \u003d getEntry(i, column);\n        }\n\n        return out;\n    }",
    "begin_line": 532,
    "end_line": 541,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.setColumn#544",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setColumn(int, double[])",
    "snippet": "public void setColumn(final int column, final double[] array) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows \u003d getRowDimension();\n        if (array.length !\u003d nRows) {\n            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n        }\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            setEntry(i, column, array[i]);\n        }\n    }",
    "begin_line": 544,
    "end_line": 553,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getEntry#556",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getEntry(int, int)",
    "snippet": "public abstract double getEntry(int row, int column);",
    "begin_line": 556,
    "end_line": 556,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.setEntry#559",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setEntry(int, int, double)",
    "snippet": "public abstract void setEntry(int row, int column, double value);",
    "begin_line": 559,
    "end_line": 559,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.addToEntry#562",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.addToEntry(int, int, double)",
    "snippet": "public abstract void addToEntry(int row, int column, double increment);",
    "begin_line": 562,
    "end_line": 562,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.multiplyEntry#565",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.multiplyEntry(int, int, double)",
    "snippet": "public abstract void multiplyEntry(int row, int column, double factor);",
    "begin_line": 565,
    "end_line": 565,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.transpose#568",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.transpose()",
    "snippet": "public RealMatrix transpose() {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        final RealMatrix out \u003d createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n    }",
    "begin_line": 568,
    "end_line": 583,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.visit#576",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.visit(int, int, double)",
    "snippet": "@Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }",
    "begin_line": 576,
    "end_line": 578,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.isSquare#586",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.isSquare()",
    "snippet": "public boolean isSquare() {\n        return getColumnDimension() \u003d\u003d getRowDimension();\n    }",
    "begin_line": 586,
    "end_line": 588,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getRowDimension#591",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getRowDimension()",
    "snippet": "public abstract int getRowDimension();",
    "begin_line": 591,
    "end_line": 591,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getColumnDimension#594",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getColumnDimension()",
    "snippet": "public abstract int getColumnDimension();",
    "begin_line": 594,
    "end_line": 594,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.getTrace#597",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getTrace()",
    "snippet": "public double getTrace() {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        if (nRows !\u003d nCols) {\n            throw new NonSquareMatrixException(nRows, nCols);\n       }\n        double trace \u003d 0;\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            trace +\u003d getEntry(i, i);\n        }\n        return trace;\n    }",
    "begin_line": 597,
    "end_line": 608,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.operate#611",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.operate(double[])",
    "snippet": "public double[] operate(final double[] v) {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        if (v.length !\u003d nCols) {\n            throw new DimensionMismatchException(v.length, nCols);\n        }\n\n        final double[] out \u003d new double[nRows];\n        for (int row \u003d 0; row \u003c nRows; ++row) {\n            double sum \u003d 0;\n            for (int i \u003d 0; i \u003c nCols; ++i) {\n                sum +\u003d getEntry(row, i) * v[i];\n            }\n            out[row] \u003d sum;\n        }\n\n        return out;\n    }",
    "begin_line": 611,
    "end_line": 628,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.operate#631",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.operate(org.apache.commons.math.linear.RealVector)",
    "snippet": "public RealVector operate(final RealVector v) {\n        try {\n            return new ArrayRealVector(operate(((ArrayRealVector) v).getDataRef()), false);\n        } catch (ClassCastException cce) {\n            final int nRows \u003d getRowDimension();\n            final int nCols \u003d getColumnDimension();\n            if (v.getDimension() !\u003d nCols) {\n                throw new DimensionMismatchException(v.getDimension(), nCols);\n            }\n\n            final double[] out \u003d new double[nRows];\n            for (int row \u003d 0; row \u003c nRows; ++row) {\n                double sum \u003d 0;\n                for (int i \u003d 0; i \u003c nCols; ++i) {\n                    sum +\u003d getEntry(row, i) * v.getEntry(i);\n                }\n                out[row] \u003d sum;\n            }\n\n            return new ArrayRealVector(out, false);\n        }\n    }",
    "begin_line": 631,
    "end_line": 652,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.preMultiply#655",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.preMultiply(double[])",
    "snippet": "public double[] preMultiply(final double[] v) {\n\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        if (v.length !\u003d nRows) {\n            throw new DimensionMismatchException(v.length, nRows);\n        }\n\n        final double[] out \u003d new double[nCols];\n        for (int col \u003d 0; col \u003c nCols; ++col) {\n            double sum \u003d 0;\n            for (int i \u003d 0; i \u003c nRows; ++i) {\n                sum +\u003d getEntry(i, col) * v[i];\n            }\n            out[col] \u003d sum;\n        }\n\n        return out;\n    }",
    "begin_line": 655,
    "end_line": 673,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.preMultiply#676",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.preMultiply(org.apache.commons.math.linear.RealVector)",
    "snippet": "public RealVector preMultiply(final RealVector v) {\n        try {\n            return new ArrayRealVector(preMultiply(((ArrayRealVector) v).getDataRef()), false);\n        } catch (ClassCastException cce) {\n\n            final int nRows \u003d getRowDimension();\n            final int nCols \u003d getColumnDimension();\n            if (v.getDimension() !\u003d nRows) {\n                throw new DimensionMismatchException(v.getDimension(), nRows);\n            }\n\n            final double[] out \u003d new double[nCols];\n            for (int col \u003d 0; col \u003c nCols; ++col) {\n                double sum \u003d 0;\n                for (int i \u003d 0; i \u003c nRows; ++i) {\n                    sum +\u003d getEntry(i, col) * v.getEntry(i);\n                }\n                out[col] \u003d sum;\n            }\n\n            return new ArrayRealVector(out, false);\n        }\n    }",
    "begin_line": 676,
    "end_line": 698,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInRowOrder#701",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor)",
    "snippet": "public double walkInRowOrder(final RealMatrixChangingVisitor visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int row \u003d 0; row \u003c rows; ++row) {\n            for (int column \u003d 0; column \u003c columns; ++column) {\n                final double oldValue \u003d getEntry(row, column);\n                final double newValue \u003d visitor.visit(row, column, oldValue);\n                setEntry(row, column, newValue);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 701,
    "end_line": 713,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInRowOrder#716",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
    "snippet": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int row \u003d 0; row \u003c rows; ++row) {\n            for (int column \u003d 0; column \u003c columns; ++column) {\n                visitor.visit(row, column, getEntry(row, column));\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 716,
    "end_line": 726,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInRowOrder#729",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor, int, int, int, int)",
    "snippet": "public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int row \u003d startRow; row \u003c\u003d endRow; ++row) {\n            for (int column \u003d startColumn; column \u003c\u003d endColumn; ++column) {\n                final double oldValue \u003d getEntry(row, column);\n                final double newValue \u003d visitor.visit(row, column, oldValue);\n                setEntry(row, column, newValue);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 729,
    "end_line": 743,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInRowOrder#746",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor, int, int, int, int)",
    "snippet": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int row \u003d startRow; row \u003c\u003d endRow; ++row) {\n            for (int column \u003d startColumn; column \u003c\u003d endColumn; ++column) {\n                visitor.visit(row, column, getEntry(row, column));\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 746,
    "end_line": 758,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInColumnOrder#761",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInColumnOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor)",
    "snippet": "public double walkInColumnOrder(final RealMatrixChangingVisitor visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int column \u003d 0; column \u003c columns; ++column) {\n            for (int row \u003d 0; row \u003c rows; ++row) {\n                final double oldValue \u003d getEntry(row, column);\n                final double newValue \u003d visitor.visit(row, column, oldValue);\n                setEntry(row, column, newValue);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 761,
    "end_line": 773,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInColumnOrder#776",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInColumnOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
    "snippet": "public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int column \u003d 0; column \u003c columns; ++column) {\n            for (int row \u003d 0; row \u003c rows; ++row) {\n                visitor.visit(row, column, getEntry(row, column));\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 776,
    "end_line": 786,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInColumnOrder#789",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInColumnOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor, int, int, int, int)",
    "snippet": "public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n                                    final int startRow, final int endRow,\n                                    final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int column \u003d startColumn; column \u003c\u003d endColumn; ++column) {\n            for (int row \u003d startRow; row \u003c\u003d endRow; ++row) {\n                final double oldValue \u003d getEntry(row, column);\n                final double newValue \u003d visitor.visit(row, column, oldValue);\n                setEntry(row, column, newValue);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 789,
    "end_line": 803,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInColumnOrder#806",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInColumnOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor, int, int, int, int)",
    "snippet": "public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n                                    final int startRow, final int endRow,\n                                    final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int column \u003d startColumn; column \u003c\u003d endColumn; ++column) {\n            for (int row \u003d startRow; row \u003c\u003d endRow; ++row) {\n                visitor.visit(row, column, getEntry(row, column));\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 806,
    "end_line": 818,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder#821",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor)",
    "snippet": "public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor) {\n        return walkInRowOrder(visitor);\n    }",
    "begin_line": 821,
    "end_line": 823,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder#826",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
    "snippet": "public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\n        return walkInRowOrder(visitor);\n    }",
    "begin_line": 826,
    "end_line": 828,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder#831",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor, int, int, int, int)",
    "snippet": "public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn, final int endColumn) {\n        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n    }",
    "begin_line": 831,
    "end_line": 835,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder#838",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor, int, int, int, int)",
    "snippet": "public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn, final int endColumn) {\n        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n    }",
    "begin_line": 838,
    "end_line": 842,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.toString#849",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.toString()",
    "snippet": "@Override\n    public String toString() {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        final StringBuffer res \u003d new StringBuffer();\n        String fullClassName \u003d getClass().getName();\n        String shortClassName \u003d fullClassName.substring(fullClassName.lastIndexOf(\u0027.\u0027) + 1);\n        res.append(shortClassName).append(\"{\");\n\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            if (i \u003e 0) {\n                res.append(\",\");\n            }\n            res.append(\"{\");\n            for (int j \u003d 0; j \u003c nCols; ++j) {\n                if (j \u003e 0) {\n                    res.append(\",\");\n                }\n                res.append(getEntry(i, j));\n            }\n            res.append(\"}\");\n        }\n\n        res.append(\"}\");\n        return res.toString();\n    }",
    "begin_line": 849,
    "end_line": 873,
    "comment": "/** \n * Get a string representation for this matrix.\n * @return a string representation for this matrix\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.equals#884",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.equals(java.lang.Object)",
    "snippet": "@Override\n    public boolean equals(final Object object) {\n        if (object \u003d\u003d this ) {\n            return true;\n        }\n        if (object instanceof RealMatrix \u003d\u003d false) {\n            return false;\n        }\n        RealMatrix m \u003d (RealMatrix) object;\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        if (m.getColumnDimension() !\u003d nCols || m.getRowDimension() !\u003d nRows) {\n            return false;\n        }\n        for (int row \u003d 0; row \u003c nRows; ++row) {\n            for (int col \u003d 0; col \u003c nCols; ++col) {\n                if (getEntry(row, col) !\u003d m.getEntry(row, col)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
    "begin_line": 884,
    "end_line": 905,
    "comment": "/** \n * Returns true iff \u003ccode\u003eobject\u003c/code\u003e is a \u003ccode\u003eRealMatrix\u003c/code\u003e instance with the same dimensions as this and all corresponding matrix entries are equal.\n * @param object the object to test equality against.\n * @return true if object equals this\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRealMatrix.hashCode#913",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/AbstractRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.hashCode()",
    "snippet": "@Override\n    public int hashCode() {\n        int ret \u003d 7;\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        ret \u003d ret * 31 + nRows;\n        ret \u003d ret * 31 + nCols;\n        for (int row \u003d 0; row \u003c nRows; ++row) {\n            for (int col \u003d 0; col \u003c nCols; ++col) {\n               ret \u003d ret * 31 + (11 * (row+1) + 17 * (col+1)) *\n                   MathUtils.hash(getEntry(row, col));\n           }\n        }\n        return ret;\n    }",
    "begin_line": 913,
    "end_line": 926,
    "comment": "/** \n * Computes a hashcode for the matrix.\n * @return hashcode for matrix\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#65",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix()",
    "snippet": "public Array2DRowRealMatrix() {}",
    "begin_line": 65,
    "end_line": 65,
    "comment": "/** \n * Creates a matrix with no data\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#75",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int, int)",
    "snippet": "public Array2DRowRealMatrix(final int rowDimension, final int columnDimension) {\n        super(rowDimension, columnDimension);\n        data \u003d new double[rowDimension][columnDimension];\n    }",
    "begin_line": 75,
    "end_line": 78,
    "comment": "/** \n * Create a new RealMatrix with the supplied row and column dimensions.\n * @param rowDimension Number of rows in the new matrix.\n * @param columnDimension Number of columns in the new matrix.\n * @throws org.apache.commons.math.exception.NotStrictlyPositiveException if the row or column dimension is not positive.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#93",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
    "snippet": "public Array2DRowRealMatrix(final double[][] d) {\n        copyIn(d);\n    }",
    "begin_line": 93,
    "end_line": 95,
    "comment": "/** \n * Create a new  {@code RealMatrix} using the input array as the underlyingdata array. \u003cp\u003eThe input array is copied, not referenced. This constructor has the same effect as calling  {@link #Array2DRowRealMatrix(double[][],boolean)}with the second argument set to  {@code true}.\u003c/p\u003e\n * @param d Data for the new matrix.\n * @throws DimensionMismatchException if {@code d} is not rectangular.\n * @throws NoDataException if {@code d} row or colum dimension is zero.\n * @throws NullPointerException if {@code d} is {@code null}.\n * @see #Array2DRowRealMatrix(double[][],boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#114",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][], boolean)",
    "snippet": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray) {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d \u003d\u003d null) {\n                throw new NullArgumentException();\n            }\n            final int nRows \u003d d.length;\n            if (nRows \u003d\u003d 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n            final int nCols \u003d d[0].length;\n            if (nCols \u003d\u003d 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            for (int r \u003d 1; r \u003c nRows; r++) {\n                if (d[r].length !\u003d nCols) {\n                    throw new DimensionMismatchException(d[r].length, nCols);\n                }\n            }\n            data \u003d d;\n        }\n    }",
    "begin_line": 114,
    "end_line": 136,
    "comment": "/** \n * Create a new RealMatrix using the input array as the underlying data array. If an array is built specially in order to be embedded in a RealMatrix and not used directly, the  {@code copyArray} may beset to  {@code false}. This will prevent the copying and improve performance as no new array will be built and no data will be copied.\n * @param d Data for new matrix.\n * @param copyArray if {@code true}, the input array will be copied, otherwise it will be referenced.\n * @throws DimensionMismatchException if {@code d} is not rectangular(not all rows have the same length) or empty.\n * @throws NullArgumentException if {@code d} is {@code null}.\n * @throws NoDataException if there are not at least one row and one column.\n * @see #Array2DRowRealMatrix(double[][])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#145",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[])",
    "snippet": "public Array2DRowRealMatrix(final double[] v) {\n        final int nRows \u003d v.length;\n        data \u003d new double[nRows][1];\n        for (int row \u003d 0; row \u003c nRows; row++) {\n            data[row][0] \u003d v[row];\n        }\n    }",
    "begin_line": 145,
    "end_line": 151,
    "comment": "/** \n * Create a new (column) RealMatrix using  {@code v} as thedata for the unique column of the created matrix. The input array is copied.\n * @param v Column vector holding data for new matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.createMatrix#155",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.createMatrix(int, int)",
    "snippet": "@Override\n    public RealMatrix createMatrix(final int rowDimension,\n                                   final int columnDimension) {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }",
    "begin_line": 155,
    "end_line": 158,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.copy#162",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copy()",
    "snippet": "@Override\n    public RealMatrix copy() {\n        return new Array2DRowRealMatrix(copyOut(), false);\n    }",
    "begin_line": 162,
    "end_line": 164,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.add#174",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.add(org.apache.commons.math.linear.Array2DRowRealMatrix)",
    "snippet": "public Array2DRowRealMatrix add(final Array2DRowRealMatrix m) {\n        // Safety check.\n        MatrixUtils.checkAdditionCompatible(this, m);\n\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final double[][] outData \u003d new double[rowCount][columnCount];\n        for (int row \u003d 0; row \u003c rowCount; row++) {\n            final double[] dataRow    \u003d data[row];\n            final double[] mRow       \u003d m.data[row];\n            final double[] outDataRow \u003d outData[row];\n            for (int col \u003d 0; col \u003c columnCount; col++) {\n                outDataRow[col] \u003d dataRow[col] + mRow[col];\n            }\n        }\n\n        return new Array2DRowRealMatrix(outData, false);\n    }",
    "begin_line": 174,
    "end_line": 191,
    "comment": "/** \n * Compute the sum of this matrix with  {@code m}.\n * @param m Matrix to be added.\n * @return {@code this} + m.\n * @throws MatrixDimensionMismatchException if  {@code m} is not the same size as this matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.subtract#201",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.subtract(org.apache.commons.math.linear.Array2DRowRealMatrix)",
    "snippet": "public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m) {\n        // Safety check.\n        MatrixUtils.checkSubtractionCompatible(this, m);\n\n        final int rowCount    \u003d getRowDimension();\n        final int columnCount \u003d getColumnDimension();\n        final double[][] outData \u003d new double[rowCount][columnCount];\n        for (int row \u003d 0; row \u003c rowCount; row++) {\n            final double[] dataRow    \u003d data[row];\n            final double[] mRow       \u003d m.data[row];\n            final double[] outDataRow \u003d outData[row];\n            for (int col \u003d 0; col \u003c columnCount; col++) {\n                outDataRow[col] \u003d dataRow[col] - mRow[col];\n            }\n        }\n\n        return new Array2DRowRealMatrix(outData, false);\n    }",
    "begin_line": 201,
    "end_line": 218,
    "comment": "/** \n * Subtract  {@code m} from this matrix.\n * @param m Matrix to be subtracted.\n * @return {@code this} - m.\n * @throws MatrixDimensionMismatchException if  {@code m} is not the same size as this matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.multiply#228",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiply(org.apache.commons.math.linear.Array2DRowRealMatrix)",
    "snippet": "public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m) {\n        // Safety check.\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows \u003d this.getRowDimension();\n        final int nCols \u003d m.getColumnDimension();\n        final int nSum \u003d this.getColumnDimension();\n        final double[][] outData \u003d new double[nRows][nCols];\n        for (int row \u003d 0; row \u003c nRows; row++) {\n            final double[] dataRow    \u003d data[row];\n            final double[] outDataRow \u003d outData[row];\n            for (int col \u003d 0; col \u003c nCols; col++) {\n                double sum \u003d 0;\n                for (int i \u003d 0; i \u003c nSum; i++) {\n                    sum +\u003d dataRow[i] * m.data[i][col];\n                }\n                outDataRow[col] \u003d sum;\n            }\n        }\n\n        return new Array2DRowRealMatrix(outData, false);\n\n    }",
    "begin_line": 228,
    "end_line": 250,
    "comment": "/** \n * Postmultiplying this matrix by  {@code m}.\n * @param m Matrix to postmultiply by.\n * @return {@code this} * m.\n * @throws DimensionMismatchException if the number of columns of thismatrix is not equal to the number of rows of  {@code m}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.getData#254",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getData()",
    "snippet": "@Override\n    public double[][] getData() {\n        return copyOut();\n    }",
    "begin_line": 254,
    "end_line": 256,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.getDataRef#263",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getDataRef()",
    "snippet": "public double[][] getDataRef() {\n        return data;\n    }",
    "begin_line": 263,
    "end_line": 265,
    "comment": "/** \n * Get a reference to the underlying data array.\n * @return 2-dimensional array of entries.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.setSubMatrix#269",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setSubMatrix(double[][], int, int)",
    "snippet": "@Override\n    public void setSubMatrix(final double[][] subMatrix,\n                             final int row, final int column) {\n        if (data \u003d\u003d null) {\n            if (row \u003e 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n            }\n            if (column \u003e 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n            }\n            final int nRows \u003d subMatrix.length;\n            if (nRows \u003d\u003d 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n\n            final int nCols \u003d subMatrix[0].length;\n            if (nCols \u003d\u003d 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            data \u003d new double[subMatrix.length][nCols];\n            for (int i \u003d 0; i \u003c data.length; ++i) {\n                if (subMatrix[i].length !\u003d nCols) {\n                    throw new DimensionMismatchException(subMatrix[i].length, nCols);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }",
    "begin_line": 269,
    "end_line": 298,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.getEntry#302",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getEntry(int, int)",
    "snippet": "@Override\n    public double getEntry(final int row, final int column) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return data[row][column];\n    }",
    "begin_line": 302,
    "end_line": 305,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.setEntry#309",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setEntry(int, int, double)",
    "snippet": "@Override\n    public void setEntry(final int row, final int column, final double value) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] \u003d value;\n    }",
    "begin_line": 309,
    "end_line": 312,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.addToEntry#316",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.addToEntry(int, int, double)",
    "snippet": "@Override\n    public void addToEntry(final int row, final int column, final double increment) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] +\u003d increment;\n    }",
    "begin_line": 316,
    "end_line": 319,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.multiplyEntry#323",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiplyEntry(int, int, double)",
    "snippet": "@Override\n    public void multiplyEntry(final int row, final int column, final double factor) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] *\u003d factor;\n    }",
    "begin_line": 323,
    "end_line": 326,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.getRowDimension#330",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getRowDimension()",
    "snippet": "@Override\n        public int getRowDimension() {\n        return (data \u003d\u003d null) ? 0 : data.length;\n    }",
    "begin_line": 330,
    "end_line": 332,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.getColumnDimension#336",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getColumnDimension()",
    "snippet": "@Override\n    public int getColumnDimension() {\n        return ((data \u003d\u003d null) || (data[0] \u003d\u003d null)) ? 0 : data[0].length;\n    }",
    "begin_line": 336,
    "end_line": 338,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.operate#342",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.operate(double[])",
    "snippet": "@Override\n    public double[] operate(final double[] v) {\n        final int nRows \u003d this.getRowDimension();\n        final int nCols \u003d this.getColumnDimension();\n        if (v.length !\u003d nCols) {\n            throw new DimensionMismatchException(v.length, nCols);\n        }\n        final double[] out \u003d new double[nRows];\n        for (int row \u003d 0; row \u003c nRows; row++) {\n            final double[] dataRow \u003d data[row];\n            double sum \u003d 0;\n            for (int i \u003d 0; i \u003c nCols; i++) {\n                sum +\u003d dataRow[i] * v[i];\n            }\n            out[row] \u003d sum;\n        }\n        return out;\n    }",
    "begin_line": 342,
    "end_line": 358,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.preMultiply#362",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.preMultiply(double[])",
    "snippet": "@Override\n    public double[] preMultiply(final double[] v) {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        if (v.length !\u003d nRows) {\n            throw new DimensionMismatchException(v.length, nRows);\n        }\n\n        final double[] out \u003d new double[nCols];\n        for (int col \u003d 0; col \u003c nCols; ++col) {\n            double sum \u003d 0;\n            for (int i \u003d 0; i \u003c nRows; ++i) {\n                sum +\u003d data[i][col] * v[i];\n            }\n            out[col] \u003d sum;\n        }\n\n        return out;\n\n    }",
    "begin_line": 362,
    "end_line": 380,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder#384",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor)",
    "snippet": "@Override\n    public double walkInRowOrder(final RealMatrixChangingVisitor visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i \u003d 0; i \u003c rows; ++i) {\n            final double[] rowI \u003d data[i];\n            for (int j \u003d 0; j \u003c columns; ++j) {\n                rowI[j] \u003d visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 384,
    "end_line": 395,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder#399",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
    "snippet": "@Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i \u003d 0; i \u003c rows; ++i) {\n            final double[] rowI \u003d data[i];\n            for (int j \u003d 0; j \u003c columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 399,
    "end_line": 410,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder#414",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor, int, int, int, int)",
    "snippet": "@Override\n    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int i \u003d startRow; i \u003c\u003d endRow; ++i) {\n            final double[] rowI \u003d data[i];\n            for (int j \u003d startColumn; j \u003c\u003d endColumn; ++j) {\n                rowI[j] \u003d visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 414,
    "end_line": 427,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder#431",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor, int, int, int, int)",
    "snippet": "@Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int i \u003d startRow; i \u003c\u003d endRow; ++i) {\n            final double[] rowI \u003d data[i];\n            for (int j \u003d startColumn; j \u003c\u003d endColumn; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 431,
    "end_line": 444,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.walkInColumnOrder#448",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInColumnOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor)",
    "snippet": "@Override\n    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int j \u003d 0; j \u003c columns; ++j) {\n            for (int i \u003d 0; i \u003c rows; ++i) {\n                final double[] rowI \u003d data[i];\n                rowI[j] \u003d visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 448,
    "end_line": 459,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.walkInColumnOrder#463",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInColumnOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
    "snippet": "@Override\n    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    \u003d getRowDimension();\n        final int columns \u003d getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int j \u003d 0; j \u003c columns; ++j) {\n            for (int i \u003d 0; i \u003c rows; ++i) {\n                visitor.visit(i, j, data[i][j]);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 463,
    "end_line": 473,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.walkInColumnOrder#477",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInColumnOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor, int, int, int, int)",
    "snippet": "@Override\n    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n                                    final int startRow, final int endRow,\n                                    final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int j \u003d startColumn; j \u003c\u003d endColumn; ++j) {\n            for (int i \u003d startRow; i \u003c\u003d endRow; ++i) {\n                final double[] rowI \u003d data[i];\n                rowI[j] \u003d visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 477,
    "end_line": 490,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.walkInColumnOrder#494",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInColumnOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor, int, int, int, int)",
    "snippet": "@Override\n    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n                                    final int startRow, final int endRow,\n                                    final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(getRowDimension(), getColumnDimension(),\n                      startRow, endRow, startColumn, endColumn);\n        for (int j \u003d startColumn; j \u003c\u003d endColumn; ++j) {\n            for (int i \u003d startRow; i \u003c\u003d endRow; ++i) {\n                visitor.visit(i, j, data[i][j]);\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 494,
    "end_line": 506,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.copyOut#513",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copyOut()",
    "snippet": "private double[][] copyOut() {\n        final int nRows \u003d this.getRowDimension();\n        final double[][] out \u003d new double[nRows][this.getColumnDimension()];\n        // can\u0027t copy 2-d array in one shot, otherwise get row references\n        for (int i \u003d 0; i \u003c nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }",
    "begin_line": 513,
    "end_line": 521,
    "comment": "/** \n * Get a fresh copy of the underlying data array.\n * @return a copy of the underlying data array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Array2DRowRealMatrix.copyIn#532",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/Array2DRowRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copyIn(double[][])",
    "snippet": "private void copyIn(final double[][] in) {\n        setSubMatrix(in, 0, 0);\n    }",
    "begin_line": 532,
    "end_line": 534,
    "comment": "/** \n * Replace data with a fresh copy of the input array.\n * @param in Data to copy.\n * @throws NoDataException if the input array is empty.\n * @throws DimensionMismatchException if the input array is not rectangular.\n * @throws org.apache.commons.math.exception.NullArgumentException ifthe input array is  {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.BlockFieldMatrix#94",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.BlockFieldMatrix(org.apache.commons.math.Field\u003cT\u003e, int, int)",
    "snippet": "public BlockFieldMatrix(final Field\u003cT\u003e field, final int rows, final int columns) {\n        super(field, rows, columns);\n        this.rows    \u003d rows;\n        this.columns \u003d columns;\n\n        // number of blocks\n        blockRows    \u003d (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns \u003d (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        blocks \u003d createBlocksLayout(field, rows, columns);\n    }",
    "begin_line": 94,
    "end_line": 105,
    "comment": "/** \n * Create a new matrix with the supplied row and column dimensions.\n * @param field Field to which the elements belong.\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @throws org.apache.commons.math.exception.NotStrictlyPositiveException if row or column dimension is not positive.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.BlockFieldMatrix#120",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.BlockFieldMatrix(T[][])",
    "snippet": "public BlockFieldMatrix(final T[][] rawData) {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }",
    "begin_line": 120,
    "end_line": 122,
    "comment": "/** \n * Create a new dense matrix copying entries from raw layout data. \u003cp\u003eThe input array \u003cem\u003emust\u003c/em\u003e already be in raw layout.\u003c/p\u003e \u003cp\u003eCalling this constructor is equivalent to call: \u003cpre\u003ematrix \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\u003c/pre\u003e \u003c/p\u003e\n * @param rawData Data for the new matrix, in raw layout.\n * @exception DimensionMismatchException if the {@code blockData} shape isinconsistent with block layout.\n * @see #BlockFieldMatrix(int,int,FieldElement[][],boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.BlockFieldMatrix#139",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.BlockFieldMatrix(int, int, T[][], boolean)",
    "snippet": "public BlockFieldMatrix(final int rows, final int columns,\n                            final T[][] blockData, final boolean copyArray) {\n        super(extractField(blockData), rows, columns);\n        this.rows    \u003d rows;\n        this.columns \u003d columns;\n\n        // number of blocks\n        blockRows    \u003d (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns \u003d (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks \u003d buildArray(getField(), blockRows * blockColumns, -1);\n        } else {\n            // reference existing array\n            blocks \u003d blockData;\n        }\n\n        int index \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length !\u003d iHeight * blockWidth(jBlock)) {\n                    throw new DimensionMismatchException(blockData[index].length,\n                                                         iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] \u003d blockData[index].clone();\n                }\n            }\n        }\n    }",
    "begin_line": 139,
    "end_line": 170,
    "comment": "/** \n * Create a new dense matrix copying entries from block layout data. \u003cp\u003eThe input array \u003cem\u003emust\u003c/em\u003e already be in blocks layout.\u003c/p\u003e\n * @param rows  the number of rows in the new matrix\n * @param columns  the number of columns in the new matrix\n * @param blockData data for new matrix\n * @param copyArray if true, the input array will be copied, otherwiseit will be referenced\n * @exception DimensionMismatchException if the {@code blockData} shape isinconsistent with block layout.\n * @see #createBlocksLayout(Field,int,int)\n * @see #toBlocksLayout(FieldElement[][])\n * @see #BlockFieldMatrix(FieldElement[][])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.toBlocksLayout#196",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.toBlocksLayout(T[][])",
    "snippet": "public static \u003cT extends FieldElement\u003cT\u003e\u003e T[][] toBlocksLayout(final T[][] rawData) {\n\n        final int rows         \u003d rawData.length;\n        final int columns      \u003d rawData[0].length;\n        final int blockRows    \u003d (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns \u003d (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i \u003d 0; i \u003c rawData.length; ++i) {\n            final int length \u003d rawData[i].length;\n            if (length !\u003d columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final Field\u003cT\u003e field \u003d extractField(rawData);\n        final T[][] blocks \u003d buildArray(field, blockRows * blockColumns, -1);\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart  \u003d iBlock * BLOCK_SIZE;\n            final int pEnd    \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight \u003d pEnd - pStart;\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd   \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth \u003d qEnd - qStart;\n\n                // allocate new block\n                final T[] block \u003d buildArray(field, iHeight * jWidth);\n                blocks[blockIndex] \u003d block;\n\n                // copy data\n                int index \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index +\u003d jWidth;\n                }\n\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
    "begin_line": 196,
    "end_line": 240,
    "comment": "/** \n * Convert a data array from raw layout to blocks layout. \u003cp\u003e Raw layout is the straightforward layout where element at row i and column j is in array element \u003ccode\u003erawData[i][j]\u003c/code\u003e. Blocks layout is the layout used in  {@link BlockFieldMatrix} instances, where the matrixis split in square blocks (except at right and bottom side where blocks may be rectangular to fit matrix size) and each block is stored in a flattened one-dimensional array. \u003c/p\u003e \u003cp\u003e This method creates an array in blocks layout from an input array in raw layout. It can be used to provide the array argument of the  {@link #BlockFieldMatrix(int,int,FieldElement[][],boolean)}constructor. \u003c/p\u003e\n * @param \u003c T \u003e Type of the field elements.\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout\n * @throws DimensionMismatchException if {@code rawData} is not rectangular(not all rows have the same length).\n * @see #createBlocksLayout(Field,int,int)\n * @see #BlockFieldMatrix(int,int,FieldElement[][],boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.createBlocksLayout#257",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.createBlocksLayout(org.apache.commons.math.Field\u003cT\u003e, int, int)",
    "snippet": "public static \u003cT extends FieldElement\u003cT\u003e\u003e T[][] createBlocksLayout(final Field\u003cT\u003e field,\n                                                                       final int rows, final int columns) {\n        final int blockRows    \u003d (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns \u003d (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final T[][] blocks \u003d buildArray(field, blockRows * blockColumns, -1);\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart  \u003d iBlock * BLOCK_SIZE;\n            final int pEnd    \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight \u003d pEnd - pStart;\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd   \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth \u003d qEnd - qStart;\n                blocks[blockIndex] \u003d buildArray(field, iHeight * jWidth);\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
    "begin_line": 257,
    "end_line": 278,
    "comment": "/** \n * Create a data array in blocks layout. \u003cp\u003e This method can be used to create the array argument of the  {@link #BlockFieldMatrix(int,int,FieldElement[][],boolean)}constructor. \u003c/p\u003e\n * @param \u003c T \u003e Type of the field elements.\n * @param field Field to which the elements belong.\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(FieldElement[][])\n * @see #BlockFieldMatrix(int,int,FieldElement[][],boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.createMatrix#282",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.createMatrix(int, int)",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e createMatrix(final int rowDimension, final int columnDimension) {\n        return new BlockFieldMatrix\u003cT\u003e(getField(), rowDimension, columnDimension);\n    }",
    "begin_line": 282,
    "end_line": 284,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.copy#288",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.copy()",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e copy() {\n\n        // create an empty matrix\n        BlockFieldMatrix\u003cT\u003e copied \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, columns);\n\n        // copy the blocks\n        for (int i \u003d 0; i \u003c blocks.length; ++i) {\n            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n        }\n\n        return copied;\n    }",
    "begin_line": 288,
    "end_line": 299,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.add#303",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.add(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e add(final FieldMatrix\u003cT\u003e m) {\n        try {\n            return add((BlockFieldMatrix\u003cT\u003e) m);\n        } catch (ClassCastException cce) {\n\n            // safety check\n            checkAdditionCompatible(m);\n\n            final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, columns);\n\n            // perform addition block-wise, to ensure good cache behavior\n            int blockIndex \u003d 0;\n            for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n                for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n\n                    // perform addition on the current block\n                    final T[] outBlock \u003d out.blocks[blockIndex];\n                    final T[] tBlock   \u003d blocks[blockIndex];\n                    final int      pStart   \u003d iBlock * BLOCK_SIZE;\n                    final int      pEnd     \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n                    final int      qStart   \u003d jBlock * BLOCK_SIZE;\n                    final int      qEnd     \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                    int k \u003d 0;\n                    for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                        for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                            outBlock[k] \u003d tBlock[k].add(m.getEntry(p, q));\n                            ++k;\n                        }\n                    }\n\n                    // go to next block\n                    ++blockIndex;\n\n                }\n            }\n\n            return out;\n        }\n    }",
    "begin_line": 303,
    "end_line": 341,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.add#350",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.add(org.apache.commons.math.linear.BlockFieldMatrix\u003cT\u003e)",
    "snippet": "public BlockFieldMatrix\u003cT\u003e add(final BlockFieldMatrix\u003cT\u003e m) {\n\n        // safety check\n        checkAdditionCompatible(m);\n\n        final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, columns);\n\n        // perform addition block-wise, to ensure good cache behavior\n        for (int blockIndex \u003d 0; blockIndex \u003c out.blocks.length; ++blockIndex) {\n            final T[] outBlock \u003d out.blocks[blockIndex];\n            final T[] tBlock   \u003d blocks[blockIndex];\n            final T[] mBlock   \u003d m.blocks[blockIndex];\n            for (int k \u003d 0; k \u003c outBlock.length; ++k) {\n                outBlock[k] \u003d tBlock[k].add(mBlock[k]);\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 350,
    "end_line": 368,
    "comment": "/** \n * Compute the sum of this and \u003ccode\u003em\u003c/code\u003e.\n * @param m    matrix to be added\n * @return     this + m\n * @throws IllegalArgumentException if m is not the same size as this\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.subtract#372",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.subtract(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e subtract(final FieldMatrix\u003cT\u003e m) {\n        try {\n            return subtract((BlockFieldMatrix\u003cT\u003e) m);\n        } catch (ClassCastException cce) {\n\n            // safety check\n            checkSubtractionCompatible(m);\n\n            final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, columns);\n\n            // perform subtraction block-wise, to ensure good cache behavior\n            int blockIndex \u003d 0;\n            for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n                for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n\n                    // perform subtraction on the current block\n                    final T[] outBlock \u003d out.blocks[blockIndex];\n                    final T[] tBlock   \u003d blocks[blockIndex];\n                    final int      pStart   \u003d iBlock * BLOCK_SIZE;\n                    final int      pEnd     \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n                    final int      qStart   \u003d jBlock * BLOCK_SIZE;\n                    final int      qEnd     \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                    int k \u003d 0;\n                    for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                        for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                            outBlock[k] \u003d tBlock[k].subtract(m.getEntry(p, q));\n                            ++k;\n                        }\n                    }\n\n                    // go to next block\n                    ++blockIndex;\n\n                }\n            }\n\n            return out;\n        }\n    }",
    "begin_line": 372,
    "end_line": 410,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.subtract#419",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.subtract(org.apache.commons.math.linear.BlockFieldMatrix\u003cT\u003e)",
    "snippet": "public BlockFieldMatrix\u003cT\u003e subtract(final BlockFieldMatrix\u003cT\u003e m) {\n        // safety check\n        checkSubtractionCompatible(m);\n\n        final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, columns);\n\n        // perform subtraction block-wise, to ensure good cache behavior\n        for (int blockIndex \u003d 0; blockIndex \u003c out.blocks.length; ++blockIndex) {\n            final T[] outBlock \u003d out.blocks[blockIndex];\n            final T[] tBlock   \u003d blocks[blockIndex];\n            final T[] mBlock   \u003d m.blocks[blockIndex];\n            for (int k \u003d 0; k \u003c outBlock.length; ++k) {\n                outBlock[k] \u003d tBlock[k].subtract(mBlock[k]);\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 419,
    "end_line": 436,
    "comment": "/** \n * Compute this minus \u003ccode\u003em\u003c/code\u003e.\n * @param m    matrix to be subtracted\n * @return     this - m\n * @throws IllegalArgumentException if m is not the same size as this\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.scalarAdd#440",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.scalarAdd(T)",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e scalarAdd(final T d) {\n        final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, columns);\n\n        // perform subtraction block-wise, to ensure good cache behavior\n        for (int blockIndex \u003d 0; blockIndex \u003c out.blocks.length; ++blockIndex) {\n            final T[] outBlock \u003d out.blocks[blockIndex];\n            final T[] tBlock   \u003d blocks[blockIndex];\n            for (int k \u003d 0; k \u003c outBlock.length; ++k) {\n                outBlock[k] \u003d tBlock[k].add(d);\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 440,
    "end_line": 453,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.scalarMultiply#457",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.scalarMultiply(T)",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e scalarMultiply(final T d) {\n\n        final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, columns);\n\n        // perform subtraction block-wise, to ensure good cache behavior\n        for (int blockIndex \u003d 0; blockIndex \u003c out.blocks.length; ++blockIndex) {\n            final T[] outBlock \u003d out.blocks[blockIndex];\n            final T[] tBlock   \u003d blocks[blockIndex];\n            for (int k \u003d 0; k \u003c outBlock.length; ++k) {\n                outBlock[k] \u003d tBlock[k].multiply(d);\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 457,
    "end_line": 471,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.multiply#475",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.multiply(org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e multiply(final FieldMatrix\u003cT\u003e m) {\n        try {\n            return multiply((BlockFieldMatrix\u003cT\u003e) m);\n        } catch (ClassCastException cce) {\n\n            // safety check\n            checkMultiplicationCompatible(m);\n\n            final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, m.getColumnDimension());\n            final T zero \u003d getField().getZero();\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex \u003d 0;\n            for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n\n                final int pStart \u003d iBlock * BLOCK_SIZE;\n                final int pEnd   \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n\n                    final int qStart \u003d jBlock * BLOCK_SIZE;\n                    final int qEnd   \u003d FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final T[] outBlock \u003d out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock \u003d 0; kBlock \u003c blockColumns; ++kBlock) {\n                        final int kWidth      \u003d blockWidth(kBlock);\n                        final T[] tBlock \u003d blocks[iBlock * blockColumns + kBlock];\n                        final int rStart      \u003d kBlock * BLOCK_SIZE;\n                        int k \u003d 0;\n                        for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                            final int lStart \u003d (p - pStart) * kWidth;\n                            final int lEnd   \u003d lStart + kWidth;\n                            for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                                T sum \u003d zero;\n                                int r \u003d rStart;\n                                for (int l \u003d lStart; l \u003c lEnd; ++l) {\n                                    sum \u003d sum.add(tBlock[l].multiply(m.getEntry(r, q)));\n                                    ++r;\n                                }\n                                outBlock[k] \u003d outBlock[k].add(sum);\n                                ++k;\n                            }\n                        }\n                    }\n\n                    // go to next block\n                    ++blockIndex;\n\n                }\n            }\n\n            return out;\n        }\n    }",
    "begin_line": 475,
    "end_line": 531,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.multiply#541",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.multiply(org.apache.commons.math.linear.BlockFieldMatrix\u003cT\u003e)",
    "snippet": "public BlockFieldMatrix\u003cT\u003e multiply(BlockFieldMatrix\u003cT\u003e m) {\n\n        // safety check\n        checkMultiplicationCompatible(m);\n\n        final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, m.columns);\n        final T zero \u003d getField().getZero();\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd   \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n\n            for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n                final int jWidth \u003d out.blockWidth(jBlock);\n                final int jWidth2 \u003d jWidth  + jWidth;\n                final int jWidth3 \u003d jWidth2 + jWidth;\n                final int jWidth4 \u003d jWidth3 + jWidth;\n\n                // select current block\n                final T[] outBlock \u003d out.blocks[blockIndex];\n\n                // perform multiplication on current block\n                for (int kBlock \u003d 0; kBlock \u003c blockColumns; ++kBlock) {\n                    final int kWidth \u003d blockWidth(kBlock);\n                    final T[] tBlock \u003d blocks[iBlock * blockColumns + kBlock];\n                    final T[] mBlock \u003d m.blocks[kBlock * m.blockColumns + jBlock];\n                    int k \u003d 0;\n                    for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                        final int lStart \u003d (p - pStart) * kWidth;\n                        final int lEnd   \u003d lStart + kWidth;\n                        for (int nStart \u003d 0; nStart \u003c jWidth; ++nStart) {\n                            T sum \u003d zero;\n                            int l \u003d lStart;\n                            int n \u003d nStart;\n                            while (l \u003c lEnd - 3) {\n                                sum \u003d sum.\n                                      add(tBlock[l].multiply(mBlock[n])).\n                                      add(tBlock[l + 1].multiply(mBlock[n + jWidth])).\n                                      add(tBlock[l + 2].multiply(mBlock[n + jWidth2])).\n                                      add(tBlock[l + 3].multiply(mBlock[n + jWidth3]));\n                                l +\u003d 4;\n                                n +\u003d jWidth4;\n                            }\n                            while (l \u003c lEnd) {\n                                sum \u003d sum.add(tBlock[l++].multiply(mBlock[n]));\n                                n +\u003d jWidth;\n                            }\n                            outBlock[k] \u003d outBlock[k].add(sum);\n                            ++k;\n                        }\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 541,
    "end_line": 603,
    "comment": "/** \n * Returns the result of postmultiplying this by m.\n * @param m    matrix to postmultiply by\n * @return     this * m\n * @throws IllegalArgumentException if columnDimension(this) !\u003d rowDimension(m)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getData#607",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getData()",
    "snippet": "@Override\n    public T[][] getData() {\n\n        final T[][] data \u003d buildArray(getField(), getRowDimension(), getColumnDimension());\n        final int lastColumns \u003d columns - (blockColumns - 1) * BLOCK_SIZE;\n\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd   \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            int regularPos   \u003d 0;\n            int lastPos      \u003d 0;\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                final T[] dataP \u003d data[p];\n                int blockIndex \u003d iBlock * blockColumns;\n                int dataPos    \u003d 0;\n                for (int jBlock \u003d 0; jBlock \u003c blockColumns - 1; ++jBlock) {\n                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n                    dataPos +\u003d BLOCK_SIZE;\n                }\n                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n                regularPos +\u003d BLOCK_SIZE;\n                lastPos    +\u003d lastColumns;\n            }\n        }\n\n        return data;\n    }",
    "begin_line": 607,
    "end_line": 632,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getSubMatrix#636",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getSubMatrix(int, int, int, int)",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e getSubMatrix(final int startRow, final int endRow,\n                                       final int startColumn, final int endColumn) {\n        // safety checks\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockFieldMatrix\u003cT\u003e out \u003d\n            new BlockFieldMatrix\u003cT\u003e(getField(), endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow    \u003d startRow    / BLOCK_SIZE;\n        final int rowsShift        \u003d startRow    % BLOCK_SIZE;\n        final int blockStartColumn \u003d startColumn / BLOCK_SIZE;\n        final int columnsShift     \u003d startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock \u003d blockStartRow;\n        for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n            final int iHeight \u003d out.blockHeight(iBlock);\n            int qBlock \u003d blockStartColumn;\n            for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n                final int jWidth \u003d out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int      outIndex \u003d iBlock * out.blockColumns + jBlock;\n                final T[] outBlock \u003d out.blocks[outIndex];\n                final int      index    \u003d pBlock * blockColumns + qBlock;\n                final int      width    \u003d blockWidth(qBlock);\n\n                final int heightExcess \u003d iHeight + rowsShift - BLOCK_SIZE;\n                final int widthExcess  \u003d jWidth + columnsShift - BLOCK_SIZE;\n                if (heightExcess \u003e 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess \u003e 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 \u003d blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess \u003e 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 \u003d blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
    "begin_line": 636,
    "end_line": 726,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.copyBlockPart#743",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.copyBlockPart(T[], int, int, int, int, int, T[], int, int, int)",
    "snippet": "private void copyBlockPart(final T[] srcBlock, final int srcWidth,\n                               final int srcStartRow, final int srcEndRow,\n                               final int srcStartColumn, final int srcEndColumn,\n                               final T[] dstBlock, final int dstWidth,\n                               final int dstStartRow, final int dstStartColumn) {\n        final int length \u003d srcEndColumn - srcStartColumn;\n        int srcPos \u003d srcStartRow * srcWidth + srcStartColumn;\n        int dstPos \u003d dstStartRow * dstWidth + dstStartColumn;\n        for (int srcRow \u003d srcStartRow; srcRow \u003c srcEndRow; ++srcRow) {\n            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);\n            srcPos +\u003d srcWidth;\n            dstPos +\u003d dstWidth;\n        }\n    }",
    "begin_line": 743,
    "end_line": 756,
    "comment": "/** \n * Copy a part of a block into another one \u003cp\u003eThis method can be called only when the specified part fits in both blocks, no verification is done here.\u003c/p\u003e\n * @param srcBlock source block\n * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)\n * @param srcStartRow start row in the source block\n * @param srcEndRow end row (exclusive) in the source block\n * @param srcStartColumn start column in the source block\n * @param srcEndColumn end column (exclusive) in the source block\n * @param dstBlock destination block\n * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)\n * @param dstStartRow start row in the destination block\n * @param dstStartColumn start column in the destination block\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setSubMatrix#760",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setSubMatrix(T[][], int, int)",
    "snippet": "@Override\n    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) {\n        // safety checks\n        final int refLength \u003d subMatrix[0].length;\n        if (refLength \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n        final int endRow    \u003d row + subMatrix.length - 1;\n        final int endColumn \u003d column + refLength - 1;\n        checkSubMatrixIndex(row, endRow, column, endColumn);\n        for (final T[] subRow : subMatrix) {\n            if (subRow.length !\u003d refLength) {\n                throw new DimensionMismatchException(refLength, subRow.length);\n            }\n        }\n\n        // compute blocks bounds\n        final int blockStartRow    \u003d row / BLOCK_SIZE;\n        final int blockEndRow      \u003d (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n        final int blockStartColumn \u003d column / BLOCK_SIZE;\n        final int blockEndColumn   \u003d (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n\n        // perform copy block-wise, to ensure good cache behavior\n        for (int iBlock \u003d blockStartRow; iBlock \u003c blockEndRow; ++iBlock) {\n            final int iHeight  \u003d blockHeight(iBlock);\n            final int firstRow \u003d iBlock * BLOCK_SIZE;\n            final int iStart   \u003d FastMath.max(row,    firstRow);\n            final int iEnd     \u003d FastMath.min(endRow + 1, firstRow + iHeight);\n\n            for (int jBlock \u003d blockStartColumn; jBlock \u003c blockEndColumn; ++jBlock) {\n                final int jWidth      \u003d blockWidth(jBlock);\n                final int firstColumn \u003d jBlock * BLOCK_SIZE;\n                final int jStart      \u003d FastMath.max(column,    firstColumn);\n                final int jEnd        \u003d FastMath.min(endColumn + 1, firstColumn + jWidth);\n                final int jLength     \u003d jEnd - jStart;\n\n                // handle one block, row by row\n                final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                for (int i \u003d iStart; i \u003c iEnd; ++i) {\n                    System.arraycopy(subMatrix[i - row], jStart - column,\n                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),\n                                     jLength);\n                }\n\n            }\n        }\n    }",
    "begin_line": 760,
    "end_line": 805,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getRowMatrix#809",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getRowMatrix(int)",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e getRowMatrix(final int row) {\n        checkRowIndex(row);\n        final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), 1, columns);\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock  \u003d row / BLOCK_SIZE;\n        final int iRow    \u003d row - iBlock * BLOCK_SIZE;\n        int outBlockIndex \u003d 0;\n        int outIndex      \u003d 0;\n        T[] outBlock \u003d out.blocks[outBlockIndex];\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth     \u003d blockWidth(jBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            final int available  \u003d outBlock.length - outIndex;\n            if (jWidth \u003e available) {\n                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n                outBlock \u003d out.blocks[++outBlockIndex];\n                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);\n                outIndex \u003d jWidth - available;\n            } else {\n                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);\n                outIndex +\u003d jWidth;\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 809,
    "end_line": 835,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setRowMatrix#839",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setRowMatrix(int, org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "@Override\n    public void setRowMatrix(final int row, final FieldMatrix\u003cT\u003e matrix) {\n        try {\n            setRowMatrix(row, (BlockFieldMatrix\u003cT\u003e) matrix);\n        } catch (ClassCastException cce) {\n            super.setRowMatrix(row, matrix);\n        }\n    }",
    "begin_line": 839,
    "end_line": 845,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setRowMatrix#859",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setRowMatrix(int, org.apache.commons.math.linear.BlockFieldMatrix\u003cT\u003e)",
    "snippet": "public void setRowMatrix(final int row, final BlockFieldMatrix\u003cT\u003e matrix) {\n        checkRowIndex(row);\n        final int nCols \u003d getColumnDimension();\n        if ((matrix.getRowDimension() !\u003d 1) ||\n            (matrix.getColumnDimension() !\u003d nCols)) {\n            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n                                                       matrix.getColumnDimension(),\n                                                       1, nCols);\n        }\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock \u003d row / BLOCK_SIZE;\n        final int iRow   \u003d row - iBlock * BLOCK_SIZE;\n        int mBlockIndex  \u003d 0;\n        int mIndex       \u003d 0;\n        T[] mBlock  \u003d matrix.blocks[mBlockIndex];\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth     \u003d blockWidth(jBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            final int available  \u003d mBlock.length - mIndex;\n            if (jWidth \u003e available) {\n                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);\n                mBlock \u003d matrix.blocks[++mBlockIndex];\n                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);\n                mIndex \u003d jWidth - available;\n            } else {\n                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);\n                mIndex +\u003d jWidth;\n           }\n        }\n    }",
    "begin_line": 859,
    "end_line": 889,
    "comment": "/** \n * Sets the entries in row number \u003ccode\u003erow\u003c/code\u003e as a row matrix.  Row indices start at 0.\n * @param row the row to be set\n * @param matrix row matrix (must have one row and the same number of columnsas the instance)\n * @throws org.apache.commons.math.exception.OutOfRangeException if thespecified row index is invalid.\n * @throws MatrixDimensionMismatchException if the matrix dimensions donot match one instance row.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getColumnMatrix#893",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getColumnMatrix(int)",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e getColumnMatrix(final int column) {\n        checkColumnIndex(column);\n        final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), rows, 1);\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock  \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth  \u003d blockWidth(jBlock);\n        int outBlockIndex \u003d 0;\n        int outIndex      \u003d 0;\n        T[] outBlock \u003d out.blocks[outBlockIndex];\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                if (outIndex \u003e\u003d outBlock.length) {\n                    outBlock \u003d out.blocks[++outBlockIndex];\n                    outIndex \u003d 0;\n                }\n                outBlock[outIndex++] \u003d block[i * jWidth + jColumn];\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 893,
    "end_line": 917,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setColumnMatrix#921",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setColumnMatrix(int, org.apache.commons.math.linear.FieldMatrix\u003cT\u003e)",
    "snippet": "@Override\n    public void setColumnMatrix(final int column, final FieldMatrix\u003cT\u003e matrix) {\n        try {\n            setColumnMatrix(column, (BlockFieldMatrix\u003cT\u003e) matrix);\n        } catch (ClassCastException cce) {\n            super.setColumnMatrix(column, matrix);\n        }\n    }",
    "begin_line": 921,
    "end_line": 927,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setColumnMatrix#941",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setColumnMatrix(int, org.apache.commons.math.linear.BlockFieldMatrix\u003cT\u003e)",
    "snippet": "void setColumnMatrix(final int column, final BlockFieldMatrix\u003cT\u003e matrix) {\n        checkColumnIndex(column);\n        final int nRows \u003d getRowDimension();\n        if ((matrix.getRowDimension() !\u003d nRows) ||\n            (matrix.getColumnDimension() !\u003d 1)) {\n            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n                                                       matrix.getColumnDimension(),\n                                                       nRows, 1);\n        }\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock  \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth  \u003d blockWidth(jBlock);\n        int mBlockIndex \u003d 0;\n        int mIndex      \u003d 0;\n        T[] mBlock \u003d matrix.blocks[mBlockIndex];\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                if (mIndex \u003e\u003d mBlock.length) {\n                    mBlock \u003d matrix.blocks[++mBlockIndex];\n                    mIndex \u003d 0;\n                }\n                block[i * jWidth + jColumn] \u003d mBlock[mIndex++];\n            }\n        }\n    }",
    "begin_line": 941,
    "end_line": 969,
    "comment": "/** \n * Sets the entries in column number  {@code column}as a column matrix.  Column indices start at 0.\n * @param column Column to be set.\n * @param matrix Column matrix (must have one column and the same number of rowsas the instance).\n * @throws org.apache.commons.math.exception.OutOfRangeException ifthe specified column index is invalid.\n * @throws MatrixDimensionMismatchException if the matrix dimensions donot match one instance column.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getRowVector#973",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getRowVector(int)",
    "snippet": "@Override\n    public FieldVector\u003cT\u003e getRowVector(final int row) {\n        checkRowIndex(row);\n        final T[] outData \u003d buildArray(getField(), columns);\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock  \u003d row / BLOCK_SIZE;\n        final int iRow    \u003d row - iBlock * BLOCK_SIZE;\n        int outIndex      \u003d 0;\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth     \u003d blockWidth(jBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n            outIndex +\u003d jWidth;\n        }\n\n        return new ArrayFieldVector\u003cT\u003e(getField(), outData, false);\n    }",
    "begin_line": 973,
    "end_line": 989,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setRowVector#993",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setRowVector(int, org.apache.commons.math.linear.FieldVector\u003cT\u003e)",
    "snippet": "@Override\n    public void setRowVector(final int row, final FieldVector\u003cT\u003e vector) {\n        try {\n            setRow(row, ((ArrayFieldVector\u003cT\u003e) vector).getDataRef());\n        } catch (ClassCastException cce) {\n            super.setRowVector(row, vector);\n        }\n    }",
    "begin_line": 993,
    "end_line": 999,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getColumnVector#1003",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getColumnVector(int)",
    "snippet": "@Override\n    public FieldVector\u003cT\u003e getColumnVector(final int column) {\n        checkColumnIndex(column);\n        final T[] outData \u003d buildArray(getField(), rows);\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock  \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth  \u003d blockWidth(jBlock);\n        int outIndex      \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                outData[outIndex++] \u003d block[i * jWidth + jColumn];\n            }\n        }\n\n        return new ArrayFieldVector\u003cT\u003e(getField(), outData, false);\n    }",
    "begin_line": 1003,
    "end_line": 1021,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setColumnVector#1025",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setColumnVector(int, org.apache.commons.math.linear.FieldVector\u003cT\u003e)",
    "snippet": "@Override\n    public void setColumnVector(final int column, final FieldVector\u003cT\u003e vector) {\n        try {\n            setColumn(column, ((ArrayFieldVector\u003cT\u003e) vector).getDataRef());\n        } catch (ClassCastException cce) {\n            super.setColumnVector(column, vector);\n        }\n    }",
    "begin_line": 1025,
    "end_line": 1031,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getRow#1035",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getRow(int)",
    "snippet": "@Override\n    public T[] getRow(final int row) {\n        checkRowIndex(row);\n        final T[] out \u003d buildArray(getField(), columns);\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock  \u003d row / BLOCK_SIZE;\n        final int iRow    \u003d row - iBlock * BLOCK_SIZE;\n        int outIndex      \u003d 0;\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth     \u003d blockWidth(jBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);\n            outIndex +\u003d jWidth;\n        }\n\n        return out;\n    }",
    "begin_line": 1035,
    "end_line": 1051,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setRow#1055",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setRow(int, T[])",
    "snippet": "@Override\n    public void setRow(final int row, final T[] array) {\n        checkRowIndex(row);\n        final int nCols \u003d getColumnDimension();\n        if (array.length !\u003d nCols) {\n            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);\n        }\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock  \u003d row / BLOCK_SIZE;\n        final int iRow    \u003d row - iBlock * BLOCK_SIZE;\n        int outIndex      \u003d 0;\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth     \u003d blockWidth(jBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n            outIndex +\u003d jWidth;\n        }\n    }",
    "begin_line": 1055,
    "end_line": 1072,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getColumn#1076",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getColumn(int)",
    "snippet": "@Override\n    public T[] getColumn(final int column) {\n        checkColumnIndex(column);\n        final T[] out \u003d buildArray(getField(), rows);\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock  \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth  \u003d blockWidth(jBlock);\n        int outIndex      \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                out[outIndex++] \u003d block[i * jWidth + jColumn];\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 1076,
    "end_line": 1094,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setColumn#1098",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setColumn(int, T[])",
    "snippet": "@Override\n    public void setColumn(final int column, final T[] array) {\n        checkColumnIndex(column);\n        final int nRows \u003d getRowDimension();\n        if (array.length !\u003d nRows) {\n            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n        }\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock  \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth  \u003d blockWidth(jBlock);\n        int outIndex      \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                block[i * jWidth + jColumn] \u003d array[outIndex++];\n            }\n        }\n    }",
    "begin_line": 1098,
    "end_line": 1117,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getEntry#1121",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getEntry(int, int)",
    "snippet": "@Override\n    public T getEntry(final int row, final int column) {\n        checkRowIndex(row);\n        checkColumnIndex(column);\n\n        final int iBlock \u003d row    / BLOCK_SIZE;\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int k      \u003d (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n            (column - jBlock * BLOCK_SIZE);\n\n        return blocks[iBlock * blockColumns + jBlock][k];\n    }",
    "begin_line": 1121,
    "end_line": 1131,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.setEntry#1135",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.setEntry(int, int, T)",
    "snippet": "@Override\n    public void setEntry(final int row, final int column, final T value) {\n        checkRowIndex(row);\n        checkColumnIndex(column);\n\n        final int iBlock \u003d row    / BLOCK_SIZE;\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int k      \u003d (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n            (column - jBlock * BLOCK_SIZE);\n\n        blocks[iBlock * blockColumns + jBlock][k] \u003d value;\n    }",
    "begin_line": 1135,
    "end_line": 1145,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.addToEntry#1149",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.addToEntry(int, int, T)",
    "snippet": "@Override\n    public void addToEntry(final int row, final int column, final T increment) {\n        checkRowIndex(row);\n        checkColumnIndex(column);\n\n        final int iBlock \u003d row    / BLOCK_SIZE;\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int k      \u003d (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n            (column - jBlock * BLOCK_SIZE);\n        final T[] blockIJ \u003d blocks[iBlock * blockColumns + jBlock];\n\n        blockIJ[k] \u003d blockIJ[k].add(increment);\n    }",
    "begin_line": 1149,
    "end_line": 1160,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.multiplyEntry#1164",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.multiplyEntry(int, int, T)",
    "snippet": "@Override\n    public void multiplyEntry(final int row, final int column, final T factor) {\n        checkRowIndex(row);\n        checkColumnIndex(column);\n\n        final int iBlock \u003d row    / BLOCK_SIZE;\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int k      \u003d (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n            (column - jBlock * BLOCK_SIZE);\n        final T[] blockIJ \u003d blocks[iBlock * blockColumns + jBlock];\n\n        blockIJ[k] \u003d blockIJ[k].multiply(factor);\n    }",
    "begin_line": 1164,
    "end_line": 1175,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.transpose#1179",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.transpose()",
    "snippet": "@Override\n    public FieldMatrix\u003cT\u003e transpose() {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        final BlockFieldMatrix\u003cT\u003e out \u003d new BlockFieldMatrix\u003cT\u003e(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockColumns; ++iBlock) {\n            for (int jBlock \u003d 0; jBlock \u003c blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock \u003d out.blocks[blockIndex];\n                final T[] tBlock   \u003d blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   \u003d iBlock * BLOCK_SIZE;\n                final int      pEnd     \u003d FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   \u003d jBlock * BLOCK_SIZE;\n                final int      qEnd     \u003d FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    final int lInc \u003d pEnd - pStart;\n                    int l \u003d p - pStart;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        outBlock[k] \u003d tBlock[l];\n                        ++k;\n                        l+\u003d lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 1179,
    "end_line": 1214,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getRowDimension#1218",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getRowDimension()",
    "snippet": "@Override\n    public int getRowDimension() {\n        return rows;\n    }",
    "begin_line": 1218,
    "end_line": 1220,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.getColumnDimension#1224",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.getColumnDimension()",
    "snippet": "@Override\n    public int getColumnDimension() {\n        return columns;\n    }",
    "begin_line": 1224,
    "end_line": 1226,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.operate#1230",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.operate(T[])",
    "snippet": "@Override\n    public T[] operate(final T[] v) {\n        if (v.length !\u003d columns) {\n            throw new DimensionMismatchException(v.length, columns);\n        }\n        final T[] out \u003d buildArray(getField(), rows);\n        final T zero \u003d getField().getZero();\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd   \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final T[] block  \u003d blocks[iBlock * blockColumns + jBlock];\n                final int      qStart \u003d jBlock * BLOCK_SIZE;\n                final int      qEnd   \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                int k \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    T sum \u003d zero;\n                    int q \u003d qStart;\n                    while (q \u003c qEnd - 3) {\n                        sum \u003d sum.\n                              add(block[k].multiply(v[q])).\n                              add(block[k + 1].multiply(v[q + 1])).\n                              add(block[k + 2].multiply(v[q + 2])).\n                              add(block[k + 3].multiply(v[q + 3]));\n                        k +\u003d 4;\n                        q +\u003d 4;\n                    }\n                    while (q \u003c qEnd) {\n                        sum \u003d sum.add(block[k++].multiply(v[q++]));\n                    }\n                    out[p] \u003d out[p].add(sum);\n                }\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 1230,
    "end_line": 1267,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.preMultiply#1271",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.preMultiply(T[])",
    "snippet": "@Override\n    public T[] preMultiply(final T[] v) {\n\n        if (v.length !\u003d rows) {\n            throw new DimensionMismatchException(v.length, rows);\n        }\n        final T[] out \u003d buildArray(getField(), columns);\n        final T zero \u003d getField().getZero();\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth  \u003d blockWidth(jBlock);\n            final int jWidth2 \u003d jWidth  + jWidth;\n            final int jWidth3 \u003d jWidth2 + jWidth;\n            final int jWidth4 \u003d jWidth3 + jWidth;\n            final int qStart \u003d jBlock * BLOCK_SIZE;\n            final int qEnd   \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n            for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n                final T[] block  \u003d blocks[iBlock * blockColumns + jBlock];\n                final int      pStart \u003d iBlock * BLOCK_SIZE;\n                final int      pEnd   \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n                for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                    int k \u003d q - qStart;\n                    T sum \u003d zero;\n                    int p \u003d pStart;\n                    while (p \u003c pEnd - 3) {\n                        sum \u003d sum.\n                              add(block[k].multiply(v[p])).\n                              add(block[k + jWidth].multiply(v[p + 1])).\n                              add(block[k + jWidth2].multiply(v[p + 2])).\n                              add(block[k + jWidth3].multiply(v[p + 3]));\n                        k +\u003d jWidth4;\n                        p +\u003d 4;\n                    }\n                    while (p \u003c pEnd) {\n                        sum \u003d sum.add(block[k].multiply(v[p++]));\n                        k +\u003d jWidth;\n                    }\n                    out[q] \u003d out[q].add(sum);\n                }\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 1271,
    "end_line": 1314,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.walkInRowOrder#1318",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e)",
    "snippet": "@Override\n    public T walkInRowOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor) {\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd   \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                    final int jWidth \u003d blockWidth(jBlock);\n                    final int qStart \u003d jBlock * BLOCK_SIZE;\n                    final int qEnd   \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                    final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                    int k \u003d (p - pStart) * jWidth;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        block[k] \u003d visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1318,
    "end_line": 1338,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.walkInRowOrder#1342",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e)",
    "snippet": "@Override\n    public T walkInRowOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor) {\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd   \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                    final int jWidth \u003d blockWidth(jBlock);\n                    final int qStart \u003d jBlock * BLOCK_SIZE;\n                    final int qEnd   \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                    final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                    int k \u003d (p - pStart) * jWidth;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1342,
    "end_line": 1362,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.walkInRowOrder#1366",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "@Override\n    public T walkInRowOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn) {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock \u003d startRow / BLOCK_SIZE; iBlock \u003c 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     \u003d iBlock * BLOCK_SIZE;\n            final int pStart \u003d FastMath.max(startRow, p0);\n            final int pEnd   \u003d FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                for (int jBlock \u003d startColumn / BLOCK_SIZE; jBlock \u003c 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth \u003d blockWidth(jBlock);\n                    final int q0     \u003d jBlock * BLOCK_SIZE;\n                    final int qStart \u003d FastMath.max(startColumn, q0);\n                    final int qEnd   \u003d FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                    int k \u003d (p - p0) * jWidth + qStart - q0;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        block[k] \u003d visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1366,
    "end_line": 1391,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.walkInRowOrder#1395",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "@Override\n    public T walkInRowOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn) {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock \u003d startRow / BLOCK_SIZE; iBlock \u003c 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     \u003d iBlock * BLOCK_SIZE;\n            final int pStart \u003d FastMath.max(startRow, p0);\n            final int pEnd   \u003d FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                for (int jBlock \u003d startColumn / BLOCK_SIZE; jBlock \u003c 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth \u003d blockWidth(jBlock);\n                    final int q0     \u003d jBlock * BLOCK_SIZE;\n                    final int qStart \u003d FastMath.max(startColumn, q0);\n                    final int qEnd   \u003d FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                    int k \u003d (p - p0) * jWidth + qStart - q0;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1395,
    "end_line": 1420,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.walkInOptimizedOrder#1424",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e)",
    "snippet": "@Override\n    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor) {\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd   \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd   \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                final T[] block \u003d blocks[blockIndex];\n                int k \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        block[k] \u003d visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n                ++blockIndex;\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1424,
    "end_line": 1445,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.walkInOptimizedOrder#1449",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e)",
    "snippet": "@Override\n    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor) {\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd   \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd   \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                final T[] block \u003d blocks[blockIndex];\n                int k \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n                ++blockIndex;\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1449,
    "end_line": 1470,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.walkInOptimizedOrder#1474",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "@Override\n    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor\u003cT\u003e visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn, final int endColumn) {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock \u003d startRow / BLOCK_SIZE; iBlock \u003c 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     \u003d iBlock * BLOCK_SIZE;\n            final int pStart \u003d FastMath.max(startRow, p0);\n            final int pEnd   \u003d FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock \u003d startColumn / BLOCK_SIZE; jBlock \u003c 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth \u003d blockWidth(jBlock);\n                final int q0     \u003d jBlock * BLOCK_SIZE;\n                final int qStart \u003d FastMath.max(startColumn, q0);\n                final int qEnd   \u003d FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    int k \u003d (p - p0) * jWidth + qStart - q0;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        block[k] \u003d visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1474,
    "end_line": 1499,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.walkInOptimizedOrder#1503",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor\u003cT\u003e, int, int, int, int)",
    "snippet": "@Override\n    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor\u003cT\u003e visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn, final int endColumn) {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock \u003d startRow / BLOCK_SIZE; iBlock \u003c 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     \u003d iBlock * BLOCK_SIZE;\n            final int pStart \u003d FastMath.max(startRow, p0);\n            final int pEnd   \u003d FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock \u003d startColumn / BLOCK_SIZE; jBlock \u003c 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth \u003d blockWidth(jBlock);\n                final int q0     \u003d jBlock * BLOCK_SIZE;\n                final int qStart \u003d FastMath.max(startColumn, q0);\n                final int qEnd   \u003d FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    int k \u003d (p - p0) * jWidth + qStart - q0;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1503,
    "end_line": 1528,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.blockHeight#1535",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.blockHeight(int)",
    "snippet": "private int blockHeight(final int blockRow) {\n        return (blockRow \u003d\u003d blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "begin_line": 1535,
    "end_line": 1537,
    "comment": "/** \n * Get the height of a block.\n * @param blockRow row index (in block sense) of the block\n * @return height (number of rows) of the block\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockFieldMatrix.blockWidth#1544",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockFieldMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockFieldMatrix",
    "signature": "org.apache.commons.math.linear.BlockFieldMatrix.blockWidth(int)",
    "snippet": "private int blockWidth(final int blockColumn) {\n        return (blockColumn \u003d\u003d blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "begin_line": 1544,
    "end_line": 1546,
    "comment": "/** \n * Get the width of a block.\n * @param blockColumn column index (in block sense) of the block\n * @return width (number of columns) of the block\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix#91",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.BlockRealMatrix(int, int)",
    "snippet": "public BlockRealMatrix(final int rows, final int columns) {\n        super(rows, columns);\n        this.rows \u003d rows;\n        this.columns \u003d columns;\n\n        // number of blocks\n        blockRows \u003d (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns \u003d (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        blocks \u003d createBlocksLayout(rows, columns);\n    }",
    "begin_line": 91,
    "end_line": 102,
    "comment": "/** \n * Create a new matrix with the supplied row and column dimensions.\n * @param rows  the number of rows in the new matrix\n * @param columns  the number of columns in the new matrix\n * @throws org.apache.commons.math.exception.NotStrictlyPositiveException if row or column dimension is not positive.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix#117",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.BlockRealMatrix(double[][])",
    "snippet": "public BlockRealMatrix(final double[][] rawData) {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }",
    "begin_line": 117,
    "end_line": 119,
    "comment": "/** \n * Create a new dense matrix copying entries from raw layout data. \u003cp\u003eThe input array \u003cem\u003emust\u003c/em\u003e already be in raw layout.\u003c/p\u003e \u003cp\u003eCalling this constructor is equivalent to call: \u003cpre\u003ematrix \u003d new BlockRealMatrix(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\u003c/pre\u003e \u003c/p\u003e\n * @param rawData data for new matrix, in raw layout\n * @throws DimensionMismatchException if the shape of {@code blockData} isinconsistent with block layout.\n * @see #BlockRealMatrix(int,int,double[][],boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix#135",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.BlockRealMatrix(int, int, double[][], boolean)",
    "snippet": "public BlockRealMatrix(final int rows, final int columns,\n                           final double[][] blockData, final boolean copyArray) {\n        super(rows, columns);\n        this.rows \u003d rows;\n        this.columns \u003d columns;\n\n        // number of blocks\n        blockRows \u003d (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns \u003d (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks \u003d new double[blockRows * blockColumns][];\n        } else {\n            // reference existing array\n            blocks \u003d blockData;\n        }\n\n        int index \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length !\u003d iHeight * blockWidth(jBlock)) {\n                    throw new DimensionMismatchException(blockData[index].length,\n                                                         iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] \u003d blockData[index].clone();\n                }\n            }\n        }\n    }",
    "begin_line": 135,
    "end_line": 166,
    "comment": "/** \n * Create a new dense matrix copying entries from block layout data. \u003cp\u003eThe input array \u003cem\u003emust\u003c/em\u003e already be in blocks layout.\u003c/p\u003e\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @param blockData data for new matrix\n * @param copyArray Whether the input array will be copied or referenced.\n * @throws DimensionMismatchException if the shape of {@code blockData} isinconsistent with block layout.\n * @see #createBlocksLayout(int,int)\n * @see #toBlocksLayout(double[][])\n * @see #BlockRealMatrix(double[][])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.toBlocksLayout#189",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.toBlocksLayout(double[][])",
    "snippet": "public static double[][] toBlocksLayout(final double[][] rawData) {\n        final int rows \u003d rawData.length;\n        final int columns \u003d rawData[0].length;\n        final int blockRows \u003d (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns \u003d (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i \u003d 0; i \u003c rawData.length; ++i) {\n            final int length \u003d rawData[i].length;\n            if (length !\u003d columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks \u003d new double[blockRows * blockColumns][];\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight \u003d pEnd - pStart;\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth \u003d qEnd - qStart;\n\n                // allocate new block\n                final double[] block \u003d new double[iHeight * jWidth];\n                blocks[blockIndex] \u003d block;\n\n                // copy data\n                int index \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index +\u003d jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
    "begin_line": 189,
    "end_line": 230,
    "comment": "/** \n * Convert a data array from raw layout to blocks layout. \u003cp\u003e Raw layout is the straightforward layout where element at row i and column j is in array element \u003ccode\u003erawData[i][j]\u003c/code\u003e. Blocks layout is the layout used in  {@link BlockRealMatrix} instances, where the matrixis split in square blocks (except at right and bottom side where blocks may be rectangular to fit matrix size) and each block is stored in a flattened one-dimensional array. \u003c/p\u003e \u003cp\u003e This method creates an array in blocks layout from an input array in raw layout. It can be used to provide the array argument of the  {@link #BlockRealMatrix(int,int,double[][],boolean)} constructor.\u003c/p\u003e\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout.\n * @throws DimensionMismatchException if {@code rawData} is not rectangular.\n * @see #createBlocksLayout(int,int)\n * @see #BlockRealMatrix(int,int,double[][],boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.createBlocksLayout#244",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.createBlocksLayout(int, int)",
    "snippet": "public static double[][] createBlocksLayout(final int rows, final int columns) {\n        final int blockRows \u003d (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns \u003d (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks \u003d new double[blockRows * blockColumns][];\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight \u003d pEnd - pStart;\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth \u003d qEnd - qStart;\n                blocks[blockIndex] \u003d new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
    "begin_line": 244,
    "end_line": 264,
    "comment": "/** \n * Create a data array in blocks layout. \u003cp\u003e This method can be used to create the array argument of the  {@link #BlockRealMatrix(int,int,double[][],boolean)} constructor.\u003c/p\u003e\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(double[][])\n * @see #BlockRealMatrix(int,int,double[][],boolean)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.createMatrix#268",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.createMatrix(int, int)",
    "snippet": "@Override\n    public BlockRealMatrix createMatrix(final int rowDimension, final int columnDimension) {\n        return new BlockRealMatrix(rowDimension, columnDimension);\n    }",
    "begin_line": 268,
    "end_line": 270,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.copy#274",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.copy()",
    "snippet": "@Override\n    public BlockRealMatrix copy() {\n        // create an empty matrix\n        BlockRealMatrix copied \u003d new BlockRealMatrix(rows, columns);\n\n        // copy the blocks\n        for (int i \u003d 0; i \u003c blocks.length; ++i) {\n            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n        }\n\n        return copied;\n    }",
    "begin_line": 274,
    "end_line": 284,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.add#288",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.add(org.apache.commons.math.linear.RealMatrix)",
    "snippet": "@Override\n    public BlockRealMatrix add(final RealMatrix m) {\n        try {\n            return add((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkAdditionCompatible(this, m);\n\n            final BlockRealMatrix out \u003d new BlockRealMatrix(rows, columns);\n\n            // perform addition block-wise, to ensure good cache behavior\n            int blockIndex \u003d 0;\n            for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n                for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n\n                    // perform addition on the current block\n                    final double[] outBlock \u003d out.blocks[blockIndex];\n                    final double[] tBlock   \u003d blocks[blockIndex];\n                    final int pStart \u003d iBlock * BLOCK_SIZE;\n                    final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n                    final int qStart \u003d jBlock * BLOCK_SIZE;\n                    final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                    int k \u003d 0;\n                    for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                        for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                            outBlock[k] \u003d tBlock[k] + m.getEntry(p, q);\n                            ++k;\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
    "begin_line": 288,
    "end_line": 323,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.add#333",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.add(org.apache.commons.math.linear.BlockRealMatrix)",
    "snippet": "public BlockRealMatrix add(final BlockRealMatrix m) {\n        // safety check\n        MatrixUtils.checkAdditionCompatible(this, m);\n\n        final BlockRealMatrix out \u003d new BlockRealMatrix(rows, columns);\n\n        // perform addition block-wise, to ensure good cache behavior\n        for (int blockIndex \u003d 0; blockIndex \u003c out.blocks.length; ++blockIndex) {\n            final double[] outBlock \u003d out.blocks[blockIndex];\n            final double[] tBlock \u003d blocks[blockIndex];\n            final double[] mBlock \u003d m.blocks[blockIndex];\n            for (int k \u003d 0; k \u003c outBlock.length; ++k) {\n                outBlock[k] \u003d tBlock[k] + mBlock[k];\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 333,
    "end_line": 350,
    "comment": "/** \n * Compute the sum of this matrix and  {@code m}.\n * @param m Matrix to be added.\n * @return {@code this} + m.\n * @throws MatrixDimensionMismatchException if {@code m} is not the samesize as this matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.subtract#354",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.subtract(org.apache.commons.math.linear.RealMatrix)",
    "snippet": "@Override\n    public BlockRealMatrix subtract(final RealMatrix m) {\n        try {\n            return subtract((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkSubtractionCompatible(this, m);\n\n            final BlockRealMatrix out \u003d new BlockRealMatrix(rows, columns);\n\n            // perform subtraction block-wise, to ensure good cache behavior\n            int blockIndex \u003d 0;\n            for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n                for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n\n                    // perform subtraction on the current block\n                    final double[] outBlock \u003d out.blocks[blockIndex];\n                    final double[] tBlock \u003d blocks[blockIndex];\n                    final int pStart \u003d iBlock * BLOCK_SIZE;\n                    final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n                    final int qStart \u003d jBlock * BLOCK_SIZE;\n                    final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                    int k \u003d 0;\n                    for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                        for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                            outBlock[k] \u003d tBlock[k] - m.getEntry(p, q);\n                            ++k;\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
    "begin_line": 354,
    "end_line": 389,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.subtract#399",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.subtract(org.apache.commons.math.linear.BlockRealMatrix)",
    "snippet": "public BlockRealMatrix subtract(final BlockRealMatrix m) {\n        // safety check\n        MatrixUtils.checkSubtractionCompatible(this, m);\n\n        final BlockRealMatrix out \u003d new BlockRealMatrix(rows, columns);\n\n        // perform subtraction block-wise, to ensure good cache behavior\n        for (int blockIndex \u003d 0; blockIndex \u003c out.blocks.length; ++blockIndex) {\n            final double[] outBlock \u003d out.blocks[blockIndex];\n            final double[] tBlock \u003d blocks[blockIndex];\n            final double[] mBlock \u003d m.blocks[blockIndex];\n            for (int k \u003d 0; k \u003c outBlock.length; ++k) {\n                outBlock[k] \u003d tBlock[k] - mBlock[k];\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 399,
    "end_line": 416,
    "comment": "/** \n * Subtract  {@code m} from this matrix.\n * @param m Matrix to be subtracted.\n * @return {@code this} - m.\n * @throws MatrixDimensionMismatchException if {@code m} is not thesame size as this matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.scalarAdd#420",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.scalarAdd(double)",
    "snippet": "@Override\n    public BlockRealMatrix scalarAdd(final double d) {\n\n        final BlockRealMatrix out \u003d new BlockRealMatrix(rows, columns);\n\n        // perform subtraction block-wise, to ensure good cache behavior\n        for (int blockIndex \u003d 0; blockIndex \u003c out.blocks.length; ++blockIndex) {\n            final double[] outBlock \u003d out.blocks[blockIndex];\n            final double[] tBlock \u003d blocks[blockIndex];\n            for (int k \u003d 0; k \u003c outBlock.length; ++k) {\n                outBlock[k] \u003d tBlock[k] + d;\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 420,
    "end_line": 434,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.scalarMultiply#438",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.scalarMultiply(double)",
    "snippet": "@Override\n    public RealMatrix scalarMultiply(final double d) {\n        final BlockRealMatrix out \u003d new BlockRealMatrix(rows, columns);\n\n        // perform subtraction block-wise, to ensure good cache behavior\n        for (int blockIndex \u003d 0; blockIndex \u003c out.blocks.length; ++blockIndex) {\n            final double[] outBlock \u003d out.blocks[blockIndex];\n            final double[] tBlock \u003d blocks[blockIndex];\n            for (int k \u003d 0; k \u003c outBlock.length; ++k) {\n                outBlock[k] \u003d tBlock[k] * d;\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 438,
    "end_line": 451,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.multiply#455",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.multiply(org.apache.commons.math.linear.RealMatrix)",
    "snippet": "@Override\n    public BlockRealMatrix multiply(final RealMatrix m) {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out \u003d new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex \u003d 0;\n            for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n                final int pStart \u003d iBlock * BLOCK_SIZE;\n                final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n                    final int qStart \u003d jBlock * BLOCK_SIZE;\n                    final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock \u003d out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock \u003d 0; kBlock \u003c blockColumns; ++kBlock) {\n                        final int kWidth \u003d blockWidth(kBlock);\n                        final double[] tBlock \u003d blocks[iBlock * blockColumns + kBlock];\n                        final int rStart \u003d kBlock * BLOCK_SIZE;\n                        int k \u003d 0;\n                        for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                            final int lStart \u003d (p - pStart) * kWidth;\n                            final int lEnd \u003d lStart + kWidth;\n                            for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                                double sum \u003d 0;\n                                int r \u003d rStart;\n                                for (int l \u003d lStart; l \u003c lEnd; ++l) {\n                                    sum +\u003d tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] +\u003d sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
    "begin_line": 455,
    "end_line": 505,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.multiply#515",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.multiply(org.apache.commons.math.linear.BlockRealMatrix)",
    "snippet": "public BlockRealMatrix multiply(BlockRealMatrix m) {\n        // safety check\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final BlockRealMatrix out \u003d new BlockRealMatrix(rows, m.columns);\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n\n            for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n                final int jWidth \u003d out.blockWidth(jBlock);\n                final int jWidth2 \u003d jWidth  + jWidth;\n                final int jWidth3 \u003d jWidth2 + jWidth;\n                final int jWidth4 \u003d jWidth3 + jWidth;\n\n                // select current block\n                final double[] outBlock \u003d out.blocks[blockIndex];\n\n                // perform multiplication on current block\n                for (int kBlock \u003d 0; kBlock \u003c blockColumns; ++kBlock) {\n                    final int kWidth \u003d blockWidth(kBlock);\n                    final double[] tBlock \u003d blocks[iBlock * blockColumns + kBlock];\n                    final double[] mBlock \u003d m.blocks[kBlock * m.blockColumns + jBlock];\n                    int k \u003d 0;\n                    for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                        final int lStart \u003d (p - pStart) * kWidth;\n                        final int lEnd \u003d lStart + kWidth;\n                        for (int nStart \u003d 0; nStart \u003c jWidth; ++nStart) {\n                            double sum \u003d 0;\n                            int l \u003d lStart;\n                            int n \u003d nStart;\n                            while (l \u003c lEnd - 3) {\n                                sum +\u003d tBlock[l] * mBlock[n] +\n                                       tBlock[l + 1] * mBlock[n + jWidth] +\n                                       tBlock[l + 2] * mBlock[n + jWidth2] +\n                                       tBlock[l + 3] * mBlock[n + jWidth3];\n                                l +\u003d 4;\n                                n +\u003d jWidth4;\n                            }\n                            while (l \u003c lEnd) {\n                                sum +\u003d tBlock[l++] * mBlock[n];\n                                n +\u003d jWidth;\n                            }\n                            outBlock[k] +\u003d sum;\n                            ++k;\n                        }\n                    }\n                }\n                // go to next block\n                ++blockIndex;\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 515,
    "end_line": 573,
    "comment": "/** \n * Returns the result of postmultiplying this by  {@code m}.\n * @param m Matrix to postmultiply by.\n * @return {@code this} * m.\n * @throws MatrixDimensionMismatchException if the matrices are notcompatible.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getData#577",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getData()",
    "snippet": "@Override\n    public double[][] getData() {\n        final double[][] data \u003d new double[getRowDimension()][getColumnDimension()];\n        final int lastColumns \u003d columns - (blockColumns - 1) * BLOCK_SIZE;\n\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            int regularPos \u003d 0;\n            int lastPos \u003d 0;\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                final double[] dataP \u003d data[p];\n                int blockIndex \u003d iBlock * blockColumns;\n                int dataPos \u003d 0;\n                for (int jBlock \u003d 0; jBlock \u003c blockColumns - 1; ++jBlock) {\n                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n                    dataPos +\u003d BLOCK_SIZE;\n                }\n                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n                regularPos +\u003d BLOCK_SIZE;\n                lastPos    +\u003d lastColumns;\n            }\n        }\n\n        return data;\n    }",
    "begin_line": 577,
    "end_line": 601,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getNorm#605",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getNorm()",
    "snippet": "@Override\n    public double getNorm() {\n        final double[] colSums \u003d new double[BLOCK_SIZE];\n        double maxColSum \u003d 0;\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; jBlock++) {\n            final int jWidth \u003d blockWidth(jBlock);\n            Arrays.fill(colSums, 0, jWidth, 0.0);\n            for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n                final int iHeight \u003d blockHeight(iBlock);\n                final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                for (int j \u003d 0; j \u003c jWidth; ++j) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c iHeight; ++i) {\n                        sum +\u003d FastMath.abs(block[i * jWidth + j]);\n                    }\n                    colSums[j] +\u003d sum;\n                }\n            }\n            for (int j \u003d 0; j \u003c jWidth; ++j) {\n                maxColSum \u003d FastMath.max(maxColSum, colSums[j]);\n            }\n        }\n        return maxColSum;\n    }",
    "begin_line": 605,
    "end_line": 627,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getFrobeniusNorm#631",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getFrobeniusNorm()",
    "snippet": "@Override\n    public double getFrobeniusNorm() {\n        double sum2 \u003d 0;\n        for (int blockIndex \u003d 0; blockIndex \u003c blocks.length; ++blockIndex) {\n            for (final double entry : blocks[blockIndex]) {\n                sum2 +\u003d entry * entry;\n            }\n        }\n        return FastMath.sqrt(sum2);\n    }",
    "begin_line": 631,
    "end_line": 639,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getSubMatrix#643",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getSubMatrix(int, int, int, int)",
    "snippet": "@Override\n    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn) {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out \u003d\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow \u003d startRow / BLOCK_SIZE;\n        final int rowsShift \u003d startRow % BLOCK_SIZE;\n        final int blockStartColumn \u003d startColumn / BLOCK_SIZE;\n        final int columnsShift \u003d startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock \u003d blockStartRow;\n        for (int iBlock \u003d 0; iBlock \u003c out.blockRows; ++iBlock) {\n            final int iHeight \u003d out.blockHeight(iBlock);\n            int qBlock \u003d blockStartColumn;\n            for (int jBlock \u003d 0; jBlock \u003c out.blockColumns; ++jBlock) {\n                final int jWidth \u003d out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex \u003d iBlock * out.blockColumns + jBlock;\n                final double[] outBlock \u003d out.blocks[outIndex];\n                final int index \u003d pBlock * blockColumns + qBlock;\n                final int width \u003d blockWidth(qBlock);\n\n                final int heightExcess \u003d iHeight + rowsShift - BLOCK_SIZE;\n                final int widthExcess \u003d jWidth + columnsShift - BLOCK_SIZE;\n                if (heightExcess \u003e 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess \u003e 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 \u003d blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess \u003e 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 \u003d blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
    "begin_line": 643,
    "end_line": 733,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.copyBlockPart#750",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.copyBlockPart(double[], int, int, int, int, int, double[], int, int, int)",
    "snippet": "private void copyBlockPart(final double[] srcBlock, final int srcWidth,\n                               final int srcStartRow, final int srcEndRow,\n                               final int srcStartColumn, final int srcEndColumn,\n                               final double[] dstBlock, final int dstWidth,\n                               final int dstStartRow, final int dstStartColumn) {\n        final int length \u003d srcEndColumn - srcStartColumn;\n        int srcPos \u003d srcStartRow * srcWidth + srcStartColumn;\n        int dstPos \u003d dstStartRow * dstWidth + dstStartColumn;\n        for (int srcRow \u003d srcStartRow; srcRow \u003c srcEndRow; ++srcRow) {\n            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);\n            srcPos +\u003d srcWidth;\n            dstPos +\u003d dstWidth;\n        }\n    }",
    "begin_line": 750,
    "end_line": 763,
    "comment": "/** \n * Copy a part of a block into another one \u003cp\u003eThis method can be called only when the specified part fits in both blocks, no verification is done here.\u003c/p\u003e\n * @param srcBlock source block\n * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)\n * @param srcStartRow start row in the source block\n * @param srcEndRow end row (exclusive) in the source block\n * @param srcStartColumn start column in the source block\n * @param srcEndColumn end column (exclusive) in the source block\n * @param dstBlock destination block\n * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)\n * @param dstStartRow start row in the destination block\n * @param dstStartColumn start column in the destination block\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setSubMatrix#767",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setSubMatrix(double[][], int, int)",
    "snippet": "@Override\n    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) {\n        // safety checks\n        final int refLength \u003d subMatrix[0].length;\n        if (refLength \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n        final int endRow \u003d row + subMatrix.length - 1;\n        final int endColumn \u003d column + refLength - 1;\n        MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);\n        for (final double[] subRow : subMatrix) {\n            if (subRow.length !\u003d refLength) {\n                throw new DimensionMismatchException(refLength, subRow.length);\n            }\n        }\n\n        // compute blocks bounds\n        final int blockStartRow \u003d row / BLOCK_SIZE;\n        final int blockEndRow \u003d (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n        final int blockStartColumn \u003d column / BLOCK_SIZE;\n        final int blockEndColumn \u003d (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n\n        // perform copy block-wise, to ensure good cache behavior\n        for (int iBlock \u003d blockStartRow; iBlock \u003c blockEndRow; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final int firstRow \u003d iBlock * BLOCK_SIZE;\n            final int iStart \u003d FastMath.max(row,    firstRow);\n            final int iEnd \u003d FastMath.min(endRow + 1, firstRow + iHeight);\n\n            for (int jBlock \u003d blockStartColumn; jBlock \u003c blockEndColumn; ++jBlock) {\n                final int jWidth \u003d blockWidth(jBlock);\n                final int firstColumn \u003d jBlock * BLOCK_SIZE;\n                final int jStart \u003d FastMath.max(column,    firstColumn);\n                final int jEnd \u003d FastMath.min(endColumn + 1, firstColumn + jWidth);\n                final int jLength \u003d jEnd - jStart;\n\n                // handle one block, row by row\n                final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                for (int i \u003d iStart; i \u003c iEnd; ++i) {\n                    System.arraycopy(subMatrix[i - row], jStart - column,\n                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),\n                                     jLength);\n                }\n\n            }\n        }\n    }",
    "begin_line": 767,
    "end_line": 812,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getRowMatrix#816",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getRowMatrix(int)",
    "snippet": "@Override\n    public BlockRealMatrix getRowMatrix(final int row) {\n        MatrixUtils.checkRowIndex(this, row);\n        final BlockRealMatrix out \u003d new BlockRealMatrix(1, columns);\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock \u003d row / BLOCK_SIZE;\n        final int iRow \u003d row - iBlock * BLOCK_SIZE;\n        int outBlockIndex \u003d 0;\n        int outIndex \u003d 0;\n        double[] outBlock \u003d out.blocks[outBlockIndex];\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth \u003d blockWidth(jBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            final int available \u003d outBlock.length - outIndex;\n            if (jWidth \u003e available) {\n                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n                outBlock \u003d out.blocks[++outBlockIndex];\n                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);\n                outIndex \u003d jWidth - available;\n            } else {\n                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);\n                outIndex +\u003d jWidth;\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 816,
    "end_line": 842,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setRowMatrix#846",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setRowMatrix(int, org.apache.commons.math.linear.RealMatrix)",
    "snippet": "@Override\n    public void setRowMatrix(final int row, final RealMatrix matrix) {\n        try {\n            setRowMatrix(row, (BlockRealMatrix) matrix);\n        } catch (ClassCastException cce) {\n            super.setRowMatrix(row, matrix);\n        }\n    }",
    "begin_line": 846,
    "end_line": 852,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setRowMatrix#866",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setRowMatrix(int, org.apache.commons.math.linear.BlockRealMatrix)",
    "snippet": "public void setRowMatrix(final int row, final BlockRealMatrix matrix) {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols \u003d getColumnDimension();\n        if ((matrix.getRowDimension() !\u003d 1) ||\n            (matrix.getColumnDimension() !\u003d nCols)) {\n            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n                                                       matrix.getColumnDimension(),\n                                                       1, nCols);\n        }\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock \u003d row / BLOCK_SIZE;\n        final int iRow \u003d row - iBlock * BLOCK_SIZE;\n        int mBlockIndex \u003d 0;\n        int mIndex \u003d 0;\n        double[] mBlock \u003d matrix.blocks[mBlockIndex];\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth \u003d blockWidth(jBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            final int available  \u003d mBlock.length - mIndex;\n            if (jWidth \u003e available) {\n                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);\n                mBlock \u003d matrix.blocks[++mBlockIndex];\n                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);\n                mIndex \u003d jWidth - available;\n            } else {\n                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);\n                mIndex +\u003d jWidth;\n           }\n        }\n    }",
    "begin_line": 866,
    "end_line": 896,
    "comment": "/** \n * Sets the entries in row number \u003ccode\u003erow\u003c/code\u003e as a row matrix.  Row indices start at 0.\n * @param row the row to be set\n * @param matrix row matrix (must have one row and the same number of columnsas the instance)\n * @throws org.apache.commons.math.exception.OutOfRangeException if the specified row index is invalid.\n * @throws MatrixDimensionMismatchException if the matrix dimensions donot match one instance row.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getColumnMatrix#900",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getColumnMatrix(int)",
    "snippet": "@Override\n    public BlockRealMatrix getColumnMatrix(final int column) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final BlockRealMatrix out \u003d new BlockRealMatrix(rows, 1);\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth \u003d blockWidth(jBlock);\n        int outBlockIndex \u003d 0;\n        int outIndex \u003d 0;\n        double[] outBlock \u003d out.blocks[outBlockIndex];\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                if (outIndex \u003e\u003d outBlock.length) {\n                    outBlock \u003d out.blocks[++outBlockIndex];\n                    outIndex \u003d 0;\n                }\n                outBlock[outIndex++] \u003d block[i * jWidth + jColumn];\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 900,
    "end_line": 924,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setColumnMatrix#928",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setColumnMatrix(int, org.apache.commons.math.linear.RealMatrix)",
    "snippet": "@Override\n    public void setColumnMatrix(final int column, final RealMatrix matrix) {\n        try {\n            setColumnMatrix(column, (BlockRealMatrix) matrix);\n        } catch (ClassCastException cce) {\n            super.setColumnMatrix(column, matrix);\n        }\n    }",
    "begin_line": 928,
    "end_line": 934,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setColumnMatrix#948",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setColumnMatrix(int, org.apache.commons.math.linear.BlockRealMatrix)",
    "snippet": "void setColumnMatrix(final int column, final BlockRealMatrix matrix) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows \u003d getRowDimension();\n        if ((matrix.getRowDimension() !\u003d nRows) ||\n            (matrix.getColumnDimension() !\u003d 1)) {\n            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n                                                       matrix.getColumnDimension(),\n                                                       nRows, 1);\n        }\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth \u003d blockWidth(jBlock);\n        int mBlockIndex \u003d 0;\n        int mIndex \u003d 0;\n        double[] mBlock \u003d matrix.blocks[mBlockIndex];\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                if (mIndex \u003e\u003d mBlock.length) {\n                    mBlock \u003d matrix.blocks[++mBlockIndex];\n                    mIndex \u003d 0;\n                }\n                block[i * jWidth + jColumn] \u003d mBlock[mIndex++];\n            }\n        }\n    }",
    "begin_line": 948,
    "end_line": 976,
    "comment": "/** \n * Sets the entries in column number \u003ccode\u003ecolumn\u003c/code\u003e as a column matrix.  Column indices start at 0.\n * @param column the column to be set\n * @param matrix column matrix (must have one column and the same number of rowsas the instance)\n * @throws org.apache.commons.math.exception.OutOfRangeException if the specified column index is invalid.\n * @throws MatrixDimensionMismatchException if the matrix dimensions donot match one instance column.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getRowVector#980",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getRowVector(int)",
    "snippet": "@Override\n    public RealVector getRowVector(final int row) {\n        MatrixUtils.checkRowIndex(this, row);\n        final double[] outData \u003d new double[columns];\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock \u003d row / BLOCK_SIZE;\n        final int iRow \u003d row - iBlock * BLOCK_SIZE;\n        int outIndex \u003d 0;\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth \u003d blockWidth(jBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n            outIndex +\u003d jWidth;\n        }\n\n        return new ArrayRealVector(outData, false);\n    }",
    "begin_line": 980,
    "end_line": 996,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setRowVector#1000",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setRowVector(int, org.apache.commons.math.linear.RealVector)",
    "snippet": "@Override\n    public void setRowVector(final int row, final RealVector vector) {\n        try {\n            setRow(row, ((ArrayRealVector) vector).getDataRef());\n        } catch (ClassCastException cce) {\n            super.setRowVector(row, vector);\n        }\n    }",
    "begin_line": 1000,
    "end_line": 1006,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getColumnVector#1010",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getColumnVector(int)",
    "snippet": "@Override\n    public RealVector getColumnVector(final int column) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final double[] outData \u003d new double[rows];\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth \u003d blockWidth(jBlock);\n        int outIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                outData[outIndex++] \u003d block[i * jWidth + jColumn];\n            }\n        }\n\n        return new ArrayRealVector(outData, false);\n    }",
    "begin_line": 1010,
    "end_line": 1028,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setColumnVector#1032",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setColumnVector(int, org.apache.commons.math.linear.RealVector)",
    "snippet": "@Override\n    public void setColumnVector(final int column, final RealVector vector) {\n        try {\n            setColumn(column, ((ArrayRealVector) vector).getDataRef());\n        } catch (ClassCastException cce) {\n            super.setColumnVector(column, vector);\n        }\n    }",
    "begin_line": 1032,
    "end_line": 1038,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getRow#1042",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getRow(int)",
    "snippet": "@Override\n    public double[] getRow(final int row) {\n        MatrixUtils.checkRowIndex(this, row);\n        final double[] out \u003d new double[columns];\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock \u003d row / BLOCK_SIZE;\n        final int iRow \u003d row - iBlock * BLOCK_SIZE;\n        int outIndex \u003d 0;\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth     \u003d blockWidth(jBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);\n            outIndex +\u003d jWidth;\n        }\n\n        return out;\n    }",
    "begin_line": 1042,
    "end_line": 1058,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setRow#1062",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setRow(int, double[])",
    "snippet": "@Override\n    public void setRow(final int row, final double[] array) {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols \u003d getColumnDimension();\n        if (array.length !\u003d nCols) {\n            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);\n        }\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int iBlock \u003d row / BLOCK_SIZE;\n        final int iRow \u003d row - iBlock * BLOCK_SIZE;\n        int outIndex \u003d 0;\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth     \u003d blockWidth(jBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n            outIndex +\u003d jWidth;\n        }\n    }",
    "begin_line": 1062,
    "end_line": 1079,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getColumn#1083",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getColumn(int)",
    "snippet": "@Override\n    public double[] getColumn(final int column) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final double[] out \u003d new double[rows];\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock  \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth  \u003d blockWidth(jBlock);\n        int outIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                out[outIndex++] \u003d block[i * jWidth + jColumn];\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 1083,
    "end_line": 1101,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setColumn#1105",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setColumn(int, double[])",
    "snippet": "@Override\n    public void setColumn(final int column, final double[] array) {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows \u003d getRowDimension();\n        if (array.length !\u003d nRows) {\n            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n        }\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock  \u003d column / BLOCK_SIZE;\n        final int jColumn \u003d column - jBlock * BLOCK_SIZE;\n        final int jWidth \u003d blockWidth(jBlock);\n        int outIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int iHeight \u003d blockHeight(iBlock);\n            final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n            for (int i \u003d 0; i \u003c iHeight; ++i) {\n                block[i * jWidth + jColumn] \u003d array[outIndex++];\n            }\n        }\n    }",
    "begin_line": 1105,
    "end_line": 1124,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getEntry#1128",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getEntry(int, int)",
    "snippet": "@Override\n    public double getEntry(final int row, final int column) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        final int iBlock \u003d row / BLOCK_SIZE;\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int k \u003d (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n            (column - jBlock * BLOCK_SIZE);\n        return blocks[iBlock * blockColumns + jBlock][k];\n    }",
    "begin_line": 1128,
    "end_line": 1135,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.setEntry#1139",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setEntry(int, int, double)",
    "snippet": "@Override\n    public void setEntry(final int row, final int column, final double value) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        final int iBlock \u003d row / BLOCK_SIZE;\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int k \u003d (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n            (column - jBlock * BLOCK_SIZE);\n        blocks[iBlock * blockColumns + jBlock][k] \u003d value;\n    }",
    "begin_line": 1139,
    "end_line": 1146,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.addToEntry#1150",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.addToEntry(int, int, double)",
    "snippet": "@Override\n    public void addToEntry(final int row, final int column, final double increment) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        final int iBlock \u003d row    / BLOCK_SIZE;\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int k \u003d (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n            (column - jBlock * BLOCK_SIZE);\n        blocks[iBlock * blockColumns + jBlock][k] +\u003d increment;\n    }",
    "begin_line": 1150,
    "end_line": 1157,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.multiplyEntry#1161",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.multiplyEntry(int, int, double)",
    "snippet": "@Override\n    public void multiplyEntry(final int row, final int column, final double factor) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        final int iBlock \u003d row / BLOCK_SIZE;\n        final int jBlock \u003d column / BLOCK_SIZE;\n        final int k \u003d (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n            (column - jBlock * BLOCK_SIZE);\n        blocks[iBlock * blockColumns + jBlock][k] *\u003d factor;\n    }",
    "begin_line": 1161,
    "end_line": 1168,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.transpose#1172",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.transpose()",
    "snippet": "@Override\n    public BlockRealMatrix transpose() {\n        final int nRows \u003d getRowDimension();\n        final int nCols \u003d getColumnDimension();\n        final BlockRealMatrix out \u003d new BlockRealMatrix(nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockColumns; ++iBlock) {\n            for (int jBlock \u003d 0; jBlock \u003c blockRows; ++jBlock) {\n                // transpose current block\n                final double[] outBlock \u003d out.blocks[blockIndex];\n                final double[] tBlock \u003d blocks[jBlock * blockColumns + iBlock];\n                final int pStart \u003d iBlock * BLOCK_SIZE;\n                final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    final int lInc \u003d pEnd - pStart;\n                    int l \u003d p - pStart;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        outBlock[k] \u003d tBlock[l];\n                        ++k;\n                        l+\u003d lInc;\n                    }\n                }\n                // go to next block\n                ++blockIndex;\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 1172,
    "end_line": 1204,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getRowDimension#1208",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getRowDimension()",
    "snippet": "@Override\n    public int getRowDimension() {\n        return rows;\n    }",
    "begin_line": 1208,
    "end_line": 1210,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.getColumnDimension#1214",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getColumnDimension()",
    "snippet": "@Override\n    public int getColumnDimension() {\n        return columns;\n    }",
    "begin_line": 1214,
    "end_line": 1216,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.operate#1220",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.operate(double[])",
    "snippet": "@Override\n    public double[] operate(final double[] v) {\n        if (v.length !\u003d columns) {\n            throw new DimensionMismatchException(v.length, columns);\n        }\n        final double[] out \u003d new double[rows];\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final double[] block  \u003d blocks[iBlock * blockColumns + jBlock];\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                int k \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    double sum \u003d 0;\n                    int q \u003d qStart;\n                    while (q \u003c qEnd - 3) {\n                        sum +\u003d block[k]     * v[q]     +\n                               block[k + 1] * v[q + 1] +\n                               block[k + 2] * v[q + 2] +\n                               block[k + 3] * v[q + 3];\n                        k +\u003d 4;\n                        q +\u003d 4;\n                    }\n                    while (q \u003c qEnd) {\n                        sum +\u003d block[k++] * v[q++];\n                    }\n                    out[p] +\u003d sum;\n                }\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 1220,
    "end_line": 1255,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.preMultiply#1259",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.preMultiply(double[])",
    "snippet": "@Override\n    public double[] preMultiply(final double[] v) {\n        if (v.length !\u003d rows) {\n            throw new DimensionMismatchException(v.length, rows);\n        }\n        final double[] out \u003d new double[columns];\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n            final int jWidth  \u003d blockWidth(jBlock);\n            final int jWidth2 \u003d jWidth  + jWidth;\n            final int jWidth3 \u003d jWidth2 + jWidth;\n            final int jWidth4 \u003d jWidth3 + jWidth;\n            final int qStart \u003d jBlock * BLOCK_SIZE;\n            final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n            for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n                final double[] block  \u003d blocks[iBlock * blockColumns + jBlock];\n                final int pStart \u003d iBlock * BLOCK_SIZE;\n                final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n                for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                    int k \u003d q - qStart;\n                    double sum \u003d 0;\n                    int p \u003d pStart;\n                    while (p \u003c pEnd - 3) {\n                        sum +\u003d block[k]           * v[p]     +\n                               block[k + jWidth]  * v[p + 1] +\n                               block[k + jWidth2] * v[p + 2] +\n                               block[k + jWidth3] * v[p + 3];\n                        k +\u003d jWidth4;\n                        p +\u003d 4;\n                    }\n                    while (p \u003c pEnd) {\n                        sum +\u003d block[k] * v[p++];\n                        k +\u003d jWidth;\n                    }\n                    out[q] +\u003d sum;\n                }\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 1259,
    "end_line": 1299,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.walkInRowOrder#1303",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor)",
    "snippet": "@Override\n    public double walkInRowOrder(final RealMatrixChangingVisitor visitor) {\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                    final int jWidth \u003d blockWidth(jBlock);\n                    final int qStart \u003d jBlock * BLOCK_SIZE;\n                    final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                    final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                    int k \u003d (p - pStart) * jWidth;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        block[k] \u003d visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1303,
    "end_line": 1323,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.walkInRowOrder#1327",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
    "snippet": "@Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                    final int jWidth \u003d blockWidth(jBlock);\n                    final int qStart \u003d jBlock * BLOCK_SIZE;\n                    final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                    final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                    int k \u003d (p - pStart) * jWidth;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1327,
    "end_line": 1347,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.walkInRowOrder#1351",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor, int, int, int, int)",
    "snippet": "@Override\n    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock \u003d startRow / BLOCK_SIZE; iBlock \u003c 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 \u003d iBlock * BLOCK_SIZE;\n            final int pStart \u003d FastMath.max(startRow, p0);\n            final int pEnd \u003d FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                for (int jBlock \u003d startColumn / BLOCK_SIZE; jBlock \u003c 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth \u003d blockWidth(jBlock);\n                    final int q0 \u003d jBlock * BLOCK_SIZE;\n                    final int qStart \u003d FastMath.max(startColumn, q0);\n                    final int qEnd \u003d FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                    int k \u003d (p - p0) * jWidth + qStart - q0;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        block[k] \u003d visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1351,
    "end_line": 1376,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.walkInRowOrder#1380",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor, int, int, int, int)",
    "snippet": "@Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock \u003d startRow / BLOCK_SIZE; iBlock \u003c 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 \u003d iBlock * BLOCK_SIZE;\n            final int pStart \u003d FastMath.max(startRow, p0);\n            final int pEnd \u003d FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                for (int jBlock \u003d startColumn / BLOCK_SIZE; jBlock \u003c 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth \u003d blockWidth(jBlock);\n                    final int q0 \u003d jBlock * BLOCK_SIZE;\n                    final int qStart \u003d FastMath.max(startColumn, q0);\n                    final int qEnd \u003d FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                    int k \u003d (p - p0) * jWidth + qStart - q0;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1380,
    "end_line": 1405,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.walkInOptimizedOrder#1409",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor)",
    "snippet": "@Override\n    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor) {\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                final double[] block \u003d blocks[blockIndex];\n                int k \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        block[k] \u003d visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n                ++blockIndex;\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1409,
    "end_line": 1430,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.walkInOptimizedOrder#1434",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
    "snippet": "@Override\n    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        int blockIndex \u003d 0;\n        for (int iBlock \u003d 0; iBlock \u003c blockRows; ++iBlock) {\n            final int pStart \u003d iBlock * BLOCK_SIZE;\n            final int pEnd \u003d FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int jBlock \u003d 0; jBlock \u003c blockColumns; ++jBlock) {\n                final int qStart \u003d jBlock * BLOCK_SIZE;\n                final int qEnd \u003d FastMath.min(qStart + BLOCK_SIZE, columns);\n                final double[] block \u003d blocks[blockIndex];\n                int k \u003d 0;\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n                ++blockIndex;\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1434,
    "end_line": 1455,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.walkInOptimizedOrder#1459",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixChangingVisitor, int, int, int, int)",
    "snippet": "@Override\n    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock \u003d startRow / BLOCK_SIZE; iBlock \u003c 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 \u003d iBlock * BLOCK_SIZE;\n            final int pStart \u003d FastMath.max(startRow, p0);\n            final int pEnd \u003d FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock \u003d startColumn / BLOCK_SIZE; jBlock \u003c 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth \u003d blockWidth(jBlock);\n                final int q0 \u003d jBlock * BLOCK_SIZE;\n                final int qStart \u003d FastMath.max(startColumn, q0);\n                final int qEnd \u003d FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    int k \u003d (p - p0) * jWidth + qStart - q0;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        block[k] \u003d visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1459,
    "end_line": 1484,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.walkInOptimizedOrder#1488",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor, int, int, int, int)",
    "snippet": "@Override\n    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn, final int endColumn) {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock \u003d startRow / BLOCK_SIZE; iBlock \u003c 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 \u003d iBlock * BLOCK_SIZE;\n            final int pStart \u003d FastMath.max(startRow, p0);\n            final int pEnd \u003d FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock \u003d startColumn / BLOCK_SIZE; jBlock \u003c 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth \u003d blockWidth(jBlock);\n                final int q0 \u003d jBlock * BLOCK_SIZE;\n                final int qStart \u003d FastMath.max(startColumn, q0);\n                final int qEnd \u003d FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block \u003d blocks[iBlock * blockColumns + jBlock];\n                for (int p \u003d pStart; p \u003c pEnd; ++p) {\n                    int k \u003d (p - p0) * jWidth + qStart - q0;\n                    for (int q \u003d qStart; q \u003c qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
    "begin_line": 1488,
    "end_line": 1513,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.blockHeight#1520",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.blockHeight(int)",
    "snippet": "private int blockHeight(final int blockRow) {\n        return (blockRow \u003d\u003d blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "begin_line": 1520,
    "end_line": 1522,
    "comment": "/** \n * Get the height of a block.\n * @param blockRow row index (in block sense) of the block\n * @return height (number of rows) of the block\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BlockRealMatrix.blockWidth#1529",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/BlockRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.blockWidth(int)",
    "snippet": "private int blockWidth(final int blockColumn) {\n        return (blockColumn \u003d\u003d blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "begin_line": 1529,
    "end_line": 1531,
    "comment": "/** \n * Get the width of a block.\n * @param blockColumn column index (in block sense) of the block\n * @return width (number of columns) of the block\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.MatrixUtils#48",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.MatrixUtils()",
    "snippet": "private MatrixUtils() {\n        super();\n    }",
    "begin_line": 48,
    "end_line": 50,
    "comment": "/** \n * Private constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createRealMatrix#65",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(int, int)",
    "snippet": "public static RealMatrix createRealMatrix(final int rows, final int columns) {\n        return (rows * columns \u003c\u003d 4096) ?\n                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n    }",
    "begin_line": 65,
    "end_line": 68,
    "comment": "/** \n * Returns a  {@link RealMatrix} with specified dimensions.\u003cp\u003eThe type of matrix returned depends on the dimension. Below 2\u003csup\u003e12\u003c/sup\u003e elements (i.e. 4096 elements or 64\u0026times;64 for a square matrix) which can be stored in a 32kB array, a  {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.\u003c/p\u003e\u003cp\u003eThe matrix elements are all set to 0.0.\u003c/p\u003e\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  RealMatrix with specified dimensions\n * @see #createRealMatrix(double[][])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createFieldMatrix#85",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createFieldMatrix(org.apache.commons.math.Field\u003cT\u003e, int, int)",
    "snippet": "public static \u003cT extends FieldElement\u003cT\u003e\u003e FieldMatrix\u003cT\u003e createFieldMatrix(final Field\u003cT\u003e field,\n                                                                               final int rows,\n                                                                               final int columns) {\n        return (rows * columns \u003c\u003d 4096) ?\n                new Array2DRowFieldMatrix\u003cT\u003e(field, rows, columns) : new BlockFieldMatrix\u003cT\u003e(field, rows, columns);\n    }",
    "begin_line": 85,
    "end_line": 90,
    "comment": "/** \n * Returns a  {@link FieldMatrix} with specified dimensions.\u003cp\u003eThe type of matrix returned depends on the dimension. Below 2\u003csup\u003e12\u003c/sup\u003e elements (i.e. 4096 elements or 64\u0026times;64 for a square matrix), a  {@link FieldMatrix} instance is built. Abovethis threshold a  {@link BlockFieldMatrix} instance is built.\u003c/p\u003e\u003cp\u003eThe matrix elements are all set to field.getZero().\u003c/p\u003e\n * @param \u003c T \u003e the type of the field elements\n * @param field field to which the matrix elements belong\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  FieldMatrix with specified dimensions\n * @see #createFieldMatrix(FieldElement[][])\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createRealMatrix#111",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(double[][])",
    "snippet": "public static RealMatrix createRealMatrix(double[][] data) {\n        if (data \u003d\u003d null ||\n            data[0] \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        return (data.length * data[0].length \u003c\u003d 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }",
    "begin_line": 111,
    "end_line": 118,
    "comment": "/** \n * Returns a  {@link RealMatrix} whose entries are the the values in thethe input array. \u003cp\u003eThe type of matrix returned depends on the dimension. Below 2\u003csup\u003e12\u003c/sup\u003e elements (i.e. 4096 elements or 64\u0026times;64 for a square matrix) which can be stored in a 32kB array, a  {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.\u003c/p\u003e\u003cp\u003eThe input array is copied, not referenced.\u003c/p\u003e\n * @param data input array\n * @return  RealMatrix containing the values of the array\n * @throws org.apache.commons.math.exception.DimensionMismatchException if  {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}is  {@code null}.\n * @see #createRealMatrix(int,int)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createFieldMatrix#139",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createFieldMatrix(T[][])",
    "snippet": "public static \u003cT extends FieldElement\u003cT\u003e\u003e FieldMatrix\u003cT\u003e createFieldMatrix(T[][] data) {\n        if (data \u003d\u003d null ||\n            data[0] \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        return (data.length * data[0].length \u003c\u003d 4096) ?\n                new Array2DRowFieldMatrix\u003cT\u003e(data) : new BlockFieldMatrix\u003cT\u003e(data);\n    }",
    "begin_line": 139,
    "end_line": 146,
    "comment": "/** \n * Returns a  {@link FieldMatrix} whose entries are the the values in thethe input array. \u003cp\u003eThe type of matrix returned depends on the dimension. Below 2\u003csup\u003e12\u003c/sup\u003e elements (i.e. 4096 elements or 64\u0026times;64 for a square matrix), a  {@link FieldMatrix} instance is built. Abovethis threshold a  {@link BlockFieldMatrix} instance is built.\u003c/p\u003e\u003cp\u003eThe input array is copied, not referenced.\u003c/p\u003e\n * @param \u003c T \u003e the type of the field elements\n * @param data input array\n * @return a matrix containing the values of the array.\n * @throws org.apache.commons.math.exception.DimensionMismatchException if  {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}is  {@code null}.\n * @see #createFieldMatrix(Field,int,int)\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createRealIdentityMatrix#156",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(int)",
    "snippet": "public static RealMatrix createRealIdentityMatrix(int dimension) {\n        final RealMatrix m \u003d createRealMatrix(dimension, dimension);\n        for (int i \u003d 0; i \u003c dimension; ++i) {\n            m.setEntry(i, i, 1.0);\n        }\n        return m;\n    }",
    "begin_line": 156,
    "end_line": 162,
    "comment": "/** \n * Returns \u003ccode\u003edimension x dimension\u003c/code\u003e identity matrix.\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createFieldIdentityMatrix#175",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createFieldIdentityMatrix(org.apache.commons.math.Field\u003cT\u003e, int)",
    "snippet": "public static \u003cT extends FieldElement\u003cT\u003e\u003e FieldMatrix\u003cT\u003e createFieldIdentityMatrix(final Field\u003cT\u003e field, final int dimension) {\n        final T zero \u003d field.getZero();\n        final T one  \u003d field.getOne();\n        @SuppressWarnings(\"unchecked\") // zero is type T\n        final T[][] d \u003d (T[][]) Array.newInstance(zero.getClass(), new int[] { dimension, dimension });\n        for (int row \u003d 0; row \u003c dimension; row++) {\n            final T[] dRow \u003d d[row];\n            Arrays.fill(dRow, zero);\n            dRow[row] \u003d one;\n        }\n        return new Array2DRowFieldMatrix\u003cT\u003e(field, d, false);\n    }",
    "begin_line": 175,
    "end_line": 186,
    "comment": "/** \n * Returns \u003ccode\u003edimension x dimension\u003c/code\u003e identity matrix.\n * @param \u003c T \u003e the type of the field elements\n * @param field field to which the elements belong\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createRealDiagonalMatrix#196",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(double[])",
    "snippet": "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n        final RealMatrix m \u003d createRealMatrix(diagonal.length, diagonal.length);\n        for (int i \u003d 0; i \u003c diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }",
    "begin_line": 196,
    "end_line": 202,
    "comment": "/** \n * Returns a diagonal matrix with specified elements.\n * @param diagonal diagonal elements of the matrix (the array elementswill be copied)\n * @return diagonal matrix\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createFieldDiagonalMatrix#214",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createFieldDiagonalMatrix(T[])",
    "snippet": "public static \u003cT extends FieldElement\u003cT\u003e\u003e FieldMatrix\u003cT\u003e createFieldDiagonalMatrix(final T[] diagonal) {\n        final FieldMatrix\u003cT\u003e m \u003d\n            createFieldMatrix(diagonal[0].getField(), diagonal.length, diagonal.length);\n        for (int i \u003d 0; i \u003c diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }",
    "begin_line": 214,
    "end_line": 221,
    "comment": "/** \n * Returns a diagonal matrix with specified elements.\n * @param \u003c T \u003e the type of the field elements\n * @param diagonal diagonal elements of the matrix (the array elementswill be copied)\n * @return diagonal matrix\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createRealVector#231",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealVector(double[])",
    "snippet": "public static RealVector createRealVector(double[] data) {\n        if (data \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        return new ArrayRealVector(data, true);\n    }",
    "begin_line": 231,
    "end_line": 236,
    "comment": "/** \n * Creates a  {@link RealVector} using the data from the input array.\n * @param data the input data\n * @return a data.length RealVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createFieldVector#248",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createFieldVector(T[])",
    "snippet": "public static \u003cT extends FieldElement\u003cT\u003e\u003e FieldVector\u003cT\u003e createFieldVector(final T[] data) {\n        if (data \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        if (data.length \u003d\u003d 0) {\n            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n        }\n        return new ArrayFieldVector\u003cT\u003e(data[0].getField(), data, true);\n    }",
    "begin_line": 248,
    "end_line": 256,
    "comment": "/** \n * Creates a  {@link FieldVector} using the data from the input array.\n * @param \u003c T \u003e the type of the field elements\n * @param data the input data\n * @return a data.length FieldVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n * @throws ZeroException if {@code data} has 0 elements\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createRowRealMatrix#267",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRowRealMatrix(double[])",
    "snippet": "public static RealMatrix createRowRealMatrix(double[] rowData) {\n        if (rowData \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        final int nCols \u003d rowData.length;\n        final RealMatrix m \u003d createRealMatrix(1, nCols);\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            m.setEntry(0, i, rowData[i]);\n        }\n        return m;\n    }",
    "begin_line": 267,
    "end_line": 277,
    "comment": "/** \n * Create a row  {@link RealMatrix} using the data from the inputarray.\n * @param rowData the input row data\n * @return a 1 x rowData.length RealMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createRowFieldMatrix#290",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRowFieldMatrix(T[])",
    "snippet": "public static \u003cT extends FieldElement\u003cT\u003e\u003e FieldMatrix\u003cT\u003e createRowFieldMatrix(final T[] rowData) {\n        if (rowData \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        final int nCols \u003d rowData.length;\n        if (nCols \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n        final FieldMatrix\u003cT\u003e m \u003d createFieldMatrix(rowData[0].getField(), 1, nCols);\n        for (int i \u003d 0; i \u003c nCols; ++i) {\n            m.setEntry(0, i, rowData[i]);\n        }\n        return m;\n    }",
    "begin_line": 290,
    "end_line": 303,
    "comment": "/** \n * Create a row  {@link FieldMatrix} using the data from the inputarray.\n * @param \u003c T \u003e the type of the field elements\n * @param rowData the input row data\n * @return a 1 x rowData.length FieldMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createColumnRealMatrix#314",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createColumnRealMatrix(double[])",
    "snippet": "public static RealMatrix createColumnRealMatrix(double[] columnData) {\n        if (columnData \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        final int nRows \u003d columnData.length;\n        final RealMatrix m \u003d createRealMatrix(nRows, 1);\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
    "begin_line": 314,
    "end_line": 324,
    "comment": "/** \n * Creates a column  {@link RealMatrix} using the data from the inputarray.\n * @param columnData  the input column data\n * @return a columnData x 1 RealMatrix\n * @throws NoDataException if {@code columnData} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.createColumnFieldMatrix#337",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createColumnFieldMatrix(T[])",
    "snippet": "public static \u003cT extends FieldElement\u003cT\u003e\u003e FieldMatrix\u003cT\u003e createColumnFieldMatrix(final T[] columnData) {\n        if (columnData \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        final int nRows \u003d columnData.length;\n        if (nRows \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final FieldMatrix\u003cT\u003e m \u003d createFieldMatrix(columnData[0].getField(), nRows, 1);\n        for (int i \u003d 0; i \u003c nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
    "begin_line": 337,
    "end_line": 350,
    "comment": "/** \n * Creates a column  {@link FieldMatrix} using the data from the inputarray.\n * @param \u003c T \u003e the type of the field elements\n * @param columnData  the input column data\n * @return a columnData x 1 FieldMatrix\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.checkMatrixIndex#361",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkMatrixIndex(org.apache.commons.math.linear.AnyMatrix, int, int)",
    "snippet": "public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column) {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }",
    "begin_line": 361,
    "end_line": 365,
    "comment": "/** \n * Check if matrix indices are valid.\n * @param m Matrix.\n * @param row Row index to check.\n * @param column Column index to check.\n * @throws OutOfRangeException if {@code row} or {@code column} is nota valid index.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.checkRowIndex#374",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkRowIndex(org.apache.commons.math.linear.AnyMatrix, int)",
    "snippet": "public static void checkRowIndex(final AnyMatrix m, final int row) {\n        if (row \u003c 0 ||\n            row \u003e\u003d m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }",
    "begin_line": 374,
    "end_line": 380,
    "comment": "/** \n * Check if a row index is valid.\n * @param m Matrix.\n * @param row Row index to check.\n * @throws OutOfRangeException if {@code row} is not a valid index.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.checkColumnIndex#389",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(org.apache.commons.math.linear.AnyMatrix, int)",
    "snippet": "public static void checkColumnIndex(final AnyMatrix m, final int column) {\n        if (column \u003c 0 || column \u003e\u003d m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }",
    "begin_line": 389,
    "end_line": 394,
    "comment": "/** \n * Check if a column index is valid.\n * @param m Matrix.\n * @param column Column index to check.\n * @throws OutOfRangeException if {@code column} is not a valid index.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.checkSubMatrixIndex#409",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(org.apache.commons.math.linear.AnyMatrix, int, int, int, int)",
    "snippet": "public static void checkSubMatrixIndex(final AnyMatrix m,\n                                           final int startRow, final int endRow,\n                                           final int startColumn, final int endColumn) {\n        checkRowIndex(m, startRow);\n        checkRowIndex(m, endRow);\n        if (endRow \u003c startRow) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n                                                endRow, startRow, false);\n        }\n\n        checkColumnIndex(m, startColumn);\n        checkColumnIndex(m, endColumn);\n        if (endColumn \u003c startColumn) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n                                                endColumn, startColumn, false);\n        }\n\n\n    }",
    "begin_line": 409,
    "end_line": 427,
    "comment": "/** \n * Check if submatrix ranges indices are valid. Rows and columns are indicated counting from 0 to  {@code n - 1}.\n * @param m Matrix.\n * @param startRow Initial row index.\n * @param endRow Final row index.\n * @param startColumn Initial column index.\n * @param endColumn Final column index.\n * @throws OutOfRangeException if the indices are invalid.\n * @throws NumberIsTooSmallException if {@code endRow \u003c startRow} or{@code endColumn \u003c startColumn}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.checkSubMatrixIndex#442",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(org.apache.commons.math.linear.AnyMatrix, int[], int[])",
    "snippet": "public static void checkSubMatrixIndex(final AnyMatrix m,\n                                           final int[] selectedRows,\n                                           final int[] selectedColumns) {\n        if (selectedRows \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        if (selectedColumns \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n        if (selectedRows.length \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\n        }\n        if (selectedColumns.length \u003d\u003d 0) {\n            throw new NoDataException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\n        }\n\n        for (final int row : selectedRows) {\n            checkRowIndex(m, row);\n        }\n        for (final int column : selectedColumns) {\n            checkColumnIndex(m, column);\n        }\n    }",
    "begin_line": 442,
    "end_line": 464,
    "comment": "/** \n * Check if submatrix ranges indices are valid. Rows and columns are indicated counting from 0 to n-1.\n * @param m Matrix.\n * @param selectedRows Array of row indices.\n * @param selectedColumns Array of column indices.\n * @throws NullArgumentException if {@code selectedRows} or{@code selectedColumns} are {@code null}.\n * @throws NoDataException if the row or column selections are empty (zerolength).\n * @throws OutOfRangeException if row or column selections are not valid.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.checkAdditionCompatible#473",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(org.apache.commons.math.linear.AnyMatrix, org.apache.commons.math.linear.AnyMatrix)",
    "snippet": "public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right) {\n        if ((left.getRowDimension()    !\u003d right.getRowDimension()) ||\n            (left.getColumnDimension() !\u003d right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "begin_line": 473,
    "end_line": 479,
    "comment": "/** \n * Check if matrices are addition compatible.\n * @param left Left hand side matrix.\n * @param right Right hand side matrix.\n * @throws MatrixDimensionMismatchException if the matrices are not addition compatible.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.checkSubtractionCompatible#488",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(org.apache.commons.math.linear.AnyMatrix, org.apache.commons.math.linear.AnyMatrix)",
    "snippet": "public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right) {\n        if ((left.getRowDimension()    !\u003d right.getRowDimension()) ||\n            (left.getColumnDimension() !\u003d right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "begin_line": 488,
    "end_line": 494,
    "comment": "/** \n * Check if matrices are subtraction compatible\n * @param left Left hand side matrix.\n * @param right Right hand side matrix.\n * @throws MatrixDimensionMismatchException if the matrices are not addition compatible.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.checkMultiplicationCompatible#503",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(org.apache.commons.math.linear.AnyMatrix, org.apache.commons.math.linear.AnyMatrix)",
    "snippet": "public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right) {\n        if (left.getColumnDimension() !\u003d right.getRowDimension()) {\n            throw new DimensionMismatchException(left.getColumnDimension(),\n                                                 right.getRowDimension());\n        }\n    }",
    "begin_line": 503,
    "end_line": 508,
    "comment": "/** \n * Check if matrices are multiplication compatible\n * @param left Left hand side matrix.\n * @param right Right hand side matrix.\n * @throws DimensionMismatchException if matrices are not multiplication compatible.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MatrixUtils.fractionMatrixToRealMatrix#515",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.fractionMatrixToRealMatrix(org.apache.commons.math.linear.FieldMatrix\u003corg.apache.commons.math.fraction.Fraction\u003e)",
    "snippet": "public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix\u003cFraction\u003e m) {\n        final FractionMatrixConverter converter \u003d new FractionMatrixConverter();\n        m.walkInOptimizedOrder(converter);\n        return converter.getConvertedMatrix();\n    }",
    "begin_line": 515,
    "end_line": 519,
    "comment": "/** \n * Convert a  {@link FieldMatrix}/ {@link Fraction} matrix to a {@link RealMatrix}.\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FractionMatrixConverter.FractionMatrixConverter#526",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.FractionMatrixConverter()",
    "snippet": "public FractionMatrixConverter() {\n            super(Fraction.ZERO);\n        }",
    "begin_line": 526,
    "end_line": 528,
    "comment": "/** \n * Simple constructor. \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FractionMatrixConverter.start#532",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.start(int, int, int, int, int, int)",
    "snippet": "@Override\n        public void start(int rows, int columns,\n                          int startRow, int endRow, int startColumn, int endColumn) {\n            data \u003d new double[rows][columns];\n        }",
    "begin_line": 532,
    "end_line": 535,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FractionMatrixConverter.visit#539",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.visit(int, int, org.apache.commons.math.fraction.Fraction)",
    "snippet": "@Override\n        public void visit(int row, int column, Fraction value) {\n            data[row][column] \u003d value.doubleValue();\n        }",
    "begin_line": 539,
    "end_line": 541,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FractionMatrixConverter.getConvertedMatrix#548",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.getConvertedMatrix()",
    "snippet": "Array2DRowRealMatrix getConvertedMatrix() {\n            return new Array2DRowRealMatrix(data, false);\n        }",
    "begin_line": 548,
    "end_line": 550,
    "comment": "/** \n * Get the converted matrix.\n * @return the converted matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FractionMatrixConverter.bigFractionMatrixToRealMatrix#560",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.bigFractionMatrixToRealMatrix(org.apache.commons.math.linear.FieldMatrix\u003corg.apache.commons.math.fraction.BigFraction\u003e)",
    "snippet": "public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix\u003cBigFraction\u003e m) {\n        final BigFractionMatrixConverter converter \u003d new BigFractionMatrixConverter();\n        m.walkInOptimizedOrder(converter);\n        return converter.getConvertedMatrix();\n    }",
    "begin_line": 560,
    "end_line": 564,
    "comment": "/** \n * Convert a  {@link FieldMatrix}/ {@link BigFraction} matrix to a {@link RealMatrix}.\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigFractionMatrixConverter.BigFractionMatrixConverter#571",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.BigFractionMatrixConverter()",
    "snippet": "public BigFractionMatrixConverter() {\n            super(BigFraction.ZERO);\n        }",
    "begin_line": 571,
    "end_line": 573,
    "comment": "/** \n * Simple constructor. \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigFractionMatrixConverter.start#577",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.start(int, int, int, int, int, int)",
    "snippet": "@Override\n        public void start(int rows, int columns,\n                          int startRow, int endRow, int startColumn, int endColumn) {\n            data \u003d new double[rows][columns];\n        }",
    "begin_line": 577,
    "end_line": 580,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigFractionMatrixConverter.visit#584",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.visit(int, int, org.apache.commons.math.fraction.BigFraction)",
    "snippet": "@Override\n        public void visit(int row, int column, BigFraction value) {\n            data[row][column] \u003d value.doubleValue();\n        }",
    "begin_line": 584,
    "end_line": 586,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigFractionMatrixConverter.getConvertedMatrix#593",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.getConvertedMatrix()",
    "snippet": "Array2DRowRealMatrix getConvertedMatrix() {\n            return new Array2DRowRealMatrix(data, false);\n        }",
    "begin_line": 593,
    "end_line": 595,
    "comment": "/** \n * Get the converted matrix.\n * @return the converted matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigFractionMatrixConverter.serializeRealVector#638",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.serializeRealVector(org.apache.commons.math.linear.RealVector, java.io.ObjectOutputStream)",
    "snippet": "public static void serializeRealVector(final RealVector vector,\n                                           final ObjectOutputStream oos)\n        throws IOException {\n        final int n \u003d vector.getDimension();\n        oos.writeInt(n);\n        for (int i \u003d 0; i \u003c n; ++i) {\n            oos.writeDouble(vector.getEntry(i));\n        }\n    }",
    "begin_line": 638,
    "end_line": 646,
    "comment": "/** \n * Serialize a  {@link RealVector}. \u003cp\u003e This method is intended to be called from within a private \u003ccode\u003ewriteObject\u003c/code\u003e method (after a call to \u003ccode\u003eoos.defaultWriteObject()\u003c/code\u003e) in a class that has a {@link RealVector} field, which should be declared \u003ccode\u003etransient\u003c/code\u003e.This way, the default handling does not serialize the vector (the  {@link RealVector} interface is not serializable by default) but this method doesserialize it specifically. \u003c/p\u003e \u003cp\u003e The following example shows how a simple class with a name and a real vector should be written: \u003cpre\u003e\u003ccode\u003e public class NamedVector implements Serializable { private final String name; private final transient RealVector coefficients; // omitted constructors, getters ... private void writeObject(ObjectOutputStream oos) throws IOException { oos.defaultWriteObject();  // takes care of name field MatrixUtils.serializeRealVector(coefficients, oos); } private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException { ois.defaultReadObject();  // takes care of name field MatrixUtils.deserializeRealVector(this, \"coefficients\", ois); } } \u003c/code\u003e\u003c/pre\u003e \u003c/p\u003e\n * @param vector real vector to serialize\n * @param oos stream where the real vector should be written\n * @exception IOException if object cannot be written to stream\n * @see #deserializeRealVector(Object,String,ObjectInputStream)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigFractionMatrixConverter.deserializeRealVector#665",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.deserializeRealVector(java.lang.Object, java.lang.String, java.io.ObjectInputStream)",
    "snippet": "public static void deserializeRealVector(final Object instance,\n                                             final String fieldName,\n                                             final ObjectInputStream ois)\n      throws ClassNotFoundException, IOException {\n        try {\n\n            // read the vector data\n            final int n \u003d ois.readInt();\n            final double[] data \u003d new double[n];\n            for (int i \u003d 0; i \u003c n; ++i) {\n                data[i] \u003d ois.readDouble();\n            }\n\n            // create the instance\n            final RealVector vector \u003d new ArrayRealVector(data, false);\n\n            // set up the field\n            final java.lang.reflect.Field f \u003d\n                instance.getClass().getDeclaredField(fieldName);\n            f.setAccessible(true);\n            f.set(instance, vector);\n\n        } catch (NoSuchFieldException nsfe) {\n            IOException ioe \u003d new IOException();\n            ioe.initCause(nsfe);\n            throw ioe;\n        } catch (IllegalAccessException iae) {\n            IOException ioe \u003d new IOException();\n            ioe.initCause(iae);\n            throw ioe;\n        }\n\n    }",
    "begin_line": 665,
    "end_line": 697,
    "comment": "/** \n * Deserialize  a  {@link RealVector} field in a class.\u003cp\u003e This method is intended to be called from within a private \u003ccode\u003ereadObject\u003c/code\u003e method (after a call to \u003ccode\u003eois.defaultReadObject()\u003c/code\u003e) in a class that has a {@link RealVector} field, which should be declared \u003ccode\u003etransient\u003c/code\u003e.This way, the default handling does not deserialize the vector (the  {@link RealVector} interface is not serializable by default) but this method doesdeserialize it specifically. \u003c/p\u003e\n * @param instance instance in which the field must be set up\n * @param fieldName name of the field within the class (may be private and final)\n * @param ois stream from which the real vector should be read\n * @exception ClassNotFoundException if a class in the stream cannot be found\n * @exception IOException if object cannot be read from the stream\n * @see #serializeRealVector(RealVector,ObjectOutputStream)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigFractionMatrixConverter.serializeRealMatrix#739",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.serializeRealMatrix(org.apache.commons.math.linear.RealMatrix, java.io.ObjectOutputStream)",
    "snippet": "public static void serializeRealMatrix(final RealMatrix matrix,\n                                           final ObjectOutputStream oos)\n        throws IOException {\n        final int n \u003d matrix.getRowDimension();\n        final int m \u003d matrix.getColumnDimension();\n        oos.writeInt(n);\n        oos.writeInt(m);\n        for (int i \u003d 0; i \u003c n; ++i) {\n            for (int j \u003d 0; j \u003c m; ++j) {\n                oos.writeDouble(matrix.getEntry(i, j));\n            }\n        }\n    }",
    "begin_line": 739,
    "end_line": 751,
    "comment": "/** \n * Serialize a  {@link RealMatrix}. \u003cp\u003e This method is intended to be called from within a private \u003ccode\u003ewriteObject\u003c/code\u003e method (after a call to \u003ccode\u003eoos.defaultWriteObject()\u003c/code\u003e) in a class that has a {@link RealMatrix} field, which should be declared \u003ccode\u003etransient\u003c/code\u003e.This way, the default handling does not serialize the matrix (the  {@link RealMatrix} interface is not serializable by default) but this method doesserialize it specifically. \u003c/p\u003e \u003cp\u003e The following example shows how a simple class with a name and a real matrix should be written: \u003cpre\u003e\u003ccode\u003e public class NamedMatrix implements Serializable { private final String name; private final transient RealMatrix coefficients; // omitted constructors, getters ... private void writeObject(ObjectOutputStream oos) throws IOException { oos.defaultWriteObject();  // takes care of name field MatrixUtils.serializeRealMatrix(coefficients, oos); } private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException { ois.defaultReadObject();  // takes care of name field MatrixUtils.deserializeRealMatrix(this, \"coefficients\", ois); } } \u003c/code\u003e\u003c/pre\u003e \u003c/p\u003e\n * @param matrix real matrix to serialize\n * @param oos stream where the real matrix should be written\n * @exception IOException if object cannot be written to stream\n * @see #deserializeRealMatrix(Object,String,ObjectInputStream)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BigFractionMatrixConverter.deserializeRealMatrix#770",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/MatrixUtils.java",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.deserializeRealMatrix(java.lang.Object, java.lang.String, java.io.ObjectInputStream)",
    "snippet": "public static void deserializeRealMatrix(final Object instance,\n                                             final String fieldName,\n                                             final ObjectInputStream ois)\n      throws ClassNotFoundException, IOException {\n        try {\n\n            // read the matrix data\n            final int n \u003d ois.readInt();\n            final int m \u003d ois.readInt();\n            final double[][] data \u003d new double[n][m];\n            for (int i \u003d 0; i \u003c n; ++i) {\n                final double[] dataI \u003d data[i];\n                for (int j \u003d 0; j \u003c m; ++j) {\n                    dataI[j] \u003d ois.readDouble();\n                }\n            }\n\n            // create the instance\n            final RealMatrix matrix \u003d new Array2DRowRealMatrix(data, false);\n\n            // set up the field\n            final java.lang.reflect.Field f \u003d\n                instance.getClass().getDeclaredField(fieldName);\n            f.setAccessible(true);\n            f.set(instance, matrix);\n\n        } catch (NoSuchFieldException nsfe) {\n            IOException ioe \u003d new IOException();\n            ioe.initCause(nsfe);\n            throw ioe;\n        } catch (IllegalAccessException iae) {\n            IOException ioe \u003d new IOException();\n            ioe.initCause(iae);\n            throw ioe;\n        }\n    }",
    "begin_line": 770,
    "end_line": 805,
    "comment": "/** \n * Deserialize  a  {@link RealMatrix} field in a class.\u003cp\u003e This method is intended to be called from within a private \u003ccode\u003ereadObject\u003c/code\u003e method (after a call to \u003ccode\u003eois.defaultReadObject()\u003c/code\u003e) in a class that has a {@link RealMatrix} field, which should be declared \u003ccode\u003etransient\u003c/code\u003e.This way, the default handling does not deserialize the matrix (the  {@link RealMatrix} interface is not serializable by default) but this method doesdeserialize it specifically. \u003c/p\u003e\n * @param instance instance in which the field must be set up\n * @param fieldName name of the field within the class (may be private and final)\n * @param ois stream from which the real matrix should be read\n * @exception ClassNotFoundException if a class in the stream cannot be found\n * @exception IOException if object cannot be read from the stream\n * @see #serializeRealMatrix(RealMatrix,ObjectOutputStream)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.OpenMapRealMatrix#47",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.OpenMapRealMatrix(int, int)",
    "snippet": "public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n        super(rowDimension, columnDimension);\n        this.rows \u003d rowDimension;\n        this.columns \u003d columnDimension;\n        this.entries \u003d new OpenIntToDoubleHashMap(0.0);\n    }",
    "begin_line": 47,
    "end_line": 52,
    "comment": "/** \n * Build a sparse matrix with the supplied row and column dimensions.\n * @param rowDimension Number of rows of the matrix.\n * @param columnDimension Number of columns of the matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.OpenMapRealMatrix#59",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.OpenMapRealMatrix(org.apache.commons.math.linear.OpenMapRealMatrix)",
    "snippet": "public OpenMapRealMatrix(OpenMapRealMatrix matrix) {\n        this.rows \u003d matrix.rows;\n        this.columns \u003d matrix.columns;\n        this.entries \u003d new OpenIntToDoubleHashMap(matrix.entries);\n    }",
    "begin_line": 59,
    "end_line": 63,
    "comment": "/** \n * Build a matrix by copying another one.\n * @param matrix matrix to copy.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.copy#67",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.copy()",
    "snippet": "@Override\n    public OpenMapRealMatrix copy() {\n        return new OpenMapRealMatrix(this);\n    }",
    "begin_line": 67,
    "end_line": 69,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.createMatrix#73",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.createMatrix(int, int)",
    "snippet": "@Override\n    public OpenMapRealMatrix createMatrix(int rowDimension, int columnDimension) {\n        return new OpenMapRealMatrix(rowDimension, columnDimension);\n    }",
    "begin_line": 73,
    "end_line": 75,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.getColumnDimension#79",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.getColumnDimension()",
    "snippet": "@Override\n    public int getColumnDimension() {\n        return columns;\n    }",
    "begin_line": 79,
    "end_line": 81,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.add#91",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.add(org.apache.commons.math.linear.OpenMapRealMatrix)",
    "snippet": "public OpenMapRealMatrix add(OpenMapRealMatrix m) {\n\n        // safety check\n        MatrixUtils.checkAdditionCompatible(this, m);\n\n        final OpenMapRealMatrix out \u003d new OpenMapRealMatrix(this);\n        for (OpenIntToDoubleHashMap.Iterator iterator \u003d m.entries.iterator(); iterator.hasNext();) {\n            iterator.advance();\n            final int row \u003d iterator.key() / columns;\n            final int col \u003d iterator.key() - row * columns;\n            out.setEntry(row, col, getEntry(row, col) + iterator.value());\n        }\n\n        return out;\n\n    }",
    "begin_line": 91,
    "end_line": 106,
    "comment": "/** \n * Compute the sum of this matrix and  {@code m}.\n * @param m Matrix to be added.\n * @return {@code this} + {@code m}.\n * @throws org.apache.commons.math.exception.DimensionMismatchException if  {@code m} is not the same size as this matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.subtract#110",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.subtract(org.apache.commons.math.linear.RealMatrix)",
    "snippet": "@Override\n    public OpenMapRealMatrix subtract(final RealMatrix m) {\n        try {\n            return subtract((OpenMapRealMatrix) m);\n        } catch (ClassCastException cce) {\n            return (OpenMapRealMatrix) super.subtract(m);\n        }\n    }",
    "begin_line": 110,
    "end_line": 116,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.subtract#126",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.subtract(org.apache.commons.math.linear.OpenMapRealMatrix)",
    "snippet": "public OpenMapRealMatrix subtract(OpenMapRealMatrix m) {\n        // Safety check.\n        MatrixUtils.checkAdditionCompatible(this, m);\n\n        final OpenMapRealMatrix out \u003d new OpenMapRealMatrix(this);\n        for (OpenIntToDoubleHashMap.Iterator iterator \u003d m.entries.iterator(); iterator.hasNext();) {\n            iterator.advance();\n            final int row \u003d iterator.key() / columns;\n            final int col \u003d iterator.key() - row * columns;\n            out.setEntry(row, col, getEntry(row, col) - iterator.value());\n        }\n\n        return out;\n    }",
    "begin_line": 126,
    "end_line": 139,
    "comment": "/** \n * Subtract  {@code m} from this matrix.\n * @param m Matrix to be subtracted.\n * @return {@code this} - {@code m}.\n * @throws org.apache.commons.math.exception.DimensionMismatchException if  {@code m} is not the same size as this matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.multiply#143",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.multiply(org.apache.commons.math.linear.RealMatrix)",
    "snippet": "@Override\n    public RealMatrix multiply(final RealMatrix m) {\n        try {\n            return multiply((OpenMapRealMatrix) m);\n        } catch (ClassCastException cce) {\n\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final int outCols \u003d m.getColumnDimension();\n            final BlockRealMatrix out \u003d new BlockRealMatrix(rows, outCols);\n            for (OpenIntToDoubleHashMap.Iterator iterator \u003d entries.iterator(); iterator.hasNext();) {\n                iterator.advance();\n                final double value \u003d iterator.value();\n                final int key      \u003d iterator.key();\n                final int i        \u003d key / columns;\n                final int k        \u003d key % columns;\n                for (int j \u003d 0; j \u003c outCols; ++j) {\n                    out.addToEntry(i, j, value * m.getEntry(k, j));\n                }\n            }\n\n            return out;\n        }\n    }",
    "begin_line": 143,
    "end_line": 166,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.multiply#177",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.multiply(org.apache.commons.math.linear.OpenMapRealMatrix)",
    "snippet": "public OpenMapRealMatrix multiply(OpenMapRealMatrix m) {\n        // Safety check.\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int outCols \u003d m.getColumnDimension();\n        OpenMapRealMatrix out \u003d new OpenMapRealMatrix(rows, outCols);\n        for (OpenIntToDoubleHashMap.Iterator iterator \u003d entries.iterator(); iterator.hasNext();) {\n            iterator.advance();\n            final double value \u003d iterator.value();\n            final int key      \u003d iterator.key();\n            final int i        \u003d key / columns;\n            final int k        \u003d key % columns;\n            for (int j \u003d 0; j \u003c outCols; ++j) {\n                final int rightKey \u003d m.computeKey(k, j);\n                if (m.entries.containsKey(rightKey)) {\n                    final int outKey \u003d out.computeKey(i, j);\n                    final double outValue \u003d\n                        out.entries.get(outKey) + value * m.entries.get(rightKey);\n                    if (outValue \u003d\u003d 0.0) {\n                        out.entries.remove(outKey);\n                    } else {\n                        out.entries.put(outKey, outValue);\n                    }\n                }\n            }\n        }\n\n        return out;\n    }",
    "begin_line": 177,
    "end_line": 205,
    "comment": "/** \n * Postmultiply this matrix by  {@code m}.\n * @param m Matrix to postmultiply by.\n * @return {@code this} * {@code m}.\n * @throws MatrixDimensionMismatchException if the number of rows of  {@code m} differ from the number of columnsof this matrix.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.getEntry#209",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.getEntry(int, int)",
    "snippet": "@Override\n    public double getEntry(int row, int column) {\n        MatrixUtils.checkRowIndex(this, row);\n        MatrixUtils.checkColumnIndex(this, column);\n        return entries.get(computeKey(row, column));\n    }",
    "begin_line": 209,
    "end_line": 213,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.getRowDimension#217",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.getRowDimension()",
    "snippet": "@Override\n    public int getRowDimension() {\n        return rows;\n    }",
    "begin_line": 217,
    "end_line": 219,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.setEntry#223",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.setEntry(int, int, double)",
    "snippet": "@Override\n    public void setEntry(int row, int column, double value) {\n        MatrixUtils.checkRowIndex(this, row);\n        MatrixUtils.checkColumnIndex(this, column);\n        if (value \u003d\u003d 0.0) {\n            entries.remove(computeKey(row, column));\n        } else {\n            entries.put(computeKey(row, column), value);\n        }\n    }",
    "begin_line": 223,
    "end_line": 231,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.addToEntry#235",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.addToEntry(int, int, double)",
    "snippet": "@Override\n    public void addToEntry(int row, int column, double increment) {\n        MatrixUtils.checkRowIndex(this, row);\n        MatrixUtils.checkColumnIndex(this, column);\n        final int key \u003d computeKey(row, column);\n        final double value \u003d entries.get(key) + increment;\n        if (value \u003d\u003d 0.0) {\n            entries.remove(key);\n        } else {\n            entries.put(key, value);\n        }\n    }",
    "begin_line": 235,
    "end_line": 245,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.multiplyEntry#249",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.multiplyEntry(int, int, double)",
    "snippet": "@Override\n    public void multiplyEntry(int row, int column, double factor) {\n        MatrixUtils.checkRowIndex(this, row);\n        MatrixUtils.checkColumnIndex(this, column);\n        final int key \u003d computeKey(row, column);\n        final double value \u003d entries.get(key) * factor;\n        if (value \u003d\u003d 0.0) {\n            entries.remove(key);\n        } else {\n            entries.put(key, value);\n        }\n    }",
    "begin_line": 249,
    "end_line": 259,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenMapRealMatrix.computeKey#267",
    "is_bug": true,
    "src_path": "org/apache/commons/math/linear/OpenMapRealMatrix.java",
    "class_name": "org.apache.commons.math.linear.OpenMapRealMatrix",
    "signature": "org.apache.commons.math.linear.OpenMapRealMatrix.computeKey(int, int)",
    "snippet": "private int computeKey(int row, int column) {\n        return row * columns + column;\n    }",
    "begin_line": 267,
    "end_line": 269,
    "comment": "/** \n * Compute the key to access a matrix element\n * @param row row index of the matrix element\n * @param column column index of the matrix element\n * @return key within the map to access the matrix element\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.FastMath#275",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.FastMath()",
    "snippet": "private FastMath() {\n    }",
    "begin_line": 275,
    "end_line": 276,
    "comment": "/** \n * Private Constructor\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.doubleHighPart#287",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.doubleHighPart(double)",
    "snippet": "private static double doubleHighPart(double d) {\n        if (d \u003e -MathUtils.SAFE_MIN \u0026\u0026 d \u003c MathUtils.SAFE_MIN){\n            return d; // These are un-normalised - don\u0027t try to convert\n        }\n        long xl \u003d Double.doubleToLongBits(d);\n        xl \u003d xl \u0026 MASK_30BITS; // Drop low order bits\n        return Double.longBitsToDouble(xl);\n    }",
    "begin_line": 287,
    "end_line": 294,
    "comment": "/** \n * Get the high order bits from the mantissa. Equivalent to adding and subtracting HEX_40000 but also works for very large numbers\n * @param d the value to split\n * @return the high order part of the mantissa\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sqrt#301",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.sqrt(double)",
    "snippet": "public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "begin_line": 301,
    "end_line": 303,
    "comment": "/** \n * Compute the square root of a number. \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e this implementation currently delegates to  {@link Math#sqrt}\n * @param a number on which evaluation is done\n * @return square root of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cosh#309",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.cosh(double)",
    "snippet": "public static double cosh(double x) {\n      if (x !\u003d x) {\n          return x;\n      }\n\n      if (x \u003e 20.0) {\n          return exp(x)/2.0;\n      }\n\n      if (x \u003c -20) {\n          return exp(-x)/2.0;\n      }\n\n      double hiPrec[] \u003d new double[2];\n      if (x \u003c 0.0) {\n          x \u003d -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya \u003d hiPrec[0] + hiPrec[1];\n      double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp \u003d ya * HEX_40000000;\n      double yaa \u003d ya + temp - temp;\n      double yab \u003d ya - yaa;\n\n      // recip \u003d 1/y\n      double recip \u003d 1.0/ya;\n      temp \u003d recip * HEX_40000000;\n      double recipa \u003d recip + temp - temp;\n      double recipb \u003d recip - recipa;\n\n      // Correct for rounding in division\n      recipb +\u003d (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      // Account for yb\n      recipb +\u003d -yb * recip * recip;\n\n      // y \u003d y + 1/y\n      temp \u003d ya + recipa;\n      yb +\u003d -(temp - ya - recipa);\n      ya \u003d temp;\n      temp \u003d ya + recipb;\n      yb +\u003d -(temp - ya - recipb);\n      ya \u003d temp;\n\n      double result \u003d ya + yb;\n      result *\u003d 0.5;\n      return result;\n    }",
    "begin_line": 309,
    "end_line": 357,
    "comment": "/** \n * Compute the hyperbolic cosine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic cosine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sinh#363",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.sinh(double)",
    "snippet": "public static double sinh(double x) {\n      boolean negate \u003d false;\n      if (x !\u003d x) {\n          return x;\n      }\n\n      if (x \u003e 20.0) {\n          return exp(x)/2.0;\n      }\n\n      if (x \u003c -20) {\n          return -exp(-x)/2.0;\n      }\n\n      if (x \u003d\u003d 0) {\n          return x;\n      }\n\n      if (x \u003c 0.0) {\n          x \u003d -x;\n          negate \u003d true;\n      }\n\n      double result;\n\n      if (x \u003e 0.25) {\n          double hiPrec[] \u003d new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya \u003d hiPrec[0] + hiPrec[1];\n          double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp \u003d ya * HEX_40000000;\n          double yaa \u003d ya + temp - temp;\n          double yab \u003d ya - yaa;\n\n          // recip \u003d 1/y\n          double recip \u003d 1.0/ya;\n          temp \u003d recip * HEX_40000000;\n          double recipa \u003d recip + temp - temp;\n          double recipb \u003d recip - recipa;\n\n          // Correct for rounding in division\n          recipb +\u003d (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb +\u003d -yb * recip * recip;\n\n          recipa \u003d -recipa;\n          recipb \u003d -recipb;\n\n          // y \u003d y + 1/y\n          temp \u003d ya + recipa;\n          yb +\u003d -(temp - ya - recipa);\n          ya \u003d temp;\n          temp \u003d ya + recipb;\n          yb +\u003d -(temp - ya - recipb);\n          ya \u003d temp;\n\n          result \u003d ya + yb;\n          result *\u003d 0.5;\n      }\n      else {\n          double hiPrec[] \u003d new double[2];\n          expm1(x, hiPrec);\n\n          double ya \u003d hiPrec[0] + hiPrec[1];\n          double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) \u003d -expm1(x) / (expm1(x) + 1) */\n          double denom \u003d 1.0 + ya;\n          double denomr \u003d 1.0 / denom;\n          double denomb \u003d -(denom - 1.0 - ya) + yb;\n          double ratio \u003d ya * denomr;\n          double temp \u003d ratio * HEX_40000000;\n          double ra \u003d ratio + temp - temp;\n          double rb \u003d ratio - ra;\n\n          temp \u003d denom * HEX_40000000;\n          double za \u003d denom + temp - temp;\n          double zb \u003d denom - za;\n\n          rb +\u003d (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb +\u003d yb*denomr;                        // numerator\n          rb +\u003d -ya * denomb * denomr * denomr;   // denominator\n\n          // y \u003d y - 1/y\n          temp \u003d ya + ra;\n          yb +\u003d -(temp - ya - ra);\n          ya \u003d temp;\n          temp \u003d ya + rb;\n          yb +\u003d -(temp - ya - rb);\n          ya \u003d temp;\n\n          result \u003d ya + yb;\n          result *\u003d 0.5;\n      }\n\n      if (negate) {\n          result \u003d -result;\n      }\n\n      return result;\n    }",
    "begin_line": 363,
    "end_line": 467,
    "comment": "/** \n * Compute the hyperbolic sine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic sine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.tanh#473",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.tanh(double)",
    "snippet": "public static double tanh(double x) {\n      boolean negate \u003d false;\n\n      if (x !\u003d x) {\n          return x;\n      }\n\n      if (x \u003e 20.0) {\n          return 1.0;\n      }\n\n      if (x \u003c -20) {\n          return -1.0;\n      }\n\n      if (x \u003d\u003d 0) {\n          return x;\n      }\n\n      if (x \u003c 0.0) {\n          x \u003d -x;\n          negate \u003d true;\n      }\n\n      double result;\n      if (x \u003e\u003d 0.5) {\n          double hiPrec[] \u003d new double[2];\n          // tanh(x) \u003d (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya \u003d hiPrec[0] + hiPrec[1];\n          double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na \u003d -1.0 + ya;\n          double nb \u003d -(na + 1.0 - ya);\n          double temp \u003d na + yb;\n          nb +\u003d -(temp - na - yb);\n          na \u003d temp;\n\n          /* Denominator */\n          double da \u003d 1.0 + ya;\n          double db \u003d -(da - 1.0 - ya);\n          temp \u003d da + yb;\n          db +\u003d -(temp - da - yb);\n          da \u003d temp;\n\n          temp \u003d da * HEX_40000000;\n          double daa \u003d da + temp - temp;\n          double dab \u003d da - daa;\n\n          // ratio \u003d na/da\n          double ratio \u003d na/da;\n          temp \u003d ratio * HEX_40000000;\n          double ratioa \u003d ratio + temp - temp;\n          double ratiob \u003d ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob +\u003d (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob +\u003d nb / da;\n          // Account for db\n          ratiob +\u003d -db * na / da / da;\n\n          result \u003d ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] \u003d new double[2];\n          // tanh(x) \u003d expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya \u003d hiPrec[0] + hiPrec[1];\n          double yb \u003d -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na \u003d ya;\n          double nb \u003d yb;\n\n          /* Denominator */\n          double da \u003d 2.0 + ya;\n          double db \u003d -(da - 2.0 - ya);\n          double temp \u003d da + yb;\n          db +\u003d -(temp - da - yb);\n          da \u003d temp;\n\n          temp \u003d da * HEX_40000000;\n          double daa \u003d da + temp - temp;\n          double dab \u003d da - daa;\n\n          // ratio \u003d na/da\n          double ratio \u003d na/da;\n          temp \u003d ratio * HEX_40000000;\n          double ratioa \u003d ratio + temp - temp;\n          double ratiob \u003d ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob +\u003d (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob +\u003d nb / da;\n          // Account for db\n          ratiob +\u003d -db * na / da / da;\n\n          result \u003d ratioa + ratiob;\n      }\n\n      if (negate) {\n          result \u003d -result;\n      }\n\n      return result;\n    }",
    "begin_line": 473,
    "end_line": 585,
    "comment": "/** \n * Compute the hyperbolic tangent of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic tangent of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.acosh#591",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.acosh(double)",
    "snippet": "public static double acosh(final double a) {\n        return FastMath.log(a + FastMath.sqrt(a * a - 1));\n    }",
    "begin_line": 591,
    "end_line": 593,
    "comment": "/** \n * Compute the inverse hyperbolic cosine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic cosine of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.asinh#599",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.asinh(double)",
    "snippet": "public static double asinh(double a) {\n\n        boolean negative \u003d false;\n        if (a \u003c 0) {\n            negative \u003d true;\n            a \u003d -a;\n        }\n\n        double absAsinh;\n        if (a \u003e 0.167) {\n            absAsinh \u003d FastMath.log(FastMath.sqrt(a * a + 1) + a);\n        } else {\n            final double a2 \u003d a * a;\n            if (a \u003e 0.097) {\n                absAsinh \u003d a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n            } else if (a \u003e 0.036) {\n                absAsinh \u003d a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n            } else if (a \u003e 0.0036) {\n                absAsinh \u003d a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n            } else {\n                absAsinh \u003d a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);\n            }\n        }\n\n        return negative ? -absAsinh : absAsinh;\n\n    }",
    "begin_line": 599,
    "end_line": 625,
    "comment": "/** \n * Compute the inverse hyperbolic sine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic sine of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atanh#631",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.atanh(double)",
    "snippet": "public static double atanh(double a) {\n\n        boolean negative \u003d false;\n        if (a \u003c 0) {\n            negative \u003d true;\n            a \u003d -a;\n        }\n\n        double absAtanh;\n        if (a \u003e 0.15) {\n            absAtanh \u003d 0.5 * FastMath.log((1 + a) / (1 - a));\n        } else {\n            final double a2 \u003d a * a;\n            if (a \u003e 0.087) {\n                absAtanh \u003d a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));\n            } else if (a \u003e 0.031) {\n                absAtanh \u003d a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));\n            } else if (a \u003e 0.003) {\n                absAtanh \u003d a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));\n            } else {\n                absAtanh \u003d a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));\n            }\n        }\n\n        return negative ? -absAtanh : absAtanh;\n\n    }",
    "begin_line": 631,
    "end_line": 657,
    "comment": "/** \n * Compute the inverse hyperbolic tangent of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic tangent of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.signum#664",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.signum(double)",
    "snippet": "public static double signum(final double a) {\n        return (a \u003c 0.0) ? -1.0 : ((a \u003e 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a\n    }",
    "begin_line": 664,
    "end_line": 666,
    "comment": "/** \n * Compute the signum of a number. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.signum#673",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.signum(float)",
    "snippet": "public static float signum(final float a) {\n        return (a \u003c 0.0f) ? -1.0f : ((a \u003e 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a\n    }",
    "begin_line": 673,
    "end_line": 675,
    "comment": "/** \n * Compute the signum of a number. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextUp#681",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.nextUp(double)",
    "snippet": "public static double nextUp(final double a) {\n        return nextAfter(a, Double.POSITIVE_INFINITY);\n    }",
    "begin_line": 681,
    "end_line": 683,
    "comment": "/** \n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextUp#689",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.nextUp(float)",
    "snippet": "public static float nextUp(final float a) {\n        return nextAfter(a, Float.POSITIVE_INFINITY);\n    }",
    "begin_line": 689,
    "end_line": 691,
    "comment": "/** \n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.random#697",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.random()",
    "snippet": "public static double random() {\n        return Math.random();\n    }",
    "begin_line": 697,
    "end_line": 699,
    "comment": "/** \n * Returns a pseudo-random number between 0.0 and 1.0. \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e this implementation currently delegates to  {@link Math#random}\n * @return a random number between 0.0 and 1.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.exp#721",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.exp(double)",
    "snippet": "public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }",
    "begin_line": 721,
    "end_line": 723,
    "comment": "/** \n * Exponential function. Computes exp(x), function result is nearly rounded.   It will be correctly rounded to the theoretical value for 99.9% of input values, otherwise it will have a 1 UPL error. Method: Lookup intVal \u003d exp(int(x)) Lookup fracVal \u003d exp(int(x-int(x) / 1024.0) * 1024.0 ); Compute z as the exponential of the remaining bits by a polynomial minus one exp(x) \u003d intVal * fracVal * (1 + z) Accuracy: Calculation is done with 63 bits of precision, so result should be correctly rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n * @param x   a double\n * @return double e\u003csup\u003ex\u003c/sup\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.exp#732",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.exp(double, double, double[])",
    "snippet": "private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x \u003c 0.0) {\n            intVal \u003d (int) -x;\n\n            if (intVal \u003e 746) {\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] \u003d 0.0;\n                    hiPrec[1] \u003d 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal \u003e 709) {\n                /* This will produce a subnormal output */\n                final double result \u003d exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] /\u003d 285040095144011776.0;\n                    hiPrec[1] /\u003d 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal \u003d\u003d 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result \u003d exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] /\u003d 4.455505956692756620;\n                    hiPrec[1] /\u003d 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA \u003d EXP_INT_TABLE_A[750-intVal];\n            intPartB \u003d EXP_INT_TABLE_B[750-intVal];\n\n            intVal \u003d -intVal;\n        } else {\n            intVal \u003d (int) x;\n\n            if (intVal \u003e 709) {\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] \u003d Double.POSITIVE_INFINITY;\n                    hiPrec[1] \u003d 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA \u003d EXP_INT_TABLE_A[750+intVal];\n            intPartB \u003d EXP_INT_TABLE_B[750+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac \u003d (int) ((x - intVal) * 1024.0);\n        final double fracPartA \u003d EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB \u003d EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 \u003c\u003d epsilon \u003c 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon \u003d x - (intVal + intFrac / 1024.0);\n\n        /* Compute z \u003d exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z \u003c 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z \u003d 0.04168701738764507;\n        z \u003d z * epsilon + 0.1666666505023083;\n        z \u003d z * epsilon + 0.5000000000042687;\n        z \u003d z * epsilon + 1.0;\n        z \u003d z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA \u003d intPartA * fracPartA;\n        double tempB \u003d intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC \u003d tempB + tempA;\n        final double result;\n        if (extra !\u003d 0.0) {\n            result \u003d tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result \u003d tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec !\u003d null) {\n            // If requesting high precision\n            hiPrec[0] \u003d tempA;\n            hiPrec[1] \u003d tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }",
    "begin_line": 732,
    "end_line": 847,
    "comment": "/** \n * Internal helper method for exponential function.\n * @param x original argument of the exponential function\n * @param extra extra bits of precision on input (To Be Confirmed)\n * @param hiPrec extra bits of precision on output (To Be Confirmed)\n * @return exp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.expm1#853",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.expm1(double)",
    "snippet": "public static double expm1(double x) {\n      return expm1(x, null);\n    }",
    "begin_line": 853,
    "end_line": 855,
    "comment": "/** \n * Compute exp(x) - 1\n * @param x number to compute shifted exponential\n * @return exp(x) - 1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.expm1#862",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.expm1(double, double)",
    "snippet": "private static double expm1(double x, double hiPrecOut[]) {\n        if (x !\u003d x || x \u003d\u003d 0.0) { // NaN or zero\n            return x;\n        }\n\n        if (x \u003c\u003d -1.0 || x \u003e\u003d 1.0) {\n            // If not between +/- 1.0\n            //return exp(x) - 1.0;\n            double hiPrec[] \u003d new double[2];\n            exp(x, 0.0, hiPrec);\n            if (x \u003e 0.0) {\n                return -1.0 + hiPrec[0] + hiPrec[1];\n            } else {\n                final double ra \u003d -1.0 + hiPrec[0];\n                double rb \u003d -(ra + 1.0 - hiPrec[0]);\n                rb +\u003d hiPrec[1];\n                return ra + rb;\n            }\n        }\n\n        double baseA;\n        double baseB;\n        double epsilon;\n        boolean negative \u003d false;\n\n        if (x \u003c 0.0) {\n            x \u003d -x;\n            negative \u003d true;\n        }\n\n        {\n            int intFrac \u003d (int) (x * 1024.0);\n            double tempA \u003d EXP_FRAC_TABLE_A[intFrac] - 1.0;\n            double tempB \u003d EXP_FRAC_TABLE_B[intFrac];\n\n            double temp \u003d tempA + tempB;\n            tempB \u003d -(temp - tempA - tempB);\n            tempA \u003d temp;\n\n            temp \u003d tempA * HEX_40000000;\n            baseA \u003d tempA + temp - temp;\n            baseB \u003d tempB + (tempA - baseA);\n\n            epsilon \u003d x - intFrac/1024.0;\n        }\n\n\n        /* Compute expm1(epsilon) */\n        double zb \u003d 0.008336750013465571;\n        zb \u003d zb * epsilon + 0.041666663879186654;\n        zb \u003d zb * epsilon + 0.16666666666745392;\n        zb \u003d zb * epsilon + 0.49999999999999994;\n        zb \u003d zb * epsilon;\n        zb \u003d zb * epsilon;\n\n        double za \u003d epsilon;\n        double temp \u003d za + zb;\n        zb \u003d -(temp - za - zb);\n        za \u003d temp;\n\n        temp \u003d za * HEX_40000000;\n        temp \u003d za + temp - temp;\n        zb +\u003d za - temp;\n        za \u003d temp;\n\n        /* Combine the parts.   expm1(a+b) \u003d expm1(a) + expm1(b) + expm1(a)*expm1(b) */\n        double ya \u003d za * baseA;\n        //double yb \u003d za*baseB + zb*baseA + zb*baseB;\n        temp \u003d ya + za * baseB;\n        double yb \u003d -(temp - ya - za * baseB);\n        ya \u003d temp;\n\n        temp \u003d ya + zb * baseA;\n        yb +\u003d -(temp - ya - zb * baseA);\n        ya \u003d temp;\n\n        temp \u003d ya + zb * baseB;\n        yb +\u003d -(temp - ya - zb*baseB);\n        ya \u003d temp;\n\n        //ya \u003d ya + za + baseA;\n        //yb \u003d yb + zb + baseB;\n        temp \u003d ya + baseA;\n        yb +\u003d -(temp - baseA - ya);\n        ya \u003d temp;\n\n        temp \u003d ya + za;\n        //yb +\u003d (ya \u003e za) ? -(temp - ya - za) : -(temp - za - ya);\n        yb +\u003d -(temp - ya - za);\n        ya \u003d temp;\n\n        temp \u003d ya + baseB;\n        //yb +\u003d (ya \u003e baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);\n        yb +\u003d -(temp - ya - baseB);\n        ya \u003d temp;\n\n        temp \u003d ya + zb;\n        //yb +\u003d (ya \u003e zb) ? -(temp - ya - zb) : -(temp - zb - ya);\n        yb +\u003d -(temp - ya - zb);\n        ya \u003d temp;\n\n        if (negative) {\n            /* Compute expm1(-x) \u003d -expm1(x) / (expm1(x) + 1) */\n            double denom \u003d 1.0 + ya;\n            double denomr \u003d 1.0 / denom;\n            double denomb \u003d -(denom - 1.0 - ya) + yb;\n            double ratio \u003d ya * denomr;\n            temp \u003d ratio * HEX_40000000;\n            final double ra \u003d ratio + temp - temp;\n            double rb \u003d ratio - ra;\n\n            temp \u003d denom * HEX_40000000;\n            za \u003d denom + temp - temp;\n            zb \u003d denom - za;\n\n            rb +\u003d (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n\n            // f(x) \u003d x/1+x\n            // Compute f\u0027(x)\n            // Product rule:  d(uv) \u003d du*v + u*dv\n            // Chain rule:  d(f(g(x)) \u003d f\u0027(g(x))*f(g\u0027(x))\n            // d(1/x) \u003d -1/(x*x)\n            // d(1/1+x) \u003d -1/( (1+x)^2) *  1 \u003d  -1/((1+x)*(1+x))\n            // d(x/1+x) \u003d -x/((1+x)(1+x)) + 1/1+x \u003d 1 / ((1+x)(1+x))\n\n            // Adjust for yb\n            rb +\u003d yb * denomr;                      // numerator\n            rb +\u003d -ya * denomb * denomr * denomr;   // denominator\n\n            // negate\n            ya \u003d -ra;\n            yb \u003d -rb;\n        }\n\n        if (hiPrecOut !\u003d null) {\n            hiPrecOut[0] \u003d ya;\n            hiPrecOut[1] \u003d yb;\n        }\n\n        return ya + yb;\n    }",
    "begin_line": 862,
    "end_line": 1002,
    "comment": "/** \n * Internal helper method for expm1\n * @param x number to compute shifted exponential\n * @param hiPrecOut receive high precision result for -1.0 \u003c x \u003c 1.0\n * @return exp(x) - 1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.slowexp#1011",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowexp(double, double)",
    "snippet": "private static double slowexp(final double x, final double result[]) {\n        final double xs[] \u003d new double[2];\n        final double ys[] \u003d new double[2];\n        final double facts[] \u003d new double[2];\n        final double as[] \u003d new double[2];\n        split(x, xs);\n        ys[0] \u003d ys[1] \u003d 0.0;\n\n        for (int i \u003d 19; i \u003e\u003d 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] \u003d as[0];\n            ys[1] \u003d as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] \u003d as[0];\n            ys[1] \u003d as[1];\n        }\n\n        if (result !\u003d null) {\n            result[0] \u003d ys[0];\n            result[1] \u003d ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }",
    "begin_line": 1011,
    "end_line": 1038,
    "comment": "/** \n * For x between 0 and 1, returns exp(x), uses extended precision\n * @param x argument of exponential\n * @param result placeholder where to place exp(x) split in two termsfor extra precision (i.e. exp(x) \u003d result[0]  result[1]\n * @return exp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.split#1045",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.split(double, double)",
    "snippet": "private static void split(final double d, final double split[]) {\n        if (d \u003c 8e298 \u0026\u0026 d \u003e -8e298) {\n            final double a \u003d d * HEX_40000000;\n            split[0] \u003d (d + a) - a;\n            split[1] \u003d d - split[0];\n        } else {\n            final double a \u003d d * 9.31322574615478515625E-10;\n            split[0] \u003d (d + a - d) * HEX_40000000;\n            split[1] \u003d d - split[0];\n        }\n    }",
    "begin_line": 1045,
    "end_line": 1055,
    "comment": "/** \n * Compute split[0], split[1] such that their sum is equal to d, and split[0] has its 30 least significant bits as zero.\n * @param d number to split\n * @param split placeholder where to place the result\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.resplit#1061",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.resplit(double)",
    "snippet": "private static void resplit(final double a[]) {\n        final double c \u003d a[0] + a[1];\n        final double d \u003d -(c - a[0] - a[1]);\n\n        if (c \u003c 8e298 \u0026\u0026 c \u003e -8e298) {\n            double z \u003d c * HEX_40000000;\n            a[0] \u003d (c + z) - z;\n            a[1] \u003d c - a[0] + d;\n        } else {\n            double z \u003d c * 9.31322574615478515625E-10;\n            a[0] \u003d (c + z - c) * HEX_40000000;\n            a[1] \u003d c - a[0] + d;\n        }\n    }",
    "begin_line": 1061,
    "end_line": 1074,
    "comment": "/** \n * Recompute a split.\n * @param a input/out array containing the split, changedon output\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.splitMult#1081",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.splitMult(double, double, double)",
    "snippet": "private static void splitMult(double a[], double b[], double ans[]) {\n        ans[0] \u003d a[0] * b[0];\n        ans[1] \u003d a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }",
    "begin_line": 1081,
    "end_line": 1087,
    "comment": "/** \n * Multiply two numbers in split form.\n * @param a first term of multiplication\n * @param b second term of multiplication\n * @param ans placeholder where to put the result\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.splitAdd#1094",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.splitAdd(double, double, double)",
    "snippet": "private static void splitAdd(final double a[], final double b[], final double ans[]) {\n        ans[0] \u003d a[0] + b[0];\n        ans[1] \u003d a[1] + b[1];\n\n        resplit(ans);\n    }",
    "begin_line": 1094,
    "end_line": 1099,
    "comment": "/** \n * Add two numbers in split form.\n * @param a first term of addition\n * @param b second term of addition\n * @param ans placeholder where to put the result\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.splitReciprocal#1119",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.splitReciprocal(double, double)",
    "snippet": "private static void splitReciprocal(final double in[], final double result[]) {\n        final double b \u003d 1.0/4194304.0;\n        final double a \u003d 1.0 - b;\n\n        if (in[0] \u003d\u003d 0.0) {\n            in[0] \u003d in[1];\n            in[1] \u003d 0.0;\n        }\n\n        result[0] \u003d a / in[0];\n        result[1] \u003d (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n\n        if (result[1] !\u003d result[1]) { // can happen if result[1] is NAN\n            result[1] \u003d 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i \u003d 0; i \u003c 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err \u003d 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n            /*err \u003d 1.0 - err; */\n            err \u003d err * (result[0] + result[1]);\n            /*printf(\"err \u003d %16e\\n\", err); */\n            result[1] +\u003d err;\n        }\n    }",
    "begin_line": 1119,
    "end_line": 1147,
    "comment": "/** \n * Compute the reciprocal of in.  Use the following algorithm. in \u003d c + d. want to find x + y such that x+y \u003d 1/(c+d) and x is much larger than y and x has several zero bits on the right. Set b \u003d 1/(2^22),  a \u003d 1 - b.  Thus (a+b) \u003d 1. Use following identity to compute (a+b)/(c+d) (a+b)/(c+d)  \u003d   a/c   +    (bc - ad) / (c^2 + cd) set x \u003d a/c  and y \u003d (bc - ad) / (c^2 + cd) This will be close to the right answer, but there will be some rounding in the calculation of X.  So by carefully computing 1 - (c+d)(x+y) we can compute an error and add that back in.   This is done carefully so that terms of similar size are subtracted first.\n * @param in initial number, in split form\n * @param result placeholder where to put the result\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.quadMult#1154",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.quadMult(double, double, double)",
    "snippet": "private static void quadMult(final double a[], final double b[], final double result[]) {\n        final double xs[] \u003d new double[2];\n        final double ys[] \u003d new double[2];\n        final double zs[] \u003d new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] \u003d zs[0];\n        result[1] \u003d zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp \u003d result[0] + zs[0];\n        result[1] \u003d result[1] - (tmp - result[0] - zs[0]);\n        result[0] \u003d tmp;\n        tmp \u003d result[0] + zs[1];\n        result[1] \u003d result[1] - (tmp - result[0] - zs[1]);\n        result[0] \u003d tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp \u003d result[0] + zs[0];\n        result[1] \u003d result[1] - (tmp - result[0] - zs[0]);\n        result[0] \u003d tmp;\n        tmp \u003d result[0] + zs[1];\n        result[1] \u003d result[1] - (tmp - result[0] - zs[1]);\n        result[0] \u003d tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp \u003d result[0] + zs[0];\n        result[1] \u003d result[1] - (tmp - result[0] - zs[0]);\n        result[0] \u003d tmp;\n        tmp \u003d result[0] + zs[1];\n        result[1] \u003d result[1] - (tmp - result[0] - zs[1]);\n        result[0] \u003d tmp;\n    }",
    "begin_line": 1154,
    "end_line": 1201,
    "comment": "/** \n * Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n * @param a first term of the multiplication\n * @param b second term of the multiplication\n * @param result placeholder where to put the result\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.expint#1208",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.expint(int, double)",
    "snippet": "private static double expint(int p, final double result[]) {\n        //double x \u003d M_E;\n        final double xs[] \u003d new double[2];\n        final double as[] \u003d new double[2];\n        final double ys[] \u003d new double[2];\n        //split(x, xs);\n        //xs[1] \u003d (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] \u003d 2.71827697753906250000;\n        //xs[1] \u003d 4.85091998273542816811e-06;\n        //xs[0] \u003d Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] \u003d Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] \u003d 2.718281828459045;\n        xs[1] \u003d 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p \u003e 0) {\n            if ((p \u0026 1) !\u003d 0) {\n                quadMult(ys, xs, as);\n                ys[0] \u003d as[0]; ys[1] \u003d as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] \u003d as[0]; xs[1] \u003d as[1];\n\n            p \u003e\u003e\u003d 1;\n        }\n\n        if (result !\u003d null) {\n            result[0] \u003d ys[0];\n            result[1] \u003d ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }",
    "begin_line": 1208,
    "end_line": 1246,
    "comment": "/** \n * Compute exp(p) for a integer p in extended precision.\n * @param p integer whose exponential is requested\n * @param result placeholder where to put the result in extended precision\n * @return exp(p) in standard precision (equal to result[0] + result[1])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log#1255",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.log(double)",
    "snippet": "public static double log(final double x) {\n        return log(x, null);\n    }",
    "begin_line": 1255,
    "end_line": 1257,
    "comment": "/** \n * Natural logarithm.\n * @param x   a double\n * @return log(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log#1265",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.log(double, double[])",
    "snippet": "private static double log(final double x, final double[] hiPrec) {\n        if (x\u003d\u003d0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits \u003d Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits \u0026 0x8000000000000000L) !\u003d 0 || x !\u003d x) {\n            if (x !\u003d 0.0) {\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] \u003d Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (hiPrec !\u003d null) {\n                hiPrec[0] \u003d Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp \u003d (int)(bits \u003e\u003e 52)-1023;\n\n        if ((bits \u0026 0x7ff0000000000000L) \u003d\u003d 0) {\n            // Subnormal!\n            if (x \u003d\u003d 0) {\n                // Zero\n                if (hiPrec !\u003d null) {\n                    hiPrec[0] \u003d Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits \u003c\u003c\u003d 1;\n            while ( (bits \u0026 0x0010000000000000L) \u003d\u003d 0) {\n                exp--;\n                bits \u003c\u003c\u003d 1;\n            }\n        }\n\n\n        if (exp \u003d\u003d -1 || exp \u003d\u003d 0) {\n            if (x \u003c 1.01 \u0026\u0026 x \u003e 0.99 \u0026\u0026 hiPrec \u003d\u003d null) {\n                /* The normal method doesn\u0027t work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa \u003d x - 1.0;\n                double xb \u003d xa - x + 1.0;\n                double tmp \u003d xa * HEX_40000000;\n                double aa \u003d xa + tmp - tmp;\n                double ab \u003d xa - aa;\n                xa \u003d aa;\n                xb \u003d ab;\n\n                double ya \u003d LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n                double yb \u003d LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\n                for (int i \u003d LN_QUICK_COEF.length - 2; i \u003e\u003d 0; i--) {\n                    /* Multiply a \u003d y * x */\n                    aa \u003d ya * xa;\n                    ab \u003d ya * xb + yb * xa + yb * xb;\n                    /* split, so now y \u003d a */\n                    tmp \u003d aa * HEX_40000000;\n                    ya \u003d aa + tmp - tmp;\n                    yb \u003d aa - ya + ab;\n\n                    /* Add  a \u003d y + lnQuickCoef */\n                    aa \u003d ya + LN_QUICK_COEF[i][0];\n                    ab \u003d yb + LN_QUICK_COEF[i][1];\n                    /* Split y \u003d a */\n                    tmp \u003d aa * HEX_40000000;\n                    ya \u003d aa + tmp - tmp;\n                    yb \u003d aa - ya + ab;\n                }\n\n                /* Multiply a \u003d y * x */\n                aa \u003d ya * xa;\n                ab \u003d ya * xb + yb * xa + yb * xb;\n                /* split, so now y \u003d a */\n                tmp \u003d aa * HEX_40000000;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 \u003c\u003d lnm \u003c ln(2)\n        double lnm[] \u003d LN_MANT[(int)((bits \u0026 0x000ffc0000000000L) \u003e\u003e 42)];\n\n        /*\n    double epsilon \u003d x / Double.longBitsToDouble(bits \u0026 0xfffffc0000000000L);\n\n    epsilon -\u003d 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y \u003d Double.longBitsToDouble(bits \u0026 0xfffffc0000000000L);\n        //double epsilon \u003d (x - y) / y;\n        double epsilon \u003d (bits \u0026 0x3ffffffffffL) / (TWO_POWER_52 + (bits \u0026 0x000ffc0000000000L));\n\n        double lnza \u003d 0.0;\n        double lnzb \u003d 0.0;\n\n        if (hiPrec !\u003d null) {\n            /* split epsilon -\u003e x */\n            double tmp \u003d epsilon * HEX_40000000;\n            double aa \u003d epsilon + tmp - tmp;\n            double ab \u003d epsilon - aa;\n            double xa \u003d aa;\n            double xb \u003d ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            double numer \u003d bits \u0026 0x3ffffffffffL;\n            double denom \u003d TWO_POWER_52 + (bits \u0026 0x000ffc0000000000L);\n            aa \u003d numer - xa*denom - xb * denom;\n            xb +\u003d aa / denom;\n\n            /* Remez polynomial evaluation */\n            double ya \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n            double yb \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\n            for (int i \u003d LN_HI_PREC_COEF.length - 2; i \u003e\u003d 0; i--) {\n                /* Multiply a \u003d y * x */\n                aa \u003d ya * xa;\n                ab \u003d ya * xb + yb * xa + yb * xb;\n                /* split, so now y \u003d a */\n                tmp \u003d aa * HEX_40000000;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n\n                /* Add  a \u003d y + lnHiPrecCoef */\n                aa \u003d ya + LN_HI_PREC_COEF[i][0];\n                ab \u003d yb + LN_HI_PREC_COEF[i][1];\n                /* Split y \u003d a */\n                tmp \u003d aa * HEX_40000000;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n            }\n\n            /* Multiply a \u003d y * x */\n            aa \u003d ya * xa;\n            ab \u003d ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz \u003d a */\n            /*\n      tmp \u003d aa * 1073741824.0;\n      lnza \u003d aa + tmp - tmp;\n      lnzb \u003d aa - lnza + ab;\n             */\n            lnza \u003d aa + ab;\n            lnzb \u003d -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza \u003d -0.16624882440418567;\n            lnza \u003d lnza * epsilon + 0.19999954120254515;\n            lnza \u003d lnza * epsilon + -0.2499999997677497;\n            lnza \u003d lnza * epsilon + 0.3333333333332802;\n            lnza \u003d lnza * epsilon + -0.5;\n            lnza \u003d lnza * epsilon + 1.0;\n            lnza \u003d lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a \u003d LN_2_A*exp;\n        double b \u003d 0.0;\n        double c \u003d a+lnm[0];\n        double d \u003d -(c-a-lnm[0]);\n        a \u003d c;\n        b \u003d b + d;\n\n        c \u003d a + lnza;\n        d \u003d -(c - a - lnza);\n        a \u003d c;\n        b \u003d b + d;\n\n        c \u003d a + LN_2_B*exp;\n        d \u003d -(c - a - LN_2_B*exp);\n        a \u003d c;\n        b \u003d b + d;\n\n        c \u003d a + lnm[1];\n        d \u003d -(c - a - lnm[1]);\n        a \u003d c;\n        b \u003d b + d;\n\n        c \u003d a + lnzb;\n        d \u003d -(c - a - lnzb);\n        a \u003d c;\n        b \u003d b + d;\n\n        if (hiPrec !\u003d null) {\n            hiPrec[0] \u003d a;\n            hiPrec[1] \u003d b;\n        }\n\n        return a + b;\n    }",
    "begin_line": 1265,
    "end_line": 1485,
    "comment": "/** \n * Internal helper method for natural logarithm function.\n * @param x original argument of the natural logarithm function\n * @param hiPrec extra bits of precision on output (To Be Confirmed)\n * @return log(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log1p#1491",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.log1p(double)",
    "snippet": "public static double log1p(final double x) {\n        double xpa \u003d 1.0 + x;\n        double xpb \u003d -(xpa - 1.0 - x);\n\n        if (x \u003d\u003d -1) {\n            return x/0.0;   // -Infinity\n        }\n\n        if (x \u003e 0 \u0026\u0026 1/x \u003d\u003d 0) { // x \u003d Infinity\n            return x;\n        }\n\n        if (x\u003e1e-6 || x\u003c-1e-6) {\n            double hiPrec[] \u003d new double[2];\n\n            final double lores \u003d log(xpa, hiPrec);\n            if (Double.isInfinite(lores)){ // don\u0027t allow this to be converted to NaN\n                return lores;\n            }\n\n            /* Do a taylor series expansion around xpa */\n            /* f(x+y) \u003d f(x) + f\u0027(x)*y + f\u0027\u0027(x)/2 y^2 */\n            double fx1 \u003d xpb/xpa;\n\n            double epsilon \u003d 0.5 * fx1 + 1.0;\n            epsilon \u003d epsilon * fx1;\n\n            return epsilon + hiPrec[1] + hiPrec[0];\n        }\n\n        /* Value is small |x| \u003c 1e6, do a Taylor series centered on 1.0 */\n        double y \u003d x * 0.333333333333333 - 0.5;\n        y \u003d y * x + 1.0;\n        y \u003d y * x;\n\n        return y;\n    }",
    "begin_line": 1491,
    "end_line": 1527,
    "comment": "/** \n * Compute log(1 + x).\n * @param x a number\n * @return log(1 + x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log10#1533",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.log10(double)",
    "snippet": "public static double log10(final double x) {\n        final double hiPrec[] \u003d new double[2];\n\n        final double lores \u003d log(x, hiPrec);\n        if (Double.isInfinite(lores)){ // don\u0027t allow this to be converted to NaN\n            return lores;\n        }\n\n        final double tmp \u003d hiPrec[0] * HEX_40000000;\n        final double lna \u003d hiPrec[0] + tmp - tmp;\n        final double lnb \u003d hiPrec[0] - lna + hiPrec[1];\n\n        final double rln10a \u003d 0.4342944622039795;\n        final double rln10b \u003d 1.9699272335463627E-8;\n\n        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n    }",
    "begin_line": 1533,
    "end_line": 1549,
    "comment": "/** \n * Compute the base 10 logarithm.\n * @param x a number\n * @return log10(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.pow#1558",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.pow(double, double)",
    "snippet": "public static double pow(double x, double y) {\n        final double lns[] \u003d new double[2];\n\n        if (y \u003d\u003d 0.0) {\n            return 1.0;\n        }\n\n        if (x !\u003d x) { // X is NaN\n            return x;\n        }\n\n\n        if (x \u003d\u003d 0) {\n            long bits \u003d Double.doubleToLongBits(x);\n            if ((bits \u0026 0x8000000000000000L) !\u003d 0) {\n                // -zero\n                long yi \u003d (long) y;\n\n                if (y \u003c 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y \u003c 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                    return -0.0;\n                }\n\n                if (y \u003e 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y \u003c 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y \u003e 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (y !\u003d y) { // y is NaN\n                return y;\n            }\n            if (y \u003c 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (x * x \u003d\u003d 1.0)\n              return Double.NaN;\n\n            if (x * x \u003e 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n            if (y !\u003d y) { // y is NaN\n                return y;\n            }\n\n            if (y \u003c 0) {\n                long yi \u003d (long) y;\n                if (y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y \u003e 0)  {\n                long yi \u003d (long) y;\n                if (y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y \u003d\u003d Double.NEGATIVE_INFINITY) {\n\n            if (x * x \u003d\u003d 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x \u003c 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x\u003c0 */\n        if (x \u003c 0) {\n            // y is an even integer in this case\n            if (y \u003e\u003d TWO_POWER_52 || y \u003c\u003d -TWO_POWER_52) {\n                return pow(-x, y);\n            }\n\n            if (y \u003d\u003d (long) y) {\n                // If y is an integer\n                return ((long)y \u0026 1) \u003d\u003d 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y \u003d ya+yb */\n        double ya;\n        double yb;\n        if (y \u003c 8e298 \u0026\u0026 y \u003e -8e298) {\n            double tmp1 \u003d y * HEX_40000000;\n            ya \u003d y + tmp1 - tmp1;\n            yb \u003d y - ya;\n        } else {\n            double tmp1 \u003d y * 9.31322574615478515625E-10;\n            double tmp2 \u003d tmp1 * 9.31322574615478515625E-10;\n            ya \u003d (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb \u003d y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores \u003d log(x, lns);\n        if (Double.isInfinite(lores)){ // don\u0027t allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna \u003d lns[0];\n        double lnb \u003d lns[1];\n\n        /* resplit lns */\n        double tmp1 \u003d lna * HEX_40000000;\n        double tmp2 \u003d lna + tmp1 - tmp1;\n        lnb +\u003d lna - tmp2;\n        lna \u003d tmp2;\n\n        // y*ln(x) \u003d (aa+ab)\n        final double aa \u003d lna * ya;\n        final double ab \u003d lna * yb + lnb * ya + lnb * yb;\n\n        lna \u003d aa+ab;\n        lnb \u003d -(lna - aa - ab);\n\n        double z \u003d 1.0 / 120.0;\n        z \u003d z * lnb + (1.0 / 24.0);\n        z \u003d z * lnb + (1.0 / 6.0);\n        z \u003d z * lnb + 0.5;\n        z \u003d z * lnb + 1.0;\n        z \u003d z * lnb;\n\n        final double result \u003d exp(lna, z, null);\n        //result \u003d result + result * z;\n        return result;\n    }",
    "begin_line": 1558,
    "end_line": 1719,
    "comment": "/** \n * Power function.  Compute x^y.\n * @param x   a double\n * @param y   a double\n * @return double\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.slowLog#1740",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowLog(double)",
    "snippet": "private static double[] slowLog(double xi) {\n        double x[] \u003d new double[2];\n        double x2[] \u003d new double[2];\n        double y[] \u003d new double[2];\n        double a[] \u003d new double[2];\n\n        split(xi, x);\n\n        /* Set X \u003d (x-1)/(x+1) */\n        x[0] +\u003d 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -\u003d 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] \u003d y[0];\n        x[1] \u003d y[1];\n\n        /* Square X -\u003e X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -\u003d 1.0;\n        //resplit(x);\n\n        y[0] \u003d LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] \u003d LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i \u003d LN_SPLIT_COEF.length-2; i \u003e\u003d 0; i--) {\n            splitMult(y, x2, a);\n            y[0] \u003d a[0];\n            y[1] \u003d a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] \u003d a[0];\n            y[1] \u003d a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] \u003d a[0];\n        y[1] \u003d a[1];\n\n        return y;\n    }",
    "begin_line": 1740,
    "end_line": 1782,
    "comment": "/** \n * xi in the range of [1, 2]. 3        5        7 x+1           /          x        x        x          \\ ln ----- \u003d   2 *  |  x  +   ----  +  ----  +  ---- + ...  | 1-x           \\          3        5        7          / So, compute a Remez approximation of the following function ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x This will be an even function with only positive coefficents. x is in the range [0 - 1/3]. Transform xi for input to the above function by setting x \u003d (xi-1)/(xi+1).   Input to the polynomial is x^2, then the result is multiplied by x.\n * @param xi number from which log is requested\n * @return log(xi)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.slowSin#1790",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowSin(double, double)",
    "snippet": "private static double slowSin(final double x, final double result[]) {\n        final double xs[] \u003d new double[2];\n        final double ys[] \u003d new double[2];\n        final double facts[] \u003d new double[2];\n        final double as[] \u003d new double[2];\n        split(x, xs);\n        ys[0] \u003d ys[1] \u003d 0.0;\n\n        for (int i \u003d 19; i \u003e\u003d 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] \u003d as[0]; ys[1] \u003d as[1];\n\n            if ( (i \u0026 1) \u003d\u003d 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i \u0026 2) !\u003d 0 ) {\n                facts[0] \u003d -facts[0];\n                facts[1] \u003d -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] \u003d as[0]; ys[1] \u003d as[1];\n        }\n\n        if (result !\u003d null) {\n            result[0] \u003d ys[0];\n            result[1] \u003d ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }",
    "begin_line": 1790,
    "end_line": 1824,
    "comment": "/** \n * For x between 0 and pi/4 compute sine.\n * @param x number from which sine is requested\n * @param result placeholder where to put the result in extended precision\n * @return sin(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.slowCos#1832",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowCos(double, double)",
    "snippet": "private static double slowCos(final double x, final double result[]) {\n\n        final double xs[] \u003d new double[2];\n        final double ys[] \u003d new double[2];\n        final double facts[] \u003d new double[2];\n        final double as[] \u003d new double[2];\n        split(x, xs);\n        ys[0] \u003d ys[1] \u003d 0.0;\n\n        for (int i \u003d 19; i \u003e\u003d 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] \u003d as[0]; ys[1] \u003d as[1];\n\n            if ( (i \u0026 1) !\u003d 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i \u0026 2) !\u003d 0 ) {\n                facts[0] \u003d -facts[0];\n                facts[1] \u003d -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] \u003d as[0]; ys[1] \u003d as[1];\n        }\n\n        if (result !\u003d null) {\n            result[0] \u003d ys[0];\n            result[1] \u003d ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }",
    "begin_line": 1832,
    "end_line": 1867,
    "comment": "/** \n * For x between 0 and pi/4 compute cosine\n * @param x number from which cosine is requested\n * @param result placeholder where to put the result in extended precision\n * @return cos(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.buildSinCosTables#1871",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.buildSinCosTables()",
    "snippet": "private static void buildSinCosTables() {\n        final double result[] \u003d new double[2];\n\n        /* Use taylor series for 0 \u003c\u003d x \u003c\u003d 6/8 */\n        for (int i \u003d 0; i \u003c 7; i++) {\n            double x \u003d i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] \u003d result[0];\n            SINE_TABLE_B[i] \u003d result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] \u003d result[0];\n            COSINE_TABLE_B[i] \u003d result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i \u003d 7; i \u003c 14; i++) {\n            double xs[] \u003d new double[2];\n            double ys[] \u003d new double[2];\n            double as[] \u003d new double[2];\n            double bs[] \u003d new double[2];\n            double temps[] \u003d new double[2];\n\n            if ( (i \u0026 1) \u003d\u003d 0) {\n                // Even, use double angle\n                xs[0] \u003d SINE_TABLE_A[i/2];\n                xs[1] \u003d SINE_TABLE_B[i/2];\n                ys[0] \u003d COSINE_TABLE_A[i/2];\n                ys[1] \u003d COSINE_TABLE_B[i/2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] \u003d result[0] * 2.0;\n                SINE_TABLE_B[i] \u003d result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] \u003d -temps[0];\n                temps[1] \u003d -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] \u003d result[0];\n                COSINE_TABLE_B[i] \u003d result[1];\n            } else {\n                xs[0] \u003d SINE_TABLE_A[i/2];\n                xs[1] \u003d SINE_TABLE_B[i/2];\n                ys[0] \u003d COSINE_TABLE_A[i/2];\n                ys[1] \u003d COSINE_TABLE_B[i/2];\n                as[0] \u003d SINE_TABLE_A[i/2+1];\n                as[1] \u003d SINE_TABLE_B[i/2+1];\n                bs[0] \u003d COSINE_TABLE_A[i/2+1];\n                bs[1] \u003d COSINE_TABLE_B[i/2+1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] \u003d result[0];\n                SINE_TABLE_B[i] \u003d result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] \u003d -temps[0];\n                temps[1] \u003d -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] \u003d result[0];\n                COSINE_TABLE_B[i] \u003d result[1];\n            }\n        }\n\n        /* Compute tangent \u003d sine/cosine */\n        for (int i \u003d 0; i \u003c 14; i++) {\n            double xs[] \u003d new double[2];\n            double ys[] \u003d new double[2];\n            double as[] \u003d new double[2];\n\n            as[0] \u003d COSINE_TABLE_A[i];\n            as[1] \u003d COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] \u003d SINE_TABLE_A[i];\n            xs[1] \u003d SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] \u003d as[0];\n            TANGENT_TABLE_B[i] \u003d as[1];\n        }\n\n    }",
    "begin_line": 1871,
    "end_line": 1963,
    "comment": "/** \n * Build the sine and cosine tables.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.polySine#1971",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.polySine(double)",
    "snippet": "private static double polySine(final double x)\n    {\n        double x2 \u003d x*x;\n\n        double p \u003d 2.7553817452272217E-6;\n        p \u003d p * x2 + -1.9841269659586505E-4;\n        p \u003d p * x2 + 0.008333333333329196;\n        p \u003d p * x2 + -0.16666666666666666;\n        //p *\u003d x2;\n        //p *\u003d x;\n        p \u003d p * x2 * x;\n\n        return p;\n    }",
    "begin_line": 1971,
    "end_line": 1984,
    "comment": "/** \n * Computes sin(x) - x, where |x| \u003c 1/16. Use a Remez polynomial approximation.\n * @param x a number smaller than 1/16\n * @return sin(x) - x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.polyCosine#1992",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.polyCosine(double)",
    "snippet": "private static double polyCosine(double x) {\n        double x2 \u003d x*x;\n\n        double p \u003d 2.479773539153719E-5;\n        p \u003d p * x2 + -0.0013888888689039883;\n        p \u003d p * x2 + 0.041666666666621166;\n        p \u003d p * x2 + -0.49999999999999994;\n        p *\u003d x2;\n\n        return p;\n    }",
    "begin_line": 1992,
    "end_line": 2002,
    "comment": "/** \n * Computes cos(x) - 1, where |x| \u003c 1/16. Use a Remez polynomial approximation.\n * @param x a number smaller than 1/16\n * @return cos(x) - 1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sinQ#2011",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.sinQ(double, double)",
    "snippet": "private static double sinQ(double xa, double xb) {\n        int idx \u003d (int) ((xa * 8.0) + 0.5);\n        final double epsilon \u003d xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA \u003d SINE_TABLE_A[idx];\n        final double sintB \u003d SINE_TABLE_B[idx];\n        final double costA \u003d COSINE_TABLE_A[idx];\n        final double costB \u003d COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA \u003d epsilon;\n        double sinEpsB \u003d polySine(epsilon);\n        final double cosEpsA \u003d 1.0;\n        final double cosEpsB \u003d polyCosine(epsilon);\n\n        // Split epsilon   xa + xb \u003d x\n        final double temp \u003d sinEpsA * HEX_40000000;\n        double temp2 \u003d (sinEpsA + temp) - temp;\n        sinEpsB +\u003d  sinEpsA - temp2;\n        sinEpsA \u003d temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result \u003d sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result \u003d sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result \u003d sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result +\u003d costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a \u003d 0;\n        double b \u003d 0;\n\n        double t \u003d sintA;\n        double c \u003d a + t;\n        double d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        t \u003d costA * sinEpsA;\n        c \u003d a + t;\n        d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        b \u003d b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t \u003d sintA*cosEpsB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n\n    t \u003d costA*sinEpsB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n         */\n\n        b \u003d b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t \u003d sintB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n\n    t \u003d costB*sinEpsA;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n\n    t \u003d sintB*cosEpsB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n\n    t \u003d costB*sinEpsB;\n    c \u003d a + t;\n    d \u003d -(c - a - t);\n    a \u003d c;\n    b \u003d b + d;\n         */\n\n        if (xb !\u003d 0.0) {\n            t \u003d ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c \u003d a + t;\n            d \u003d -(c - a - t);\n            a \u003d c;\n            b \u003d b + d;\n        }\n\n        result \u003d a + b;\n\n        return result;\n    }",
    "begin_line": 2011,
    "end_line": 2126,
    "comment": "/** \n * Compute sine over the first quadrant (0 \u003c x \u003c pi/2). Use combination of table lookup and rational polynomial expansion.\n * @param xa number from which sine is requested\n * @param xb extra bits for x (may be 0.0)\n * @return sin(xa + xb)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cosQ#2135",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.cosQ(double, double)",
    "snippet": "private static double cosQ(double xa, double xb) {\n        final double pi2a \u003d 1.5707963267948966;\n        final double pi2b \u003d 6.123233995736766E-17;\n\n        final double a \u003d pi2a - xa;\n        double b \u003d -(a - pi2a + xa);\n        b +\u003d pi2b - xb;\n\n        return sinQ(a, b);\n    }",
    "begin_line": 2135,
    "end_line": 2144,
    "comment": "/** \n * Compute cosine in the first quadrant by subtracting input from PI/2 and then calling sinQ.  This is more accurate as the input approaches PI/2.\n * @param xa number from which cosine is requested\n * @param xb extra bits for x (may be 0.0)\n * @return cos(xa + xb)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.tanQ#2154",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.tanQ(double, double, boolean)",
    "snippet": "private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx \u003d (int) ((xa * 8.0) + 0.5);\n        final double epsilon \u003d xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA \u003d SINE_TABLE_A[idx];\n        final double sintB \u003d SINE_TABLE_B[idx];\n        final double costA \u003d COSINE_TABLE_A[idx];\n        final double costB \u003d COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA \u003d epsilon;\n        double sinEpsB \u003d polySine(epsilon);\n        final double cosEpsA \u003d 1.0;\n        final double cosEpsB \u003d polyCosine(epsilon);\n\n        // Split epsilon   xa + xb \u003d x\n        double temp \u003d sinEpsA * HEX_40000000;\n        double temp2 \u003d (sinEpsA + temp) - temp;\n        sinEpsB +\u003d  sinEpsA - temp2;\n        sinEpsA \u003d temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result \u003d sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result \u003d sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result \u003d sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result +\u003d costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a \u003d 0;\n        double b \u003d 0;\n\n        // Compute sine\n        double t \u003d sintA;\n        double c \u003d a + t;\n        double d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        t \u003d costA*sinEpsA;\n        c \u003d a + t;\n        d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        b \u003d b + sintA*cosEpsB + costA*sinEpsB;\n        b \u003d b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina \u003d a + b;\n        double sinb \u003d -(sina - a - b);\n\n        // Compute cosine\n\n        a \u003d b \u003d c \u003d d \u003d 0.0;\n\n        t \u003d costA*cosEpsA;\n        c \u003d a + t;\n        d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        t \u003d -sintA*sinEpsA;\n        c \u003d a + t;\n        d \u003d -(c - a - t);\n        a \u003d c;\n        b \u003d b + d;\n\n        b \u003d b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b \u003d b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa \u003d a + b;\n        double cosb \u003d -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp \u003d cosa; cosa \u003d sina; sina \u003d tmp;\n            tmp \u003d cosb; cosb \u003d sinb; sinb \u003d tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est \u003d (sina+sinb)/(cosa+cosb);\n    double err \u003d (sina - cosa*est) + (sinb - cosb*est);\n    est +\u003d err/(cosa+cosb);\n    err \u003d (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) \u003d 1/x,   f\u0027(x) \u003d -1/x^2\n\n        double est \u003d sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp \u003d est * HEX_40000000;\n        double esta \u003d (est + temp) - temp;\n        double estb \u003d  est - esta;\n\n        temp \u003d cosa * HEX_40000000;\n        double cosaa \u003d (cosa + temp) - temp;\n        double cosab \u003d  cosa - cosaa;\n\n        //double err \u003d (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err \u003d (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err +\u003d sinb/cosa;                     // Change in est due to sinb\n        err +\u003d -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb !\u003d 0.0) {\n            // tan\u0027 \u003d 1 + tan^2      cot\u0027 \u003d -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj \u003d xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj \u003d -xbadj;\n            }\n\n            err +\u003d xbadj;\n        }\n\n        return est+err;\n    }",
    "begin_line": 2154,
    "end_line": 2289,
    "comment": "/** \n * Compute tangent (or cotangent) over the first quadrant.   0 \u003c x \u003c pi/2 Use combination of table lookup and rational polynomial expansion.\n * @param xa number from which sine is requested\n * @param xb extra bits for x (may be 0.0)\n * @param cotanFlag if true, compute the cotangent instead of the tangent\n * @return tan(xa+xb) (or cotangent, depending on cotanFlag)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.reducePayneHanek#2302",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.reducePayneHanek(double, double)",
    "snippet": "private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits \u003d Double.doubleToLongBits(x);\n        int exponent \u003d (int) ((inbits \u003e\u003e 52) \u0026 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits \u0026\u003d 0x000fffffffffffffL;\n        inbits |\u003d 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits \u003c\u003c\u003d 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx \u003d exponent \u003e\u003e 6;\n        int shift \u003d exponent - (idx \u003c\u003c 6);\n\n        if (shift !\u003d 0) {\n            shpi0 \u003d (idx \u003d\u003d 0) ? 0 : (RECIP_2PI[idx-1] \u003c\u003c shift);\n            shpi0 |\u003d RECIP_2PI[idx] \u003e\u003e\u003e (64-shift);\n            shpiA \u003d (RECIP_2PI[idx] \u003c\u003c shift) | (RECIP_2PI[idx+1] \u003e\u003e\u003e (64-shift));\n            shpiB \u003d (RECIP_2PI[idx+1] \u003c\u003c shift) | (RECIP_2PI[idx+2] \u003e\u003e\u003e (64-shift));\n        } else {\n            shpi0 \u003d (idx \u003d\u003d 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA \u003d RECIP_2PI[idx];\n            shpiB \u003d RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a \u003d inbits \u003e\u003e\u003e 32;\n        long b \u003d inbits \u0026 0xffffffffL;\n\n        long c \u003d shpiA \u003e\u003e\u003e 32;\n        long d \u003d shpiA \u0026 0xffffffffL;\n\n        long ac \u003d a * c;\n        long bd \u003d b * d;\n        long bc \u003d b * c;\n        long ad \u003d a * d;\n\n        long prodB \u003d bd + (ad \u003c\u003c 32);\n        long prodA \u003d ac + (ad \u003e\u003e\u003e 32);\n\n        boolean bita \u003d (bd \u0026 0x8000000000000000L) !\u003d 0;\n        boolean bitb \u003d (ad \u0026 0x80000000L ) !\u003d 0;\n        boolean bitsum \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prodA++;\n        }\n\n        bita \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (bc \u0026 0x80000000L ) !\u003d 0;\n\n        prodB \u003d prodB + (bc \u003c\u003c 32);\n        prodA \u003d prodA + (bc \u003e\u003e\u003e 32);\n\n        bitsum \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c \u003d shpiB \u003e\u003e\u003e 32;\n        d \u003d shpiB \u0026 0xffffffffL;\n        ac \u003d a * c;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        /* Collect terms */\n        ac \u003d ac + ((bc + ad) \u003e\u003e\u003e 32);\n\n        bita \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (ac \u0026 0x8000000000000000L ) !\u003d 0;\n        prodB +\u003d ac;\n        bitsum \u003d (prodB \u0026 0x8000000000000000L) !\u003d 0;\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c \u003d shpi0 \u003e\u003e\u003e 32;\n        d \u003d shpi0 \u0026 0xffffffffL;\n\n        bd \u003d b * d;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        prodA +\u003d bd + ((bc + ad) \u003c\u003c 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart \u003d (int)(prodA \u003e\u003e\u003e 62);\n\n        /* Multiply by 4 */\n        prodA \u003c\u003c\u003d 2;\n        prodA |\u003d prodB \u003e\u003e\u003e 62;\n        prodB \u003c\u003c\u003d 2;\n\n        /* Multiply by PI/4 */\n        a \u003d prodA \u003e\u003e\u003e 32;\n        b \u003d prodA \u0026 0xffffffffL;\n\n        c \u003d PI_O_4_BITS[0] \u003e\u003e\u003e 32;\n        d \u003d PI_O_4_BITS[0] \u0026 0xffffffffL;\n\n        ac \u003d a * c;\n        bd \u003d b * d;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        long prod2B \u003d bd + (ad \u003c\u003c 32);\n        long prod2A \u003d ac + (ad \u003e\u003e\u003e 32);\n\n        bita \u003d (bd \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (ad \u0026 0x80000000L ) !\u003d 0;\n        bitsum \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prod2A++;\n        }\n\n        bita \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (bc \u0026 0x80000000L ) !\u003d 0;\n\n        prod2B \u003d prod2B + (bc \u003c\u003c 32);\n        prod2A \u003d prod2A + (bc \u003e\u003e\u003e 32);\n\n        bitsum \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c \u003d PI_O_4_BITS[1] \u003e\u003e\u003e 32;\n        d \u003d PI_O_4_BITS[1] \u0026 0xffffffffL;\n        ac \u003d a * c;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        /* Collect terms */\n        ac \u003d ac + ((bc + ad) \u003e\u003e\u003e 32);\n\n        bita \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (ac \u0026 0x8000000000000000L ) !\u003d 0;\n        prod2B +\u003d ac;\n        bitsum \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a \u003d prodB \u003e\u003e\u003e 32;\n        b \u003d prodB \u0026 0xffffffffL;\n        c \u003d PI_O_4_BITS[0] \u003e\u003e\u003e 32;\n        d \u003d PI_O_4_BITS[0] \u0026 0xffffffffL;\n        ac \u003d a * c;\n        bc \u003d b * c;\n        ad \u003d a * d;\n\n        /* Collect terms */\n        ac \u003d ac + ((bc + ad) \u003e\u003e\u003e 32);\n\n        bita \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        bitb \u003d (ac \u0026 0x8000000000000000L ) !\u003d 0;\n        prod2B +\u003d ac;\n        bitsum \u003d (prod2B \u0026 0x8000000000000000L) !\u003d 0;\n        /* Carry */\n        if ( (bita \u0026\u0026 bitb) ||\n                ((bita || bitb) \u0026\u0026 !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA \u003d (prod2A \u003e\u003e\u003e 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB \u003d (((prod2A \u0026 0xfffL) \u003c\u003c 40) + (prod2B \u003e\u003e\u003e 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA \u003d tmpA + tmpB;\n        double sumB \u003d -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] \u003d intPart;\n        result[1] \u003d sumA * 2.0;\n        result[2] \u003d sumB * 2.0;\n    }",
    "begin_line": 2302,
    "end_line": 2512,
    "comment": "/** \n * Reduce the input argument using the Payne and Hanek method. This is good for all inputs 0.0 \u003c x \u003c inf Output is remainder after dividing by PI/2 The result array should contain 3 numbers. result[0] is the integer portion, so mod 4 this gives the quadrant. result[1] is the upper bits of the remainder result[2] is the lower bits of the remainder\n * @param x number to reduce\n * @param result placeholder where to put the result\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sin#2519",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.sin(double)",
    "snippet": "public static double sin(double x) {\n        boolean negative \u003d false;\n        int quadrant \u003d 0;\n        double xa;\n        double xb \u003d 0.0;\n\n        /* Take absolute value of the input */\n        xa \u003d x;\n        if (x \u003c 0) {\n            negative \u003d true;\n            xa \u003d -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa \u003d\u003d 0.0) {\n            long bits \u003d Double.doubleToLongBits(x);\n            if (bits \u003c 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa !\u003d xa || xa \u003d\u003d Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa \u003e 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] \u003d new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant \u003d ((int) reduceResults[0]) \u0026 3;\n            xa \u003d reduceResults[1];\n            xb \u003d reduceResults[2];\n        } else if (xa \u003e 1.5707963267948966) {\n            /* Inline the Cody/Waite reduction for performance */\n\n            // Estimate k\n            //k \u003d (int)(xa / 1.5707963267948966);\n            int k \u003d (int)(xa * 0.6366197723675814);\n\n            // Compute remainder\n            double remA;\n            double remB;\n            while (true) {\n                double a \u003d -k * 1.570796251296997;\n                remA \u003d xa + a;\n                remB \u003d -(remA - xa - a);\n\n                a \u003d -k * 7.549789948768648E-8;\n                double b \u003d remA;\n                remA \u003d a + b;\n                remB +\u003d -(remA - b - a);\n\n                a \u003d -k * 6.123233995736766E-17;\n                b \u003d remA;\n                remA \u003d a + b;\n                remB +\u003d -(remA - b - a);\n\n                if (remA \u003e 0.0)\n                    break;\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2\n                k--;\n            }\n            quadrant \u003d k \u0026 3;\n            xa \u003d remA;\n            xb \u003d remB;\n        }\n\n        if (negative) {\n            quadrant ^\u003d 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "begin_line": 2519,
    "end_line": 2609,
    "comment": "/** \n * Sine function.\n * @param x a number\n * @return sin(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cos#2616",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.cos(double)",
    "snippet": "public static double cos(double x) {\n        int quadrant \u003d 0;\n\n        /* Take absolute value of the input */\n        double xa \u003d x;\n        if (x \u003c 0) {\n            xa \u003d -xa;\n        }\n\n        if (xa !\u003d xa || xa \u003d\u003d Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb \u003d 0;\n        if (xa \u003e 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] \u003d new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant \u003d ((int) reduceResults[0]) \u0026 3;\n            xa \u003d reduceResults[1];\n            xb \u003d reduceResults[2];\n        } else if (xa \u003e 1.5707963267948966) {\n            /* Inline the Cody/Waite reduction for performance */\n\n            // Estimate k\n            //k \u003d (int)(xa / 1.5707963267948966);\n            int k \u003d (int)(xa * 0.6366197723675814);\n\n            // Compute remainder\n            double remA;\n            double remB;\n            while (true) {\n                double a \u003d -k * 1.570796251296997;\n                remA \u003d xa + a;\n                remB \u003d -(remA - xa - a);\n\n                a \u003d -k * 7.549789948768648E-8;\n                double b \u003d remA;\n                remA \u003d a + b;\n                remB +\u003d -(remA - b - a);\n\n                a \u003d -k * 6.123233995736766E-17;\n                b \u003d remA;\n                remA \u003d a + b;\n                remB +\u003d -(remA - b - a);\n\n                if (remA \u003e 0.0)\n                    break;\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2\n                k--;\n            }\n            quadrant \u003d k \u0026 3;\n            xa \u003d remA;\n            xb \u003d remB;\n        }\n\n        //if (negative)\n        //  quadrant \u003d (quadrant + 2) % 4;\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "begin_line": 2616,
    "end_line": 2693,
    "comment": "/** \n * Cosine function\n * @param x a number\n * @return cos(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.tan#2700",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.tan(double)",
    "snippet": "public static double tan(double x) {\n        boolean negative \u003d false;\n        int quadrant \u003d 0;\n\n        /* Take absolute value of the input */\n        double xa \u003d x;\n        if (x \u003c 0) {\n            negative \u003d true;\n            xa \u003d -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa \u003d\u003d 0.0) {\n            long bits \u003d Double.doubleToLongBits(x);\n            if (bits \u003c 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa !\u003d xa || xa \u003d\u003d Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb \u003d 0;\n        if (xa \u003e 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] \u003d new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant \u003d ((int) reduceResults[0]) \u0026 3;\n            xa \u003d reduceResults[1];\n            xb \u003d reduceResults[2];\n        } else if (xa \u003e 1.5707963267948966) {\n            /* Inline the Cody/Waite reduction for performance */\n\n            // Estimate k\n            //k \u003d (int)(xa / 1.5707963267948966);\n            int k \u003d (int)(xa * 0.6366197723675814);\n\n            // Compute remainder\n            double remA;\n            double remB;\n            while (true) {\n                double a \u003d -k * 1.570796251296997;\n                remA \u003d xa + a;\n                remB \u003d -(remA - xa - a);\n\n                a \u003d -k * 7.549789948768648E-8;\n                double b \u003d remA;\n                remA \u003d a + b;\n                remB +\u003d -(remA - b - a);\n\n                a \u003d -k * 6.123233995736766E-17;\n                b \u003d remA;\n                remA \u003d a + b;\n                remB +\u003d -(remA - b - a);\n\n                if (remA \u003e 0.0)\n                    break;\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2\n                k--;\n            }\n            quadrant \u003d k \u0026 3;\n            xa \u003d remA;\n            xb \u003d remB;\n        }\n\n        if (xa \u003e 1.5) {\n            // Accurracy suffers between 1.5 and PI/2\n            final double pi2a \u003d 1.5707963267948966;\n            final double pi2b \u003d 6.123233995736766E-17;\n\n            final double a \u003d pi2a - xa;\n            double b \u003d -(a - pi2a + xa);\n            b +\u003d pi2b - xb;\n\n            xa \u003d a + b;\n            xb \u003d -(xa - a - b);\n            quadrant ^\u003d 1;\n            negative ^\u003d true;\n        }\n\n        double result;\n        if ((quadrant \u0026 1) \u003d\u003d 0) {\n            result \u003d tanQ(xa, xb, false);\n        } else {\n            result \u003d -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\n            result \u003d -result;\n        }\n\n        return result;\n    }",
    "begin_line": 2700,
    "end_line": 2800,
    "comment": "/** \n * Tangent function\n * @param x a number\n * @return tan(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atan#2807",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.atan(double)",
    "snippet": "public static double atan(double x) {\n        return atan(x, 0.0, false);\n    }",
    "begin_line": 2807,
    "end_line": 2809,
    "comment": "/** \n * Arctangent function\n * @param x a number\n * @return atan(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atan#2817",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.atan(double, double, boolean)",
    "snippet": "private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate \u003d false;\n        int idx;\n\n        if (xa \u003d\u003d 0.0) { // Matches +/- 0.0; return correct sign\n            return leftPlane ? copySign(Math.PI, xa) : xa;\n        }\n\n        if (xa \u003c 0) {\n            // negative\n            xa \u003d -xa;\n            xb \u003d -xb;\n            negate \u003d true;\n        }\n\n        if (xa \u003e 1.633123935319537E16) { // Very large input\n            return (negate ^ leftPlane) ? (-Math.PI/2.0) : (Math.PI/2.0);\n        }\n\n        /* Estimate the closest tabulated arctan value, compute eps \u003d xa-tangentTable */\n        if (xa \u003c 1.0) {\n            idx \u003d (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n        } else {\n            double temp \u003d 1.0/xa;\n            idx \u003d (int) (-((-1.7168146928204136 * temp * temp + 8.0) * temp) + 13.07);\n        }\n        double epsA \u003d xa - TANGENT_TABLE_A[idx];\n        double epsB \u003d -(epsA - xa + TANGENT_TABLE_A[idx]);\n        epsB +\u003d xb - TANGENT_TABLE_B[idx];\n\n        double temp \u003d epsA + epsB;\n        epsB \u003d -(temp - epsA - epsB);\n        epsA \u003d temp;\n\n        /* Compute eps \u003d eps / (1.0 + xa*tangent) */\n        temp \u003d xa * HEX_40000000;\n        double ya \u003d xa + temp - temp;\n        double yb \u003d xb + xa - ya;\n        xa \u003d ya;\n        xb +\u003d yb;\n\n        //if (idx \u003e 8 || idx \u003d\u003d 0)\n        if (idx \u003d\u003d 0) {\n            /* If the slope of the arctan is gentle enough (\u003c 0.45), this approximation will suffice */\n            //double denom \u003d 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\n            double denom \u003d 1.0 / (1.0 + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n            //double denom \u003d 1.0 / (1.0 + xa*tangentTableA[idx]);\n            ya \u003d epsA * denom;\n            yb \u003d epsB * denom;\n        } else {\n            double temp2 \u003d xa * TANGENT_TABLE_A[idx];\n            double za \u003d 1.0 + temp2;\n            double zb \u003d -(za - 1.0 - temp2);\n            temp2 \u003d xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n            temp \u003d za + temp2;\n            zb +\u003d -(temp - za - temp2);\n            za \u003d temp;\n\n            zb +\u003d xb * TANGENT_TABLE_B[idx];\n            ya \u003d epsA / za;\n\n            temp \u003d ya * HEX_40000000;\n            final double yaa \u003d (ya + temp) - temp;\n            final double yab \u003d ya - yaa;\n\n            temp \u003d za * HEX_40000000;\n            final double zaa \u003d (za + temp) - temp;\n            final double zab \u003d za - zaa;\n\n            /* Correct for rounding in division */\n            yb \u003d (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\n            yb +\u003d -epsA * zb / za / za;\n            yb +\u003d epsB / za;\n        }\n\n\n        epsA \u003d ya;\n        epsB \u003d yb;\n\n        /* Evaluate polynomial */\n        double epsA2 \u003d epsA*epsA;\n\n        /*\n    yb \u003d -0.09001346640161823;\n    yb \u003d yb * epsA2 + 0.11110718400605211;\n    yb \u003d yb * epsA2 + -0.1428571349122913;\n    yb \u003d yb * epsA2 + 0.19999999999273194;\n    yb \u003d yb * epsA2 + -0.33333333333333093;\n    yb \u003d yb * epsA2 * epsA;\n         */\n\n        yb \u003d 0.07490822288864472;\n        yb \u003d yb * epsA2 + -0.09088450866185192;\n        yb \u003d yb * epsA2 + 0.11111095942313305;\n        yb \u003d yb * epsA2 + -0.1428571423679182;\n        yb \u003d yb * epsA2 + 0.19999999999923582;\n        yb \u003d yb * epsA2 + -0.33333333333333287;\n        yb \u003d yb * epsA2 * epsA;\n\n\n        ya \u003d epsA;\n\n        temp \u003d ya + yb;\n        yb \u003d -(temp - ya - yb);\n        ya \u003d temp;\n\n        /* Add in effect of epsB.   atan\u0027(x) \u003d 1/(1+x^2) */\n        yb +\u003d epsB / (1.0 + epsA * epsA);\n\n        double result;\n        double resultb;\n\n        //result \u003d yb + eighths[idx] + ya;\n        double za \u003d EIGHTHS[idx] + ya;\n        double zb \u003d -(za - EIGHTHS[idx] - ya);\n        temp \u003d za + yb;\n        zb +\u003d -(temp - za - yb);\n        za \u003d temp;\n\n        result \u003d za + zb;\n        resultb \u003d -(result - za - zb);\n\n        if (leftPlane) {\n            // Result is in the left plane\n            final double pia \u003d 1.5707963267948966*2.0;\n            final double pib \u003d 6.123233995736766E-17*2.0;\n\n            za \u003d pia - result;\n            zb \u003d -(za - pia + result);\n            zb +\u003d pib - resultb;\n\n            result \u003d za + zb;\n            resultb \u003d -(result - za - zb);\n        }\n\n\n        if (negate ^ leftPlane) {\n            result \u003d -result;\n        }\n\n        return result;\n    }",
    "begin_line": 2817,
    "end_line": 2959,
    "comment": "/** \n * Internal helper function to compute arctangent.\n * @param xa number from which arctangent is requested\n * @param xb extra bits for x (may be 0.0)\n * @param leftPlane if true, result angle must be put in the left half plane\n * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atan2#2967",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.atan2(double, double)",
    "snippet": "public static double atan2(double y, double x) {\n        if (x !\u003dx || y !\u003d y) {\n            return Double.NaN;\n        }\n\n        if (y \u003d\u003d 0.0) {\n            double result \u003d x*y;\n            double invx \u003d 1.0/x;\n            double invy \u003d 1.0/y;\n\n            if (invx \u003d\u003d 0.0) { // X is infinite\n                if (x \u003e 0) {\n                    return y; // return +/- 0.0\n                } else {\n                    return copySign(Math.PI, y);\n                }\n            }\n\n            if (x \u003c 0.0 || invx \u003c 0.0) {\n                if (y \u003c 0.0 || invy \u003c 0.0) {\n                    return -Math.PI;\n                } else {\n                    return Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n\n        // y cannot now be zero\n\n        if (y \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n                return Math.PI/4.0;\n            }\n\n            if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n                return Math.PI*3.0/4.0;\n            }\n\n            return Math.PI/2.0;\n        }\n\n        if (y \u003d\u003d Double.NEGATIVE_INFINITY) {\n            if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n                return -Math.PI/4.0;\n            }\n\n            if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n                return -Math.PI*3.0/4.0;\n            }\n\n            return -Math.PI/2.0;\n        }\n\n        if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n            if (y \u003e 0.0 || 1/y \u003e 0.0) {\n                return 0.0;\n            }\n\n            if (y \u003c 0.0 || 1/y \u003c 0.0) {\n                return -0.0;\n            }\n        }\n\n        if (x \u003d\u003d Double.NEGATIVE_INFINITY)\n        {\n            if (y \u003e 0.0 || 1/y \u003e 0.0) {\n                return Math.PI;\n            }\n\n            if (y \u003c 0.0 || 1/y \u003c 0.0) {\n                return -Math.PI;\n            }\n        }\n\n        // Neither y nor x can be infinite or NAN here\n\n        if (x \u003d\u003d 0) {\n            if (y \u003e 0.0 || 1/y \u003e 0.0) {\n                return Math.PI/2.0;\n            }\n\n            if (y \u003c 0.0 || 1/y \u003c 0.0) {\n                return -Math.PI/2.0;\n            }\n        }\n\n        // Compute ratio r \u003d y/x\n        final double r \u003d y/x;\n        if (Double.isInfinite(r)) { // bypass calculations that can create NaN\n            return atan(r, 0, x \u003c 0);\n        }\n\n        double ra \u003d doubleHighPart(r);\n        double rb \u003d r - ra;\n\n        // Split x\n        final double xa \u003d doubleHighPart(x);\n        final double xb \u003d x - xa;\n\n        rb +\u003d (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\n        double temp \u003d ra + rb;\n        rb \u003d -(temp - ra - rb);\n        ra \u003d temp;\n\n        if (ra \u003d\u003d 0) { // Fix up the sign so atan works correctly\n            ra \u003d copySign(0.0, y);\n        }\n\n        // Call atan\n        double result \u003d atan(ra, rb, x \u003c 0);\n\n        return result;\n    }",
    "begin_line": 2967,
    "end_line": 3082,
    "comment": "/** \n * Two arguments arctangent function\n * @param y ordinate\n * @param x abscissa\n * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.asin#3088",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.asin(double)",
    "snippet": "public static double asin(double x) {\n      if (x !\u003d x) {\n          return Double.NaN;\n      }\n\n      if (x \u003e 1.0 || x \u003c -1.0) {\n          return Double.NaN;\n      }\n\n      if (x \u003d\u003d 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x \u003d\u003d -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x \u003d\u003d 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) \u003d atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp \u003d x * HEX_40000000;\n      final double xa \u003d x + temp - temp;\n      final double xb \u003d x - xa;\n\n      /* Square it */\n      double ya \u003d xa*xa;\n      double yb \u003d xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya \u003d -ya;\n      yb \u003d -yb;\n\n      double za \u003d 1.0 + ya;\n      double zb \u003d -(za - 1.0 - ya);\n\n      temp \u003d za + yb;\n      zb +\u003d -(temp - za - yb);\n      za \u003d temp;\n\n      /* Square root */\n      double y;\n      y \u003d sqrt(za);\n      temp \u003d y * HEX_40000000;\n      ya \u003d y + temp - temp;\n      yb \u003d y - ya;\n\n      /* Extend precision of sqrt */\n      yb +\u003d (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx \u003d zb / (2.0*y);\n\n      // Compute ratio r \u003d x/y\n      double r \u003d x/y;\n      temp \u003d r * HEX_40000000;\n      double ra \u003d r + temp - temp;\n      double rb \u003d r - ra;\n\n      rb +\u003d (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb +\u003d -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp \u003d ra + rb;\n      rb \u003d -(temp - ra - rb);\n      ra \u003d temp;\n\n      return atan(ra, rb, false);\n    }",
    "begin_line": 3088,
    "end_line": 3158,
    "comment": "/** \n * Compute the arc sine of a number.\n * @param x number on which evaluation is done\n * @return arc sine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.acos#3164",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.acos(double)",
    "snippet": "public static double acos(double x) {\n      if (x !\u003d x) {\n          return Double.NaN;\n      }\n\n      if (x \u003e 1.0 || x \u003c -1.0) {\n          return Double.NaN;\n      }\n\n      if (x \u003d\u003d -1.0) {\n          return Math.PI;\n      }\n\n      if (x \u003d\u003d 1.0) {\n          return 0.0;\n      }\n\n      if (x \u003d\u003d 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) \u003d atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp \u003d x * HEX_40000000;\n      final double xa \u003d x + temp - temp;\n      final double xb \u003d x - xa;\n\n      /* Square it */\n      double ya \u003d xa*xa;\n      double yb \u003d xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya \u003d -ya;\n      yb \u003d -yb;\n\n      double za \u003d 1.0 + ya;\n      double zb \u003d -(za - 1.0 - ya);\n\n      temp \u003d za + yb;\n      zb +\u003d -(temp - za - yb);\n      za \u003d temp;\n\n      /* Square root */\n      double y \u003d sqrt(za);\n      temp \u003d y * HEX_40000000;\n      ya \u003d y + temp - temp;\n      yb \u003d y - ya;\n\n      /* Extend precision of sqrt */\n      yb +\u003d (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb +\u003d zb / (2.0*y);\n      y \u003d ya+yb;\n      yb \u003d -(y - ya - yb);\n\n      // Compute ratio r \u003d y/x\n      double r \u003d y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra \u003d doubleHighPart(r);\n      double rb \u003d r - ra;\n\n      rb +\u003d (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb +\u003d yb / x;  // Add in effect additional bits of sqrt.\n\n      temp \u003d ra + rb;\n      rb \u003d -(temp - ra - rb);\n      ra \u003d temp;\n\n      return atan(ra, rb, x\u003c0);\n    }",
    "begin_line": 3164,
    "end_line": 3240,
    "comment": "/** \n * Compute the arc cosine of a number.\n * @param x number on which evaluation is done\n * @return arc cosine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cbrt#3246",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.cbrt(double)",
    "snippet": "public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits \u003d Double.doubleToLongBits(x);\n      int exponent \u003d (int) ((inbits \u003e\u003e 52) \u0026 0x7ff) - 1023;\n      boolean subnormal \u003d false;\n\n      if (exponent \u003d\u003d -1023) {\n          if (x \u003d\u003d 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal \u003d true;\n          x *\u003d 1.8014398509481984E16;  // 2^54\n          inbits \u003d Double.doubleToLongBits(x);\n          exponent \u003d (int) ((inbits \u003e\u003e 52) \u0026 0x7ff) - 1023;\n      }\n\n      if (exponent \u003d\u003d 1024) {\n          // Nan or infinity.  Don\u0027t care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 \u003d exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n      double p2 \u003d Double.longBitsToDouble((inbits \u0026 0x8000000000000000L) |\n                                          (long)(((exp3 + 1023) \u0026 0x7ff)) \u003c\u003c 52);\n\n      /* This will be a number between 1 and 2 */\n      final double mant \u003d Double.longBitsToDouble((inbits \u0026 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est \u003d -0.010714690733195933;\n      est \u003d est * mant + 0.0875862700108075;\n      est \u003d est * mant + -0.3058015757857271;\n      est \u003d est * mant + 0.7249995199969751;\n      est \u003d est * mant + 0.5039018405998233;\n\n      est *\u003d CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton\u0027s method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs \u003d x / (p2*p2*p2);\n      est +\u003d (xs - est*est*est) / (3*est*est);\n      est +\u003d (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton\u0027s method in extended precision to get the last bit right.\n      double temp \u003d est * HEX_40000000;\n      double ya \u003d est + temp - temp;\n      double yb \u003d est - ya;\n\n      double za \u003d ya * ya;\n      double zb \u003d ya * yb * 2.0 + yb * yb;\n      temp \u003d za * HEX_40000000;\n      double temp2 \u003d za + temp - temp;\n      zb +\u003d za - temp2;\n      za \u003d temp2;\n\n      zb \u003d za * yb + ya * zb + zb * yb;\n      za \u003d za * ya;\n\n      double na \u003d xs - za;\n      double nb \u003d -(na - xs + za);\n      nb -\u003d zb;\n\n      est +\u003d (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *\u003d p2;\n\n      if (subnormal) {\n          est *\u003d 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
    "begin_line": 3246,
    "end_line": 3324,
    "comment": "/** \n * Compute the cubic root of a number.\n * @param x number on which evaluation is done\n * @return cubic root of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.toRadians#3331",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.toRadians(double)",
    "snippet": "public static double toRadians(double x)\n    {\n        if (Double.isInfinite(x) || x \u003d\u003d 0.0) { // Matches +/- 0.0; return correct sign\n            return x;\n        }\n\n        // These are PI/180 split into high and low order bits\n        final double facta \u003d 0.01745329052209854;\n        final double factb \u003d 1.997844754509471E-9;\n\n        double xa \u003d doubleHighPart(x);\n        double xb \u003d x - xa;\n\n        double result \u003d xb * factb + xb * facta + xa * factb + xa * facta;\n        if (result \u003d\u003d 0) {\n            result \u003d result * x; // ensure correct sign if calculation underflows\n        }\n        return result;\n    }",
    "begin_line": 3331,
    "end_line": 3349,
    "comment": "/** \n * Convert degrees to radians, with error of less than 0.5 ULP\n * @param x angle in degrees\n * @return x converted into radians\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.toDegrees#3356",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.toDegrees(double)",
    "snippet": "public static double toDegrees(double x)\n    {\n        if (Double.isInfinite(x) || x \u003d\u003d 0.0) { // Matches +/- 0.0; return correct sign\n            return x;\n        }\n\n        // These are 180/PI split into high and low order bits\n        final double facta \u003d 57.2957763671875;\n        final double factb \u003d 3.145894820876798E-6;\n\n        double xa \u003d doubleHighPart(x);\n        double xb \u003d x - xa;\n\n        return xb * factb + xb * facta + xa * factb + xa * facta;\n    }",
    "begin_line": 3356,
    "end_line": 3370,
    "comment": "/** \n * Convert radians to degrees, with error of less than 0.5 ULP\n * @param x angle in radians\n * @return x converted into degrees\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3377",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.abs(int)",
    "snippet": "public static int abs(final int x) {\n        return (x \u003c 0) ? -x : x;\n    }",
    "begin_line": 3377,
    "end_line": 3379,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3386",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.abs(long)",
    "snippet": "public static long abs(final long x) {\n        return (x \u003c 0l) ? -x : x;\n    }",
    "begin_line": 3386,
    "end_line": 3388,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3395",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.abs(float)",
    "snippet": "public static float abs(final float x) {\n        return (x \u003c 0.0f) ? -x : (x \u003d\u003d 0.0f) ? 0.0f : x; // -0.0 \u003d\u003e +0.0\n    }",
    "begin_line": 3395,
    "end_line": 3397,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3404",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.abs(double)",
    "snippet": "public static double abs(double x) {\n        return (x \u003c 0.0) ? -x : (x \u003d\u003d 0.0) ? 0.0 : x; // -0.0 \u003d\u003e +0.0\n    }",
    "begin_line": 3404,
    "end_line": 3406,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.ulp#3413",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.ulp(double)",
    "snippet": "public static double ulp(double x) {\n        if (Double.isInfinite(x)) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }",
    "begin_line": 3413,
    "end_line": 3418,
    "comment": "/** \n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.ulp#3425",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.ulp(float)",
    "snippet": "public static float ulp(float x) {\n        if (Float.isInfinite(x)) {\n            return Float.POSITIVE_INFINITY;\n        }\n        return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n    }",
    "begin_line": 3425,
    "end_line": 3430,
    "comment": "/** \n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.scalb#3438",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.scalb(double, int)",
    "snippet": "public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n \u003e -1023) \u0026\u0026 (n \u003c 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) \u003c\u003c 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d \u003d\u003d 0)) {\n            return d;\n        }\n        if (n \u003c -2098) {\n            return (d \u003e 0) ? 0.0 : -0.0;\n        }\n        if (n \u003e 2097) {\n            return (d \u003e 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits \u003d Double.doubleToLongBits(d);\n        final long sign \u003d bits \u0026 0x8000000000000000L;\n        int  exponent   \u003d ((int) (bits \u003e\u003e\u003e 52)) \u0026 0x7ff;\n        long mantissa   \u003d bits \u0026 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent \u003d exponent + n;\n\n        if (n \u003c 0) {\n            // we are really in the case n \u003c\u003d -1023\n            if (scaledExponent \u003e 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) \u003c\u003c 52) | mantissa);\n            } else if (scaledExponent \u003e -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa \u003d mantissa | (1L \u003c\u003c 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit \u003d mantissa \u0026 (1L \u003c\u003c (-scaledExponent));\n                mantissa \u003d mantissa \u003e\u003e\u003e (1 - scaledExponent);\n                if (mostSignificantLostBit !\u003d 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign \u003d\u003d 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n \u003e\u003d 1024\n            if (exponent \u003d\u003d 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa \u003e\u003e\u003e 52) !\u003d 1) {\n                    mantissa \u003d mantissa \u003c\u003c 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa \u003d mantissa \u0026 0x000fffffffffffffL;\n\n                if (scaledExponent \u003c 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) \u003c\u003c 52) | mantissa);\n                } else {\n                    return (sign \u003d\u003d 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent \u003c 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) \u003c\u003c 52) | mantissa);\n            } else {\n                return (sign \u003d\u003d 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
    "begin_line": 3438,
    "end_line": 3514,
    "comment": "/** \n * Multiply a double number by a power of 2.\n * @param d number to multiply\n * @param n power of 2\n * @return d \u0026times; 2\u003csup\u003en\u003c/sup\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.scalb#3522",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.scalb(float, int)",
    "snippet": "public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n \u003e -127) \u0026\u0026 (n \u003c 128)) {\n            return f * Float.intBitsToFloat((n + 127) \u003c\u003c 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f \u003d\u003d 0f)) {\n            return f;\n        }\n        if (n \u003c -277) {\n            return (f \u003e 0) ? 0.0f : -0.0f;\n        }\n        if (n \u003e 276) {\n            return (f \u003e 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits \u003d Float.floatToIntBits(f);\n        final int sign \u003d bits \u0026 0x80000000;\n        int  exponent  \u003d (bits \u003e\u003e\u003e 23) \u0026 0xff;\n        int mantissa   \u003d bits \u0026 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent \u003d exponent + n;\n\n        if (n \u003c 0) {\n            // we are really in the case n \u003c\u003d -127\n            if (scaledExponent \u003e 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent \u003c\u003c 23) | mantissa);\n            } else if (scaledExponent \u003e -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa \u003d mantissa | (1 \u003c\u003c 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit \u003d mantissa \u0026 (1 \u003c\u003c (-scaledExponent));\n                mantissa \u003d mantissa \u003e\u003e\u003e (1 - scaledExponent);\n                if (mostSignificantLostBit !\u003d 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign \u003d\u003d 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n \u003e\u003d 128\n            if (exponent \u003d\u003d 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa \u003e\u003e\u003e 23) !\u003d 1) {\n                    mantissa \u003d mantissa \u003c\u003c 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa \u003d mantissa \u0026 0x007fffff;\n\n                if (scaledExponent \u003c 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent \u003c\u003c 23) | mantissa);\n                } else {\n                    return (sign \u003d\u003d 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent \u003c 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent \u003c\u003c 23) | mantissa);\n            } else {\n                return (sign \u003d\u003d 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
    "begin_line": 3522,
    "end_line": 3598,
    "comment": "/** \n * Multiply a float number by a power of 2.\n * @param f number to multiply\n * @param n power of 2\n * @return f \u0026times; 2\u003csup\u003en\u003c/sup\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextAfter#3631",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.nextAfter(double, double)",
    "snippet": "public static double nextAfter(double d, double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(d) || Double.isNaN(direction)) {\n            return Double.NaN;\n        } else if (d \u003d\u003d direction) {\n            return direction;\n        } else if (Double.isInfinite(d)) {\n            return (d \u003c 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n        } else if (d \u003d\u003d 0) {\n            return (direction \u003c 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final long bits \u003d Double.doubleToLongBits(d);\n        final long sign \u003d bits \u0026 0x8000000000000000L;\n        if ((direction \u003c d) ^ (sign \u003d\u003d 0L)) {\n            return Double.longBitsToDouble(sign | ((bits \u0026 0x7fffffffffffffffL) + 1));\n        } else {\n            return Double.longBitsToDouble(sign | ((bits \u0026 0x7fffffffffffffffL) - 1));\n        }\n\n    }",
    "begin_line": 3631,
    "end_line": 3654,
    "comment": "/** \n * Get the next machine representable number after a number, moving in the direction of another number. \u003cp\u003e The ordering is as follows (increasing): \u003cul\u003e \u003cli\u003e-INFINITY\u003c/li\u003e \u003cli\u003e-MAX_VALUE\u003c/li\u003e \u003cli\u003e-MIN_VALUE\u003c/li\u003e \u003cli\u003e-0.0\u003c/li\u003e \u003cli\u003e+0.0\u003c/li\u003e \u003cli\u003e+MIN_VALUE\u003c/li\u003e \u003cli\u003e+MAX_VALUE\u003c/li\u003e \u003cli\u003e+INFINITY\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cp\u003e If arguments compare equal, then the second argument is returned. \u003cp\u003e If  {@code direction} is greater than {@code d}, the smallest machine representable number strictly greater than {@code d} is returned; if less, then the largest representable numberstrictly less than  {@code d} is returned.\u003c/p\u003e\u003cp\u003e If  {@code d} is infinite and direction does notbring it back to finite numbers, it is returned unchanged.\u003c/p\u003e\n * @param d base number\n * @param direction (the only important thing is whether{@code direction} is greater or smaller than {@code d})\n * @return the next machine representable number in the specified direction\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextAfter#3687",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.nextAfter(float, double)",
    "snippet": "public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f \u003d\u003d direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f \u003c 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f \u003d\u003d 0f) {\n            return (direction \u003c 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits \u003d Float.floatToIntBits(f);\n        final int sign \u003d bits \u0026 0x80000000;\n        if ((direction \u003c f) ^ (sign \u003d\u003d 0)) {\n            return Float.intBitsToFloat(sign | ((bits \u0026 0x7fffffff) + 1));\n        } else {\n            return Float.intBitsToFloat(sign | ((bits \u0026 0x7fffffff) - 1));\n        }\n\n    }",
    "begin_line": 3687,
    "end_line": 3710,
    "comment": "/** \n * Get the next machine representable number after a number, moving in the direction of another number. \u003cp\u003e The ordering is as follows (increasing): \u003cul\u003e \u003cli\u003e-INFINITY\u003c/li\u003e \u003cli\u003e-MAX_VALUE\u003c/li\u003e \u003cli\u003e-MIN_VALUE\u003c/li\u003e \u003cli\u003e-0.0\u003c/li\u003e \u003cli\u003e+0.0\u003c/li\u003e \u003cli\u003e+MIN_VALUE\u003c/li\u003e \u003cli\u003e+MAX_VALUE\u003c/li\u003e \u003cli\u003e+INFINITY\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cp\u003e If arguments compare equal, then the second argument is returned. \u003cp\u003e If  {@code direction} is greater than {@code f}, the smallest machine representable number strictly greater than {@code f} is returned; if less, then the largest representable numberstrictly less than  {@code f} is returned.\u003c/p\u003e\u003cp\u003e If  {@code f} is infinite and direction does notbring it back to finite numbers, it is returned unchanged.\u003c/p\u003e\n * @param f base number\n * @param direction (the only important thing is whether{@code direction} is greater or smaller than {@code f})\n * @return the next machine representable number in the specified direction\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.floor#3716",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.floor(double)",
    "snippet": "public static double floor(double x) {\n        long y;\n\n        if (x !\u003d x) { // NaN\n            return x;\n        }\n\n        if (x \u003e\u003d TWO_POWER_52 || x \u003c\u003d -TWO_POWER_52) {\n            return x;\n        }\n\n        y \u003d (long) x;\n        if (x \u003c 0 \u0026\u0026 y !\u003d x) {\n            y--;\n        }\n\n        if (y \u003d\u003d 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "begin_line": 3716,
    "end_line": 3737,
    "comment": "/** \n * Get the largest whole number smaller than x.\n * @param x number from which floor is requested\n * @return a double number f such that f is an integer f \u003c\u003d x \u003c f + 1.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.ceil#3743",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.ceil(double)",
    "snippet": "public static double ceil(double x) {\n        double y;\n\n        if (x !\u003d x) { // NaN\n            return x;\n        }\n\n        y \u003d floor(x);\n        if (y \u003d\u003d x) {\n            return y;\n        }\n\n        y +\u003d 1.0;\n\n        if (y \u003d\u003d 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "begin_line": 3743,
    "end_line": 3762,
    "comment": "/** \n * Get the smallest whole number larger than x.\n * @param x number from which ceil is requested\n * @return a double number c such that c is an integer c - 1.0 \u003c x \u003c\u003d c\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.rint#3768",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.rint(double)",
    "snippet": "public static double rint(double x) {\n        double y \u003d floor(x);\n        double d \u003d x - y;\n\n        if (d \u003e 0.5) {\n            if (y \u003d\u003d -1.0) {\n                return -0.0; // Preserve sign of operand\n            }\n            return y+1.0;\n        }\n        if (d \u003c 0.5) {\n            return y;\n        }\n\n        /* half way, round to even */\n        long z \u003d (long) y;\n        return (z \u0026 1) \u003d\u003d 0 ? y : y + 1.0;\n    }",
    "begin_line": 3768,
    "end_line": 3785,
    "comment": "/** \n * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n * @param x number from which nearest whole number is requested\n * @return a double number r such that r is an integer r - 0.5 \u003c\u003d x \u003c\u003d r + 0.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.round#3791",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.round(double)",
    "snippet": "public static long round(double x) {\n        return (long) floor(x + 0.5);\n    }",
    "begin_line": 3791,
    "end_line": 3793,
    "comment": "/** \n * Get the closest long to x.\n * @param x number from which closest long is requested\n * @return closest long to x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.round#3799",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.round(float)",
    "snippet": "public static int round(final float x) {\n        return (int) floor(x + 0.5f);\n    }",
    "begin_line": 3799,
    "end_line": 3801,
    "comment": "/** \n * Get the closest int to x.\n * @param x number from which closest int is requested\n * @return closest int to x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3808",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.min(int, int)",
    "snippet": "public static int min(final int a, final int b) {\n        return (a \u003c\u003d b) ? a : b;\n    }",
    "begin_line": 3808,
    "end_line": 3810,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3817",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.min(long, long)",
    "snippet": "public static long min(final long a, final long b) {\n        return (a \u003c\u003d b) ? a : b;\n    }",
    "begin_line": 3817,
    "end_line": 3819,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3826",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.min(float, float)",
    "snippet": "public static float min(final float a, final float b) {\n        if (a \u003e b) {\n            return b;\n        }\n        if (a \u003c b) {\n            return a;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a !\u003d b) {\n            return Float.NaN;\n        }\n        /* min(+0.0,-0.0) \u003d\u003d -0.0 */\n        /* 0x80000000 \u003d\u003d Float.floatToRawIntBits(-0.0d) */\n        int bits \u003d Float.floatToRawIntBits(a);\n        if (bits \u003d\u003d 0x80000000) {\n            return a;\n        }\n        return b;\n    }",
    "begin_line": 3826,
    "end_line": 3844,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3851",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.min(double, double)",
    "snippet": "public static double min(final double a, final double b) {\n        if (a \u003e b) {\n            return b;\n        }\n        if (a \u003c b) {\n            return a;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a !\u003d b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) \u003d\u003d -0.0 */\n        /* 0x8000000000000000L \u003d\u003d Double.doubleToRawLongBits(-0.0d) */\n        long bits \u003d Double.doubleToRawLongBits(a);\n        if (bits \u003d\u003d 0x8000000000000000L) {\n            return a;\n        }\n        return b;\n    }",
    "begin_line": 3851,
    "end_line": 3869,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3876",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.max(int, int)",
    "snippet": "public static int max(final int a, final int b) {\n        return (a \u003c\u003d b) ? b : a;\n    }",
    "begin_line": 3876,
    "end_line": 3878,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3885",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.max(long, long)",
    "snippet": "public static long max(final long a, final long b) {\n        return (a \u003c\u003d b) ? b : a;\n    }",
    "begin_line": 3885,
    "end_line": 3887,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3894",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.max(float, float)",
    "snippet": "public static float max(final float a, final float b) {\n        if (a \u003e b) {\n            return a;\n        }\n        if (a \u003c b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a !\u003d b) {\n            return Float.NaN;\n        }\n        /* min(+0.0,-0.0) \u003d\u003d -0.0 */\n        /* 0x80000000 \u003d\u003d Float.floatToRawIntBits(-0.0d) */\n        int bits \u003d Float.floatToRawIntBits(a);\n        if (bits \u003d\u003d 0x80000000) {\n            return b;\n        }\n        return a;\n    }",
    "begin_line": 3894,
    "end_line": 3912,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3919",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.max(double, double)",
    "snippet": "public static double max(final double a, final double b) {\n        if (a \u003e b) {\n            return a;\n        }\n        if (a \u003c b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a !\u003d b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) \u003d\u003d -0.0 */\n        /* 0x8000000000000000L \u003d\u003d Double.doubleToRawLongBits(-0.0d) */\n        long bits \u003d Double.doubleToRawLongBits(a);\n        if (bits \u003d\u003d 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }",
    "begin_line": 3919,
    "end_line": 3937,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.hypot#3953",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.hypot(double, double)",
    "snippet": "public static double hypot(final double x, final double y) {\n        if (Double.isInfinite(x) || Double.isInfinite(y)) {\n            return Double.POSITIVE_INFINITY;\n        } else if (Double.isNaN(x) || Double.isNaN(y)) {\n            return Double.NaN;\n        } else {\n\n            final int expX \u003d getExponent(x);\n            final int expY \u003d getExponent(y);\n            if (expX \u003e expY + 27) {\n                // y is neglectible with respect to x\n                return abs(x);\n            } else if (expY \u003e expX + 27) {\n                // x is neglectible with respect to y\n                return abs(y);\n            } else {\n\n                // find an intermediate scale to avoid both overflow and underflow\n                final int middleExp \u003d (expX + expY) / 2;\n\n                // scale parameters without losing precision\n                final double scaledX \u003d scalb(x, -middleExp);\n                final double scaledY \u003d scalb(y, -middleExp);\n\n                // compute scaled hypotenuse\n                final double scaledH \u003d sqrt(scaledX * scaledX + scaledY * scaledY);\n\n                // remove scaling\n                return scalb(scaledH, middleExp);\n\n            }\n\n        }\n    }",
    "begin_line": 3953,
    "end_line": 3986,
    "comment": "/** \n * Returns the hypotenuse of a triangle with sides  {@code x} and {@code y}- sqrt(\u003ci\u003ex\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u0026nbsp;+\u003ci\u003ey\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e)\u003cbr/\u003e avoiding intermediate overflow or underflow. \u003cul\u003e \u003cli\u003e If either argument is infinite, then the result is positive infinity.\u003c/li\u003e \u003cli\u003e else, if either argument is NaN then the result is NaN.\u003c/li\u003e \u003c/ul\u003e\n * @param x a value\n * @param y a value\n * @return sqrt(\u003ci\u003ex\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u0026nbsp;+\u003ci\u003ey\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.IEEEremainder#4008",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.IEEEremainder(double, double)",
    "snippet": "public static double IEEEremainder(double dividend, double divisor) {\n        return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation\n    }",
    "begin_line": 4008,
    "end_line": 4010,
    "comment": "/** \n * Computes the remainder as prescribed by the IEEE 754 standard. The remainder value is mathematically equal to  {@code x - y*n}where  {@code n} is the mathematical integer closest to the exact mathematical valueof the quotient  {@code x/y}. If two mathematical integers are equally close to  {@code x/y} then{@code n} is the integer that is even.\u003cp\u003e \u003cul\u003e \u003cli\u003eIf either operand is NaN, the result is NaN.\u003c/li\u003e \u003cli\u003eIf the result is not NaN, the sign of the result equals the sign of the dividend.\u003c/li\u003e \u003cli\u003eIf the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.\u003c/li\u003e \u003cli\u003eIf the dividend is finite and the divisor is an infinity, the result equals the dividend.\u003c/li\u003e \u003cli\u003eIf the dividend is a zero and the divisor is finite, the result equals the dividend.\u003c/li\u003e \u003c/ul\u003e \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e this implementation currently delegates to  {@link StrictMath#IEEEremainder}\n * @param dividend the number to be divided\n * @param divisor the number by which to divide\n * @return the remainder, rounded\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.copySign#4020",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.copySign(double, double)",
    "snippet": "public static double copySign(double magnitude, double sign){\n        long m \u003d Double.doubleToLongBits(magnitude);\n        long s \u003d Double.doubleToLongBits(sign);\n        if ((m \u003e\u003d 0 \u0026\u0026 s \u003e\u003d 0) || (m \u003c 0 \u0026\u0026 s \u003c 0)) { // Sign is currently OK\n            return magnitude;\n        }\n        return -magnitude; // flip sign\n    }",
    "begin_line": 4020,
    "end_line": 4027,
    "comment": "/** \n * Returns the first argument with the sign of the second argument. A NaN  {@code sign} argument is treated as positive.\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.copySign#4037",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.copySign(float, float)",
    "snippet": "public static float copySign(float magnitude, float sign){\n        int m \u003d Float.floatToIntBits(magnitude);\n        int s \u003d Float.floatToIntBits(sign);\n        if ((m \u003e\u003d 0 \u0026\u0026 s \u003e\u003d 0) || (m \u003c 0 \u0026\u0026 s \u003c 0)) { // Sign is currently OK\n            return magnitude;\n        }\n        return -magnitude; // flip sign\n    }",
    "begin_line": 4037,
    "end_line": 4044,
    "comment": "/** \n * Returns the first argument with the sign of the second argument. A NaN  {@code sign} argument is treated as positive.\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.getExponent#4055",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.getExponent(double)",
    "snippet": "public static int getExponent(final double d) {\n        return (int) ((Double.doubleToLongBits(d) \u003e\u003e\u003e 52) \u0026 0x7ff) - 1023;\n    }",
    "begin_line": 4055,
    "end_line": 4057,
    "comment": "/** \n * Return the exponent of a double number, removing the bias. \u003cp\u003e For double numbers of the form 2\u003csup\u003ex\u003c/sup\u003e, the unbiased exponent is exactly x. \u003c/p\u003e\n * @param d number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.getExponent#4068",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/FastMath.java",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.getExponent(float)",
    "snippet": "public static int getExponent(final float f) {\n        return ((Float.floatToIntBits(f) \u003e\u003e\u003e 23) \u0026 0xff) - 127;\n    }",
    "begin_line": 4068,
    "end_line": 4070,
    "comment": "/** \n * Return the exponent of a float number, removing the bias. \u003cp\u003e For float numbers of the form 2\u003csup\u003ex\u003c/sup\u003e, the unbiased exponent is exactly x. \u003c/p\u003e\n * @param f number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.MathUtils#97",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.MathUtils()",
    "snippet": "private MathUtils() {\n        super();\n    }",
    "begin_line": 97,
    "end_line": 99,
    "comment": "/** \n * Private Constructor\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.addAndCheck#111",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.addAndCheck(int, int)",
    "snippet": "public static int addAndCheck(int x, int y) {\n        long s \u003d (long)x + (long)y;\n        if (s \u003c Integer.MIN_VALUE || s \u003e Integer.MAX_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n        }\n        return (int)s;\n    }",
    "begin_line": 111,
    "end_line": 117,
    "comment": "/** \n * Add two integers, checking for overflow.\n * @param x an addend\n * @param y an addend\n * @return the sum {@code x+y}\n * @throws MathArithmeticException if the result can not be representedas an  {@code int}.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.addAndCheck#129",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.addAndCheck(long, long)",
    "snippet": "public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n    }",
    "begin_line": 129,
    "end_line": 131,
    "comment": "/** \n * Add two long integers, checking for overflow.\n * @param a an addend\n * @param b an addend\n * @return the sum {@code a+b}\n * @throws MathArithmeticException if the result can not be represented as anlong\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.addAndCheck#144",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.addAndCheck(long, long, org.apache.commons.math.exception.util.Localizable)",
    "snippet": "private static long addAndCheck(long a, long b, Localizable pattern) {\n        long ret;\n        if (a \u003e b) {\n            // use symmetry to reduce boundary cases\n            ret \u003d addAndCheck(b, a, pattern);\n        } else {\n            // assert a \u003c\u003d b\n\n            if (a \u003c 0) {\n                if (b \u003c 0) {\n                    // check for negative overflow\n                    if (Long.MIN_VALUE - b \u003c\u003d a) {\n                        ret \u003d a + b;\n                    } else {\n                        throw new MathArithmeticException(pattern, a, b);\n                    }\n                } else {\n                    // opposite sign addition is always safe\n                    ret \u003d a + b;\n                }\n            } else {\n                // assert a \u003e\u003d 0\n                // assert b \u003e\u003d 0\n\n                // check for positive overflow\n                if (a \u003c\u003d Long.MAX_VALUE - b) {\n                    ret \u003d a + b;\n                } else {\n                    throw new MathArithmeticException(pattern, a, b);\n                }\n            }\n        }\n        return ret;\n    }",
    "begin_line": 144,
    "end_line": 177,
    "comment": "/** \n * Add two long integers, checking for overflow.\n * @param a Addend.\n * @param b Addend.\n * @param pattern Pattern to use for any thrown exception.\n * @return the sum {@code a + b}.\n * @throws MathArithmeticException if the result cannot be representedas a  {@code long}.\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.binomialCoefficient#204",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.binomialCoefficient(int, int)",
    "snippet": "public static long binomialCoefficient(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n \u003d\u003d k) || (k \u003d\u003d 0)) {\n            return 1;\n        }\n        if ((k \u003d\u003d 1) || (k \u003d\u003d n - 1)) {\n            return n;\n        }\n        // Use symmetry for large k\n        if (k \u003e n / 2)\n            return binomialCoefficient(n, n - k);\n\n        // We use the formula\n        // (n choose k) \u003d n! / (n-k)! / k!\n        // (n choose k) \u003d\u003d ((n-k+1)*...*n) / (1*...*k)\n        // which could be written\n        // (n choose k) \u003d\u003d (n-1 choose k-1) * n / k\n        long result \u003d 1;\n        if (n \u003c\u003d 61) {\n            // For n \u003c\u003d 61, the naive implementation cannot overflow.\n            int i \u003d n - k + 1;\n            for (int j \u003d 1; j \u003c\u003d k; j++) {\n                result \u003d result * i / j;\n                i++;\n            }\n        } else if (n \u003c\u003d 66) {\n            // For n \u003e 61 but n \u003c\u003d 66, the result cannot overflow,\n            // but we must take care not to overflow intermediate values.\n            int i \u003d n - k + 1;\n            for (int j \u003d 1; j \u003c\u003d k; j++) {\n                // We know that (result * i) is divisible by j,\n                // but (result * i) may overflow, so we split j:\n                // Filter out the gcd, d, so j/d and i/d are integer.\n                // result is divisible by (j/d) because (j/d)\n                // is relative prime to (i/d) and is a divisor of\n                // result * (i/d).\n                final long d \u003d gcd(i, j);\n                result \u003d (result / (j / d)) * (i / d);\n                i++;\n            }\n        } else {\n            // For n \u003e 66, a result overflow might occur, so we check\n            // the multiplication, taking care to not overflow\n            // unnecessary.\n            int i \u003d n - k + 1;\n            for (int j \u003d 1; j \u003c\u003d k; j++) {\n                final long d \u003d gcd(i, j);\n                result \u003d mulAndCheck(result / (j / d), i / d);\n                i++;\n            }\n        }\n        return result;\n    }",
    "begin_line": 204,
    "end_line": 256,
    "comment": "/** \n * Returns an exact representation of the \u003ca href\u003d\"http://mathworld.wolfram.com/BinomialCoefficient.html\"\u003e Binomial Coefficient\u003c/a\u003e, \" {@code n choose k}\", the number of {@code k}-element subsets that can be selected from an {@code n}-element set. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e  {@code 0 \u003c\u003d k \u003c\u003d n } (otherwise{@code IllegalArgumentException} is thrown)\u003c/li\u003e\u003cli\u003e The result is small enough to fit into a  {@code long}. The largest value of  {@code n} for which all coefficients are{@code  \u003c Long.MAX_VALUE} is 66. If the computed value exceeds{@code Long.MAX_VALUE} an {@code ArithMeticException} isthrown.\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws MathIllegalArgumentException if preconditions are not met.\n * @throws MathArithmeticException if the result is too large to berepresented by a long integer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.binomialCoefficientDouble#280",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.binomialCoefficientDouble(int, int)",
    "snippet": "public static double binomialCoefficientDouble(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n \u003d\u003d k) || (k \u003d\u003d 0)) {\n            return 1d;\n        }\n        if ((k \u003d\u003d 1) || (k \u003d\u003d n - 1)) {\n            return n;\n        }\n        if (k \u003e n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n \u003c 67) {\n            return binomialCoefficient(n,k);\n        }\n\n        double result \u003d 1d;\n        for (int i \u003d 1; i \u003c\u003d k; i++) {\n             result *\u003d (double)(n - k + i) / (double)i;\n        }\n\n        return FastMath.floor(result + 0.5);\n    }",
    "begin_line": 280,
    "end_line": 301,
    "comment": "/** \n * Returns a  {@code double} representation of the \u003cahref\u003d\"http://mathworld.wolfram.com/BinomialCoefficient.html\"\u003e Binomial Coefficient\u003c/a\u003e, \" {@code n choose k}\", the number of {@code k}-element subsets that can be selected from an {@code n}-element set. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e  {@code 0 \u003c\u003d k \u003c\u003d n } (otherwise{@code IllegalArgumentException} is thrown)\u003c/li\u003e\u003cli\u003e The result is small enough to fit into a  {@code double}. The largest value of  {@code n} for which all coefficients are \u003cDouble.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.binomialCoefficientLog#321",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.binomialCoefficientLog(int, int)",
    "snippet": "public static double binomialCoefficientLog(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n \u003d\u003d k) || (k \u003d\u003d 0)) {\n            return 0;\n        }\n        if ((k \u003d\u003d 1) || (k \u003d\u003d n - 1)) {\n            return FastMath.log(n);\n        }\n\n        /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value\n         */\n        if (n \u003c 67) {\n            return FastMath.log(binomialCoefficient(n,k));\n        }\n\n        /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n        if (n \u003c 1030) {\n            return FastMath.log(binomialCoefficientDouble(n, k));\n        }\n\n        if (k \u003e n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        /*\n         * Sum logs for values that could overflow\n         */\n        double logSum \u003d 0;\n\n        // n!/(n-k)!\n        for (int i \u003d n - k + 1; i \u003c\u003d n; i++) {\n            logSum +\u003d FastMath.log(i);\n        }\n\n        // divide by k!\n        for (int i \u003d 2; i \u003c\u003d k; i++) {\n            logSum -\u003d FastMath.log(i);\n        }\n\n        return logSum;\n    }",
    "begin_line": 321,
    "end_line": 366,
    "comment": "/** \n * Returns the natural  {@code log} of the \u003cahref\u003d\"http://mathworld.wolfram.com/BinomialCoefficient.html\"\u003e Binomial Coefficient\u003c/a\u003e, \" {@code n choose k}\", the number of {@code k}-element subsets that can be selected from an {@code n}-element set. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e  {@code 0 \u003c\u003d k \u003c\u003d n } (otherwise{@code IllegalArgumentException} is thrown)\u003c/li\u003e\u003c/ul\u003e\u003c/p\u003e\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkBinomial#376",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkBinomial(int, int)",
    "snippet": "private static void checkBinomial(final int n, final int k) {\n        if (n \u003c k) {\n            throw new NumberIsTooLargeException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n                                                k, n, true);\n        }\n        if (n \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER, n);\n        }\n    }",
    "begin_line": 376,
    "end_line": 384,
    "comment": "/** \n * Check binomial preconditions.\n * @param n Size of the set.\n * @param k Size of the subsets to be counted.\n * @throws NotPositiveException if {@code n \u003c 0}.\n * @throws NumberIsTooLargeException if {@code k \u003e n}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.compareTo#396",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.compareTo(double, double, double)",
    "snippet": "public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x \u003c y) {\n            return -1;\n        }\n        return 1;\n    }",
    "begin_line": 396,
    "end_line": 403,
    "comment": "/** \n * Compares two numbers given some amount of allowed error.\n * @param x the first number\n * @param y the second number\n * @param eps the amount of error to allow when checking for equality\n * @return \u003cul\u003e\u003cli\u003e0 if  {@link #equals(double,double,double) equals(x, y, eps)}\u003c/li\u003e \u003cli\u003e\u0026lt; 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u0026lt; y\u003c/li\u003e\u003cli\u003e\u003e 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u003e y\u003c/li\u003e\u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.compareTo#422",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.compareTo(double, double, int)",
    "snippet": "public static int compareTo(final double x, final double y, final int maxUlps) {\n        if (equals(x, y, maxUlps)) {\n            return 0;\n        } else if (x \u003c y) {\n            return -1;\n        }\n        return 1;\n    }",
    "begin_line": 422,
    "end_line": 429,
    "comment": "/** \n * Compares two numbers given some amount of allowed error. Two float numbers are considered equal if there are  {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return \u003cul\u003e\u003cli\u003e0 if  {@link #equals(double,double,int) equals(x, y, maxUlps)}\u003c/li\u003e \u003cli\u003e\u0026lt; 0 if ! {@link #equals(double,double,int) equals(x, y, maxUlps)} \u0026amp;\u0026amp; x \u0026lt; y\u003c/li\u003e\u003cli\u003e\u003e 0 if ! {@link #equals(double,double,int) equals(x, y, maxUlps)} \u0026amp;\u0026amp; x \u003e y\u003c/li\u003e\u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.cosh#438",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.cosh(double)",
    "snippet": "public static double cosh(double x) {\n        return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n    }",
    "begin_line": 438,
    "end_line": 440,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/HyperbolicCosine.html\"\u003e hyperbolic cosine\u003c/a\u003e of x.\n * @param x double value for which to find the hyperbolic cosine\n * @return hyperbolic cosine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#450",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(float, float)",
    "snippet": "public static boolean equals(float x, float y) {\n        return equals(x, y, 1);\n    }",
    "begin_line": 450,
    "end_line": 452,
    "comment": "/** \n * Returns true iff they are equal as defined by {@link #equals(float,float,int) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equalsIncludingNaN#463",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equalsIncludingNaN(float, float)",
    "snippet": "public static boolean equalsIncludingNaN(float x, float y) {\n        return (Float.isNaN(x) \u0026\u0026 Float.isNaN(y)) || equals(x, y, 1);\n    }",
    "begin_line": 463,
    "end_line": 465,
    "comment": "/** \n * Returns true if both arguments are NaN or neither is NaN and they are equal as defined by  {@link #equals(float,float) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#477",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(float, float, float)",
    "snippet": "public static boolean equals(float x, float y, float eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) \u003c\u003d eps;\n    }",
    "begin_line": 477,
    "end_line": 479,
    "comment": "/** \n * Returns true if both arguments are equal or within the range of allowed error (inclusive).\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equalsIncludingNaN#492",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equalsIncludingNaN(float, float, float)",
    "snippet": "public static boolean equalsIncludingNaN(float x, float y, float eps) {\n        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) \u003c\u003d eps);\n    }",
    "begin_line": 492,
    "end_line": 494,
    "comment": "/** \n * Returns true if both arguments are NaN or are equal or within the range of allowed error (inclusive).\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#514",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(float, float, int)",
    "snippet": "public static boolean equals(float x, float y, int maxUlps) {\n        int xInt \u003d Float.floatToIntBits(x);\n        int yInt \u003d Float.floatToIntBits(y);\n\n        // Make lexicographically ordered as a two\u0027s-complement integer.\n        if (xInt \u003c 0) {\n            xInt \u003d SGN_MASK_FLOAT - xInt;\n        }\n        if (yInt \u003c 0) {\n            yInt \u003d SGN_MASK_FLOAT - yInt;\n        }\n\n        final boolean isEqual \u003d FastMath.abs(xInt - yInt) \u003c\u003d maxUlps;\n\n        return isEqual \u0026\u0026 !Float.isNaN(x) \u0026\u0026 !Float.isNaN(y);\n    }",
    "begin_line": 514,
    "end_line": 529,
    "comment": "/** \n * Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are  {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floatingpoint values between  {@code x} and {@code y}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equalsIncludingNaN#543",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equalsIncludingNaN(float, float, int)",
    "snippet": "public static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n        return (Float.isNaN(x) \u0026\u0026 Float.isNaN(y)) || equals(x, y, maxUlps);\n    }",
    "begin_line": 543,
    "end_line": 545,
    "comment": "/** \n * Returns true if both arguments are NaN or if they are equal as defined by  {@link #equals(float,float,int) equals(x, y, maxUlps)}.\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#557",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(float[], float[])",
    "snippet": "public static boolean equals(float[] x, float[] y) {\n        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n        }\n        if (x.length !\u003d y.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 557,
    "end_line": 570,
    "comment": "/** \n * Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by {@link #equals(float,float)}.\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimensionand equal elements.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equalsIncludingNaN#583",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equalsIncludingNaN(float[], float[])",
    "snippet": "public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n        }\n        if (x.length !\u003d y.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c x.length; ++i) {\n            if (!equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 583,
    "end_line": 596,
    "comment": "/** \n * Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by {@link #equalsIncludingNaN(double,double) this method}.\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension andequal elements\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#606",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double, double)",
    "snippet": "public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }",
    "begin_line": 606,
    "end_line": 608,
    "comment": "/** \n * Returns true iff they are equal as defined by {@link #equals(double,double,int) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equalsIncludingNaN#619",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equalsIncludingNaN(double, double)",
    "snippet": "public static boolean equalsIncludingNaN(double x, double y) {\n        return (Double.isNaN(x) \u0026\u0026 Double.isNaN(y)) || equals(x, y, 1);\n    }",
    "begin_line": 619,
    "end_line": 621,
    "comment": "/** \n * Returns true if both arguments are NaN or neither is NaN and they are equal as defined by  {@link #equals(double,double) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#634",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double, double, double)",
    "snippet": "public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) \u003c\u003d eps;\n    }",
    "begin_line": 634,
    "end_line": 636,
    "comment": "/** \n * Returns  {@code true} if there is no double value strictly between thearguments or the difference between them is within the range of allowed error (inclusive).\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating pointnumbers or they are within range of each other.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equalsIncludingNaN#649",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equalsIncludingNaN(double, double, double)",
    "snippet": "public static boolean equalsIncludingNaN(double x, double y, double eps) {\n        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) \u003c\u003d eps);\n    }",
    "begin_line": 649,
    "end_line": 651,
    "comment": "/** \n * Returns true if both arguments are NaN or are equal or within the range of allowed error (inclusive).\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#670",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double, double, int)",
    "snippet": "public static boolean equals(double x, double y, int maxUlps) {\n        long xInt \u003d Double.doubleToLongBits(x);\n        long yInt \u003d Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two\u0027s-complement integer.\n        if (xInt \u003c 0) {\n            xInt \u003d SGN_MASK - xInt;\n        }\n        if (yInt \u003c 0) {\n            yInt \u003d SGN_MASK - yInt;\n        }\n\n        final boolean isEqual \u003d FastMath.abs(xInt - yInt) \u003c\u003d maxUlps;\n\n        return isEqual \u0026\u0026 !Double.isNaN(x) \u0026\u0026 !Double.isNaN(y);\n    }",
    "begin_line": 670,
    "end_line": 685,
    "comment": "/** \n * Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are  {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floatingpoint values between  {@code x} and {@code y}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equalsIncludingNaN#699",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equalsIncludingNaN(double, double, int)",
    "snippet": "public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n        return (Double.isNaN(x) \u0026\u0026 Double.isNaN(y)) || equals(x, y, maxUlps);\n    }",
    "begin_line": 699,
    "end_line": 701,
    "comment": "/** \n * Returns true if both arguments are NaN or if they are equal as defined by  {@link #equals(double,double,int) equals(x, y, maxUlps)}.\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#713",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double[], double[])",
    "snippet": "public static boolean equals(double[] x, double[] y) {\n        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n        }\n        if (x.length !\u003d y.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 713,
    "end_line": 726,
    "comment": "/** \n * Returns  {@code true} iff both arguments are {@code null} or have samedimensions and all their elements are equal as defined by {@link #equals(double,double)}.\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have samedimension and equal elements.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equalsIncludingNaN#739",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equalsIncludingNaN(double[], double[])",
    "snippet": "public static boolean equalsIncludingNaN(double[] x, double[] y) {\n        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n        }\n        if (x.length !\u003d y.length) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c x.length; ++i) {\n            if (!equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "begin_line": 739,
    "end_line": 752,
    "comment": "/** \n * Returns  {@code true} iff both arguments are {@code null} or have samedimensions and all their elements are equal as defined by {@link #equalsIncludingNaN(double,double) this method}.\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have samedimension and equal elements.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.factorial#778",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.factorial(int)",
    "snippet": "public static long factorial(final int n) {\n        if (n \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                                           n);\n        }\n        if (n \u003e 20) {\n            throw new MathArithmeticException();\n        }\n        return FACTORIALS[n];\n    }",
    "begin_line": 778,
    "end_line": 787,
    "comment": "/** \n * Returns n!. Shorthand for  {@code n} \u003cahref\u003d\"http://mathworld.wolfram.com/Factorial.html\"\u003e Factorial\u003c/a\u003e, the product of the numbers  {@code 1,...,n}. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e  {@code n \u003e\u003d 0} (otherwise{@code IllegalArgumentException} is thrown)\u003c/li\u003e\u003cli\u003e The result is small enough to fit into a  {@code long}. The largest value of  {@code n} for which {@code n!} \u003cLong.MAX_VALUE} is 20. If the computed value exceeds  {@code Long.MAX_VALUE}an  {@code ArithMeticException } is thrown.\u003c/li\u003e\u003c/ul\u003e \u003c/p\u003e\n * @param n argument\n * @return {@code n!}\n * @throws MathArithmeticException if the result is too large to be representedby a  {@code long}.\n * @throws NotPositiveException if {@code n \u003c 0}.\n * @throws MathArithmeticException if {@code n \u003e 20}: The factorial value is too large to fit in a  {@code long}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.factorialDouble#802",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.factorialDouble(int)",
    "snippet": "public static double factorialDouble(final int n) {\n        if (n \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                                           n);\n        }\n        if (n \u003c 21) {\n            return factorial(n);\n        }\n        return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);\n    }",
    "begin_line": 802,
    "end_line": 811,
    "comment": "/** \n * Compute n!, the\u003ca href\u003d\"http://mathworld.wolfram.com/Factorial.html\"\u003e factorial\u003c/a\u003e of  {@code n} (the product of the numbers 1 to n), as a{@code double}. The result should be small enough to fit into a  {@code double}: The largest  {@code n} for which {@code n! \u003c Double.MAX_VALUE} is 170.If the computed value exceeds  {@code Double.MAX_VALUE}, {@code Double.POSITIVE_INFINITY} is returned.\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.factorialLog#820",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.factorialLog(int)",
    "snippet": "public static double factorialLog(final int n) {\n        if (n \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                                           n);\n        }\n        if (n \u003c 21) {\n            return FastMath.log(factorial(n));\n        }\n        double logSum \u003d 0;\n        for (int i \u003d 2; i \u003c\u003d n; i++) {\n            logSum +\u003d FastMath.log(i);\n        }\n        return logSum;\n    }",
    "begin_line": 820,
    "end_line": 833,
    "comment": "/** \n * Compute the natural logarithm of the factorial of  {@code n}.\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.gcd#864",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.gcd(int, int)",
    "snippet": "public static int gcd(final int p, final int q) {\n        int u \u003d p;\n        int v \u003d q;\n        if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n            if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                                                  p, q);\n            }\n            return FastMath.abs(u) + FastMath.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can\u0027t necessarily negate a negative number without\n        // overflow)\n        /* assert u!\u003d0 \u0026\u0026 v!\u003d0; */\n        if (u \u003e 0) {\n            u \u003d -u;\n        } // make u negative\n        if (v \u003e 0) {\n            v \u003d -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k \u003d 0;\n        while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) { // while u and v are\n                                                            // both even...\n            u /\u003d 2;\n            v /\u003d 2;\n            k++; // cast out twos.\n        }\n        if (k \u003d\u003d 31) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                                              p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u\u003c0 \u0026\u0026 v\u003c0; */\n            // B4/B3: cast out twos from t.\n            while ((t \u0026 1) \u003d\u003d 0) { // while t is even..\n                t /\u003d 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t \u003e 0) {\n                u \u003d -t;\n            } else {\n                v \u003d t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t \u003d (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t !\u003d 0);\n        return -u * (1 \u003c\u003c k); // gcd is u*2^k\n    }",
    "begin_line": 864,
    "end_line": 920,
    "comment": "/** \n * \u003cp\u003e Gets the greatest common divisor of the absolute value of two numbers, using the \"binary gcd\" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). \u003c/p\u003e Special cases: \u003cul\u003e \u003cli\u003eThe invocations {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)}, {@code gcd(Integer.MIN_VALUE, 0)} and{@code gcd(0, Integer.MIN_VALUE)} throw an{@code ArithmeticException}, because the result would be 2^31, which is too large for an int value.\u003c/li\u003e \u003cli\u003eThe result of  {@code gcd(x, x)},  {@code gcd(0, x)} and{@code gcd(x, 0)} is the absolute value of {@code x}, except for the special cases above. \u003cli\u003eThe invocation  {@code gcd(0, 0)} is the only one which returns{@code 0}.\u003c/li\u003e \u003c/ul\u003e\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor, never negative.\n * @throws MathArithmeticException if the result cannot be represented asa non-negative  {@code int} value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.gcd#951",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.gcd(long, long)",
    "snippet": "public static long gcd(final long p, final long q) {\n        long u \u003d p;\n        long v \u003d q;\n        if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n            if ((u \u003d\u003d Long.MIN_VALUE) || (v \u003d\u003d Long.MIN_VALUE)){\n                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n                                                  p, q);\n            }\n            return FastMath.abs(u) + FastMath.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^63, while positive numbers can only be as large as 2^63-1\n        // (i.e. we can\u0027t necessarily negate a negative number without\n        // overflow)\n        /* assert u!\u003d0 \u0026\u0026 v!\u003d0; */\n        if (u \u003e 0) {\n            u \u003d -u;\n        } // make u negative\n        if (v \u003e 0) {\n            v \u003d -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k \u003d 0;\n        while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 63) { // while u and v are\n                                                            // both even...\n            u /\u003d 2;\n            v /\u003d 2;\n            k++; // cast out twos.\n        }\n        if (k \u003d\u003d 63) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n                                              p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        long t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u\u003c0 \u0026\u0026 v\u003c0; */\n            // B4/B3: cast out twos from t.\n            while ((t \u0026 1) \u003d\u003d 0) { // while t is even..\n                t /\u003d 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t \u003e 0) {\n                u \u003d -t;\n            } else {\n                v \u003d t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t \u003d (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t !\u003d 0);\n        return -u * (1L \u003c\u003c k); // gcd is u*2^k\n    }",
    "begin_line": 951,
    "end_line": 1007,
    "comment": "/** \n * \u003cp\u003e Gets the greatest common divisor of the absolute value of two numbers, using the \"binary gcd\" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). \u003c/p\u003e Special cases: \u003cul\u003e \u003cli\u003eThe invocations {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)}, {@code gcd(Long.MIN_VALUE, 0L)} and{@code gcd(0L, Long.MIN_VALUE)} throw an{@code ArithmeticException}, because the result would be 2^63, which is too large for a long value.\u003c/li\u003e \u003cli\u003eThe result of  {@code gcd(x, x)},  {@code gcd(0L, x)} and{@code gcd(x, 0L)} is the absolute value of {@code x}, except for the special cases above. \u003cli\u003eThe invocation  {@code gcd(0L, 0L)} is the only one which returns{@code 0L}.\u003c/li\u003e \u003c/ul\u003e\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor, never negative.\n * @throws MathArithmeticException if the result cannot be represented asa non-negative  {@code long} value.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.hash#1015",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.hash(double)",
    "snippet": "public static int hash(double value) {\n        return new Double(value).hashCode();\n    }",
    "begin_line": 1015,
    "end_line": 1017,
    "comment": "/** \n * Returns an integer hash code representing the given double value.\n * @param value the value to be hashed\n * @return the hash code\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.hash#1026",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.hash(double[])",
    "snippet": "public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }",
    "begin_line": 1026,
    "end_line": 1028,
    "comment": "/** \n * Returns an integer hash code representing the given double array.\n * @param value the value to be hashed (may be null)\n * @return the hash code\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#1037",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(byte)",
    "snippet": "public static byte indicator(final byte x) {\n        return (x \u003e\u003d ZB) ? PB : NB;\n    }",
    "begin_line": 1037,
    "end_line": 1039,
    "comment": "/** \n * For a byte value x, this method returns (byte)(+1) if x \u003e\u003d 0 and (byte)(-1) if x \u003c 0.\n * @param x the value, a byte\n * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#1049",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(double)",
    "snippet": "public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x \u003e\u003d 0.0) ? 1.0 : -1.0;\n    }",
    "begin_line": 1049,
    "end_line": 1054,
    "comment": "/** \n * For a double precision value x, this method returns +1.0 if x \u003e\u003d 0 and -1.0 if x \u003c 0. Returns  {@code NaN} if {@code x} is{@code NaN}.\n * @param x the value, a double\n * @return +1.0 or -1.0, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#1063",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(float)",
    "snippet": "public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x \u003e\u003d 0.0F) ? 1.0F : -1.0F;\n    }",
    "begin_line": 1063,
    "end_line": 1068,
    "comment": "/** \n * For a float value x, this method returns +1.0F if x \u003e\u003d 0 and -1.0F if x \u003c 0. Returns  {@code NaN} if {@code x} is {@code NaN}.\n * @param x the value, a float\n * @return +1.0F or -1.0F, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#1076",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(int)",
    "snippet": "public static int indicator(final int x) {\n        return (x \u003e\u003d 0) ? 1 : -1;\n    }",
    "begin_line": 1076,
    "end_line": 1078,
    "comment": "/** \n * For an int value x, this method returns +1 if x \u003e\u003d 0 and -1 if x \u003c 0.\n * @param x the value, an int\n * @return +1 or -1, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#1086",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(long)",
    "snippet": "public static long indicator(final long x) {\n        return (x \u003e\u003d 0L) ? 1L : -1L;\n    }",
    "begin_line": 1086,
    "end_line": 1088,
    "comment": "/** \n * For a long value x, this method returns +1L if x \u003e\u003d 0 and -1L if x \u003c 0.\n * @param x the value, a long\n * @return +1L or -1L, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#1097",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(short)",
    "snippet": "public static short indicator(final short x) {\n        return (x \u003e\u003d ZS) ? PS : NS;\n    }",
    "begin_line": 1097,
    "end_line": 1099,
    "comment": "/** \n * For a short value x, this method returns (short)(+1) if x \u003e\u003d 0 and (short)(-1) if x \u003c 0.\n * @param x the value, a short\n * @return (short)(+1) or (short)(-1), depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.lcm#1123",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.lcm(int, int)",
    "snippet": "public static int lcm(int a, int b) {\n        if (a \u003d\u003d 0 || b \u003d\u003d 0){\n            return 0;\n        }\n        int lcm \u003d FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm \u003d\u003d Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS,\n                                              a, b);\n        }\n        return lcm;\n    }",
    "begin_line": 1123,
    "end_line": 1133,
    "comment": "/** \n * \u003cp\u003e Returns the least common multiple of the absolute value of two numbers, using the formula  {@code lcm(a,b) \u003d (a / gcd(a,b)) * b}. \u003c/p\u003e Special cases: \u003cul\u003e \u003cli\u003eThe invocations  {@code lcm(Integer.MIN_VALUE, n)} and{@code lcm(n, Integer.MIN_VALUE)}, where  {@code abs(n)} is apower of 2, throw an  {@code ArithmeticException}, because the result would be 2^31, which is too large for an int value.\u003c/li\u003e \u003cli\u003eThe result of  {@code lcm(0, x)} and {@code lcm(x, 0)} is{@code 0} for any {@code x}. \u003c/ul\u003e\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be represented asa non-negative  {@code int} value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.lcm#1157",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.lcm(long, long)",
    "snippet": "public static long lcm(long a, long b) {\n        if (a \u003d\u003d 0 || b \u003d\u003d 0){\n            return 0;\n        }\n        long lcm \u003d FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm \u003d\u003d Long.MIN_VALUE){\n            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS,\n                                              a, b);\n        }\n        return lcm;\n    }",
    "begin_line": 1157,
    "end_line": 1167,
    "comment": "/** \n * \u003cp\u003e Returns the least common multiple of the absolute value of two numbers, using the formula  {@code lcm(a,b) \u003d (a / gcd(a,b)) * b}. \u003c/p\u003e Special cases: \u003cul\u003e \u003cli\u003eThe invocations  {@code lcm(Long.MIN_VALUE, n)} and{@code lcm(n, Long.MIN_VALUE)}, where  {@code abs(n)} is apower of 2, throw an  {@code ArithmeticException}, because the result would be 2^63, which is too large for an int value.\u003c/li\u003e \u003cli\u003eThe result of  {@code lcm(0L, x)} and {@code lcm(x, 0L)} is{@code 0L} for any {@code x}. \u003c/ul\u003e\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be representedas a non-negative  {@code long} value.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.log#1185",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.log(double, double)",
    "snippet": "public static double log(double base, double x) {\n        return FastMath.log(x)/FastMath.log(base);\n    }",
    "begin_line": 1185,
    "end_line": 1187,
    "comment": "/** \n * \u003cp\u003eReturns the \u003ca href\u003d\"http://mathworld.wolfram.com/Logarithm.html\"\u003elogarithm\u003c/a\u003e for base  {@code b} of {@code x}. \u003c/p\u003e \u003cp\u003eReturns  {@code NaN} if either argument is negative. If{@code base} is 0 and {@code x} is positive, 0 is returned.If  {@code base} is positive and {@code x} is 0,{@code Double.NEGATIVE_INFINITY} is returned.  If both argumentsare 0, the result is  {@code NaN}.\u003c/p\u003e\n * @param base the base of the logarithm, must be greater than 0\n * @param x argument, must be greater than 0\n * @return the value of the logarithm - the number y such that base^y \u003d x.\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.mulAndCheck#1199",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.mulAndCheck(int, int)",
    "snippet": "public static int mulAndCheck(int x, int y) {\n        long m \u003d ((long)x) * ((long)y);\n        if (m \u003c Integer.MIN_VALUE || m \u003e Integer.MAX_VALUE) {\n            throw new MathArithmeticException();\n        }\n        return (int)m;\n    }",
    "begin_line": 1199,
    "end_line": 1205,
    "comment": "/** \n * Multiply two integers, checking for overflow.\n * @param x Factor.\n * @param y Factor.\n * @return the product {@code x * y}.\n * @throws MathArithmeticException if the result can not berepresented as an  {@code int}.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.mulAndCheck#1217",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.mulAndCheck(long, long)",
    "snippet": "public static long mulAndCheck(long a, long b) {\n        long ret;\n        if (a \u003e b) {\n            // use symmetry to reduce boundary cases\n            ret \u003d mulAndCheck(b, a);\n        } else {\n            if (a \u003c 0) {\n                if (b \u003c 0) {\n                    // check for positive overflow with negative a, negative b\n                    if (a \u003e\u003d Long.MAX_VALUE / b) {\n                        ret \u003d a * b;\n                    } else {\n                        throw new MathArithmeticException();\n                    }\n                } else if (b \u003e 0) {\n                    // check for negative overflow with negative a, positive b\n                    if (Long.MIN_VALUE / b \u003c\u003d a) {\n                        ret \u003d a * b;\n                    } else {\n                        throw new MathArithmeticException();\n\n                    }\n                } else {\n                    // assert b \u003d\u003d 0\n                    ret \u003d 0;\n                }\n            } else if (a \u003e 0) {\n                // assert a \u003e 0\n                // assert b \u003e 0\n\n                // check for positive overflow with positive a, positive b\n                if (a \u003c\u003d Long.MAX_VALUE / b) {\n                    ret \u003d a * b;\n                } else {\n                    throw new MathArithmeticException();\n                }\n            } else {\n                // assert a \u003d\u003d 0\n                ret \u003d 0;\n            }\n        }\n        return ret;\n    }",
    "begin_line": 1217,
    "end_line": 1259,
    "comment": "/** \n * Multiply two long integers, checking for overflow.\n * @param a Factor.\n * @param b Factor.\n * @return the product {@code a * b}.\n * @throws MathArithmeticException if the result can not be representedas a  {@code long}.\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.normalizeAngle#1280",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.normalizeAngle(double, double)",
    "snippet": "public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n     }",
    "begin_line": 1280,
    "end_line": 1282,
    "comment": "/** \n * Normalize an angle in a 2\u0026pi wide interval around a center value. \u003cp\u003eThis method has three main uses:\u003c/p\u003e \u003cul\u003e \u003cli\u003enormalize an angle between 0 and 2\u0026pi;:\u003cbr/\u003e {@code a \u003d MathUtils.normalizeAngle(a, FastMath.PI);}\u003c/li\u003e \u003cli\u003enormalize an angle between -\u0026pi; and +\u0026pi;\u003cbr/\u003e {@code a \u003d MathUtils.normalizeAngle(a, 0.0);}\u003c/li\u003e \u003cli\u003ecompute the angle between two defining angular positions:\u003cbr\u003e {@code angle \u003d MathUtils.normalizeAngle(end, start) - start;}\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eNote that due to numerical accuracy and since \u0026pi; cannot be represented exactly, the result interval is \u003cem\u003eclosed\u003c/em\u003e, it cannot be half-closed as would be more satisfactory in a purely mathematical view.\u003c/p\u003e\n * @param a angle to normalize\n * @param center center of the desired 2\u0026pi; interval for the result\n * @return a-2k\u0026pi; with integer k and center-\u0026pi; \u0026lt;\u003d a-2k\u0026pi; \u0026lt;\u003d center+\u0026pi;\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.reduce#1300",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.reduce(double, double, double)",
    "snippet": "public static double reduce(double a,\n                                double period,\n                                double offset) {\n        final double p \u003d FastMath.abs(period);\n        return a - p * FastMath.floor((a - offset) / p) - offset;\n    }",
    "begin_line": 1300,
    "end_line": 1305,
    "comment": "/** \n * \u003cp\u003eReduce  {@code |a - offset|} to the primary interval{@code [0, |period|)}.\u003c/p\u003e \u003cp\u003eSpecifically, the value returned is \u003cbr/\u003e {@code a - |period| * floor((a - offset) / |period|) - offset}.\u003c/p\u003e \u003cp\u003eIf any of the parameters are  {@code NaN} or infinite, the result is{@code NaN}.\u003c/p\u003e\n * @param a Value to reduce.\n * @param period Period.\n * @param offset Value that will be mapped to {@code 0}.\n * @return the value, within the interval {@code [0 |period|)}, that corresponds to  {@code a}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.normalizeArray#1328",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.normalizeArray(double[], double)",
    "snippet": "public static double[] normalizeArray(double[] values, double normalizedSum) {\n         if (Double.isInfinite(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum \u003d 0d;\n         final int len \u003d values.length;\n         double[] out \u003d new double[len];\n         for (int i \u003d 0; i \u003c len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum +\u003d values[i];\n             }\n         }\n         if (sum \u003d\u003d 0) {\n             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i \u003d 0; i \u003c len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] \u003d Double.NaN;\n             } else {\n                 out[i] \u003d values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }",
    "begin_line": 1328,
    "end_line": 1357,
    "comment": "/** \n * \u003cp\u003eNormalizes an array to make it sum to a specified value. Returns the result of the transformation \u003cpre\u003e x |-\u003e x * normalizedSum / sum \u003c/pre\u003e applied to each non-NaN element x of the input array, where sum is the sum of the non-NaN entries in the input array.\u003c/p\u003e \u003cp\u003eThrows IllegalArgumentException if  {@code normalizedSum} is infiniteor NaN and ArithmeticException if the input array contains any infinite elements or sums to 0\u003c/p\u003e \u003cp\u003eIgnores (i.e., copies unchanged to the output array) NaNs in the input array.\u003c/p\u003e\n * @param values input array to be normalized\n * @param normalizedSum target sum for the normalized array\n * @return normalized array\n * @throws MathArithmeticException if the input array contains infinite elements or sums to zero\n * @throws MathIllegalArgumentException if the target sum is infinite or NaN\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1368",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(double, int)",
    "snippet": "public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }",
    "begin_line": 1368,
    "end_line": 1370,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounded using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1391",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(double, int, int)",
    "snippet": "public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;\n            } else {\n                return Double.NaN;\n            }\n        }\n    }",
    "begin_line": 1391,
    "end_line": 1404,
    "comment": "/** \n * \u003cp\u003eRound the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in {@link BigDecimal}.\u003c/p\u003e \u003cp\u003eIf  {@code x} is infinite or NaN, then the value of {@code x} isreturned unchanged, regardless of the other parameters.\u003c/p\u003e\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @param roundingMethod the rounding method as defined in{@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if roundingMethod\u003d\u003dROUND_UNNECESSARY and thespecified scaling operation would require rounding.\n * @throws IllegalArgumentException if roundingMethod does not represent avalid rounding mode.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1415",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(float, int)",
    "snippet": "public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }",
    "begin_line": 1415,
    "end_line": 1417,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounded using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1431",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(float, int, int)",
    "snippet": "public static float round(float x, int scale, int roundingMethod) {\n        float sign \u003d indicator(x);\n        float factor \u003d (float)FastMath.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }",
    "begin_line": 1431,
    "end_line": 1435,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in {@link BigDecimal}.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @param roundingMethod the rounding method as defined in{@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.roundUnscaled#1449",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.roundUnscaled(double, double, int)",
    "snippet": "private static double roundUnscaled(double unscaled,\n                                        double sign,\n                                        int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign \u003d\u003d -1) {\n                unscaled \u003d FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled \u003d FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled \u003d FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign \u003d\u003d -1) {\n                unscaled \u003d FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled \u003d FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled \u003d FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction \u003d unscaled - FastMath.floor(unscaled);\n            if (fraction \u003e 0.5) {\n                unscaled \u003d FastMath.ceil(unscaled);\n            } else {\n                unscaled \u003d FastMath.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction \u003d unscaled - FastMath.floor(unscaled);\n            if (fraction \u003e 0.5) {\n                unscaled \u003d FastMath.ceil(unscaled);\n            } else if (fraction \u003c 0.5) {\n                unscaled \u003d FastMath.floor(unscaled);\n            } else {\n                // The following equality test is intentional and needed for rounding purposes\n                if (FastMath.floor(unscaled) / 2.0 \u003d\u003d FastMath.floor(Math\n                    .floor(unscaled) / 2.0)) { // even\n                    unscaled \u003d FastMath.floor(unscaled);\n                } else { // odd\n                    unscaled \u003d FastMath.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled \u003d FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction \u003d unscaled - FastMath.floor(unscaled);\n            if (fraction \u003e\u003d 0.5) {\n                unscaled \u003d FastMath.ceil(unscaled);\n            } else {\n                unscaled \u003d FastMath.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled !\u003d FastMath.floor(unscaled)) {\n                throw new MathArithmeticException();\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled \u003d FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD,\n                                                   roundingMethod,\n                                                   \"ROUND_CEILING\", BigDecimal.ROUND_CEILING,\n                                                   \"ROUND_DOWN\", BigDecimal.ROUND_DOWN,\n                                                   \"ROUND_FLOOR\", BigDecimal.ROUND_FLOOR,\n                                                   \"ROUND_HALF_DOWN\", BigDecimal.ROUND_HALF_DOWN,\n                                                   \"ROUND_HALF_EVEN\", BigDecimal.ROUND_HALF_EVEN,\n                                                   \"ROUND_HALF_UP\", BigDecimal.ROUND_HALF_UP,\n                                                   \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n                                                   \"ROUND_UP\", BigDecimal.ROUND_UP);\n        }\n        return unscaled;\n    }",
    "begin_line": 1449,
    "end_line": 1528,
    "comment": "/** \n * Round the given non-negative value to the \"nearest\" integer. Nearest is determined by the rounding method specified. Rounding methods are defined in  {@link BigDecimal}.\n * @param unscaled Value to round.\n * @param sign Sign of the original, scaled value.\n * @param roundingMethod Rounding method, as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1540",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(byte)",
    "snippet": "public static byte sign(final byte x) {\n        return (x \u003d\u003d ZB) ? ZB : (x \u003e ZB) ? PB : NB;\n    }",
    "begin_line": 1540,
    "end_line": 1542,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for byte value  {@code x}. \u003cp\u003e For a byte value x, this method returns (byte)(+1) if x \u003e 0, (byte)(0) if x \u003d 0, and (byte)(-1) if x \u003c 0.\u003c/p\u003e\n * @param x the value, a byte\n * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1556",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(double)",
    "snippet": "public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x \u003d\u003d 0.0) ? 0.0 : (x \u003e 0.0) ? 1.0 : -1.0;\n    }",
    "begin_line": 1556,
    "end_line": 1561,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for double precision  {@code x}. \u003cp\u003e For a double value  {@code x}, this method returns {@code +1.0} if {@code x \u003e 0},  {@code 0.0} if{@code x \u003d 0.0}, and  {@code -1.0} if {@code x \u003c 0}. Returns  {@code NaN} if {@code x} is {@code NaN}.\u003c/p\u003e\n * @param x the value, a double\n * @return +1.0, 0.0, or -1.0, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1574",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(float)",
    "snippet": "public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x \u003d\u003d 0.0F) ? 0.0F : (x \u003e 0.0F) ? 1.0F : -1.0F;\n    }",
    "begin_line": 1574,
    "end_line": 1579,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for float value  {@code x}. \u003cp\u003e For a float value x, this method returns +1.0F if x \u003e 0, 0.0F if x \u003d 0.0F, and -1.0F if x \u003c 0. Returns  {@code NaN} if {@code x}is  {@code NaN}.\u003c/p\u003e\n * @param x the value, a float\n * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1591",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(int)",
    "snippet": "public static int sign(final int x) {\n        return (x \u003d\u003d 0) ? 0 : (x \u003e 0) ? 1 : -1;\n    }",
    "begin_line": 1591,
    "end_line": 1593,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for int value  {@code x}. \u003cp\u003e For an int value x, this method returns +1 if x \u003e 0, 0 if x \u003d 0, and -1 if x \u003c 0.\u003c/p\u003e\n * @param x the value, an int\n * @return +1, 0, or -1, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1605",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(long)",
    "snippet": "public static long sign(final long x) {\n        return (x \u003d\u003d 0L) ? 0L : (x \u003e 0L) ? 1L : -1L;\n    }",
    "begin_line": 1605,
    "end_line": 1607,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for long value  {@code x}. \u003cp\u003e For a long value x, this method returns +1L if x \u003e 0, 0L if x \u003d 0, and -1L if x \u003c 0.\u003c/p\u003e\n * @param x the value, a long\n * @return +1L, 0L, or -1L, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1616",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(short)",
    "snippet": "public static short sign(final short x) {\n        return (x \u003d\u003d ZS) ? ZS : (x \u003e ZS) ? PS : NS;\n    }",
    "begin_line": 1616,
    "end_line": 1618,
    "comment": "/** \n * Compute the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003esign\u003c/a\u003e of the argument.\n * @param x the value, a short\n * @return 1 if {@code x \u003e 0}, 0 if  {@code x \u003d\u003d 0}, and -1 if  {@code x \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sinh#1627",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sinh(double)",
    "snippet": "public static double sinh(double x) {\n        return (FastMath.exp(x) - FastMath.exp(-x)) / 2.0;\n    }",
    "begin_line": 1627,
    "end_line": 1629,
    "comment": "/** \n * Compute the \u003ca href\u003d\"http://mathworld.wolfram.com/HyperbolicSine.html\"\u003e hyperbolic sine\u003c/a\u003e of the argument.\n * @param x Value for which to find the hyperbolic sine.\n * @return hyperbolic sine of {@code x}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.subAndCheck#1641",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.subAndCheck(int, int)",
    "snippet": "public static int subAndCheck(int x, int y) {\n        long s \u003d (long)x - (long)y;\n        if (s \u003c Integer.MIN_VALUE || s \u003e Integer.MAX_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n        }\n        return (int)s;\n    }",
    "begin_line": 1641,
    "end_line": 1647,
    "comment": "/** \n * Subtract two integers, checking for overflow.\n * @param x Minuend.\n * @param y Subtrahend.\n * @return the difference {@code x - y}.\n * @throws MathArithmeticException if the result can not be representedas an  {@code int}.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.subAndCheck#1659",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.subAndCheck(long, long)",
    "snippet": "public static long subAndCheck(long a, long b) {\n        long ret;\n        if (b \u003d\u003d Long.MIN_VALUE) {\n            if (a \u003c 0) {\n                ret \u003d a - b;\n            } else {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n            }\n        } else {\n            // use additive inverse\n            ret \u003d addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n        }\n        return ret;\n    }",
    "begin_line": 1659,
    "end_line": 1672,
    "comment": "/** \n * Subtract two long integers, checking for overflow.\n * @param a Value.\n * @param b Value.\n * @return the difference {@code a - b}.\n * @throws MathArithmeticException if the result can not be represented as a{@code long}.\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1682",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(int, int)",
    "snippet": "public static int pow(final int k, int e) {\n        if (e \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n        }\n\n        int result \u003d 1;\n        int k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result *\u003d k2p;\n            }\n            k2p *\u003d k2p;\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n    }",
    "begin_line": 1682,
    "end_line": 1698,
    "comment": "/** \n * Raise an int to an int power.\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @throws NotPositiveException if {@code e \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1708",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(int, long)",
    "snippet": "public static int pow(final int k, long e) {\n        if (e \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n        }\n\n        int result \u003d 1;\n        int k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result *\u003d k2p;\n            }\n            k2p *\u003d k2p;\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n    }",
    "begin_line": 1708,
    "end_line": 1724,
    "comment": "/** \n * Raise an int to a long power.\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @throws NotPositiveException if {@code e \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1734",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(long, int)",
    "snippet": "public static long pow(final long k, int e) {\n        if (e \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n        }\n\n        long result \u003d 1l;\n        long k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result *\u003d k2p;\n            }\n            k2p *\u003d k2p;\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n    }",
    "begin_line": 1734,
    "end_line": 1750,
    "comment": "/** \n * Raise a long to an int power.\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @throws NotPositiveException if {@code e \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1760",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(long, long)",
    "snippet": "public static long pow(final long k, long e) {\n        if (e \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n        }\n\n        long result \u003d 1l;\n        long k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result *\u003d k2p;\n            }\n            k2p *\u003d k2p;\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n    }",
    "begin_line": 1760,
    "end_line": 1776,
    "comment": "/** \n * Raise a long to a long power.\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @throws NotPositiveException if {@code e \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1786",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(java.math.BigInteger, int)",
    "snippet": "public static BigInteger pow(final BigInteger k, int e) {\n        if (e \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n        }\n\n        return k.pow(e);\n    }",
    "begin_line": 1786,
    "end_line": 1792,
    "comment": "/** \n * Raise a BigInteger to an int power.\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @throws NotPositiveException if {@code e \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1802",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(java.math.BigInteger, long)",
    "snippet": "public static BigInteger pow(final BigInteger k, long e) {\n        if (e \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n        }\n\n        BigInteger result \u003d BigInteger.ONE;\n        BigInteger k2p    \u003d k;\n        while (e !\u003d 0) {\n            if ((e \u0026 0x1) !\u003d 0) {\n                result \u003d result.multiply(k2p);\n            }\n            k2p \u003d k2p.multiply(k2p);\n            e \u003d e \u003e\u003e 1;\n        }\n\n        return result;\n\n    }",
    "begin_line": 1802,
    "end_line": 1819,
    "comment": "/** \n * Raise a BigInteger to a long power.\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @throws NotPositiveException if {@code e \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1829",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(java.math.BigInteger, java.math.BigInteger)",
    "snippet": "public static BigInteger pow(final BigInteger k, BigInteger e) {\n        if (e.compareTo(BigInteger.ZERO) \u003c 0) {\n            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n        }\n\n        BigInteger result \u003d BigInteger.ONE;\n        BigInteger k2p    \u003d k;\n        while (!BigInteger.ZERO.equals(e)) {\n            if (e.testBit(0)) {\n                result \u003d result.multiply(k2p);\n            }\n            k2p \u003d k2p.multiply(k2p);\n            e \u003d e.shiftRight(1);\n        }\n\n        return result;\n    }",
    "begin_line": 1829,
    "end_line": 1845,
    "comment": "/** \n * Raise a BigInteger to a BigInteger power.\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @throws NotPositiveException if {@code e \u003c 0}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance1#1854",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance1(double[], double[])",
    "snippet": "public static double distance1(double[] p1, double[] p2) {\n        double sum \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            sum +\u003d FastMath.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }",
    "begin_line": 1854,
    "end_line": 1860,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance1#1869",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance1(int[], int[])",
    "snippet": "public static int distance1(int[] p1, int[] p2) {\n      int sum \u003d 0;\n      for (int i \u003d 0; i \u003c p1.length; i++) {\n          sum +\u003d FastMath.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }",
    "begin_line": 1869,
    "end_line": 1875,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance#1884",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance(double[], double[])",
    "snippet": "public static double distance(double[] p1, double[] p2) {\n        double sum \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            final double dp \u003d p1[i] - p2[i];\n            sum +\u003d dp * dp;\n        }\n        return FastMath.sqrt(sum);\n    }",
    "begin_line": 1884,
    "end_line": 1891,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance#1900",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance(int[], int[])",
    "snippet": "public static double distance(int[] p1, int[] p2) {\n      double sum \u003d 0;\n      for (int i \u003d 0; i \u003c p1.length; i++) {\n          final double dp \u003d p1[i] - p2[i];\n          sum +\u003d dp * dp;\n      }\n      return FastMath.sqrt(sum);\n    }",
    "begin_line": 1900,
    "end_line": 1907,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distanceInf#1916",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distanceInf(double[], double[])",
    "snippet": "public static double distanceInf(double[] p1, double[] p2) {\n        double max \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            max \u003d FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }",
    "begin_line": 1916,
    "end_line": 1922,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distanceInf#1931",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distanceInf(int[], int[])",
    "snippet": "public static int distanceInf(int[] p1, int[] p2) {\n        int max \u003d 0;\n        for (int i \u003d 0; i \u003c p1.length; i++) {\n            max \u003d FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }",
    "begin_line": 1931,
    "end_line": 1937,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkOrder#1960",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkOrder(double[], org.apache.commons.math.util.MathUtils.OrderDirection, boolean, boolean)",
    "snippet": "public static boolean checkOrder(double[] val, OrderDirection dir,\n                                     boolean strict, boolean abort) {\n        double previous \u003d val[0];\n        boolean ok \u003d true;\n\n        int max \u003d val.length;\n        for (int i \u003d 1; i \u003c max; i++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[i] \u003c\u003d previous) {\n                        ok \u003d false;\n                    }\n                } else {\n                    if (val[i] \u003c previous) {\n                        ok \u003d false;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[i] \u003e\u003d previous) {\n                        ok \u003d false;\n                    }\n                } else {\n                    if (val[i] \u003e previous) {\n                        ok \u003d false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new IllegalArgumentException();\n            }\n\n            if (!ok \u0026\u0026\n                abort) {\n                throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);\n            }\n            previous \u003d val[i];\n        }\n\n        return ok;\n    }",
    "begin_line": 1960,
    "end_line": 2003,
    "comment": "/** \n * Check that the given array is sorted.\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the array is sorted.\n * @throws NonMonotonousSequenceException if the array is not sortedand  {@code abort} is {@code true}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkOrder#2014",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkOrder(double[], org.apache.commons.math.util.MathUtils.OrderDirection, boolean)",
    "snippet": "public static void checkOrder(double[] val, OrderDirection dir,\n                                  boolean strict) {\n        checkOrder(val, dir, strict, true);\n    }",
    "begin_line": 2014,
    "end_line": 2017,
    "comment": "/** \n * Check that the given array is sorted.\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @throws NonMonotonousSequenceException if the array is not sorted.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkOrder#2026",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkOrder(double[])",
    "snippet": "public static void checkOrder(double[] val) {\n        checkOrder(val, OrderDirection.INCREASING, true);\n    }",
    "begin_line": 2026,
    "end_line": 2028,
    "comment": "/** \n * Check that the given array is sorted in strictly increasing order.\n * @param val Values.\n * @throws NonMonotonousSequenceException if the array is not sorted.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkFinite#2037",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkFinite(double)",
    "snippet": "public static void checkFinite(final double x) {\n        if (Double.isInfinite(x) || Double.isNaN(x)) {\n            throw new NotFiniteNumberException(x);\n        }\n    }",
    "begin_line": 2037,
    "end_line": 2041,
    "comment": "/** \n * Check that the argument is a real number.\n * @param x Argument.\n * @throws NotFiniteNumberException if {@code x} is not afinite real number.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkFinite#2050",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkFinite(double[])",
    "snippet": "public static void checkFinite(final double[] val) {\n        for (int i \u003d 0; i \u003c val.length; i++) {\n            final double x \u003d val[i];\n            if (Double.isInfinite(x) || Double.isNaN(x)) {\n                throw new NotFiniteNumberException(LocalizedFormats.ARRAY_ELEMENT, x, i);\n            }\n        }\n    }",
    "begin_line": 2050,
    "end_line": 2057,
    "comment": "/** \n * Check that all the elements are real number.\n * @param val Arguments.\n * @throws NotFiniteNumberException if any values of the array is not afinite real number.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.safeNorm#2119",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.safeNorm(double[])",
    "snippet": "public static double safeNorm(double[] v) {\n        double rdwarf \u003d 3.834e-20;\n        double rgiant \u003d 1.304e+19;\n        double s1 \u003d 0;\n        double s2 \u003d 0;\n        double s3 \u003d 0;\n        double x1max \u003d 0;\n        double x3max \u003d 0;\n        double floatn \u003d (double) v.length;\n        double agiant \u003d rgiant / floatn;\n        for (int i \u003d 0; i \u003c v.length; i++) {\n            double xabs \u003d Math.abs(v[i]);\n            if (xabs \u003c rdwarf || xabs \u003e agiant) {\n                if (xabs \u003e rdwarf) {\n                    if (xabs \u003e x1max) {\n                        double r \u003d x1max / xabs;\n                        s1\u003d 1 + s1 * r * r;\n                        x1max \u003d xabs;\n                    } else {\n                        double r \u003d xabs / x1max;\n                        s1 +\u003d r * r;\n                    }\n                } else {\n                    if (xabs \u003e x3max) {\n                        double r \u003d x3max / xabs;\n                        s3\u003d 1 + s3 * r * r;\n                        x3max \u003d xabs;\n                    } else {\n                        if (xabs !\u003d 0) {\n                            double r \u003d xabs / x3max;\n                            s3 +\u003d r * r;\n                        }\n                    }\n                }\n            } else {\n                s2 +\u003d xabs * xabs;\n            }\n        }\n        double norm;\n        if (s1 !\u003d 0) {\n            norm \u003d x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n        } else {\n            if (s2 \u003d\u003d 0) {\n                norm \u003d x3max * Math.sqrt(s3);\n            } else {\n                if (s2 \u003e\u003d x3max) {\n                    norm \u003d Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n                } else {\n                    norm \u003d Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n                }\n            }\n        }\n        return norm;\n    }",
    "begin_line": 2119,
    "end_line": 2172,
    "comment": "/** \n * Returns the Cartesian norm (2-norm), handling both overflow and underflow. Translation of the minpack enorm subroutine. The redistribution policy for MINPACK is available \u003ca href\u003d\"http://www.netlib.org/minpack/disclaimer\"\u003ehere\u003c/a\u003e, for convenience, it is reproduced below.\u003c/p\u003e \u003ctable border\u003d\"0\" width\u003d\"80%\" cellpadding\u003d\"10\" align\u003d\"center\" bgcolor\u003d\"#E0E0E0\"\u003e \u003ctr\u003e\u003ctd\u003e Minpack Copyright Notice (1999) University of Chicago. All rights reserved \u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: \u003col\u003e \u003cli\u003eRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\u003c/li\u003e \u003cli\u003eRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\u003c/li\u003e \u003cli\u003eThe end-user documentation included with the redistribution, if any, must include the following acknowledgment: {@code This product includes software developed by the University ofChicago, as Operator of Argonne National Laboratory.}Alternately, this acknowledgment may appear in the software itself, if and wherever such third-party acknowledgments normally appear.\u003c/li\u003e \u003cli\u003e\u003cstrong\u003eWARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL BE CORRECTED.\u003c/strong\u003e\u003c/li\u003e \u003cli\u003e\u003cstrong\u003eLIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE POSSIBILITY OF SUCH LOSS OR DAMAGES.\u003c/strong\u003e\u003c/li\u003e \u003col\u003e\u003c/td\u003e\u003c/tr\u003e \u003c/table\u003e\n * @param v vector of doubles\n * @return the 2-norm of the vector\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sortInPlace#2184",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sortInPlace(double[], double[])",
    "snippet": "public static void sortInPlace(double[] x,\n                                   double[] ... yList) {\n        sortInPlace(x, OrderDirection.INCREASING, yList);\n    }",
    "begin_line": 2184,
    "end_line": 2187,
    "comment": "/** \n * Sort an array in increasing order, performing the same reordering of entries on other arrays.\n * @param x Array to be sorted.\n * @param yList Set of arrays whose permutations of entries must followthose performed on  {@code x}.\n * @throws DimensionMismatchException if any {@code y} has not the samesize as  {@code x}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sortInPlace#2199",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sortInPlace(double[], org.apache.commons.math.util.MathUtils.OrderDirection, double[])",
    "snippet": "public static void sortInPlace(double[] x,\n                                   final OrderDirection dir,\n                                   double[] ... yList) {\n        if (x \u003d\u003d null ||\n            yList \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n\n        final int len \u003d x.length;\n        final List\u003cPair\u003cDouble, double[]\u003e\u003e list\n            \u003d new ArrayList\u003cPair\u003cDouble, double[]\u003e\u003e(len);\n\n        final int yListLen \u003d yList.length;\n        for (int i \u003d 0; i \u003c len; i++) {\n            final double[] yValues \u003d new double[yListLen];\n            for (int j \u003d 0; j \u003c yListLen; j++) {\n                double[] y \u003d yList[j];\n                if (y.length !\u003d len) {\n                    throw new DimensionMismatchException(y.length, len);\n                }\n                yValues[j] \u003d y[i];\n            }\n            list.add(new Pair\u003cDouble, double[]\u003e(x[i], yValues));\n        }\n\n        final Comparator\u003cPair\u003cDouble, double[]\u003e\u003e comp\n            \u003d new Comparator\u003cPair\u003cDouble, double[]\u003e\u003e() {\n            public int compare(Pair\u003cDouble, double[]\u003e o1,\n                               Pair\u003cDouble, double[]\u003e o2) {\n                int val;\n                switch (dir) {\n                case INCREASING:\n                    val \u003d o1.getKey().compareTo(o2.getKey());\n                break;\n                case DECREASING:\n                    val \u003d o2.getKey().compareTo(o1.getKey());\n                break;\n                default:\n                    // Should never happen.\n                    throw new IllegalArgumentException();\n                }\n                return val;\n            }\n        };\n\n        Collections.sort(list, comp);\n\n        for (int i \u003d 0; i \u003c len; i++) {\n            final Pair\u003cDouble, double[]\u003e e \u003d list.get(i);\n            x[i] \u003d e.getKey();\n            final double[] yValues \u003d e.getValue();\n            for (int j \u003d 0; j \u003c yListLen; j++) {\n                yList[j][i] \u003d yValues[j];\n            }\n        }\n    }",
    "begin_line": 2199,
    "end_line": 2254,
    "comment": "/** \n * Sort an array, performing the same reordering of entries on other arrays.\n * @param x Array to be sorted.\n * @param dir Order direction.\n * @param yList Set of arrays whose permutations of entries must followthose performed on  {@code x}.\n * @throws DimensionMismatchException if any {@code y} has not the samesize as  {@code x}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.compare#2226",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.compare(org.apache.commons.math.util.Pair\u003cjava.lang.Double,double[]\u003e, org.apache.commons.math.util.Pair\u003cjava.lang.Double,double[]\u003e)",
    "snippet": "public int compare(Pair\u003cDouble, double[]\u003e o1,\n                               Pair\u003cDouble, double[]\u003e o2) {\n                int val;\n                switch (dir) {\n                case INCREASING:\n                    val \u003d o1.getKey().compareTo(o2.getKey());\n                break;\n                case DECREASING:\n                    val \u003d o2.getKey().compareTo(o1.getKey());\n                break;\n                default:\n                    // Should never happen.\n                    throw new IllegalArgumentException();\n                }\n                return val;\n            }",
    "begin_line": 2226,
    "end_line": 2241,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.copyOf#2262",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.copyOf(int[])",
    "snippet": "public static int[] copyOf(int[] source) {\n         return copyOf(source, source.length);\n     }",
    "begin_line": 2262,
    "end_line": 2264,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.copyOf#2272",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.copyOf(double[])",
    "snippet": "public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }",
    "begin_line": 2272,
    "end_line": 2274,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.copyOf#2285",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.copyOf(int[], int)",
    "snippet": "public static int[] copyOf(int[] source, int len) {\n         final int[] output \u003d new int[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }",
    "begin_line": 2285,
    "end_line": 2289,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the sourcelength, the copy will be truncated, if larger it will padded with zeroes.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.copyOf#2300",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.copyOf(double[], int)",
    "snippet": "public static double[] copyOf(double[] source, int len) {\n         final double[] output \u003d new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }",
    "begin_line": 2300,
    "end_line": 2304,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the sourcelength, the copy will be truncated, if larger it will padded with zeroes.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkNotNull#2314",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkNotNull(java.lang.Object, org.apache.commons.math.exception.util.Localizable, java.lang.Object)",
    "snippet": "public static void checkNotNull(Object o,\n                                    Localizable pattern,\n                                    Object ... args) {\n        if (o \u003d\u003d null) {\n            throw new NullArgumentException(pattern, args);\n        }\n    }",
    "begin_line": 2314,
    "end_line": 2320,
    "comment": "/** \n * Checks that an object is not null.\n * @param o Object to be checked.\n * @param pattern Message pattern.\n * @param args Arguments to replace the placeholders in {@code pattern}.\n * @throws NullArgumentException if {@code o} is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkNotNull#2328",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkNotNull(java.lang.Object)",
    "snippet": "public static void checkNotNull(Object o) {\n        if (o \u003d\u003d null) {\n            throw new NullArgumentException();\n        }\n    }",
    "begin_line": 2328,
    "end_line": 2332,
    "comment": "/** \n * Checks that an object is not null.\n * @param o Object to be checked.\n * @throws NullArgumentException if {@code o} is {@code null}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap#94",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap()",
    "snippet": "public OpenIntToDoubleHashMap() {\n        this(DEFAULT_EXPECTED_SIZE, Double.NaN);\n    }",
    "begin_line": 94,
    "end_line": 96,
    "comment": "/** \n * Build an empty map with default size and using NaN for missing entries.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap#102",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(double)",
    "snippet": "public OpenIntToDoubleHashMap(final double missingEntries) {\n        this(DEFAULT_EXPECTED_SIZE, missingEntries);\n    }",
    "begin_line": 102,
    "end_line": 104,
    "comment": "/** \n * Build an empty map with default size\n * @param missingEntries value to return when a missing entry is fetched\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap#110",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(int)",
    "snippet": "public OpenIntToDoubleHashMap(final int expectedSize) {\n        this(expectedSize, Double.NaN);\n    }",
    "begin_line": 110,
    "end_line": 112,
    "comment": "/** \n * Build an empty map with specified size and using NaN for missing entries.\n * @param expectedSize expected number of elements in the map\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap#119",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(int, double)",
    "snippet": "public OpenIntToDoubleHashMap(final int expectedSize,\n                                  final double missingEntries) {\n        final int capacity \u003d computeCapacity(expectedSize);\n        keys   \u003d new int[capacity];\n        values \u003d new double[capacity];\n        states \u003d new byte[capacity];\n        this.missingEntries \u003d missingEntries;\n        mask   \u003d capacity - 1;\n    }",
    "begin_line": 119,
    "end_line": 127,
    "comment": "/** \n * Build an empty map with specified size.\n * @param expectedSize expected number of elements in the map\n * @param missingEntries value to return when a missing entry is fetched\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap#133",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(org.apache.commons.math.util.OpenIntToDoubleHashMap)",
    "snippet": "public OpenIntToDoubleHashMap(final OpenIntToDoubleHashMap source) {\n        final int length \u003d source.keys.length;\n        keys \u003d new int[length];\n        System.arraycopy(source.keys, 0, keys, 0, length);\n        values \u003d new double[length];\n        System.arraycopy(source.values, 0, values, 0, length);\n        states \u003d new byte[length];\n        System.arraycopy(source.states, 0, states, 0, length);\n        missingEntries \u003d source.missingEntries;\n        size  \u003d source.size;\n        mask  \u003d source.mask;\n        count \u003d source.count;\n    }",
    "begin_line": 133,
    "end_line": 145,
    "comment": "/** \n * Copy constructor.\n * @param source map to copy\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.computeCapacity#152",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.computeCapacity(int)",
    "snippet": "private static int computeCapacity(final int expectedSize) {\n        if (expectedSize \u003d\u003d 0) {\n            return 1;\n        }\n        final int capacity   \u003d (int) FastMath.ceil(expectedSize / LOAD_FACTOR);\n        final int powerOfTwo \u003d Integer.highestOneBit(capacity);\n        if (powerOfTwo \u003d\u003d capacity) {\n            return capacity;\n        }\n        return nextPowerOfTwo(capacity);\n    }",
    "begin_line": 152,
    "end_line": 162,
    "comment": "/** \n * Compute the capacity needed for a given size.\n * @param expectedSize expected size of the map\n * @return capacity to use for the specified size\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.nextPowerOfTwo#169",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.nextPowerOfTwo(int)",
    "snippet": "private static int nextPowerOfTwo(final int i) {\n        return Integer.highestOneBit(i) \u003c\u003c 1;\n    }",
    "begin_line": 169,
    "end_line": 171,
    "comment": "/** \n * Find the smallest power of two greater than the input value\n * @param i input value\n * @return smallest power of two greater than the input value\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.get#178",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.get(int)",
    "snippet": "public double get(final int key) {\n\n        final int hash  \u003d hashOf(key);\n        int index \u003d hash \u0026 mask;\n        if (containsKey(key, index)) {\n            return values[index];\n        }\n\n        if (states[index] \u003d\u003d FREE) {\n            return missingEntries;\n        }\n\n        int j \u003d index;\n        for (int perturb \u003d perturb(hash); states[index] !\u003d FREE; perturb \u003e\u003e\u003d PERTURB_SHIFT) {\n            j \u003d probe(perturb, j);\n            index \u003d j \u0026 mask;\n            if (containsKey(key, index)) {\n                return values[index];\n            }\n        }\n\n        return missingEntries;\n\n    }",
    "begin_line": 178,
    "end_line": 201,
    "comment": "/** \n * Get the stored value associated with the given key\n * @param key key associated with the data\n * @return data associated with the key\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.containsKey#208",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.containsKey(int)",
    "snippet": "public boolean containsKey(final int key) {\n\n        final int hash  \u003d hashOf(key);\n        int index \u003d hash \u0026 mask;\n        if (containsKey(key, index)) {\n            return true;\n        }\n\n        if (states[index] \u003d\u003d FREE) {\n            return false;\n        }\n\n        int j \u003d index;\n        for (int perturb \u003d perturb(hash); states[index] !\u003d FREE; perturb \u003e\u003e\u003d PERTURB_SHIFT) {\n            j \u003d probe(perturb, j);\n            index \u003d j \u0026 mask;\n            if (containsKey(key, index)) {\n                return true;\n            }\n        }\n\n        return false;\n\n    }",
    "begin_line": 208,
    "end_line": 231,
    "comment": "/** \n * Check if a value is associated with a key.\n * @param key key to check\n * @return true if a value is associated with key\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.iterator#240",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.iterator()",
    "snippet": "public Iterator iterator() {\n        return new Iterator();\n    }",
    "begin_line": 240,
    "end_line": 242,
    "comment": "/** \n * Get an iterator over map elements. \u003cp\u003eThe specialized iterators returned are fail-fast: they throw a \u003ccode\u003eConcurrentModificationException\u003c/code\u003e when they detect the map has been modified during iteration.\u003c/p\u003e\n * @return iterator over the map elements\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.perturb#249",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.perturb(int)",
    "snippet": "private static int perturb(final int hash) {\n        return hash \u0026 0x7fffffff;\n    }",
    "begin_line": 249,
    "end_line": 251,
    "comment": "/** \n * Perturb the hash for starting probing.\n * @param hash initial hash\n * @return perturbed hash\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.findInsertionIndex#258",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.findInsertionIndex(int)",
    "snippet": "private int findInsertionIndex(final int key) {\n        return findInsertionIndex(keys, states, key, mask);\n    }",
    "begin_line": 258,
    "end_line": 260,
    "comment": "/** \n * Find the index at which a key should be inserted\n * @param key key to lookup\n * @return index at which key should be inserted\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.findInsertionIndex#270",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.findInsertionIndex(int[], byte[], int, int)",
    "snippet": "private static int findInsertionIndex(final int[] keys, final byte[] states,\n                                          final int key, final int mask) {\n        final int hash \u003d hashOf(key);\n        int index \u003d hash \u0026 mask;\n        if (states[index] \u003d\u003d FREE) {\n            return index;\n        } else if (states[index] \u003d\u003d FULL \u0026\u0026 keys[index] \u003d\u003d key) {\n            return changeIndexSign(index);\n        }\n\n        int perturb \u003d perturb(hash);\n        int j \u003d index;\n        if (states[index] \u003d\u003d FULL) {\n            while (true) {\n                j \u003d probe(perturb, j);\n                index \u003d j \u0026 mask;\n                perturb \u003e\u003e\u003d PERTURB_SHIFT;\n\n                if (states[index] !\u003d FULL || keys[index] \u003d\u003d key) {\n                    break;\n                }\n            }\n        }\n\n        if (states[index] \u003d\u003d FREE) {\n            return index;\n        } else if (states[index] \u003d\u003d FULL) {\n            // due to the loop exit condition,\n            // if (states[index] \u003d\u003d FULL) then keys[index] \u003d\u003d key\n            return changeIndexSign(index);\n        }\n\n        final int firstRemoved \u003d index;\n        while (true) {\n            j \u003d probe(perturb, j);\n            index \u003d j \u0026 mask;\n\n            if (states[index] \u003d\u003d FREE) {\n                return firstRemoved;\n            } else if (states[index] \u003d\u003d FULL \u0026\u0026 keys[index] \u003d\u003d key) {\n                return changeIndexSign(index);\n            }\n\n            perturb \u003e\u003e\u003d PERTURB_SHIFT;\n\n        }\n\n    }",
    "begin_line": 270,
    "end_line": 317,
    "comment": "/** \n * Find the index at which a key should be inserted\n * @param keys keys table\n * @param states states table\n * @param key key to lookup\n * @param mask bit mask for hash values\n * @return index at which key should be inserted\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.probe#325",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.probe(int, int)",
    "snippet": "private static int probe(final int perturb, final int j) {\n        return (j \u003c\u003c 2) + j + perturb + 1;\n    }",
    "begin_line": 325,
    "end_line": 327,
    "comment": "/** \n * Compute next probe for collision resolution\n * @param perturb perturbed hash\n * @param j previous probe\n * @return next probe\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.changeIndexSign#334",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.changeIndexSign(int)",
    "snippet": "private static int changeIndexSign(final int index) {\n        return -index - 1;\n    }",
    "begin_line": 334,
    "end_line": 336,
    "comment": "/** \n * Change the index sign\n * @param index initial index\n * @return changed index\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.size#342",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.size()",
    "snippet": "public int size() {\n        return size;\n    }",
    "begin_line": 342,
    "end_line": 344,
    "comment": "/** \n * Get the number of elements stored in the map.\n * @return number of elements stored in the map\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.remove#352",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.remove(int)",
    "snippet": "public double remove(final int key) {\n\n        final int hash  \u003d hashOf(key);\n        int index \u003d hash \u0026 mask;\n        if (containsKey(key, index)) {\n            return doRemove(index);\n        }\n\n        if (states[index] \u003d\u003d FREE) {\n            return missingEntries;\n        }\n\n        int j \u003d index;\n        for (int perturb \u003d perturb(hash); states[index] !\u003d FREE; perturb \u003e\u003e\u003d PERTURB_SHIFT) {\n            j \u003d probe(perturb, j);\n            index \u003d j \u0026 mask;\n            if (containsKey(key, index)) {\n                return doRemove(index);\n            }\n        }\n\n        return missingEntries;\n\n    }",
    "begin_line": 352,
    "end_line": 375,
    "comment": "/** \n * Remove the value associated with a key.\n * @param key key to which the value is associated\n * @return removed value\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.containsKey#384",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.containsKey(int, int)",
    "snippet": "private boolean containsKey(final int key, final int index) {\n        return (key !\u003d 0 || states[index] \u003d\u003d FULL) \u0026\u0026 keys[index] \u003d\u003d key;\n    }",
    "begin_line": 384,
    "end_line": 386,
    "comment": "/** \n * Check if the tables contain an element associated with specified key at specified index.\n * @param key key to check\n * @param index index to check\n * @return true if an element is associated with key at index\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.doRemove#393",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.doRemove(int)",
    "snippet": "private double doRemove(int index) {\n        keys[index]   \u003d 0;\n        states[index] \u003d REMOVED;\n        final double previous \u003d values[index];\n        values[index] \u003d missingEntries;\n        --size;\n        ++count;\n        return previous;\n    }",
    "begin_line": 393,
    "end_line": 401,
    "comment": "/** \n * Remove an element at specified index.\n * @param index index of the element to remove\n * @return removed value\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.put#409",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.put(int, double)",
    "snippet": "public double put(final int key, final double value) {\n        int index \u003d findInsertionIndex(key);\n        double previous \u003d missingEntries;\n        boolean newMapping \u003d true;\n        if (index \u003c 0) {\n            index \u003d changeIndexSign(index);\n            previous \u003d values[index];\n            newMapping \u003d false;\n        }\n        keys[index]   \u003d key;\n        states[index] \u003d FULL;\n        values[index] \u003d value;\n        if (newMapping) {\n            ++size;\n            if (shouldGrowTable()) {\n                growTable();\n            }\n            ++count;\n        }\n        return previous;\n\n    }",
    "begin_line": 409,
    "end_line": 430,
    "comment": "/** \n * Put a value associated with a key in the map.\n * @param key key to which value is associated\n * @param value value to put in the map\n * @return previous value associated with the key\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.growTable#435",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.growTable()",
    "snippet": "private void growTable() {\n\n        final int oldLength      \u003d states.length;\n        final int[] oldKeys      \u003d keys;\n        final double[] oldValues \u003d values;\n        final byte[] oldStates   \u003d states;\n\n        final int newLength \u003d RESIZE_MULTIPLIER * oldLength;\n        final int[] newKeys \u003d new int[newLength];\n        final double[] newValues \u003d new double[newLength];\n        final byte[] newStates \u003d new byte[newLength];\n        final int newMask \u003d newLength - 1;\n        for (int i \u003d 0; i \u003c oldLength; ++i) {\n            if (oldStates[i] \u003d\u003d FULL) {\n                final int key \u003d oldKeys[i];\n                final int index \u003d findInsertionIndex(newKeys, newStates, key, newMask);\n                newKeys[index]   \u003d key;\n                newValues[index] \u003d oldValues[i];\n                newStates[index] \u003d FULL;\n            }\n        }\n\n        mask   \u003d newMask;\n        keys   \u003d newKeys;\n        values \u003d newValues;\n        states \u003d newStates;\n\n    }",
    "begin_line": 435,
    "end_line": 462,
    "comment": "/** \n * Grow the tables.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.shouldGrowTable#468",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.shouldGrowTable()",
    "snippet": "private boolean shouldGrowTable() {\n        return size \u003e (mask + 1) * LOAD_FACTOR;\n    }",
    "begin_line": 468,
    "end_line": 470,
    "comment": "/** \n * Check if tables should grow due to increased size.\n * @return true if  tables should grow\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OpenIntToDoubleHashMap.hashOf#477",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.hashOf(int)",
    "snippet": "private static int hashOf(final int key) {\n        final int h \u003d key ^ ((key \u003e\u003e\u003e 20) ^ (key \u003e\u003e\u003e 12));\n        return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);\n    }",
    "begin_line": 477,
    "end_line": 480,
    "comment": "/** \n * Compute the hash value of a key\n * @param key key to hash\n * @return hash value of the key\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Iterator.Iterator#498",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator()",
    "snippet": "private Iterator() {\n\n            // preserve the modification count of the map to detect concurrent modifications later\n            referenceCount \u003d count;\n\n            // initialize current index\n            next \u003d -1;\n            try {\n                advance();\n            } catch (NoSuchElementException nsee) {\n                // ignored\n            }\n\n        }",
    "begin_line": 498,
    "end_line": 511,
    "comment": "/** \n * Simple constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Iterator.hasNext#517",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.hasNext()",
    "snippet": "public boolean hasNext() {\n            return next \u003e\u003d 0;\n        }",
    "begin_line": 517,
    "end_line": 519,
    "comment": "/** \n * Check if there is a next element in the map.\n * @return true if there is a next element\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Iterator.key#527",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.key()",
    "snippet": "public int key()\n            throws ConcurrentModificationException, NoSuchElementException {\n            if (referenceCount !\u003d count) {\n                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n            }\n            if (current \u003c 0) {\n                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n            }\n            return keys[current];\n        }",
    "begin_line": 527,
    "end_line": 536,
    "comment": "/** \n * Get the key of current entry.\n * @return key of current entry\n * @exception ConcurrentModificationException if the map is modified during iteration\n * @exception NoSuchElementException if there is no element left in the map\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Iterator.value#544",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.value()",
    "snippet": "public double value()\n            throws ConcurrentModificationException, NoSuchElementException {\n            if (referenceCount !\u003d count) {\n                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n            }\n            if (current \u003c 0) {\n                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n            }\n            return values[current];\n        }",
    "begin_line": 544,
    "end_line": 553,
    "comment": "/** \n * Get the value of current entry.\n * @return value of current entry\n * @exception ConcurrentModificationException if the map is modified during iteration\n * @exception NoSuchElementException if there is no element left in the map\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Iterator.advance#560",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.advance()",
    "snippet": "public void advance()\n            throws ConcurrentModificationException, NoSuchElementException {\n\n            if (referenceCount !\u003d count) {\n                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n            }\n\n            // advance on step\n            current \u003d next;\n\n            // prepare next step\n            try {\n                while (states[++next] !\u003d FULL) {\n                    // nothing to do\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                next \u003d -2;\n                if (current \u003c 0) {\n                    throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n                }\n            }\n\n        }",
    "begin_line": 560,
    "end_line": 582,
    "comment": "/** \n * Advance iterator one step further.\n * @exception ConcurrentModificationException if the map is modified during iteration\n * @exception NoSuchElementException if there is no element left in the map\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Iterator.readObject#593",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.readObject(java.io.ObjectInputStream)",
    "snippet": "private void readObject(final ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        count \u003d 0;\n    }",
    "begin_line": 593,
    "end_line": 597,
    "comment": "/** \n * Read a serialized object.\n * @param stream input stream\n * @throws IOException if object cannot be read\n * @throws ClassNotFoundException if the class correspondingto the serialized object cannot be found\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]